<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xorex</title>
  
  <subtitle>要成为世界上最幸福的人啊！</subtitle>
  <link href="https://xorex.space/atom.xml" rel="self"/>
  
  <link href="https://xorex.space/"/>
  <updated>2021-06-05T16:47:14.015Z</updated>
  <id>https://xorex.space/</id>
  
  <author>
    <name>Xorex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为美好的世界献上祝福</title>
    <link href="https://xorex.space/2022/05/20/567f91f8bbba/"/>
    <id>https://xorex.space/2022/05/20/567f91f8bbba/</id>
    <published>2022-05-20T11:58:03.000Z</published>
    <updated>2021-06-05T16:47:14.015Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="689bfc10a9fed57c789bc7685d36a5d9d75f31b34cafe041b99ff510386c6242">8a972074cb8fb594adf191142c932486f63d9db6a4bbbbf65eb58b44e7f3a502ca39de9d3c1e3d9c70fdc9a01ad868dc3486910eced5f4e34f64df4c5155d0e28740e7f637329c5391f9bbe6ff64e653a789e2cef71c949e21aa63f2fba5c2f8909ab81d64320e8cb4384ed74fbebab2050cb82c4a7d22b4b9fd24d8a61fc8d8029f2ecbce16d7ac4071fe5c0ae2c3425b4c421b4a82a69b6012152d7d464a3624e786c960a03a52f9cd3453ffde3f9e7f7f8db1b21b9fd158b70d49126036880e6f581475aa1c9265c50093981c7c70663d0a1e3bede2870b4a7e0a6dc0d1a1ce8dbc658189e95bd6888f0f4d48bc8d7fa179df02ce8435ed223754c508e2b86eb7748ba754993eb71d24a37e5f551d0164956aa4d5dd5f723185894b6581fdc9638900b4666fa18e9bd6f6874b22c630932f62849d260f383329527390267e1ae61d8591c4aeb352f4b29108c2465a5e074d349edb5a9af79cb59ade636bb557cc6cdecd797157def65921204d200554354bc3d381c49d4097e92d1d51fd01c2313cff9d6502cf7e7f4b2399cc1e6be251d80c7050309bf346d386a7b536645f5c4c96178bc331da5740a42b0bd02b9968ce31b992b998e972e1dd06841a9d53b1d8280616027ac636ce646b67ae2c98a4b2ce990afefc45bd9b4d068c8fde09917cd2e84b9ffdf59606a1a60816d2f994703dfbbad7039e96e0b658292bacb1858ba7d9e49eb3187431fa4a1f8363915dc73aad3d519447f7cc0ff818de1453e2ab8257e0057131b57981825fc2c9f788e75c5564eb2ad8404bab6a82c47ab0a53249beb3b2306c2e5554ac2302070a4190176ddf1f1a7c9f4e483174777de2b527a91c806a1327390ff9a7eb985697c66546afc772628cec06b528dccdd1cb1d1d13ad8f74668fa5f5d0195cde6adade74f3ee1870b9a5da2542345b0f3ccb4e45aa3e4ca19ee469c348bc52b7c915f9fd94f14a9ce369c3d58e5c0e6550c9e6944437b122bacc312d2eaf41ec6165983d4afd819eb351ba8b730ee916f9cd78fef8008dcb9c56e63761799af98a3a7f796a1fa589fb9951d440a514e59ecf489a527c3a856fb48273361bc634d065d3e1833fc4a3b59e3f44008e8a1565a63506724732b84253673b58773214fb18c6f216ce7f94a3000979160f8fbe89f7300870c0103288288d986af8c35cf489154c5116b9e29ea3806b83fb4fb5c13bf5fac94b9fbb3d4dbc0a39cf185ce78c526bc7ed204162cdae47a4d016b2d81ea2ba9fc9830fb3527f1841ccf23061c0b80b53f3ae74c11c56b01d7711482081a2fcee250f16af2cb412ec812dc57d4d1d6985a692f17764a8bda6787d62fb8612eb25c70420071fd319dbc83c5d7f8ab892ebe088697c5f2833a61978a2b3c68e6916e569324b6bba4123401b6cccf173cb6f5f16b310bd23c631794739ed100cba1697a02e0cd558489edd5b9fb774265919385617ef45af3e351137e2be1db5a0dc536cc5ab5a80897d655a4da942de4a3fc9462a7d2eb6b49a288980210c8bf4649156b1e7d1f2c6e6eb1b8cb056067a2306541b7828ad3c48713b7ddcd33bdc4c83aec20ea2f4812ad03fedb8d33e6214f83ca38ffcbb55ca3859cd0cf07b65dd04174589117adf9d5c76448c6786447889122c612fb0ba366bfd64384a5162e27375fa7747622c6cf3b1c9c09bae41d179b1ac15d3cdd3254c2498e37f38e8b43b6620a7898afadb4e74414a7783ae2ffefd6aaac8cd082f33fa0abb3c8271690175664331e3053092c2b6abbf7e66adb0530ddde01a965e6abe809db7bd6d79229a09bd7df84c25da01c92e73a035e2667a75229c48e889842fbd0a1d7dbf7c579292b8557b8f400157e95b2864450dc73474ca6520544b623d98a0445e62a98d184853b6cf236e48ffe6ede26b4ca737f3f8c2f19701125867ec08135ca682b3cedc732362def3eefbf16d0327fedf680a5dc50bbb5590feeffc83a065c7c09fee680f2395508e418e59c28bcce45dcb357e95c2590a7ef9049d04d6bdbebce82c03d09be7d60c90ff409231a5b8df0091ede2ea2abe007dce72a5565fa7792a143ea45e0f14c3eed8ac989811cb44a0cb0fa483aa5f25831ccd3124d07a5558b126178f10f3600a554228513b55f48fdc6ca3d88c9a4203c3f729197919ecaff8376f9535fd87232cb896294f9fc4fdb1c094dc5b8c13fc9c0af0f6d5d0649aceb4beec719f7032a9d68ec16a1f386654f29e0adf7ade3d6d883067a74baa45dd07ca46c074be4a2d4d3cedd9cb43aa79ea8605e4a843d693cd9a062524820c3ae94cd3ba631d7d2c844b4cfd17570d07e02bb79c647880cb8f4a0614ff595bd22cff36fae33ba66ff6b9614ce43b5e2c2e2103b2a7c36dee450c0294e61645f1ff62b02acba1a876583591a53d9995c97318865eac82e9ab2d7daaee2edc69d2f6240b9cb98c8f3cc1c140d3ccfdb1894a3a9ae4db3704f4bef50c79ed660d72c4d76ca15c7b090c3a3ec8b6a1663e8ef6b80b33a790d75a8f2cab63863cfbab878fb45829ac4b30877f4b44ebb6fb1bd3deef6d4bb492d9e8dcd8f44dfda2afc59f9957524ddc5a9d26235be96e405f99fc668073799bfc29c611f3d097c9bef8404dfd98753bd059c4ccb2dc28284fa4d26f7388f29f063c5924d5d793e65af69eea2a654c3ca088ed576cea7a496de608c7fdc8adf94e22690d642584b9d121a80980bff1d66f2dbc7abf03c7272b4bd1f74df56756a806d0e76f293912b968b023f95efc0779c20497e818842577470c33cf1f1412cea0944a4fa2cd2a145d2a4dc588712f11729cb1233d6eabd234e0556425985afe3cf2518e4f70bbf31c038d5c335f500e0125cd3429ce768886381d9bf7fa0236a3449fd423c501be99daf36e54f58f09e63462c975afb417a015bd5f4a918f66f022aa79981cb82c29087351b1afe7b5051ad3712c3150e62f9d01f429d0b1050f348592d09d22cd5dc3409e3d11e7664dc114d8c37160b9d39f7d594813fd90cd23ac43c86cce7f22a0ecc46e9c77c1a1097fab3af5c9e0bbd893630d1db32066c3aeb8544e5a3b1e9f4905a3685a041e7921c29f7eb36041f276e3de9da457c90c0a4e9b1ec38db531d7887628745c5f26194ad2c2bc892a0e62a63be8e7162540b04696ee38d1ffa3deef3f110517e9813d259eb2617581819a50a37da390650ba8a86f576db6036fe772c8f8d2b15633f5d1905f11d452d62d67121d9a7d30cf26419c7100f2f51a3f0f8597048cda90b68b1b86116671fed5953d70fa552b04bcd54001afaaa291346a9eef0cb871f350a08a2e2ad3ead37fbe7af6c5ea3fbb4e2af874efb0d4f33d149f83b525500d0d106ae12249119307c0242bcfff7425822d2f61aae575154c5499f03b06da9bdfabf4707602c20b2eb9173a7f01dd7ea77e0b44303670982c11b53a5603e22cc74ca166846ef28697572ae88504db22754792584f45a2a559813081ab34c8641550dc1259ba7cc55de0d8ea0ae7ab83afc533113272ad893f0106a087e6bd0eb90c464eca576a7a217ef654ea365834f37076cec52bb40f7c2ec76ca2fdfd93511f3132b68d5279d42422d4562ad20cba8e76ddf4570fdeb4a0b1e63f2b87edf688afd4f51ae842b14864a528c57686385e5e763d175bf04d26ffd612a90f5d5ed0d49d6dbd4e472a192665afa263e1d9c2dfafb17858b59b5957992af881daf5231757ae0a3733d0e032415f2e6147113228b4c342045de3f73e08d00f893f7c05ab15b64603ef42b1e300b879fe6a8703d130048a0ef4c43a0f5aae256cfbd422f76818720e45572b16b6aae06c7c9a8a2be60d6bc205e8a0bccfea6660196c6ccb73571d9fce6aec0dbf9a211c12769ce9f1d4d2dcaccffc5049e92fc42abc59c6b952abf55ce944bd619f23f17700a194a95daeae67c69a289b48ac154619c185012cae1d913657e9fcc2ea89ededbd49813fddef2a842336a0a62385844b872a5c648b7ab23e2015579b053780d4c2fc01e621dfdb0f169723e26e319948f6355a3d52c26774488a5f43a1d574e80c78730f8b825210e3a93d5b904cd14d74f09255b74f5e5185d35713038bfecaff6c4cbc9c3e6b3638c64ed1af85cd0746586e41377fa167c73f22a605639878844d9a73dc5c244e02e359c3ae6cb62540b36a4b5e2150898258f2f86d881fb21d0e5c1c4e3552eb48159529396d53cc96ff48320c1406acc328fe9c1cddb62363481ed658ec32273b5f6149e80d7f111cad43e8f989c6f9609f194d18319b7932ce1854265e28c93ad307ee5f638c795b49f625b6783187862743df526a3da373e9e814846ea92343d3d5979772a38dec79be44317f0c75efadac03409fc473af07b7c47adb8170959bb5d20d41362e96ff110bbecd6edb3a7fef4bab4470423113aa367d0e8a2425c87bd98550ac0e7db65c9c7d32db12cff2bcfa81cda4e41d0b308f9578b4b1e5d5794d5ce80ad0ef7eed3cf3039f85c28d6fc247f3e04e4da416c126c6a7453431952565dbd973ceb410451246d221b4c4c59bb45dc1e8f01d15456e4bc59b26feee41aa8ef0356eab5d03e4a9cced9df106708a16de62ca4bf2d9ca503747ed9f4b6b664916a7bf851b7392e1e71ded53d2576c775e15be1a4502a80dd2f5c34808e17f642d8a987ec273b5d0868a114466b331e563ac674abec48fd6783c8624a06a92dc359b3efbc0e9c28aa832f4a61417ff2859ddbda7ccc5617d1a9d17ce2843ea48c7b5bddf9e2d79aeae9d844002cae5545cceded9192bb31c3b49b7723b30da30318015acd6f16cabae11f2f2d197f0b0097fe222019bd1e82d6fb82b1b7a240b0be445cef0404adc7c55a1ff0bf296c88b6be1ce1b0083dd453c5a91cf01c0abe097a59f9f5771310187ee251f978945d21311f01ed29eb1ded81deda69d472642b543e0e8bf92781a96f9e576e3172770483f69c15fea7ec986b796d1a5c1f0a08e96b1090dd9119f840d9c016ac32b8cf483f3986934121380be1af639c7efc0ce4f4429aa99eabaf015c4f81a232aa9d030faa9c401c118532146e91ea4ccb77bbe21995fcdb4f16409a41715920a010d8adbca438d7c94852563dc36af172bd19e552fe44a45222fc43fe10e7ba6d4d857156399cd143de7caaeb001e14fcb3d03be87ea1717c748bce8c47ad170f8170c159e37f533dc7f0415eeb55dd07c7c28b7358f4cf62b257b6e3d972ee8d75e04c673e0cd267ac89badebc34fa445f6cac623c9ee9447556c5149db450291ba01c3dc62ebc7661da869d3c7f23b853f29af418a41890aab8c1093ba44d46019deb75043ee8b76f9fc9fbd149ad4b77ccbade7d360c94eba7766b1650414c48088892abb236903bac42fa1c32d90d972ef54da2a2d87b8e0f2ddbf5b006e6ff79660d4122fdb8332e5ec80a90bcd95db27fcf79376ed0baaea37dc99c00194e35cd48c3f93a78000fbbead43982ed3dacbea40785414ac60d9281353479cee2cae86b73a3769ebd29736f9dff2ca6be49d2908d7517f4f11d6145e23cab64929ca877bb055d9a547e4f13dfb1cc300487538fe065df2eb6cad120563d809978f54eb6337ddab9e509fd1ffb27217ccc59f8bdc582037569b46a1d88ca9641b721f5177a10abb2038b60945f5ddc42f0433c0062cf5410a8ca84a91930718f1ba1a0bb879da6130740911c5a7431c19985ea8a6f6a64ee53399cb40a1252e2dee4a36178fa2e25826e8787db25c33b3c11a1574a0bc8b5f58cb6f7bc7b31878ac035bce91319ed0f5bbef3e7b249ca8c7ecae0ed40e38f8881f73125aa4058883ed2e3241d9706bc3c185c9fe9f0c9a64318a0e848ad08864b747a38a166cfa55dbaf417deaf2781a8223d6b3856a69a48e53f3bea85f02eaab5a61d8185e7856ff545e2e666b839bac6ca08a34a9ed391eb859330148e35f0a9221f8000f1ba42a55a545688868027c4a34cf2d05dc12f3e512500e853e853fc713465766e55741d58b28a9b994fd03cb213d1475e84189329170f0160ed9f5cf75260be695c74fa812375c6f0ad329adc909e5f76cb3f12a98b4128d5b17677cbc9322360667ad6f2268f49e6c70f905adae18ef1a10b8ebcc6c5df15fbcaee97e5bf039a683af766b7ee350eeb564f7df1159c0cfc7b863ed7844ab0f55c147028bbc125822720807d0da21387520376d1f581235ae9887f952ee49b5d746989ce8d9378aa6bee5faf12d9ac3b2f79e3a684361dba69b657884b8cab25daec678f004f793a845fbe5bdec336aa74d05948fbafca14c7ec43a6569883b0ad31a801c38d78173453b632b65ccb08ac379aa6f0dcf7a11035415c58b39557dff5a4246860f5ce80cc862218a43986e3b9f27ceebcdd62f7fb645f5c77b7450995789545edb0a5c11119e87691691478b9d939ac95c43e2245d4c448e806b01c0918ed18805edd519d2a927adb92fbfd2c9dfc5d564d82f5b092b5203547ed28d731726e47fe054cecfa6b4137024e8ca9b943d46aac7b792bfdb857831de16281dc4b15ccf73a6774799cada60cd4e964b3ec56b057df054ac12f14c886dc99ffbe46426607d8b754058f944304ffa6dd7a19e96ff9fb9630948e0526ab72cad0633b507a48ed58f7d34cfb0dc68c6fd9523246b3b63d4db3ee7a6563787fc9f7cbd88966881671abf8c037f15d362a7ae43e3174ccd05716e3e595a36b45b42d16059f1ffe3f85acb416942c0d82de9db439b96e08aacf890b61a936c285397eef3e83ad4a47f00059c0e0e9675e6dd257f5db2cd06bdb0506cb696f9a698c85a95cd95aee8c354456a8fcc055818e2b4da0b44376810cd607b3809f03d7af96ea963adaf4a8abaae66ec2b993cff102c57380bb41030f6192163a8076dbd2e7b037553d1f3928804847b1f359563a0e752c3b9b80dad8102cf77d3f7100a6e881e52db01c42d9694c3cd6afc86a77fda767232b2e66a393b2011ac6af6f9d00d9be3d31e1065b61a118319daa5422a78bf06ba773bb2a5f9343b948483ad66b781222d9bcb211e13d4c851d5bbf7328025b38ca63c4907945cedf110a838aba27cad851f73ddc5c5ee6538ebecb22454cde54cefd0d808263364a9d3fab55df73b11e0ac7f426f22d3050163fecf163512def63d06ede8f842fc5a41bd7b65915eb55bf776e7460d8675ce525a3bd8ce12fb42134dbd97321fea31444376355c9163a30d28d09c43be25fc49d7c9286e4b13c4dde2ec4f425d2f8a50c5f9229d2d6714e05d41eac3f8c2df13b25af2d912472a5ad9b600ff739bec4386b96fbf28767a19cd7696cf194bb1822b0bba1d55ecb053024fbfaf595ffb2b62114e56608cb119c3d6b26f3800998e20c7697e33087f223d6cef191cdc11a61009321aeac4c757fccb57ad6880f05302b00c7c12309e882126ee82c2d65f236d6aba8297a9fa113ddeecfaec3bf578f964449f208f86a55e7c7fc680104ccacc8b51731eac235142f937d68d117766c6b97a0890c2f0c5906269d463b70a27fcf042d702d6a84816c0b04c615e4641b37b352a5bdef59f27ceb05fe42f15f85ee9d3a3cb109fc07f4ea42d8577921315a1d57995acda377a83a95277869401d204d0154e45231dfa418ba19565adeb6f947f85ba84ead98fd9f72ddf24173d8bb6c675d60eb4c0bd019e2c2e04904ec56b0570662f7686ee4cd789bb9bf9a7cdc6cd155be5bc6dcbc548914afaa55553e6c8f9f7eac4ae6a9b43d0f42e810250d9812b6726d59c7a2adcf70a051bd6b970a701e7385972939f42c34c08676b778787a96fceb316a48b9e94efb3cece703aef605279442697282a777b97a5aa22ca2cfbd694d2e7e786878bd5b67cccff6e6763c52b8b0a4e5485fdee23ad79007c7201371e010c8a24d80b18e7d35d4d7d9335f4990dc027a096d5cf811f8fa3e21fe8146307e98fe97bcca6bcc11a0a67d7e65288ef112033b9f13248cdf8634ea67d6051e92933aacad2e4bac99ba8ae764a3c63cfc1069d1922f47f3e48f46c7d818682b51c92e31caf6977926dd3df0e6e9dc65d9858133186907b94939e288f46cee43adb7ff69d369c5828e043d10f3f132d5098c687633080f027dd73f34b4f070299a2ed3579eb2f7068d66a7485f3e20c2e9bb963d760467cfba67fd1cc253e97c8c0cb054fd06b2ed7d612388a50e59b2268f7094783f19103c8ed86d86ada4fd4d6b63eee59240d19cc566d83b3d499f86f0da374362dd17b24eeef5f8ff2536f431a0ba9c5fe7955508bf5824b9829e38687448f2e83c726931838c4d038ff25d171486f5ba4fbb2499edb41fa89c2113701003cfd6703d040acdcf83c87324d33778e217d37da1d2b072c39067b23f9e980d59f1b73757168124746a5c3b15eb75b41c0ba004ffa77b12ba35b1e9b5d141348c39d499d0621b12e1aa022bd569cb2bb30e15e82b458f336e2f3285f10e0a7859f824af87fe5d65159e0ec969ecc2161bb0e33dc9125fbac004c2705a85be85bdba10b86ce22b7b06cf08757792e8592bf397398fc9627094221440b4ecdab198583376f3393bd5ddf19c9f6ec3ac94aa6c9a44aa6509508f9c1a242158084e475c6819ce401816f785a6bcb3e553fb0917355e92c2cabf25b2bcd4d4f1443a3fa3330a3a8f46534b8dd466ec18fc4bafe757f0980c35cd260cf7cc46518f4813bf5614c82709a99ed68cd32a17aa97b99a1ba9f468fa44ffc29202d4baf93b9240d6c34d7d2349feedbcb34e6f28d6d6cff003d28b319ae4c153bb5b82e286feb73638187bd02e9b6b21a3ef2281ae8d589c921d426330cf693eb80eb45e3dd83df3f7e5f92268351885c3aff655d09df11c9e4aa4e011bb1ddcbc715673f4308b76e281aed3335c8447f82667fcd64089ca564d199b96b826a8425c15d033b37a437595111808f946326a4a7547e1afc1f60bf5d6881d5682048fd3fda3cc034b8962e8e3ab397e167e4e7a67fb5f6405170cb7b8a93a151963957a0c7e5a10f5c831de7608f2dc4742e10a0bff962ba5509b2c987e644e866f968538ada9b9dc173f7d06c13d7fd976a9556c0b92399da6389a79920bd7a6449c10bc99c4d8621f8d82237e635025391224151ae2808e73c2955a60e60c501d0e9fa96b55ce0677e57fdbf149aecd83033c72896390072961db8da0c5f683ba2308d0815acd5b23311c530e15a5ec406435cbabf12617615ddde9db78f91be2c139a96e354f7e1276393d6b0e1f0f5c98b2ea4c5f13e925201dd683080379e5c1e52c244a7b61937b3acda4e40ceb5c1b879fa0fa3f556f2b8cd0b978169299c61fa2bd70bd8d4699dcbe70818945a8e36b234e554d92705390e9639b926e87bb1fcf22a60833cf2fd5e97c245a383e05c0a1b13f75135b3a742f652cd2e7da3e73e8da53493ee51fb001e7f12618f8cd52e05e4f653b88338bb3f50649e351b6fc9cefdcbcb40903acea8e572bfcae0b0571ce2e3d5363e578d13e6acb598d176f392a60638490f32c5e128fa2e7e444511e8281829cc11a39d59d789abd84b6002e84ce4ef485957b48b3210fa04f4552cad85f28be845f3812d72e86190af94b9c370c2a30d3b6eabcc3fdebd1b5f4e1258f054466cdfa2ba30aaf845046cc19db80c200ae27f90532be1526717f3a4152a78985c93e735f46edad5be9899b890368c7443bd8bf0ac52f33c0388d906d1ae2778dc9415f48fe5b4d0eb8dfbdf96400fc43247b8fc8603302649fd9938f5d8be1fd266a32d4bc33f07cadf49933d016ff6463617e1968bb04dcad750ff91fff3ddaa7eac57728aa4fda71b6562d5285138a90e7bfcd1c190684f8a4832c4bb77737b81cf021e01abe5a7371a0ebbe5617235503f804212feed8fcb82fc2eaee5dccff4c0423fd78e874c30ce500e1fe9c6722f768561c3c903cf1193342660764081c81cdf0a7cfa9e519becba3ab8fd7cb705ee5930d61f732151414f9ed04a548f1b6d7fdaa22ff84f94f787afd2bfcfbef75830dabadcd44d3db76f40e1e5f25bb08fb979499873f8e12d53976af844bf4b9d041a2784a23b4824b329a9cc7098605eb815c475fd8f7c525ec8879decce1c48dbb8250e58b9e3057bb355c954fd92034065744a2f2b9fc1970d4f61eec37d842e0ac703585960b13237e87d94764e9db6bc45918fde2a365ee5308c52f01576712f31ba9a8b0dcc27cae382</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Encrypted</summary>
    
    
    
    <category term="阶段性总结" scheme="https://xorex.space/categories/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="幸福" scheme="https://xorex.space/tags/%E5%B9%B8%E7%A6%8F/"/>
    
  </entry>
  
  <entry>
    <title>Sep-21-Diary</title>
    <link href="https://xorex.space/2021/09/19/4248ad9a289e/"/>
    <id>https://xorex.space/2021/09/19/4248ad9a289e/</id>
    <published>2021-09-19T15:43:22.000Z</published>
    <updated>2021-09-19T16:56:10.213Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为什么会想起来要写这个东西呢，emmmmmmm，大概是因为，觉得最近的自己好幸福，因此想要将最近发生的事情都一一记录下来，免得都忘记了 QAQ</p></blockquote><h2 id="9-月-19-日-周日"><a href="#9-月-19-日-周日" class="headerlink" title="9 月 19 日 周日"></a>9 月 19 日 周日</h2><p>经过调休之后的三天中秋节假期的前两天都要搭在了摆摊招新上面了，早上赖床到 10 点，然后去和各位小伙伴们一起大致装饰了一下摊位，中间去和 syc 易控的摊位一起互动了一下，恰钱归来的 77 还是一如既往的帅，交际花小熊还是一如既往的可爱。</p><p>中午下训的时候来的学弟学妹们很多，不少学弟学妹们也都加了群（虽然没有那天网安院宣讲瞬间加爆群更震撼）。自己也学了学如何营业吸引新生，（开发实验室了解一下！），去耐心的和各位学弟学妹们讲解开发实验室是做什么的，有什么方向等等，感觉自己成长了不少 hhh。摆摊中间也很快乐的面基了几位可爱的学弟。虽然自己记忆力过于差导致没记住几个（可能是因为穿着迷彩服长得都差不多？）网友面基了属于是。</p><p>忙了一中午之后，带了蜜雪冰城犒劳了一下各位小伙伴们，吃了饭，回实验室休息了一小会，然后又带了两把椅子回来，小伙伴在打牌玩。上训的时候来咨询的学弟学妹们就少很多了，基本都是赶着去集合。我也逛了逛其他社团的摊位，倒是没有我感兴趣的。以后清闲了可以在学校创办一个 现代工业社，为各位工业党组织一个交流的平台。</p><p>之后就是让其他小伙伴们回去休息，我独自一人趴着睡觉了一下午，直到思达同学过来，我们一起摆电脑（更有开发实验室的感觉了）下午下训的人多了一点。过了一会还有学弟买可乐慰问我 hhhh</p><p>晚上等它们上训之后我们就撤了，领了外卖吃完之后，就去准备和苯苯面基。下训之前和小熊一起乱转，唱跳天文，音乐这几个社团聚集在一起氛围很棒。因为是晴天，月亮还很圆，能用它们的天文望远镜看很清晰的月亮，大概有 80 倍的无损。因为不太好意思就没去拍照。</p><p>后来面基了苯苯，拉了几个学弟学妹进招生群，还见到了可爱的小虾，一起去超市买了糖，路途中间还是有点尴尬，不过对我来说已经是很大的进步了。最后有点小后悔没把她送到楼下。</p><p>赶完模电作业，洗了澡，一天结束了。好耶！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;为什么会想起来要写这个东西呢，emmmmmmm，大概是因为，觉得最近的自己好幸福，因此想要将最近发生的事情都一一记录下来，免得都忘记了 QAQ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;9-月-19-日-周日&quot;&gt;&lt;a href=&quot;#9-月</summary>
      
    
    
    
    <category term="Diary" scheme="https://xorex.space/categories/Diary/"/>
    
    
    <category term="Diary" scheme="https://xorex.space/tags/Diary/"/>
    
  </entry>
  
  <entry>
    <title>JVM-02-内存结构</title>
    <link href="https://xorex.space/2021/09/14/1a1fe348928a/"/>
    <id>https://xorex.space/2021/09/14/1a1fe348928a/</id>
    <published>2021-09-14T04:50:52.000Z</published>
    <updated>2021-09-19T16:21:49.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
      
    
    
    
    <category term="开发底层原理" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="JVM" scheme="https://xorex.space/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-01-类加载子系统</title>
    <link href="https://xorex.space/2021/09/07/8934dfa7770a/"/>
    <id>https://xorex.space/2021/09/07/8934dfa7770a/</id>
    <published>2021-09-06T16:25:43.000Z</published>
    <updated>2021-09-19T16:21:32.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从零开始的-JVM-学习生活"><a href="#从零开始的-JVM-学习生活" class="headerlink" title="从零开始的 JVM 学习生活"></a>从零开始的 JVM 学习生活</h2><p>JVM 作为 Java 运行的平台，的确是需要好好玩一玩的！</p><h2 id="JVM-声明周期"><a href="#JVM-声明周期" class="headerlink" title="JVM 声明周期"></a>JVM 声明周期</h2><p>JVM 生命周期分为 启动 执行 结束 三个阶段。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>通过 BootStrap ClassLoader 这个类加载器把该虚拟机的初始类加载进来并执行（初始类负责完成启动工作，不同的 JVM 初始类叫法不同）</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>一个 Java 程序的执行本质就是一个 JVM 进程的执行，执行过程中可以看到 OpenJDK Platform 这个进程的资源使用情况。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>JVM 结束可能情况：</p><ul><li>正常程序结束</li><li>出现错误和未处理异常</li><li>操作系统出现错误</li><li>Java 某个线程调用了 exit 方法（会结束整个 JVM 进程）</li></ul><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p>Class Loading SubSystem</p><p>这个系统主要负责将一个 class 文件加载到 JVM 中的全过程，而这个过程包含下面的 <strong>加载-链接-初始化</strong> 三个步骤。</p><h3 id="加载-Loading"><a href="#加载-Loading" class="headerlink" title="加载 Loading"></a>加载 Loading</h3><p>加载 Loading 过程主要干了三件事：</p><ul><li>先获取类的二进制字节流（读取 class 文件获取流）</li><li>将二进制字节流转化为内存中方法区的数据（将文件内容转移到内存中固定格式的数据）</li><li>在内存中生成此类的 Class 对象，作为方法区这些数据的入口（获取操作这些数据的接口）</li></ul><h3 id="链接-Linking"><a href="#链接-Linking" class="headerlink" title="链接 Linking"></a>链接 Linking</h3><p>链接 Linking 也主要干三件事：<strong>验证-准备-解析</strong></p><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证 Verify"></a>验证 Verify</h4><p>主要是为了保证上一步加载进来的二进制数据都是合法的。</p><ul><li>文件格式验证：</li></ul><p>验证文件内容组成是否符合 JVM 规范（文件结构校验）</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">魔数 CAFEBABE</span><br><span class="line">版本号是否能被处理</span><br><span class="line">常量池 tag 是否在范围内</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ul><li>元数据验证：</li></ul><p>对类的描述信息进行语义验证（语法校验）</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个类是否继承了标了 final 的类</span><br><span class="line">这个类是否实现了接口或者抽象父类的所有方法</span><br><span class="line">重写的方法是否符合重写规则</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ul><li>字节码验证</li></ul><p>对方法体的字节码指令验证（运行时语法校验）</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">操作栈放入 int 却按照 float 加载</span><br><span class="line">跳转指令跳转到其他方法的指令上面</span><br><span class="line">类型转化是否符合向上转型</span><br><span class="line">......</span><br></pre></td></tr></table></figure><ul><li>符号引用验证</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如常量池的引用类型全限定内名能否找到类</span><br><span class="line">引用的数据访问行是否合法 public private 等</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备 Prepare"></a>准备 Prepare</h4><p>准备这一段主要在为类的非 static final 字段分配内存。该地址的内存空间中全是二进制零，也就是： 0 false 0x00 \u0000 0.0f null(引用类型) 等等。</p><p>对于一个非 static final 的字段来说，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>实现执行 prepare 阶段，为 i 分配内存，内存中值为 0，结束 prepare 之后，会在后面的阶段（static 是在类加载子系统的初始化阶段，非 static XXXXX）为 i 设置自定义初始值 10。</p><hr><p>为什么 final 字段一定要自定义初始化？</p><p>如果不在<strong>定义</strong>的时候或者<strong>构造函数</strong>中对 final 字段进行赋值的话，则生成的对象中 final 字段的值是未知的，外部也不知道此字段是否能赋值。因此 final 字段要么在定义的时候给初始化值，要么在构造函数中进行初始化，总之绝不能在实例中调用 final 是一个未知量。</p><hr><p>结合上面 final 的分析，因为 static final 不依赖于实例，所以自然没了 final 字段中构造函数初始化的方式，是只能也必须在定义的时候给出初始化值的。</p><p>这样 static final 初始化值一定是常量，是在编译成字节码的时候就确定的。因此这里在准备阶段分配完内存之后，<strong>直接默认给初值为常量值了</strong>。因此 static final 的字段初始化值确定就是在 Prepare 阶段完成的。</p><h4 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析 Resolve"></a>解析 Resolve</h4><p>解析主要是符号引用（比如限定全类名，<code>Ljava/lang/String;</code> <code>toString()</code>）转化为一个指向目标的指针，比如（String 的 Class 对象地址，方法区 toString() 的地址）</p><p>解析主要是在 JVM 执行完下面的初始化之后再执行的。</p><p>除了符号引用变为目标引用，还会在这个过程中建立一个虚方法表，用来解决由于多态引起的频繁方法分派的问题。</p><h3 id="初始化-Inilalization"><a href="#初始化-Inilalization" class="headerlink" title="初始化 Inilalization"></a>初始化 Inilalization</h3><p>这个初始化是针对类 static （不包括 static final）字段和 static 代码块。链接的准备阶段为字段分配了内存空间，而这个现在所处的阶段就是为分配了空间的 static 字段进行赋值和执行 static 代码块里面的内容。 </p><p>这里的初始化就是调用通过字节码指令分析（收集所有的 static 字段赋值指令和 static 代码块中的代码指令）生成的一个 <code>&lt;clinit&gt;</code> (class init) 方法，把所有对 static 字段进行初始化的代码和结合在一起，然后执行，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会生成用来执行的初始化方法 <code>&lt;clinit&gt;</code>，它的字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> iconst_1</span><br><span class="line"> 1 putstatic #7 &lt;space/xorex/rename/Test.num : I&gt;</span><br><span class="line"> <span class="number">4</span> iconst_1</span><br><span class="line"> <span class="number">5</span> istore_0</span><br><span class="line"> <span class="number">6</span> iload_0</span><br><span class="line"> <span class="number">7</span> bipush <span class="number">10</span></span><br><span class="line"> <span class="number">9</span> if_icmpgt <span class="number">18</span> (+<span class="number">9</span>)</span><br><span class="line"><span class="number">12</span> iinc <span class="number">0</span> by <span class="number">1</span></span><br><span class="line"><span class="number">15</span> goto <span class="number">6</span> (-<span class="number">9</span>)</span><br><span class="line"><span class="number">18</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>这里生成的 <code>&lt;clinit&gt;</code> 就是将 static 的 num 赋值语句和 static 代码块里面的语句的字节码放在一起，然后在当前线程中执行它。</p><hr><p>需要注意的是，在初始化阶段中的 <code>&lt;clinit&gt;</code> 执行内容中是不包括 static final 的初始化赋值的，因为这个过程已经在链接的 Prepare 阶段完成。</p><p>并且 <code>&lt;clinit&gt;</code> 的执行过程是线程安全的，一个类只会被类加载一次，也就是只会执行一次 <code>&lt;clinit&gt;</code> 方法。</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器负责，类加载系统中的装载 Loader 阶段，也就读取二进制字节流并生成对应的 Class 对象。</p><p>来看看一个类是如何被加载到 JVM 中的吧：</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>引导类加载器 BootStrapClassLoader</li></ul><p>作用：用来加载 Java 核心库的类（java、javax、sun 开头的类），使用 C++ 编写，无法获取其对象，作为 JVM 的一部分。在 JVM 启动的时候，就会调用 BootStrapClassLoader 去加载一些 JVM 需要的类，其中就包括了 ExtClassLoader 和 AppClassLoader （所以这两个 ClassLoader 是 BootStrapClassLoader 加载出来的），并作为 ExtClassLoader 的父加载器。</p><p>这里是在 Launcher （BootStrapClassLoader 加载的）里面实现上面的内容的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String bootClassPath =</span><br><span class="line">        System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> launcher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 ExtClassLoader 父加载器为 null（其实就是 BootStrapClassLoader）</span></span><br><span class="line">        ClassLoader extcl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            extcl = ExtClassLoader.getExtClassLoader();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                <span class="string">&quot;Could not create extension class loader&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 AppClassLoader 并将 ExtClassLoader 设置为其父加载器</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            loader = AppClassLoader.getAppClassLoader(extcl);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(</span><br><span class="line">                <span class="string">&quot;Could not create application class loader&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置当前线程的上下文类加载器</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义类加载器 UserDefineClassLoader</li></ul><p>概念：这里不是特指程序员自己写的类加载器，而是所有继承了 ClassLoader 类的加载器都叫自定义加载器。</p><p>比如用来加载 ext 目录下类的扩展类加载器 ExtClassLoader，以及负责加载 classpath 的应用程序类加载器 AppClassLoader 也就是我们自己编写的类的默认加载器。</p><p>当然我们也可以自己定义类加载器，来实现特殊的功能，这个后面再说。</p><h3 id="获取类加载器"><a href="#获取类加载器" class="headerlink" title="获取类加载器"></a>获取类加载器</h3><ol><li>获取指定类的类加载器 clazz.getClassLoader()</li><li>获取当前线程执行类的类加载器 Thread.currentThread().getContextClassLoader()</li><li>获取当前系统加载第三方类的默认的 ClassLoader（一般来说是 AppClassLoader）ClassLoader.getSystemClassLoader()在我们代码里面，引用一个类的时候（需要被加载），是当前线程调用 getContextClassLoader() 获取的，默认是 AppClassLoader，也就是说，我们引用的类一般都是使用默认的 AppClassLoader 来处理。而加载核心库和 BootStrapClassLoader 和加载 ext 目录下的扩展类的 ExtClassLoader 什么时候排上用场呢，就要轮到下面介绍的双亲委派机制了：</li></ol><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>当一个类加载器收到了类加载请求会先交给它的父类加载器处理，当父类加载器无法处理的时候，自己再判断能否处理，能就处理就处理。所以所有的类加载都会被上级 ClassLoader 确认，保证了一定是最顶级的类加载器去加载自己能加载的类：</p><p><img src="https://xorex.space/image/331.jpg" alt="331.jpg"></p><p>说起类加载器的双亲委派机制，就要讨论一下 ClassLoader 这个抽象类了。</p><p>核心方法的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断类是否被加载</span></span><br><span class="line">    Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没被加载就进入双亲委派机制里</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c = parent.loadClass(name, <span class="keyword">false</span>); <span class="comment">//交给父加载器处理</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//父加载器为 null 的就让 BootStrap 来干</span></span><br><span class="line">            c = findBootstrapClassOrNull(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123; <span class="comment">//父加载器也搞不定，那就自己处理</span></span><br><span class="line">            c = findClass(name); <span class="comment">//处理的是 findClass()</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>想要自定义其实就继承 ClassLoader 抽象类即可，然后重写方法 findClass()，不直接重写被调用的 loadClass() 方法是因为想要保留双亲委派机制，所以就更改 findClass() 来更改对字节码的处理过程实现自定义类加载器。</p><p>下面就是一个针对 AES 加密算法加密过的 .class 文件进行加载的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//加锁保证所有线程只会加载一次此类</span></span><br><span class="line">        <span class="keyword">synchronized</span>(getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">//被调用到就说明所有的父加载器都无法处理</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                File file = <span class="keyword">new</span> File(path);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = AESUtil.decrypt(file, <span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">                <span class="comment">//解码获取源字节数组之后，调用 defineClass 将合法的字节数组解析到符合 Class 的内存中并返回对象（此方法核心是 native 方法，交给 C++ 处理）</span></span><br><span class="line">                <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类加载子系统暂时告一段落，下一个目标，运行时数据区概述及线程！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;从零开始的-JVM-学习生活&quot;&gt;&lt;a href=&quot;#从零开始的-JVM-学习生活&quot; class=&quot;headerlink&quot; title=&quot;从零开始的 JVM 学习生活&quot;&gt;&lt;/a&gt;从零开始的 JVM 学习生活&lt;/h2&gt;&lt;p&gt;JVM 作为 Java 运行的平台，的确是需</summary>
      
    
    
    
    <category term="开发底层原理" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="JVM" scheme="https://xorex.space/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM-00-工具使用</title>
    <link href="https://xorex.space/2021/08/28/5d198c827fc8/"/>
    <id>https://xorex.space/2021/08/28/5d198c827fc8/</id>
    <published>2021-08-28T13:37:57.000Z</published>
    <updated>2021-09-19T16:21:07.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM-相关设置"><a href="#JVM-相关设置" class="headerlink" title="JVM 相关设置"></a>JVM 相关设置</h2><p><code>-XX:+PrintFlagsInitial</code> 打印所有 JVM 的默认参数。</p><p><code>-XX:+PrintFlagsFinal</code> 打印经过修改之后的 JVM 参数。</p><p><code>-XX:+PrintGCDetials</code> 执行过程中输出 GC 的过程。</p><p><code>-Xms100m</code> 等价于 <code>-XX:InitialHeapSize=100m</code> 设置堆空间的初试内存大小为 100m，默认物理内存 1/64。</p><p><code>-Xmx100m</code> 等价于 <code>-XX:MaxHeapSize=100m</code> 设置对空间的最大内存大小为 100m，默认物理内存 1/4。</p><p><code>-Xss1m</code>（可以附加单位）等价于 <code>-XX:ThreadStackSize=1024</code>（指定单位为 kb）</p><p><code>-XX:SurvivorRatio=8</code> 设置 S0 S1 区和 Eden 区比例为 1:1:8 。</p><p><code>-XX:NewRatio=3</code> 设置新生代和老年代的比例为 1:3。</p><p><code>-XX:MaxTenuringThreshold=10</code> 设置 S 区晋升老年代的时间门槛为生存 10 次 GC。</p><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>Java Process Status，用来查看 Java 当前正在运行的进程的相关信息。</p><p><code>jps</code> 输出 PID 和进程名。</p><p><code>jps -l</code> 输出 PID 和详细的进程名。</p><p><code>jps -v</code> 打印 JVM 的设置参数。</p><h2 id="jVirutalVM"><a href="#jVirutalVM" class="headerlink" title="jVirutalVM"></a>jVirutalVM</h2><p>可视化工具</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM-相关设置&quot;&gt;&lt;a href=&quot;#JVM-相关设置&quot; class=&quot;headerlink&quot; title=&quot;JVM 相关设置&quot;&gt;&lt;/a&gt;JVM 相关设置&lt;/h2&gt;&lt;p&gt;&lt;code&gt;-XX:+PrintFlagsInitial&lt;/code&gt; 打印所有 JVM 的</summary>
      
    
    
    
    <category term="开发底层原理" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="jvm" scheme="https://xorex.space/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM 疑问表</title>
    <link href="https://xorex.space/2021/08/23/758bc43727a3/"/>
    <id>https://xorex.space/2021/08/23/758bc43727a3/</id>
    <published>2021-08-23T08:26:01.000Z</published>
    <updated>2021-09-19T16:20:57.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ol><li><p>被加载到内存的类的具体格式是什么位置在哪里，每一部分的信息是如何放到内存中的，又是如何提供给外界访问的。</p></li><li><p>将符号引用解析为直接引用的过程是如何实现的，Hash 表吗？</p></li><li><p>早期绑定，晚期绑定，静态链接，动态链接概念上的区别。</p></li><li><p>晚期绑定的流程是什么样的，是对运行时常量池中替换还是虚拟机栈中的动态链接进行替换？</p></li><li><p>为什么 Java 中的 Lambda 表达式是动态语言特性，哪里体现了变量类型是由运行时的值确定的？将 Lambda 赋值给一个变量不也需要声明变量的接口类型吗。</p></li><li><p>虚方法表在内存中的位置是哪里，多态的具体实现原理，方法分派的流程。</p></li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;被加载到内存的类的具体格式是什么位置在哪里，每一部分的信息是如何放到内存中的，又是如何提供给外界访问的。&lt;</summary>
      
    
    
    
    <category term="开发底层原理" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="JVM" scheme="https://xorex.space/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JavaByteCodeResolver 项目记录</title>
    <link href="https://xorex.space/2021/08/18/36f2db03f802/"/>
    <id>https://xorex.space/2021/08/18/36f2db03f802/</id>
    <published>2021-08-18T08:58:53.000Z</published>
    <updated>2021-08-26T16:12:55.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MUTF-Charset-实现"><a href="#MUTF-Charset-实现" class="headerlink" title="MUTF Charset 实现"></a>MUTF Charset 实现</h2><h2 id="BytesTo-Double-Float"><a href="#BytesTo-Double-Float" class="headerlink" title="BytesTo Double Float"></a>BytesTo Double Float</h2><p>整个实现的细节 etc</p><p>QAQ ，明天早上就去写！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MUTF-Charset-实现&quot;&gt;&lt;a href=&quot;#MUTF-Charset-实现&quot; class=&quot;headerlink&quot; title=&quot;MUTF Charset 实现&quot;&gt;&lt;/a&gt;MUTF Charset 实现&lt;/h2&gt;&lt;h2 id=&quot;BytesTo-Doubl</summary>
      
    
    
    
    <category term="项目记录" scheme="https://xorex.space/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="JVM" scheme="https://xorex.space/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java .class 文件结构</title>
    <link href="https://xorex.space/2021/08/14/e5acbdd3c85b/"/>
    <id>https://xorex.space/2021/08/14/e5acbdd3c85b/</id>
    <published>2021-08-14T06:07:20.000Z</published>
    <updated>2021-08-22T02:51:43.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>我们来看看 Java 的 Hello World 程序经过 Javac (Java Compiler) 之后，会编译成 Java 字节码文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F </span><br><span class="line">00000000: CA FE BA BE 00 00 00 3B 00 1D 0A 00 02 00 03 07    J~:&gt;...;........</span><br><span class="line">00000010: 00 04 0C 00 05 00 06 01 00 10 6A 61 76 61 2F 6C    ..........java&#x2F;l</span><br><span class="line">00000020: 61 6E 67 2F 4F 62 6A 65 63 74 01 00 06 3C 69 6E    ang&#x2F;Object...&lt;in</span><br><span class="line">00000030: 69 74 3E 01 00 03 28 29 56 09 00 08 00 09 07 00    it&gt;...()V.......</span><br><span class="line">00000040: 0A 0C 00 0B 00 0C 01 00 10 6A 61 76 61 2F 6C 61    .........java&#x2F;la</span><br><span class="line">00000050: 6E 67 2F 53 79 73 74 65 6D 01 00 03 6F 75 74 01    ng&#x2F;System...out.</span><br><span class="line">00000060: 00 15 4C 6A 61 76 61 2F 69 6F 2F 50 72 69 6E 74    ..Ljava&#x2F;io&#x2F;Print</span><br><span class="line">00000070: 53 74 72 65 61 6D 3B 08 00 0E 01 00 0C 48 65 6C    Stream;......Hel</span><br><span class="line">00000080: 6C 6F 20 57 6F 72 6C 64 21 0A 00 10 00 11 07 00    lo.World!.......</span><br><span class="line">00000090: 12 0C 00 13 00 14 01 00 13 6A 61 76 61 2F 69 6F    .........java&#x2F;io</span><br><span class="line">000000a0: 2F 50 72 69 6E 74 53 74 72 65 61 6D 01 00 07 70    &#x2F;PrintStream...p</span><br><span class="line">000000b0: 72 69 6E 74 6C 6E 01 00 15 28 4C 6A 61 76 61 2F    rintln...(Ljava&#x2F;</span><br><span class="line">000000c0: 6C 61 6E 67 2F 53 74 72 69 6E 67 3B 29 56 07 00    lang&#x2F;String;)V..</span><br><span class="line">000000d0: 16 01 00 18 4A 61 76 61 2F 56 53 63 6F 64 65 50    ....Java&#x2F;VScodeP</span><br><span class="line">000000e0: 72 6F 6A 65 63 74 2F 48 65 6C 6C 6F 01 00 04 43    roject&#x2F;Hello...C</span><br><span class="line">000000f0: 6F 64 65 01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72    ode...LineNumber</span><br><span class="line">00000100: 54 61 62 6C 65 01 00 04 6D 61 69 6E 01 00 16 28    Table...main...(</span><br><span class="line">00000110: 5B 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69    [Ljava&#x2F;lang&#x2F;Stri</span><br><span class="line">00000120: 6E 67 3B 29 56 01 00 0A 53 6F 75 72 63 65 46 69    ng;)V...SourceFi</span><br><span class="line">00000130: 6C 65 01 00 0A 48 65 6C 6C 6F 2E 6A 61 76 61 00    le...Hello.java.</span><br><span class="line">00000140: 21 00 15 00 02 00 00 00 00 00 02 00 01 00 05 00    !...............</span><br><span class="line">00000150: 06 00 01 00 17 00 00 00 1D 00 01 00 01 00 00 00    ................</span><br><span class="line">00000160: 05 2A B7 00 01 B1 00 00 00 01 00 18 00 00 00 06    .*7..1..........</span><br><span class="line">00000170: 00 01 00 00 00 03 00 09 00 19 00 1A 00 01 00 17    ................</span><br><span class="line">00000180: 00 00 00 25 00 02 00 01 00 00 00 09 B2 00 07 12    ...%........2...</span><br><span class="line">00000190: 0D B6 00 0F B1 00 00 00 01 00 18 00 00 00 0A 00    .6..1...........</span><br><span class="line">000001a0: 02 00 00 00 05 00 08 00 06 00 01 00 1B 00 00 00    ................</span><br><span class="line">000001b0: 02 00 1C                                           ...</span><br></pre></td></tr></table></figure><p>然后我们可以使用 Java 自带的反编译工具 javap 来对字节码反编译：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Classfile /E:/Work/Java/VScodeProject/Hello.class</span><br><span class="line">  Last modified 2021年8月14日; size 435 bytes</span><br><span class="line">  SHA-256 checksum 324a5e74b6109dc3e1235281f57ee39e74d08af19760dda79433bd878f5a7ece</span><br><span class="line">  Compiled from &quot;Hello.java&quot;</span><br><span class="line">public class Java.VScodeProject.Hello</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 59</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #21                         // Java/VScodeProject/Hello</span><br><span class="line">  super_class: #2                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #2.#3          // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #4             // java/lang/Object</span><br><span class="line">   #3 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               &lt;init&gt;</span><br><span class="line">   #6 = Utf8               ()V</span><br><span class="line">   #7 = Fieldref           #8.#9          // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #8 = Class              #10            // java/lang/System</span><br><span class="line">   #9 = NameAndType        #11:#12        // out:Ljava/io/PrintStream;</span><br><span class="line">  #10 = Utf8               java/lang/System</span><br><span class="line">  #11 = Utf8               out</span><br><span class="line">  #12 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #13 = String             #14            // Hello Wrold!</span><br><span class="line">  #14 = Utf8               Hello Wrold!</span><br><span class="line">  #15 = Methodref          #16.#17        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #16 = Class              #18            // java/io/PrintStream</span><br><span class="line">  #17 = NameAndType        #19:#20        // println:(Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               java/io/PrintStream</span><br><span class="line">  #19 = Utf8               println</span><br><span class="line">  #20 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #21 = Class              #22            // Java/VScodeProject/Hello</span><br><span class="line">  #22 = Utf8               Java/VScodeProject/Hello</span><br><span class="line">  #23 = Utf8               Code</span><br><span class="line">  #24 = Utf8               LineNumberTable</span><br><span class="line">  #25 = Utf8               main</span><br><span class="line">  #26 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #27 = Utf8               SourceFile</span><br><span class="line">  #28 = Utf8               Hello.java</span><br><span class="line">&#123;</span><br><span class="line">  public Java.VScodeProject.Hello();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #13                 // String Hello Wrold!</span><br><span class="line">         5: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 8</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Hello.java&quot;</span><br></pre></td></tr></table></figure><p>对于一个字节码文件来说，一共由以下十个部分的组成：</p><ul><li><p>魔数字 Magic Number 类似于网络传输的 MIME 协议，用来标识文件的内容类型。</p></li><li><p>版本号 Minor/Major Version 生成的字节码 Javac 版本。</p></li><li><p>常量池 Constant Pool </p></li><li><p>类访问标记 Access Flag</p></li><li><p>类访问索引 This Class</p></li><li><p>超类索引 Super Class</p></li><li><p>接口表索引 Interface</p></li><li><p>字段表 Field</p></li><li><p>方法表 Method</p></li><li><p>属性表 Attribute</p></li></ul><h2 id="魔数-Magic-Number"><a href="#魔数-Magic-Number" class="headerlink" title="魔数 Magic Number"></a>魔数 Magic Number</h2><p>很多类型的文件，其起始的几个字节的内容是固定的（或是有意填充，或是本就如此）。因此这几个字节的内容也被称为魔数 (Magic Number)，因为根据这几个字节的内容就可以确定文件类型。</p><p>Java 字节码文件 <code>.class</code> 的内容开头标识为前四个字节： CAFEBABE，咖啡宝贝：</p><p><img src="https://xorex.space/image/328.jpg" alt="328.jpg"></p><p>当我们修改了 <code>.class</code> 里面的魔数之后，JVM 再去加载并运行这个类的时候，就会报错了，说魔数值不相容 Incompatible：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\Work&gt;java Java.VScodeProject.Hello</span><br><span class="line">Error: LinkageError occurred while loading main class Java.VScodeProject.Hello</span><br><span class="line">        java.lang.ClassFormatError: Incompatible magic value 3405691579 in class file Java/VScodeProject/Hello</span><br></pre></td></tr></table></figure><p>其实 Java 创始人还想了一个魔数：CAFEHEAD，不过这个 CAFEHEAD 用到了 Java 的序列化文件的魔数了。</p><h2 id="版本号-Minor-Verson"><a href="#版本号-Minor-Verson" class="headerlink" title="版本号 Minor Verson"></a>版本号 Minor Verson</h2><p>版本号码就是紧跟着魔数的后面四个字节的内容，表示 Javac 编译时的版本号：</p><p><img src="https://xorex.space/image/329.jpg" alt="329.jpg"></p><p>里面的 0x3B 就是 59 版本号，表示 Java 15 版本的 Javac 编译出来的。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Java 1.2 使用主要版本 46</span><br><span class="line">Java 1.3 使用主要版本 47</span><br><span class="line">Java 1.4 使用主要版本 48</span><br><span class="line">Java 5 使用主要版本 49</span><br><span class="line">...</span><br><span class="line">Java 8 使用主要版本 52</span><br><span class="line">...</span><br><span class="line">Java 15 使用主要版本 59</span><br></pre></td></tr></table></figure><p>当版本号大于 JVM 的版本的时候，加载就会报错 59 的 JVM 没法加载 74 Javac 编译的文件：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\Work&gt;java Java.VScodeProject.Hello</span><br><span class="line">Error: LinkageError occurred while loading main class Java.VScodeProject.Hello</span><br><span class="line">        java.lang.UnsupportedClassVersionError: Java/VScodeProject/Hello has been compiled by a more recent version of the Java Runtime (class file version 74.0), this version of the Java Runtime only recognizes class file versions up to 59.0</span><br></pre></td></tr></table></figure><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>紧跟着后面的就是常量池了，主要存储复杂的常量（简单的如 0 这些直接内嵌到后面的代码中）。</p><p>这个常量池的结构是这样的，最前面的两个字节变量为 poolCount 表示一共有多少个常量，这里的 HelloWorld 是 0x001D，表示一共有 29 个，除掉保留的 id 0，一共有 28 个常量。然后这个 poolCount 后面的内容就是一块一块的常量表示了。一共有 28 块。</p><p>这 28 块的长度是不知道的，只能一个一个依次读取每一个常量块，然后确认里面的内容，直到读完 28 个之后，才结束对常量池的处理。</p><p>对于每一个常量块，是由 tag + 内容 组成的，下面是 tag 值和类型含义：</p><table><thead><tr><th>tag</th><th>常量项类型</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>CONSTANT_Utf8</td><td>用于存储字符串的常量项。该项真正包含了字符串内容。而 CONSTANT_String 常量项只存储了一个指向 CONSTANT_Utf8 项的索引。</td></tr><tr><td>3</td><td>CONSTANT_Integer</td><td>Java中，int 和 float 型数据的长度都是4个字节。这两种常量分别代表 int 和 float 型数据信息。</td></tr><tr><td>4</td><td>CONSTANT_Float</td><td>同上</td></tr><tr><td>5</td><td>CONSTANT_Long</td><td>Java中， long 和 double 型数据的长度都是8个字节。这两种常量分别代表 long 以及 double 型数据信息。</td></tr><tr><td>6</td><td>CONSTANT_Double</td><td>同上</td></tr><tr><td>7</td><td>CONSTANT_Class</td><td>代表类或接口的信息。</td></tr><tr><td>8</td><td>CONSTANT_String</td><td>代表一个字符串（String）。该常量本身不存储字符串的内容，它只是存储了一个索引值。</td></tr><tr><td>9</td><td>CONSTANT_Fieldref</td><td>存储成员变量的信息。</td></tr><tr><td>10</td><td>CONSTANT_Methodref</td><td>存储成员函数的信息。</td></tr><tr><td>11</td><td>CONSTANT_InterfaceMethodref</td><td>存储接口函数的信息。</td></tr><tr><td>12</td><td>CONSTANT_NameAndType</td><td>这种类型的常量项用于描述类的成员域或成员函数相关的信息。</td></tr><tr><td>15</td><td>CONSTANT_MethodHandle</td><td>用于描述 MethodHandle 信息。MethodHandle 和反射有关系。Java类库中对应的类为 java.lang.invoke.MethodHandle 。</td></tr><tr><td>16</td><td>CONSTANT_MethodType</td><td>用于描述一个成员函数的信息。只包括函数的 参数类型 和 返回值 ，不包括函数名和所属类的类名。</td></tr><tr><td>18</td><td>CONSTANT_InvokeDynamic</td><td>用于 invokeDynamic 指令。invokeDynamic 和 Java 平台上实现了一些动态语言（如Python）相类似的有关功能。</td></tr></tbody></table><h3 id="3-Integer-4-Float"><a href="#3-Integer-4-Float" class="headerlink" title="3_Integer 4_Float"></a>3_Integer 4_Float</h3><p>Java 中，int 和 float 型数据的长度都是 4 个字节。tag 3 和 tag 4 分别代表 int 和 float 型数据信息。</p><p>当你看到一块代码为： 03 00 00 00 01 表示 tag 为 Integer 整形的常量，值为 1。（需要说一下 JVM 使用的是大端模式来存储数据，所以这里是高位在前，和 x86 小端模式相反）</p><p>我们表示为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Integer_Info &#123;</span><br><span class="line">    u1 tag; <span class="comment">//使用一个字节装 tag </span></span><br><span class="line">    u4 bytes; <span class="comment">// 使用四个字节装值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，Java 将 boolean char byte short int 这些小于等于四字节的非浮点数都以 3_Integer 来保存。</p><h3 id="5-Long-6-Double"><a href="#5-Long-6-Double" class="headerlink" title="5_Long 6_Double"></a>5_Long 6_Double</h3><p>Java中，long 和 double 型数据的长度都是8个字节。这两种常量分别代表 long 以及 double 型数据信息。再 poolCount 中，Long 和 Double 是按照两个常量快的大小计算的（按照几个不是看实际占用容量，而是另外一套规则）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Long_Info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u8 bytes; <span class="comment">//JVM 大端模式直接写就好</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTANT_Double_Info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u8 bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-UTF8"><a href="#1-UTF8" class="headerlink" title="1_UTF8"></a>1_UTF8</h3><p>这是存储的是字符串真正内容的 tag ，而 8_String 存储的则是指向 1_UTF8 的一个索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Utf8 &#123;</span><br><span class="line">    u1 tag; </span><br><span class="line">    u2 length;</span><br><span class="line">    ulength bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 length 表示后面存储字符串真正内容的 bytes 长度，而不是字符串的长度。bytes[] 里面使用 MUTF-8 （Modified UTF-8）编码来存储字符串内容。</p><p>MUTF-8 和 UTF-8 只有两处不同：</p><ol><li><p>对于 UTF-8 的一位的空字符 0x00，在 MUTF-8 使用 0xC080 两位表示，也就是：11000000 1000000（UTF-8 的两位 0x00 表示方法）</p></li><li><p>对于 UTF-8 的四字节字符，使用双字符表示。</p></li></ol><p>剩下的单字符则，双字符，三字符和 UTF-8 一模一样。</p><h3 id="8-String"><a href="#8-String" class="headerlink" title="8_String"></a>8_String</h3><p>前面说了，这个只是保存一个指向 1_UTF8 的索引（也就是常量块的 ID），从哪里找 String 的真正内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_String &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 utf8StringIndex; <span class="comment">//真正内容的存储地方</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Class"><a href="#7-Class" class="headerlink" title="7_Class"></a>7_Class</h3><p>用来表示类或者接口，同样不保存类的具体内容，而是指向一个 1_UTF8 的索引，里面保存了类的全限定名称，如 <code>java/lang/System</code>。</p><p>表示方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 utf8ClassIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-NameAndType"><a href="#12-NameAndType" class="headerlink" title="12_NameAndType"></a>12_NameAndType</h3><p>使用 NameAndType 来表示字段和方法，记录了字段或者方法的名字（指向 1_utf8 的 ID）和描述符（同样是指向 1_utf8 的 ID），占用三个常量池 ID:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_NameAndType &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 utf8NameIndex;</span><br><span class="line">    u2 utf8DescriptorIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>名字就是方法名或者字段名，而描述符的规则具体的可以看下面在介绍字段表和方法表里面的东西。</p><h3 id="9-Fieldref-10-Methodref-11-InterfaceMethodref"><a href="#9-Fieldref-10-Methodref-11-InterfaceMethodref" class="headerlink" title="9_Fieldref 10_Methodref 11_InterfaceMethodref"></a>9_Fieldref 10_Methodref 11_InterfaceMethodref</h3><p>三者主要都是用来标记在类中出现过的字段，方法的。</p><p>其中本类的所有字段都会以 Fieldref 的格式保存在常量池中。本类所创建的所有方法和代码调用的所有方法以 Methodref 格式保存，而代码调用过的接口的方法，则以 InterfaceMethodref 保存。</p><p>三者的结构模式都是一样的，固定的 tag 来区分常量块里面的内容，classIndex 指向一个 7_Class 的 ID 描述此字段方法接口所属的 Class 的信息，nameAndTypeIndex 指向一个 12_NameAndType 的 ID 描述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Field/Method/InterfaceMethod-ref &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 classIndex;</span><br><span class="line">    u2 nameAndTypeIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-MethodHandle-16-MethodType-18-InvokeDynamic"><a href="#15-MethodHandle-16-MethodType-18-InvokeDynamic" class="headerlink" title="15_MethodHandle 16_MethodType 18_InvokeDynamic"></a>15_MethodHandle 16_MethodType 18_InvokeDynamic</h3><p>这些主要是为了更好的支持动态语言调用出现的。具体内容就不多介绍了。</p><h2 id="访问标记"><a href="#访问标记" class="headerlink" title="访问标记"></a>访问标记</h2><p>紧接着常量池的就是访问标记了，集合成两个字节。</p><p><img src="https://xorex.space/image/330.jpg" alt="330.jpg"></p><h2 id="This-Class-Super-name-Interfaces"><a href="#This-Class-Super-name-Interfaces" class="headerlink" title="This_Class Super_name Interfaces"></a>This_Class Super_name Interfaces</h2><p>这三个都是用来记录当前类索引，父类索引，接口索引的。</p><p>每个占据两个二字节，分别指向一个 7_Class 和 1_Utf8 类型，记录类或接口信息，和名字。</p><h2 id="字段表"><a href="#字段表" class="headerlink" title="字段表"></a>字段表</h2><h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h3><p>是一个类似于常量池的变长结构，是用来记录整个类中的所有字段的信息的。最大的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FieldTable &#123;</span><br><span class="line">    u2 fieldsCount <span class="comment">//类种的字段数量</span></span><br><span class="line">    FieldInfo[] Fields[fieldsCount] <span class="comment">//多个 FieldInfo 组成的每个字段的信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是描述字段信息的 FieldInfo 了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FieldInfo &#123;</span><br><span class="line">    u2 accessFlags <span class="comment">//两个字节，字段访问标记，原理和上面的类访问标记一样</span></span><br><span class="line">    u2 nameIndex <span class="comment">//1_utf8 的常量池地址，字段名</span></span><br><span class="line">    u2 descriptorIndex <span class="comment">//1_utf8 常量池地址，字段描述符</span></span><br><span class="line">    u2 attributesCount <span class="comment">//字段属性数量</span></span><br><span class="line">    attributeInfo attributtes[attributesCount] <span class="comment">//字段属性具体内容。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面主要介绍一下字段描述符和字段属性具体内容：</p><h3 id="字段描述符规则"><a href="#字段描述符规则" class="headerlink" title="字段描述符规则"></a>字段描述符规则</h3><table><thead><tr><th>描述符</th><th>类型</th></tr></thead><tbody><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>D</td><td>double</td></tr><tr><td>F</td><td>floats</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>S</td><td>short</td></tr><tr><td>Z</td><td>boolean</td></tr><tr><td>‘L’+’FullClassName’+’;’</td><td>引用类型</td></tr><tr><td>[</td><td>一个维度的数组</td></tr></tbody></table><p>举个例子，<code>String[]</code> 被描述为：<code>[Ljava/lang/String;</code>，<code>[</code> 为一维数组，<code>L</code> 表示为引用类型，<code>java/lang/String</code> 为引用类型的全类名，<code>;</code> 为结束符号。 </p><h3 id="字段属性具体内容"><a href="#字段属性具体内容" class="headerlink" title="字段属性具体内容"></a>字段属性具体内容</h3><p>先欠着，以后再写。</p><h2 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h2><p>方法表的结构和 字段表差不多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MethodTable &#123;</span><br><span class="line">  u2 methodsCount</span><br><span class="line">  MethodInfo[] methods[MethodCount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MethodInfo &#123;</span><br><span class="line">  u2 accessFlags</span><br><span class="line">  u2 nameIndex</span><br><span class="line">  u2 descriptorIndex</span><br><span class="line">  u2 attributesCount</span><br><span class="line">  AttributeInfo attributes[attributesCount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法名和描述符"><a href="#方法名和描述符" class="headerlink" title="方法名和描述符"></a>方法名和描述符</h3><p>对于方法名索引 nameIndex 就是一个指向 utf8Info 的常量，就是方法的名字</p><p>描述符的格式则是：<code>(A)B</code> 其中 A 是方法的参数，里面参数的描述符和字段的格式是一样的，挨在一起，本身位置就在参数里面的位置，B 表示方法的返回值。</p><p><code>(IDLjava/lang/String;)Ljava/lang/Object;</code> 所表示的方法就是：</p><p>Object method(int param1,double param2,String param3);</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World&quot;&gt;&lt;/a&gt;Hello World&lt;/h2&gt;&lt;p&gt;我们来看看 Java 的 Hello World 程序经过 Java</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="JVM" scheme="https://xorex.space/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-算法入门</title>
    <link href="https://xorex.space/2021/08/09/e904f9b136c8/"/>
    <id>https://xorex.space/2021/08/09/e904f9b136c8/</id>
    <published>2021-08-09T04:15:47.000Z</published>
    <updated>2021-08-14T06:08:42.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><blockquote><p>关于老年退役 OIer 竟然忘光光所有的算法和数据结构，然后从所有 OIer 和 ACMer 都看不起的 LeetCode 开始学习算法和数据结构的故事。</p></blockquote><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><p>为什么不是具体分析而是二分模板呢，因为具体分析太乱了，left right 的范围，while 循环结束的条件，每一次 mid 判断之后，left 和 right 变化的过程。每一道题目都不一样，所以二分还是要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left+<span class="number">1</span>&lt;right) &#123; <span class="comment">//推出循环条件就是 left+1==right</span></span><br><span class="line">    mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]&gt;target) right=mid;</span><br><span class="line">    <span class="keyword">else</span> left=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出循环之后，需要的答案就在 left 或者 right 里面，只需要对他们两个进行判断就好了</span></span><br><span class="line"><span class="keyword">if</span>(XXX) XXX; <span class="comment">// 单独判断 left</span></span><br><span class="line"><span class="keyword">if</span>(XXX) XXX; <span class="comment">// 单独判断 right</span></span><br></pre></td></tr></table></figure><h3 id="算法题目"><a href="#算法题目" class="headerlink" title="算法题目"></a>算法题目</h3><p>都很简单就不搞了。</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="算法模板-1"><a href="#算法模板-1" class="headerlink" title="算法模板"></a>算法模板</h3><p>没有模板。</p><h3 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p></blockquote><ul><li>输入: nums = [1,2,3,4,5,6,7], k = 3</li><li>输出: [5,6,7,1,2,3,4]</li></ul><p>要求使用空间复杂度为 O(1) 的算法。</p><h4 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h4><p>我们观察 <code>[1,2,3,4,5,6,7]</code> 变为 <code>[5,6,7,1,2,3,4]</code> 的过程，是将原来的顺序的数组拆分成了两个部分 [5,6,7] 和 [1,2,3,4] 两个部分。我们将这个两个部分进行反转，变成 <code>[7,6,5]</code> 和 <code>[4,3,2,1]</code> 。结合在一起就变成了原数组的反转。</p><p>所以我们可以利用这个过程的逆过程来求数组右移的结果，也就是三次反转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P0189</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k=k%nums.length;</span><br><span class="line">        trunOver(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>); <span class="comment">//整体翻转</span></span><br><span class="line">        trunOver(nums, <span class="number">0</span>, k-<span class="number">1</span>); <span class="comment">//前一块翻转</span></span><br><span class="line">        trunOver(nums, k, nums.length-<span class="number">1</span>); <span class="comment">//后一块翻转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trunOver</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(end-start+<span class="number">1</span>)/<span class="number">2</span>;i++) &#123;</span><br><span class="line">            temp=nums[start+i];</span><br><span class="line">            nums[start+i]=nums[end-i];</span><br><span class="line">            nums[end-i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h4><p>这里是一个一个元素置换实现的，至于为什么需要 GCD(n,k) 轮置换才能全部结束，我根本看不懂它是怎么证明的，所以我选择另外一种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Method2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times=GCD(nums.length, k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;times;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp,pre=nums[i],next=i;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                next=(next+k)%nums.length;</span><br><span class="line">                temp=nums[next];</span><br><span class="line">                nums[next]=pre;</span><br><span class="line">                pre=temp;</span><br><span class="line">            &#125;<span class="keyword">while</span>(next!=i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y&gt;<span class="number">0</span>?GCD(y, x%y):x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那就是不计算置换多少轮，而是如果换位置的元素数量小于，则继续置换直到换位置元素数量等于 n 就好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Method3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;count&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp,pre=nums[i],next=i;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                count++; <span class="comment">//使用 count 计数</span></span><br><span class="line">                next=(next+k)%nums.length;</span><br><span class="line">                temp=nums[next];</span><br><span class="line">                nums[next]=pre;</span><br><span class="line">                pre=temp;</span><br><span class="line">            &#125; <span class="keyword">while</span>(next!=i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LeetCode&quot;&gt;&lt;a href=&quot;#LeetCode&quot; class=&quot;headerlink&quot; title=&quot;LeetCode&quot;&gt;&lt;/a&gt;LeetCode&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;关于老年退役 OIer 竟然忘光光所有的算法和数据结构，然后从所有</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://xorex.space/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://xorex.space/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-06-数据访问</title>
    <link href="https://xorex.space/2021/08/08/c76cee16e45c/"/>
    <id>https://xorex.space/2021/08/08/c76cee16e45c/</id>
    <published>2021-08-07T17:31:37.000Z</published>
    <updated>2021-08-14T06:08:14.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><h3 id="starter-data-jdbc"><a href="#starter-data-jdbc" class="headerlink" title="starter-data-jdbc"></a>starter-data-jdbc</h3><p>分析 SpringBoot 的流程，就是导入 starter，它可以帮我们所有可以默认配置的东西都配置了，除了数据库类型和数据库配置。</p><p><img src="https://xorex.space/image/327.jpg" alt="327.jpg"></p><p>可以看到为我们导入了 Spring 的 JDBC 数据库相关包 (beans,tx,core)，一个数据库连接池 HikariCP，然后就是 Spring-Data 的东西了。</p><p>我们现在导入数据库驱动，因为 starter-data-jdbc 已经仲裁版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mysql-connector-java.version</span>&gt;</span>8.0.23<span class="tag">&lt;/<span class="name">mysql-connector-java.version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以我们引入数据库驱动的时候，其实是可以不写版本号的，但是因为驱动版本过高，所以修改一下降低驱动版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>剩下的事情就是写数据库的配置了，通过 DataSourceAutoConfiguration 可以看到使用的 DataSourceProperties 的 @ConfigurationProperties 是为 spring.datasource 前缀，我们就可以再 yaml 中配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">XXXXXXX</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>项目已启动，就会运行默认的连接池 HikariCP 来连接数据库。</p><h3 id="使用-Druid"><a href="#使用-Druid" class="headerlink" title="使用 Druid"></a>使用 Druid</h3><p>阿里的 Druid 虽然性能比不过 HikariCP，但是提供了很多很方便使用的生态页面，我们来用用 Druid 试试。</p><p>使用方法很简单，加入 Druid 的 starter 之后，引入一堆 AutoConfiguration 和 Properties 自动配置，就可以直接使用了。至于更多功能的 Druid 定制化，则不在讨论范围内。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="整合-MyBatis"><a href="#整合-MyBatis" class="headerlink" title="整合 MyBatis"></a>整合 MyBatis</h3><p>同样是引入 MyBatis 的 starter 启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从使用的 MyBatisProperties 可以看出来，绑定的配置前缀是 mybatis。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mybatis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisProperties</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们就可以在 application.yaml/properties 中配置 MyBatis 了。</p><p>以前我们需要 Config.xml 和 Mapper.xml，但是现在有了自动配置之后，我们就可以利用 application.yaml/properties 的 mybatis 前缀配置将 Config.xml 配置文件给省略掉：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span> <span class="comment">#驼峰和下划线映射</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:MyBatis/Mapper/*.xml</span> <span class="comment">#mappers 位置定位</span></span><br></pre></td></tr></table></figure><p>指明了 mapper.xml 还需要将 Mapper 的接口也放入 IOC 容器中才可以，这里使用注解 <code>@Mapper</code> （标注在接口处） 或者 <code>MapperScanner</code> （建议标注在和数据库配置相关的 @Configuration 的配置类上） 来注册 Mapper 接口。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>还是引入 starter：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是 SpringBoot 默认是集成了 JUnit5 的，不包含其他的 JUnit 版本，不同的是不需要引入 Spring 环境了，在测试类的开头用 <code>@SpringBootTest</code> 就可以直接使用 SpringBoot 环境了。</p><p>剩下的东西大部分和 JUnit4 差不多，以后做项目深入学一学，练一练。</p><h2 id="指标监控-Actuator"><a href="#指标监控-Actuator" class="headerlink" title="指标监控 Actuator"></a>指标监控 Actuator</h2><p>SpringBoot 已经内置集成了 Actuator 这个东西，我们只需要引入 spring-boot-starter-actuator 即可。</p><p>具体的内容有点复杂，不太想学了，以后再搞吧……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库连接&quot;&gt;&lt;a href=&quot;#数据库连接&quot; class=&quot;headerlink&quot; title=&quot;数据库连接&quot;&gt;&lt;/a&gt;数据库连接&lt;/h2&gt;&lt;h3 id=&quot;starter-data-jdbc&quot;&gt;&lt;a href=&quot;#starter-data-jdbc&quot; class</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringBoot" scheme="https://xorex.space/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-05-视图解析与模板引擎</title>
    <link href="https://xorex.space/2021/08/03/5036c7ea09d6/"/>
    <id>https://xorex.space/2021/08/03/5036c7ea09d6/</id>
    <published>2021-08-02T16:34:12.000Z</published>
    <updated>2021-08-11T10:12:00.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图解析流程"><a href="#视图解析流程" class="headerlink" title="视图解析流程"></a>视图解析流程</h2><p>视图解析的地方主要是从返回值开始的，上一篇已经分析了返回值的处理流程，其中用于处理视图的有下面几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String</span><br><span class="line">ModelAndView</span><br><span class="line">View</span><br></pre></td></tr></table></figure><h3 id="重定向-redirect"><a href="#重定向-redirect" class="headerlink" title="重定向 redirect"></a>重定向 redirect</h3><p>我们以常用的 ViewNameMethodReturnValueHandler 来说（就是处理返回值为 String 的）：</p><p>先将视图名放到 ModelAndViewContainer 中，然后判断是不是重定向视图（看有没有 forward: 开头），经过各种数据获取之后，将 ModelAndViewContainer 里面的东西抽取并返回一个 ModelAndView 对象。</p><p>有了 ModelAndView 对象之后，也就是有了数据和视图名了，就可以去处理派发结果了调用 processDispatchResult() -&gt; render() 来渲染我们要得到的页面：</p><p>遍历所有的视图解析器（ViewResolver），通过视图名来找到可以处理当前视图的 ViewResolver，找到之后，就通过 ViewResolver 解析视图名来得到视图 View：</p><p>（比如能处理的 <code>redirect:/XXXX</code> 的 ViewResolver 就是 ContentNegotiatingViewResolver 这个解析器。它通过内部的一系列解析之后，返回了一个 RedirectView 对象。</p><p>只需要调用 RedirectView 对象的 render() 方法，它就会获取目标的 URL 地址，然后调用 response.sendRedirect(encodeedURL); 来跳转页面。</p><h3 id="页面转发-forward"><a href="#页面转发-forward" class="headerlink" title="页面转发 forward"></a>页面转发 forward</h3><p>当然还有另外一个常用的，那就是转发到其他的页面的时候，它是使用 InternalResourceView 来完成的，而核心功能还是 Servlet 的提供的原生 <code>request.getRequestDispatcher(path).forward(request,response);</code> </p><h3 id="模板页面-字符串"><a href="#模板页面-字符串" class="headerlink" title="模板页面 字符串"></a>模板页面 字符串</h3><p>如果是 Thymeleaf 模板引擎的话，就会获得一个 ThymeleafView 来渲染视图，渲染过程和 JSP 差不多：</p><p>先拿到 Model 里面的所有数据，然后明确页面的所有设置，剩下的就是在 Writer 输出流中不断的填充数据，输出代码了。 </p><h2 id="拦截器系统"><a href="#拦截器系统" class="headerlink" title="拦截器系统"></a>拦截器系统</h2><p>拦截器系统只需要实现 HandlerInterceptor 接口，具体的原理和过程可以参考原 SpringMVC 的文章。至于将自己实现的 Interceptor 放入 IOC 容器中，还是要依靠重写 WebMvcConfigurer 的配置方法。可以说所有关于 SpringMVC 的配置，都是在这个 WebMvcConfigurer 中的方法完成的。</p><p>我们只需要对这个配置类设置 Interceptor 进行重写就好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123; <span class="comment">//返回一个修改了某些默认实现的 WebMvcConfigurer 到 IOC 容器中。</span></span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">//重写添加 Interceptor 的方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">                        .addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                        .excludePathPatterns(<span class="string">&quot;/index.html&quot;</span>);</span><br><span class="line">            &#125; <span class="comment">//注意要拦截的范围</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件上传功能"><a href="#文件上传功能" class="headerlink" title="文件上传功能"></a>文件上传功能</h2><p>具体的使用方法还是看 SpringMVC，毕竟用的还是 MVC 的那一套东西，这里就分析一下源码。</p><p>关于文件上传的使用，因为 MultipartAutoConfiguration 运行的时候，从 MultipartProperties 中读取并将 StandardServletMultipartResolver 放到了 IOC 中。</p><p>当请求过来的时候，会用 StandardServletMultipartResolver 来判断当前请求是否为文件上传请求，依据就是 multipart 这个关键词。</p><p>判断成功之后会对请求进行二次包装，变成一个 StandardServletMultipartRequest，之后就是和参数解析流程一样的了，</p><p>不同的就是对于 StandardServletMultipartRequest 类型的请求，能解析它的是 RequestPartMethodArgumentResolver 。它会将请求里面的内容封装为 MultipartFile，然后传给处理方法的参数。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="基本异常响应"><a href="#基本异常响应" class="headerlink" title="基本异常响应"></a>基本异常响应</h3><p>SpringBoot 有自动的异常处理机制，只要抛了异常，对于浏览器用户，就会返回错误白页：</p><p><img src="https://xorex.space/image/325.jpg" alt="325.jpg"></p><p>对于非浏览器用户，就会返回错误的 Json 数据，因为异常信息太多了，就改成 404 了：</p><p><img src="https://xorex.space/image/326.jpg" alt="326.jpg"></p><p>自定义错误页面的话，只需要在静态资源或者模板资源目录下面创造 <code>/error</code> 文件夹，然后将状态码作为响应文件的文件名（可以使用掩码，不确定的用 x 来代替，比如 5xx.html 表示所有 5 开头的状态码）</p><p>放了之后一旦出现不正常的响应码，就会去 <code>/error</code> 下面找对应文件名，然后返回页面。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>这个源码在前面 SpringMVC 就分析过了，不过唯一不同的是当出现所有的 ExceptionResolver 都无法处理的错误的时候，SpringBoot 并不会抛给容器 Tomcat，而是转发请求到 <code>/error</code> 页面，这个页面有一个默认的 BasicErrorController 来处理。</p><p>这个 Controller 从请求域拿到各种数据，然后去找 ViewResolver 来处理这些数据，经过遍历之后，获得了一个 DefaultErrorViewResolver 来处理，它唯一干的事情就是根据响应码从 <code>/error</code> 静态页面或者模板页面里面找对应响应码的错误页面。</p><p>找到页面之后将视图名（错误页面文件名）封装到 ModelAndView 中，然后返回，开始视图 解析流程。</p><h3 id="自定义处理规则"><a href="#自定义处理规则" class="headerlink" title="自定义处理规则"></a>自定义处理规则</h3><p>先说一下具体的流程，抛出异常之后就会遍历所有的 Resolver，找到能够解析此异常的解析器。找到解析器之后，会遍历解析器内部的所有 Handler 处理器，依靠这些处理器对异常进行具体的处理。</p><p>以解析器 ExceptionHandlerExceptionResolver 来说，自定义其内部处理器方式和规则，和 SpringMVC 是一模一样的。也就是使用注解：<code>@ExceptionHandler</code> 来定义处理的异常类型和处理方法。</p><p>而要自定义 Resolver 只需要实现接口 HandlerExceptionResolver 接口，然后加上 <code>@Component</code> 注册 IOC 容器就好了。</p><h2 id="原生-Servlet-API"><a href="#原生-Servlet-API" class="headerlink" title="原生 Servlet API"></a>原生 Servlet API</h2><p>对于注册原生的 Servlet Filter Listener 来说，我们有两种方法，一种是基于注解扫描添加，一种是在 IOC 中通过修改 RegistrationBean 的行为来注册 Serlvet。</p><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>原生 Serlvet 使用方法和以前一样，不同的是自定义 Serlvet 完之后，需要使用 <code>@WebServlet(&quot;/path&quot;)</code> 来注册 Servlet 和定义映射的路径。然后在 <code>@SpringBootApplication</code> 的启动类中加上注解 <code>@ServletComponentScan(&quot;space.xorex&quot;)</code> ，来在定义扫描的包路径。</p><hr><p>或者使用 ServletRegistrationBean 来注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">servlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> Servlet(),<span class="string">&quot;/servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="function">ServletRegistrationBean <span class="title">servlet01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> Servlet01(), <span class="string">&quot;/servlet01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter 同样也是，使用 <code>@WebFilter</code> 定义路径，<code>@ServletComponentScan(&quot;space.xorex&quot;)</code> 定义扫描路径。</p><hr><p>还是可以依靠 FilterRegistrationBean 来注册 Filter，格式是和上面的一样的。</p><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>Listener 只需要用 <code>@WebListener</code> 来注册一下，然后 <code>@ServletComponentScan(&quot;space.xorex&quot;)</code> 来扫描路径。</p><hr><p>同样是可以通过 ListenerRegistrationBean 来注册 Listener，格式是和上面一样的。</p><h2 id="内嵌服务器"><a href="#内嵌服务器" class="headerlink" title="内嵌服务器"></a>内嵌服务器</h2><h3 id="内嵌原理"><a href="#内嵌原理" class="headerlink" title="内嵌原理"></a>内嵌原理</h3><p>Tomcat 是 SpringBoot 默认的内嵌服务器，在启动的时候会通过 TomcatServletWebServerFactory 来获取 TomcatWebServer 实例，并启动服务器。</p><p>而要修改内嵌的服务器，方式就是通过切换导入的 WebServer 的 Jar 包，来决定加载的服务器类型。如果要讲默认的 Tomcat 修改为 Jetty。应该将默认的 Tomcat 排除配置，然后加入 Jetty 的 starter：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后启动之后就是使用 Jetty 作为容器和服务器了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-08-08 00:26:08.499  INFO 13260 --- [  restartedMain] o.s.b.web.embedded.jetty.JettyWebServer  : Jetty started on port(s) 8080 (http&#x2F;1.1) with context path &#39;&#x2F;&#39;</span><br></pre></td></tr></table></figure><h3 id="定制-Serlvet-容器"><a href="#定制-Serlvet-容器" class="headerlink" title="定制 Serlvet 容器"></a>定制 Serlvet 容器</h3><p>这个主要就是修改 <code>server</code> 下面的配置了。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;视图解析流程&quot;&gt;&lt;a href=&quot;#视图解析流程&quot; class=&quot;headerlink&quot; title=&quot;视图解析流程&quot;&gt;&lt;/a&gt;视图解析流程&lt;/h2&gt;&lt;p&gt;视图解析的地方主要是从返回值开始的，上一篇已经分析了返回值的处理流程，其中用于处理视图的有下面几种：&lt;/p&gt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringBoot" scheme="https://xorex.space/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-04-动态资源处理</title>
    <link href="https://xorex.space/2021/08/01/d5fec45a0a25/"/>
    <id>https://xorex.space/2021/08/01/d5fec45a0a25/</id>
    <published>2021-08-01T03:54:43.000Z</published>
    <updated>2021-08-11T10:12:14.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h2><h3 id="装配原理"><a href="#装配原理" class="headerlink" title="装配原理"></a>装配原理</h3><p>装配 SpringMVC 的时候就已经装配了 HiddenHttpMethodFilter，我们只需要在配置文件中开启使用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;HiddenHttpMethodFilter.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.mvc.hiddenmethod.filter&quot;,</span></span><br><span class="line"><span class="meta">    name = &#123;&quot;enabled&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrderedHiddenHttpMethodFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就需要配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">hiddenmethod:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#开启页面表单的Rest功能</span></span><br></pre></td></tr></table></figure><h3 id="HidenHttpMethodFilter"><a href="#HidenHttpMethodFilter" class="headerlink" title="HidenHttpMethodFilter"></a>HidenHttpMethodFilter</h3><p>本质是是一个包装器模式，通过重写了 HttpRequest 的 getMethod() 方法，检测如果有 <code>_method=XXX</code> 参数并且 XXX 为允许的 PUT DELETE BATCH 三种请求，就将 getMethod() 的返回值替换成对应的请求。</p><p>这是为了解决 HTML 只能发起 GET 和 POST 请求的弊端，对于非静态页面（JavaScript），则可以发送全部请求，所以这个功能是选开的。</p><h3 id="注解更换"><a href="#注解更换" class="headerlink" title="注解更换"></a>注解更换</h3><p>SpringMVC 有多了新的注解，用来代替 <code>@RequestMapping</code>，分别是：</p><ol><li>@GetMapping</li><li>@PostMapping</li><li>@PutMapping</li><li>@DeleteMapping</li></ol><h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><p>详细的处理流程和 SpringMVC 是相同的，都是交给了 DispatcherServlet 来解决，所以我们可以完全按照 SpringMVC 的流程来进行请求处理：</p><h3 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h3><ol><li>@PathVariable 不指定名字的时候用 Map 接受所有的路径变量。</li><li>@RequestHeader 不指定名字的时候用 Map 接受所有的请求头。</li><li>@ModelAttribute 操作隐含模型，标注在属性获取数据，标注在方法上存入数据</li><li>@RequestParam 不指定名字的时候用 Map 接受所有的请求参数。</li><li>@RequestBody 获取请求体内所有数据。</li><li>@CookieValue 加名字接收 Cookie 的 String 值或 Cookie 对象，不加名字没法用。</li><li>@RequestAttribute 必须指定名字来获取指定的请求域对象的值，不支持 Map 全都拿走（为啥啊？）</li><li>@MatrixVariable 获取矩阵变量的值。</li></ol><h3 id="矩阵变量"><a href="#矩阵变量" class="headerlink" title="矩阵变量"></a>矩阵变量</h3><p>首先需要明确一个矩阵变量的概念，对于普通的变量来说只能 <code>?key1=value1&amp;key2=value2</code> 这样通过字符串传递参数，而这些参数是一维的，是只能一个 key 对应一个 value 的。</p><p>矩阵变量的意义是将字符串传递参数从一维变为二维，而多的一个维度就通过路径分隔实现的，也是通过 key=value 的形式表示一组参数，不同的是同一个维度（路径分割下）的参数通过前缀 <code>;</code> 隔开，一个 key 的多个 value 可以用 <code>,</code> 隔开。</p><p><code>http://localhost:8080/Matrix/Boy;name=Xorex;hobby=coding,eat,sleep/Girl;name=yukino;hobby=play,outgoing,love</code></p><p>需要注意的是，对于一个 <code>/&#123;&#125;/</code> 之间的内容来说，<code>;</code> 开头之后的一组 <code>key=value</code> 或 <code>key=value1,value2</code> 作为一个参数，可以有若干个以 <code>;</code> 开头的参数，他们组成了一个维度的矩阵变量。而 <code>;</code> 之前的字符串则是作为这个维度的路径变量，可以用 @PathVariable 来捕获。具体例子可以看下面的 Demo。</p><p>这就是矩阵变量，有两个维度一个是性别维度，一个是个人信息的维度。而 @MatrixVariable 的作用就是从矩阵变量中提取信息。</p><p>因为 SpringMVC 的 urlPathHelper 的属性 removeSemicolonContent 设置为了 true，也就是将 <code>;</code> 给移除掉了，导致无法使用矩阵变量，我们首先需要设置为 false 才可以，方式就是将生成 urlPathHelper 对象的 WebMvcConfigurer 配置类的生成 urlPathHelper 方法自己实现。</p><p>WebMvcConfigurer 是一个有默认实现的接口（Java 8 新特性），我们只需要实现 WebMvcConfigurer 并单独重写 configurePathMath() 方法即可，然后扔到 IOC 容器中，会由于 @Conditional 系类注解导致不加载原来的，然后被使用的配置就是我们自己放入的 IOC 容器的这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">//在 IOC 容器中配置自定义 WebMvcConfigurer </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">//因为默认实现机制，我们只需要重写一个方法就能实现接口</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">            UrlPathHelper urlPathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">            urlPathHelper.setRemoveSemicolonContent(<span class="keyword">false</span>);</span><br><span class="line">            configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以这样捕获上面的 URL（<code>http://localhost:8080/Matrix/Boy;name=Xorex;hobby=coding,eat,sleep/Girl;name=yukino;hobby=play,outgoing,love</code>） 了：</p><p>使用 pathVar 来区分维度，value 选定参数，两者确定了矩阵变量里面的一个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/Matrix/&#123;Boy&#125;/&#123;Girl&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getMatrix</span><span class="params">(<span class="meta">@MatrixVariable(pathVar = &quot;Boy&quot;,value = &quot;name&quot;)</span> String boyName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@MatrixVariable(pathVar = &quot;Boy&quot;,value = &quot;hobby&quot;)</span> List&lt;String&gt; boyHobbys,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@MatrixVariable(pathVar = &quot;Girl&quot;,value = &quot;name&quot;)</span> String girlName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@MatrixVariable(pathVar = &quot;Girl&quot;,value = &quot;hobby&quot;)</span> List&lt;String&gt; girlHobbys,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@PathVariable</span> Map&lt;String,String&gt; paths)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;boyName&quot;</span>, boyName);</span><br><span class="line">    map.put(<span class="string">&quot;boyHobbys&quot;</span>, boyHobbys);</span><br><span class="line">    map.put(<span class="string">&quot;girlName&quot;</span>, girlName);</span><br><span class="line">    map.put(<span class="string">&quot;girlHobbys&quot;</span>, girlHobbys);</span><br><span class="line">    map.put(<span class="string">&quot;pathMap&quot;</span>, paths);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;girlName&quot;</span>: <span class="string">&quot;yukino&quot;</span>,</span><br><span class="line"><span class="attr">&quot;girlHobbys&quot;</span>: [<span class="string">&quot;play&quot;</span>, <span class="string">&quot;outgoing&quot;</span>, <span class="string">&quot;love&quot;</span>],</span><br><span class="line"><span class="attr">&quot;boyHobbys&quot;</span>: [<span class="string">&quot;coding&quot;</span>, <span class="string">&quot;eat&quot;</span>, <span class="string">&quot;sleep&quot;</span>],</span><br><span class="line"><span class="attr">&quot;pathMap&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;Boy&quot;</span>: <span class="string">&quot;Boy&quot;</span>,</span><br><span class="line"><span class="attr">&quot;Girl&quot;</span>: <span class="string">&quot;Girl&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;boyName&quot;</span>: <span class="string">&quot;Xorex&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法参数-返回参数"><a href="#方法参数-返回参数" class="headerlink" title="方法参数/返回参数"></a>方法参数/返回参数</h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>众所周知，SpringMVC 对于一个请求的处理通过 Adapter 来实现的，以 RequestMappingHandlerAdapter 来说，他就是请求和 @RequestMapping 标注方法之间的桥梁。</p><p>我们就以最常用的 RequestMappingHandlerAdapter 来分析一下，SpringMVC 是如何处理请求参数的：</p><p>首先调用 RequestMappingHandlerAdapter 的 handle() 来处理请求之后，会来到：</p><p>handleInternal() 执行完一些对于缓存和 Session 的判断之后，进入：</p><p>invokeHandlerMethod() 这里首先会获取用来处理方法参数的 HandlerMethodArgumentResolvers 和处理方法返回值的 HandlerMethodReturnValueHandlers。</p><p>我们来看看它们，都是用来处理每一个不同的参数的（看名字就知道了）：</p><p><img src="https://xorex.space/image/323.jpg" alt="323.jpg"></p><p>然后进入 invokeAndHandle() 方法，再进入 invokeForRequest() 方法，第一步是调用 getMethodArgumentValues() 来获取方法参数，这里就是对方法参数的处理：</p><p>具体过程还是那个样子，双重循环，遍历所有的参数，同时遍历所有的参数解析器，依次尝试，直到确定某个参数可以被某个解析器解析。</p><h3 id="Servlet-API"><a href="#Servlet-API" class="headerlink" title="Servlet API"></a>Servlet API</h3><p>对于 WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId 这些 Servlet 的原生 API，作为处理方法的参数的时候，会被 <code>ServletRequestMethodArgumentResolver</code> 解析器处理。</p><h3 id="复杂参数"><a href="#复杂参数" class="headerlink" title="复杂参数"></a>复杂参数</h3><h4 id="Map-Model-ModelAndView"><a href="#Map-Model-ModelAndView" class="headerlink" title="Map Model ModelAndView"></a>Map Model ModelAndView</h4><p>当 Map，Model，ModelAndView（本质上还是包含了 Model）作为参数，会分别被 MapMethodProcessor 和 ModelMethodProcessor 处理（没听错，参数用的不是 Resolver 而是 Processor，是因为这两个东西虽然在参数的位置，但实际上干的是返回值的事情）。</p><p>这两个处理器其实本质上都是一样的，他们里面保存的东西都会被放到同一个地方：ModelAndViewContainer 里面的 BingAwareModelMap 中。这个 ModelAndViewContainer 是保存模型和视图数据的对象。</p><p><strong>重重重重点来了</strong>，经过了一系列的后续处理之后，最终回到页面渲染的部分，在渲染之前，有一句话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">exposeModelAsReqeustAttributes(model,request);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法也非常简单，就是单纯的将 Model 放入了 Request 中：</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">exposeModelAsRequestAttributes</span><span class="params">(Map&lt;String, Object&gt; model, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    model.forEach((name, value) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.setAttribute(name, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.removeAttribute(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们在操作的 Model 和 Map 到底发生了什么了。</p><h4 id="POJO-封装"><a href="#POJO-封装" class="headerlink" title="POJO 封装"></a>POJO 封装</h4><p>这里指的是将大量的 key=value 封装到一个 POJO 中。</p><p>源码是首先判断枚举 Resolvers 来判断哪一个可以处理这个参数。其中 ServletModelAttributeMethodProcessor 可以处理。这个 Processor 判断可以处理的依据就是参数没有注解并且不是一个简单参数（也就是非基础类型+枚举类+数组+Date+URL+URI+Local等等）。</p><p>两者都满足之后就返回  ServletModelAttributeMethodProcessor 来处理封装 POJO，下面介绍一下封装流程。</p><p>首先创建一个空的 POJO 对象，然后调用 createBinder() 并传入 POJO 对象和请求数据，来获取一个 WebDataBindaer 这个数据绑定器的作用就是将请求的参数绑定到 POJO 里面的属性中。</p><p>剩下的过程也就很熟悉了，依次枚举 POJO 需要封装的属性，然后枚举 Converters 转换器，直到可以完成请求的 String 到对应的属性类型，然后调用 Converters 进行转化并赋值。</p><p>大概流程就是这些，因为里面内容过于复杂，所以就不自己粘贴源码之类的了。</p><p>对于 POJO 里面包含自定义类型的，就需要自己实现 <code>Converter&lt;S,T&gt;</code> 接口了，具体接口实现流程可以参考 SpringMVC 里面的相关章节，这里只介绍实现之后的配置：</p><p>因为 converters 可以通过 WebMvcConfigurer 类里面的 addFormatters() 方法里面使用 FormatterRegistry.addConverter() 方法将自定义的 <code>Converter&lt;S,T&gt;</code> 添加到配置中的 converters 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 这就等价于在 applicationContext.xml 中配置 IOC 容器内容了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addConverter(<span class="keyword">new</span> MyConvertor&lt;String,Address&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在封装过程中，ModelAndView 也会保存一个被封装 POJO 的引用。</p><h3 id="返回内容"><a href="#返回内容" class="headerlink" title="返回内容"></a>返回内容</h3><p>理论上的方法返回处理都比较清楚了，也是枚举返回类型的 Processor，找到一个合适的去处理它，看名字就知道是处理哪种类型的返回值了：</p><p><img src="https://xorex.space/image/324.jpg" alt="324.jpg"></p><p>从这些 Processor 可以看到 SpringMVC 支持的范围值类型为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//认识的</span></span><br><span class="line">ModelAndView</span><br><span class="line">Model</span><br><span class="line">String</span><br><span class="line">Map</span><br><span class="line">View</span><br><span class="line">ResponseEntity</span><br><span class="line">HttpEntity</span><br><span class="line">HttpHeaders</span><br><span class="line"><span class="meta">@ModelAttribute</span> 标注的类</span><br><span class="line"></span><br><span class="line"><span class="comment">//不认识的</span></span><br><span class="line">ResponseBodyEmitter </span><br><span class="line">StreamingResponseBody</span><br><span class="line">Callable</span><br><span class="line">DeferredResult</span><br><span class="line">ListenableFuture</span><br><span class="line">CompletionStage</span><br><span class="line">WebAsyncTask</span><br></pre></td></tr></table></figure><p>这里我们主要讨论的是几个常用的 Processor 内部的一些细节，对于我们最常用的 Json 数据返回来说，通过 @RequestBody 来返回 POJO 转化为 Json 数据的 Processor 就是 RequestResponseBodyMethodProcessor 。</p><p>而这个处理类的核心就是在 handleReturnValue() 方法中的 writeWithMessageConverters() 。在这里干了什么事情呢，就是找 Converters，要将信息作为 ResponseBody 写出去，就要找到将返回值转化为 String 的 Converter。而除了找到能处理的 Converter，还要找到浏览器想要的 Converter。</p><p>这就要说说内容协商了：</p><p>首先浏览器会发请求的时候，会有一个请求头 Accept：</p><p><code>accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</code></p><p>这些定义了浏览器可以接受的内容以及不同内容接收的优先级（后面的 q=0.9），服务器接收到之后，会解析出来所有的内容，然后一个二重循环遍历所有的 MessageConverters，找到能转化处理并且转化内容优先级更高的 MassageConverter。</p><p>而我们在前后端分离开发的时候，一般都是 MappingJackson2HttpMessageConverter 这个转换器，将 POJO 转化为 JSON。</p><h3 id="基于请求参数的内容协商"><a href="#基于请求参数的内容协商" class="headerlink" title="基于请求参数的内容协商"></a>基于请求参数的内容协商</h3><p>不在 accept 找协商，而是请求参数 <code>format=XXX</code> 中确定数据想要的响应内容，只需要开启配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">contentnegotiation:</span></span><br><span class="line">      <span class="attr">favor-parameter:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后就会自动注册一个 strategie （协商策略），优先级高于原本的哪个（从 Accept 请求头解析协商内容）。这个 strategie 会从请求参数中找 <code>format=XXX</code> 然后就是返回要接受的请求类型了。经过 MessageConverters 遍历之后，找到合适的并处理。</p><p>其中 <code>format=XXX</code> 接收两个参数：json 或者 xml。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RestFul-风格&quot;&gt;&lt;a href=&quot;#RestFul-风格&quot; class=&quot;headerlink&quot; title=&quot;RestFul 风格&quot;&gt;&lt;/a&gt;RestFul 风格&lt;/h2&gt;&lt;h3 id=&quot;装配原理&quot;&gt;&lt;a href=&quot;#装配原理&quot; class=&quot;head</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringBoot" scheme="https://xorex.space/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-03-开发技巧 &amp; 静态资源处理</title>
    <link href="https://xorex.space/2021/07/31/dcedfd27f096/"/>
    <id>https://xorex.space/2021/07/31/dcedfd27f096/</id>
    <published>2021-07-30T17:09:04.000Z</published>
    <updated>2021-08-14T13:55:12.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些开发技巧"><a href="#一些开发技巧" class="headerlink" title="一些开发技巧"></a>一些开发技巧</h2><h3 id="Lombok-简化"><a href="#Lombok-简化" class="headerlink" title="Lombok 简化"></a>Lombok 简化</h3><p>引入 Lombok 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Lombok 主要解决 Bean 的臃肿问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span> <span class="comment">//生成 getter setter toString equals hashCode 方法</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">//生成全参数构造器</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span> <span class="comment">//生成无参构造器</span></span><br><span class="line"><span class="meta">@ToString</span> <span class="comment">//生成 toString 方法</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span> <span class="comment">//生成 eauqls 和 hashCode 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Uesr</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Uesr</span><span class="params">(String userName, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以注入日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span> <span class="comment">//引入日志</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line">        log.info(<span class="string">&quot;启动完成！&quot;</span>); <span class="comment">//直接调用 log 就可以使用日志系统。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dev-Tools"><a href="#Dev-Tools" class="headerlink" title="Dev-Tools"></a>Dev-Tools</h3><p>这个工具主要是解决热更新的问题（其实就是重启），引入依赖之后，按 ctrl+F9 来更新页面。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Spring-init"><a href="#Spring-init" class="headerlink" title="Spring init"></a>Spring init</h3><p>在创建项目的时候选择 Spring 项目，然后勾选所需要的组件，IDEA 会自动加载所有的依赖，并创造出完整的目录结构。</p><h2 id="application-yaml"><a href="#application-yaml" class="headerlink" title="application.yaml"></a>application.yaml</h2><p>application.yaml 是和 application.properties 作用都是完全一样的，不过 yaml 语法格式有点区别。</p><p>yml/yaml 是一种类似于 json 的数据保存格式，它的表示形式是 <code>key: value</code> 记得中间有个空格，它的包含关系是通过缩进来解决的，类似于 Python。</p><h3 id="基本值"><a href="#基本值" class="headerlink" title="基本值"></a>基本值</h3><p>基本值支持一下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整形 int</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点型 float</span></span><br><span class="line"><span class="attr">money:</span> <span class="number">23213.21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 布尔型 boolean</span></span><br><span class="line"><span class="attr">alive:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日期 data</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-02-02</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空 null</span></span><br><span class="line"><span class="attr">point:</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串 string</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Xorex</span> <span class="string">\n</span> <span class="string">is</span> <span class="string">Xorex</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&#x27;Xorex \n is Xorex&#x27;</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&quot;Xorex \n is Xorex&quot;</span></span><br><span class="line"><span class="comment"># 前两者相同，都会转义 \n，而后者不会转义 \n 表示为换行。</span></span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>当内容为对象的时候，比如 Bean，Map 的时候，可以新增一个层级写多行 <code>key: value</code> ，或者使用 json 的大括号格式写成一行 <code>&#123;key: value,key: value&#125;</code> 逗号隔开，需要空格。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">Tempest</span> <span class="string">Xorex</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">gender:</span> <span class="string">M</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">ChengDu</span></span><br><span class="line"></span><br><span class="line"><span class="attr">user:</span> &#123;<span class="attr">user:</span> <span class="string">Tempest</span> <span class="string">Xorex</span>,<span class="attr">password:</span> <span class="number">123456</span>,<span class="attr">gender:</span> <span class="string">M</span>,<span class="attr">address:</span> <span class="string">ChengDu</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h3><p>同样是两种，多行格式开头没了 key，用 <code>-</code> 表示新的一行开头，或者用单行写法：[XXX,XXX,XXX]</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pet:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">monkey</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pet:</span> [<span class="string">dog</span>,<span class="string">monkey</span>,<span class="string">cat</span>]</span><br></pre></td></tr></table></figure><h3 id="小例子："><a href="#小例子：" class="headerlink" title="小例子："></a>小例子：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Boolean alive;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] interests;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; level;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; score;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Xorex</span></span><br><span class="line">  <span class="attr">alive:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="attr">userName:</span> <span class="string">Xorex</span></span><br><span class="line">    <span class="attr">address:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ChengDu</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SiChuan</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">China</span></span><br><span class="line">  <span class="attr">interests:</span> [<span class="string">Sing</span>,<span class="string">jump</span>,<span class="string">Rap</span>,<span class="string">Basketball</span>]</span><br><span class="line">  <span class="attr">level:</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">  <span class="attr">score:</span></span><br><span class="line">    <span class="attr">Chinese:</span> <span class="number">59</span></span><br><span class="line">    <span class="attr">Math:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">English:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">user:</span> &#123;<span class="attr">userName:</span> <span class="string">Xorex</span>,<span class="attr">password:</span> <span class="number">123456</span>&#125;</span><br></pre></td></tr></table></figure><p>成功完成 yaml 版本的自动配置：</p><p><code>Test(name=Xorex, alive=true, age=18, address=Address(userName=Xorex, address=[ChengDu, SiChuan, China]), interests=[Sing, jump, Rap, Basketball], level=[1, 2, 3, 4, 5, 6], score=&#123;Chinese=59, Math=100, English=100&#125;, user=User(userName=Xorex, password=123456))</code></p><h2 id="静态资源映射"><a href="#静态资源映射" class="headerlink" title="静态资源映射"></a>静态资源映射</h2><h3 id="静态资源文件夹"><a href="#静态资源文件夹" class="headerlink" title="静态资源文件夹"></a>静态资源文件夹</h3><p>SpringBoot 是使用 ResourceHttpRequestHandler 来处理请求的，对于一个请求来说，如果 Controller 可以处理，就会交给它，不能处理的则会会依次从 <code>META-INF/resources</code>、<code>/resources</code>、 <code>/static</code> 和 <code>/public</code> 按照请求的静态文件名从里面找同名的静态文件。</p><p>这四个文件夹都可以放静态文件，同名文件的优先级顺序为上面的排列顺序，从源码中也可以看出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>, <span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="修改静态资源文件夹映射路径"><a href="#修改静态资源文件夹映射路径" class="headerlink" title="修改静态资源文件夹映射路径"></a>修改静态资源文件夹映射路径</h3><p>是路径和文件夹的映射，以前四个文件夹是映射到根目录的，现在可以通过在配置中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br></pre></td></tr></table></figure><p>这样访问静态资源需要在原本路径下前面提娜佳 <code>/res/</code> 的 pattern 才可以访问。</p><h3 id="修改静态资源文件夹"><a href="#修改静态资源文件夹" class="headerlink" title="修改静态资源文件夹"></a>修改静态资源文件夹</h3><p>当我们在配置中设置 static-locations 这一项之后，原本的四大静态资源文件夹只会保留一个 <code>META-INF/resources</code> 毕竟是 JavaWeb 原生的东西肯定会保留（剩下三个会被取消），但访问优先级会下降到最低。而新配置的文件夹优先级按照配置顺序来。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> [<span class="string">classpath:/Static-Resource/</span>,<span class="string">classpath:/Static-Resource2/</span>]</span><br><span class="line">      <span class="comment"># 这里记得写 classpath 哇</span></span><br></pre></td></tr></table></figure><h3 id="Webjar"><a href="#Webjar" class="headerlink" title="Webjar"></a>Webjar</h3><p>Webjar 是指 SpringBoot 将前端所需依赖会打包成一个 Webjar 来供你使用，而我们下载之后的 Webjar 包里面的内容的访问路径则是 <code>/webjars/**</code>，比如我们引入 jQuery 的 Webjar：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后可以看到已经下载过的 jQuery，可以看到是放在 <code>/META-INF/resources/webjars/</code> 下面的，这也是为什么修改 static-locations 之后，还保留 <code>/META-INF/resources</code>，并且 webjar 的内容访问路径为 <code>/webjars/**</code> 了：</p><p><img src="https://xorex.space/image/322.jpg" alt="322.jpg"></p><p>对应源码地方就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addResourceHandler(registry, <span class="string">&quot;/webjars/**&quot;</span>, <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后访问 <code>http://localhost:8080/res/webjars/jquery/3.5.1/jquery.js</code> 成功！</p><h3 id="欢迎页"><a href="#欢迎页" class="headerlink" title="欢迎页"></a>欢迎页</h3><p>对于官方的欢迎页的设置来说，可以用 <code>index.html</code> 的文件名放到静态资源文件夹里面，这样直接访问主机名就可以看到 <code>index.html</code>，但是这个时候是不可以配置静态资源访问前缀的，也就是 <code>static-path-pattern</code> ，不然就会失效，理由如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,</span><br><span class="line">ApplicationContext applicationContext, Resource welcomePage, String staticPathPattern) &#123;</span><br><span class="line"><span class="keyword">if</span> (welcomePage != <span class="keyword">null</span> &amp;&amp; <span class="string">&quot;/**&quot;</span>.equals(staticPathPattern)) &#123; </span><br><span class="line">      <span class="comment">//这自己设置了 staticPathPattern 之后，判断就不成立了。</span></span><br><span class="line">logger.info(<span class="string">&quot;Adding welcome page: &quot;</span> + welcomePage);</span><br><span class="line">setRootViewName(<span class="string">&quot;forward:index.html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Adding welcome page template: index&quot;</span>);</span><br><span class="line">setRootViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要实现就只能通过 Controller 映射 <code>/</code> 页面转发到 <code>index.html</code> 了。</p><h3 id="favicon-ico"><a href="#favicon-ico" class="headerlink" title="favicon.ico"></a>favicon.ico</h3><p>配置网页小图标只需要将文件命名为 <code>favicon.ico</code> 然后放到静态资源目录即可，这个生效也<strong>不能配置</strong> static-path-pattern。</p><p>这是因为浏览器获取小图标的方式就是访问 <code>网页根目录+favicon.ico</code> 更改了 static-path-pattern 之后也自然无法找到小图标了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一些开发技巧&quot;&gt;&lt;a href=&quot;#一些开发技巧&quot; class=&quot;headerlink&quot; title=&quot;一些开发技巧&quot;&gt;&lt;/a&gt;一些开发技巧&lt;/h2&gt;&lt;h3 id=&quot;Lombok-简化&quot;&gt;&lt;a href=&quot;#Lombok-简化&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringBoot" scheme="https://xorex.space/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-02-自动配置原理</title>
    <link href="https://xorex.space/2021/07/30/47898b4fe443/"/>
    <id>https://xorex.space/2021/07/30/47898b4fe443/</id>
    <published>2021-07-30T09:46:33.000Z</published>
    <updated>2021-07-31T02:39:44.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><h3 id="SpringBootApplication-解析"><a href="#SpringBootApplication-解析" class="headerlink" title="@SpringBootApplication 解析"></a>@SpringBootApplication 解析</h3><p>我们是在 <code>@SpringBootApplication</code> 中确定的 SpringBoot 的程序入口，也是 SpringBoot 的初始化开始的地方。那么 SpringBoot 是如何实现自动配置的呢，将 <code>@SpringBootApplication</code> 点开，可以看到是下面三个注解组成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br></pre></td></tr></table></figure><p><code>@SpringBootConfiguration</code> 本质就是个 <code>@Configuration</code> 表示这个类是一个配置类（也就是可以当作 applicationContext.xml 使用的类），比如在里面使用注解 <code>@Bean</code> 代替 <code>&lt;bean&gt;</code> 来配置 IOC 容器的 Bean。</p><p><code>@ComponentScan</code> 主要是用来扫描包组件的，它可以自定义扫描的 BasePackage，如果没有指定的话，就是 <code>@SpringBootApplication</code> 所在的地方为 BasePackage 。</p><p><code>@EnableAutoConfiguration</code> 这个是核心，又包含了下面的两种注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>这里又套娃导入了一个 <code>@Import(&#123;Registrar.class&#125;)</code> ，点开 Registrar.class 可以看到，代码里面主要干了下面的事情：</p><p>自动配置包类，注册了当前路径为下面的 PackageNames 作为配置的下属包（其实也对应 <code>@ComponentScan</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoConfigurationPackages.register(getPackageNames().toArray()); <span class="comment">// 有简略</span></span><br></pre></td></tr></table></figure><h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h4><p>这里主要导入了 AutoConfigurationImportSelector.class 这个类，主要干的事情就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getAutoConfigurationEntry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是获得 100 多个 web 的 starter 所需要配置的类的全类名（其实是在一个文件中写死的类名），然后返回。</p><hr><p>SpringBoot 更厉害的是，它不是全部都真的将所有的预设类实例化并添加到 IOC 容器中的，而是根据 <code>@Conditional</code> 注解，根据里面的条件判断是否加载这个类。</p><p>比如虽然导入了 web-starter 的开发环境，可能需要 AOP 相关，但是 SpringBoot 是根据 <code>@ConditionalOnClass(Advice.class)</code> 来判断是否加载的，只有导入了 AspectJ 这个包（Advice.class 存在），SpringBoot 才会给你将 AOP 所需要的类都给加入到 IOC 容器中。</p><p>这就是传说中的按需加载。</p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><h3 id="具体实现细节"><a href="#具体实现细节" class="headerlink" title="具体实现细节"></a>具体实现细节</h3><p>上面大概说了说实利用 <code>@Conditional</code> 系列注解进行按需加载的，我们来结合一个熟悉的案例分析一下，DispatcherServlet:</p><p>上面说到了返回的 100 多个配置类的全类名统一格式都是 XXXXAutoConfiguration，通过运行这些类，来对相关内容进行自动配置。</p><p>我们点开 DispathcerServletAutoConfiguration，这个就是对 DispathcerServlet 进行自动配置的类，先看看程序头：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(&#123;DispatcherServlet.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;ServletWebServerFactoryAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServletAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@ConditionalOnClass</code>表示导入了 DispathcerSevlet（也就是 SpringMVC） 后才会运行下面的自动装配类。<code>@AutoConfigureAfter</code> 表示先自动加载完服务器的 AutoConfiguration 之后再加载自己。这两个都是启动装配的起始条件。</p><p>再进一步就是子类 RegistrationConfiguration 了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;DispatcherServletAutoConfiguration.DispatcherServletConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServletRegistrationConfiguration</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@EnableConfigurationProperties</code> 表示使用 WebMvcProperties.class 内容作为配置文件，而这个类是使用 <code>spring.mvc</code> 作为配置的 prefix 的。</p><p>前面都是讲了按需加载的一些东西，那么具体的 DispatcherServlet 的配置细节在那里呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title">dispatcherServletRegistration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DispatcherServletRegistrationBean registration = <span class="keyword">new</span> DispatcherServletRegistrationBean(dispatcherServlet, webMvcProperties.getServlet().getPath());</span><br><span class="line">    registration.setName(<span class="string">&quot;dispatcherServlet&quot;</span>);</span><br><span class="line">    registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">    multipartConfig.ifAvailable(registration::setMultipartConfig);</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是将一系列的配置信息都设置到了 registration 中，最后返回，这里就是将获取的所有配置信息设置的地方。</p><h3 id="更改设置信息"><a href="#更改设置信息" class="headerlink" title="更改设置信息"></a>更改设置信息</h3><p>如何修改默认的设置信息呢，当然是在 application.properties 里面修改了，那么这些修改又是如何影响到 SpringBoot 的自动装配呢，我们以 CharacterEncodingFilter 的自动装配为例展示一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;ServerProperties.class&#125;)</span> <span class="comment">//调用外部的 服务器设置</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span> <span class="comment">//有这个类才会进行自动初始化</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;server.servlet.encoding&quot;,  //在调用的外部 ServerProperties 中 server.servlet.encoding 选项是否为enabled，如果是成立，如果不是失败，如果没有配置则默认为是。</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;enabled&quot;&#125;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Encoding properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从外部的 ServerProerties 中获取关于编码的设置，并放入本地变量 properties 中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(ServerProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties.getServlet().getEncoding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//在 IOC 中创建 Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span> <span class="comment">//IOC 中必须没有手动创建此实例才会自动创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123; <span class="comment">//根据读取的 properties 配置信息创建 Bean 并放入 IOC 中。</span></span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的代码，我们能看到配置信息的最重要来源就是上一级的 ServerProperties.class 里面获取的，那么 ServerProperties 又是如何生成的呢？</p><p>上一篇文章前面提到了 <code>@ConfigurationProperties(prefix=&quot;XXX&quot;)</code> 标注了之后会从 application.properties 找到前缀为 XXX 的配置然后调用 set 方法进行配置注入。 ServerProperties.class 在创建之后会属性都是默认值，然后再经过 <code>@ConfigurationProperties(prefix=&quot;XXX&quot;)</code> 从配置文件中注入外部设置来覆盖默认设置。</p><hr><p>具体从读取到 @ConfigurationProperties 再到读取 application.properties 注入设置的详细源码，一定会再详细介绍的。</p><p>现在对于 SpringBoot 的了解还是太浅了…… </p><p>QAQ</p><h2 id="自动装配总结"><a href="#自动装配总结" class="headerlink" title="自动装配总结"></a>自动装配总结</h2><ol><li>SpringBoot 会首先获取所有自动装配运行类的名字，然后依次运行 XXXAutoConfiguration 的自动装配运行类，负责装配 XXX。</li><li>自动装配运行类通过 <code>@Conditional</code> 系列注解，判断满足要求之后开始从 XXXProperties.class 中拿到具体的配置信息。XXXProperties 和 application.properties 绑定。</li><li>自动装配运行类运行后会向 IOC 容器中添加很多配置好的组件，IOC 有了这些配置好的组件之后就拥有了对应的功能。</li><li>可以通过自己使用 <code>@Bean</code> 向 IOC 中添加配件来实现自定义配置，或者在 application.properties 中设置自定义配置。</li></ol><h2 id="自动装配开发技巧"><a href="#自动装配开发技巧" class="headerlink" title="自动装配开发技巧"></a>自动装配开发技巧</h2><ol><li><p>开发的时候将对应的场景依赖引入即可，xxx-starter</p></li><li><p>查看场景依赖的哪些元素装配了，可以在设置中设置 debug=true，会打印日志，Positive 生效部分，Negative 不生效部分</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自动配置原理&quot;&gt;&lt;a href=&quot;#自动配置原理&quot; class=&quot;headerlink&quot; title=&quot;自动配置原理&quot;&gt;&lt;/a&gt;自动配置原理&lt;/h2&gt;&lt;h3 id=&quot;SpringBootApplication-解析&quot;&gt;&lt;a href=&quot;#SpringBootApp</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringBoot" scheme="https://xorex.space/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-01-快速开始和自动配置</title>
    <link href="https://xorex.space/2021/07/29/cdaa75e9175f/"/>
    <id>https://xorex.space/2021/07/29/cdaa75e9175f/</id>
    <published>2021-07-29T06:34:46.000Z</published>
    <updated>2021-07-31T08:56:03.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot-快速开始"><a href="#SpringBoot-快速开始" class="headerlink" title="SpringBoot 快速开始"></a>SpringBoot 快速开始</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>SpringBoot 项目只需要一个普通的 Maven 项目就可以了。我们是通过运行 SpringBoot 的 SpringApplication.run() 方法，来让 SpringBoot 控制整个项目的。</p><p>首先我们需要将在 Maven 中引入包含了大量依赖信息的 SpringBoot parent（继承信息），和我们要进行 Web 开发的 starter （真正的引入依赖下载 jar 包）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也就是 parent 引入保存的各种开发场景对应的依赖需求集合，我们在 dependencies 真正的引入这些依赖的时候，就不需要一个个写了，直接调用依赖集合名就好了。</p><p>然后我们就能看到所有关于 web 开发的 jar 包就都被导入了，包括 tomcat。这些 jar 包的集合被 SpringBoot 叫作一个 starter，开始集合。</p><h3 id="让-SpringBoot-接管项目"><a href="#让-SpringBoot-接管项目" class="headerlink" title="让 SpringBoot 接管项目"></a>让 SpringBoot 接管项目</h3><p>就像配置 DispatcherServlet 让 SpringMVC 接管业务流程一样，这里是让 SpringBoot 直接从根本接管所有东西，不仅仅是业务流程，包括了 Tomcat 的创建。</p><p>只需要创建一个方法，在 main 方法中运行 SpringBoot 的启动程序，SpringApplication.run()，参数就是这个类本身的 class 和输入的参数，当然这个类也需要用注解标记为 SpringBoot 启动类。要运行整个项目的时候，就直接运行 main 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开始写业务逻辑"><a href="#开始写业务逻辑" class="headerlink" title="开始写业务逻辑"></a>开始写业务逻辑</h3><p>剩下的部分就是按照 SpringMVC 的形式写了，不用管配置啥的，直接各种注解随便用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Controller 和 RequestBody 的结合，意思为用来实现 rest 风格的 Controller</span></span><br><span class="line"><span class="meta">@RestController</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello SpringBoot!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h3><p>SpringBoot 因为一个人就接管了整个项目，所以可以将整个项目的所有配置都简化到一个文件中： <code>application.properties</code> ，这个文件可以改所有的配置。</p><p>比如将端口号改为 8888，只需要在 <code>application.properties</code> 中写下即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">servet.port</span>=<span class="string">8888</span></span><br></pre></td></tr></table></figure><p>而在 application.properties 里面的各种配置信息提示需要将配置处理器 Springboot-configurationg-processor 引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 maven 插件配置的地方设置打包去除到这个 processor ，因为只是支持配置提示，也不需要打包成运行环境。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><p>以前部署是打包成 war 包，放到服务器的 Tomcat 环境上面的，现在因为所有的东西都被 SpringBoot 管理，所以只需要让 SpringBoot 跑起来就可以了。</p><p>那么我们就可以将项目打包成一个可以运行 main 方法的 jar 包即可。（main 方法负责启动 SpringBoot）</p><p>我们是用 Maven 进行打包的，先引入 SpringBoot 关于 Maven 的打包插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后运行（注意 IDEA 需要停止运行当前的 SpringBoot 防止端口占用）</p><p><code>java -jar SpringBoot-1.0-SNAPSHOT.jar</code></p><h2 id="SpringBoot-依赖管理"><a href="#SpringBoot-依赖管理" class="headerlink" title="SpringBoot 依赖管理"></a>SpringBoot 依赖管理</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>SpringBoot 一个让我们省心的就是它的 starter 直接配齐了所有的生产环境。starter 的实现就是依靠 SpringBoot 的依赖管理，什么样的生产环境需要什么依赖，以及依赖的版本号，都被记录在 <code>spring-boot-starter-parent</code> 中。</p><h3 id="版本更改"><a href="#版本更改" class="headerlink" title="版本更改"></a>版本更改</h3><p>依赖的具体版本是通过在 SpringBoot 的依赖管理中的 <code>&lt;properties&gt;&lt;/properties&gt;</code> 标签中定义好的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--截取一部分--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jstl.version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">jstl.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jtds.version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">jtds.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">junit-jupiter.version</span>&gt;</span>5.7.2<span class="tag">&lt;/<span class="name">junit-jupiter.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kafka.version</span>&gt;</span>2.7.1<span class="tag">&lt;/<span class="name">kafka.version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们要更改它的版本只需要在 Maven 中配置 <code>&lt;properties&gt;&lt;/properties&gt;</code> 中设置具体的版本即可，比如想要文艺复兴，使用 8.0.1 的 tomcat，改就完事了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tomcat.version</span>&gt;</span>8.0.1<span class="tag">&lt;/<span class="name">tomcat.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SpringBoot-自动配置"><a href="#SpringBoot-自动配置" class="headerlink" title="SpringBoot 自动配置"></a>SpringBoot 自动配置</h2><h3 id="组件配置"><a href="#组件配置" class="headerlink" title="组件配置"></a>组件配置</h3><p>以前我们要引入很多的组件，比如 DispatcherServlet，CharacterEncoding 等等，现在使用了 SpringBoot 之后就不需要写了，这是因为 SpringBoot 会自动将一整套的开发环境预设到 IOC 容器中，<code>SpringApplication.run(MainApplication.class, args)</code> 的返回结果就是这个 IOC 容器。</p><h3 id="包扫描"><a href="#包扫描" class="headerlink" title="包扫描"></a>包扫描</h3><p>SpringBoot 会扫描标注了 <code>@SpringBootApplication</code> 的启动类以下的所有子包：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line"> +- example</span><br><span class="line">     +- myapplication</span><br><span class="line">         +- Application.java //下面的 customer 和 order 两个包都会被扫描注解</span><br><span class="line">         |</span><br><span class="line">         +- customer</span><br><span class="line">         |   +- Customer.java</span><br><span class="line">         |   +- CustomerController.java</span><br><span class="line">         |   +- CustomerService.java</span><br><span class="line">         |   +- CustomerRepository.java</span><br><span class="line">         |</span><br><span class="line">         +- order</span><br><span class="line">             +- Order.java</span><br><span class="line">             +- OrderController.java</span><br><span class="line">             +- OrderService.java</span><br><span class="line">             +- OrderRepository.java</span><br></pre></td></tr></table></figure><p>所以我们才不需要配置扫描的包。但如果真的想要配置，在 <code>@SpringBootApplication</code> 添加属性：<code>scanBasePackages = &quot;space.xorex&quot;</code> 。</p><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>SpringBoot 所有场景的默认配置信息都在 spring-boot-autoconfigure 里面：</p><p><img src="https://xorex.space/image/321.jpg" alt="321.jpg"></p><h2 id="容器功能"><a href="#容器功能" class="headerlink" title="容器功能"></a>容器功能</h2><h3 id="添加容器"><a href="#添加容器" class="headerlink" title="添加容器"></a>添加容器</h3><p>Spring 一个重要功能就是 IOC ，那么到了 SpringBoot，如何使用 IOC 容器呢？</p><p><code>@Configuration</code> 用来标注表示这是一个配置类，然后对方法 <code>@Bean</code> 表示这是一个 Bean 配置，方法名就是 id，返回的结果就是配置 Bean 获取的结果。</p><p>这样成功将 id=userXorex 的 User 实例添加到了 IOC 容器中，默认为 <strong>单实例对象</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uesr <span class="title">userXorex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Uesr(<span class="string">&quot;Xorex&quot;</span>,<span class="string">&quot;Tempest&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">xorexAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Address(<span class="string">&quot;ChengDu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例获取"><a href="#实例获取" class="headerlink" title="实例获取"></a>实例获取</h3><p>因为上面写过之后两个 bean 都被加入了单例的 IOC 中，所以自然可以用 @Autowired 来获取单例 bean 的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">static</span> Uesr user1;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">static</span> Uesr user2;</span><br><span class="line">System.out.println(user1==user2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>但是还有另外一种获取方法，就是调用 MyConfig 里面的方法返回 bean 实例。当我们的 @Configuration 配置的为默认： proxyBeanMethods=true 的时候，也就是使用代理获取对象的时候，在外部获取的都是容器中的单例 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyConfig config=run.getBean(MyConfig.class); </span><br><span class="line"><span class="comment">//从 IOC 中拿到 Config，此时的 proxyBeanmethods=true ，也就是 Config IOC 代理了，返回的实例是从 IOC 容器中拿出来的。</span></span><br><span class="line">Uesr user1=config.userXorex(); <span class="comment">// 从 Config 中返回 bean</span></span><br><span class="line">Uesr user2=config.userXorex();</span><br><span class="line">System.out.println(user1==user2); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>当我们将 proxyBeanMethods=false 的时候，上面从 IOC 中取出来的 MyConfig 就是普通类了（等同于 new 出来一个普通的 MyConfig），调用方法返回的 bean 也是方法里面 new 出来的，就不是 IOC 控制的单例对象了。</p><h3 id="快速添加"><a href="#快速添加" class="headerlink" title="快速添加"></a>快速添加</h3><p>可以使用 <code>@Import(&#123;XXX1.class,XXX2.class&#125;)</code> 快速将两个类 XXX1 和 XXX2 的无参构造器的实例放入 IOC 容器中，id 就是这个类的全类名。</p><h3 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h3><p>这里的配置绑定指的是将 application.properties 中的配置信息和 IOC 容器中的 Bean 的属性相绑定。</p><p>比如我们将配置文件中的 info.xxx 配置于 Info 类中的属性 xxx 相绑定，只需要在 <code>@ConfigurationProperties</code></p><h4 id="1-Component-ConfigurationProperties"><a href="#1-Component-ConfigurationProperties" class="headerlink" title="1. @Component + @ConfigurationProperties"></a>1. @Component + @ConfigurationProperties</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-ConfigurationProperties-Bean"><a href="#2-ConfigurationProperties-Bean" class="headerlink" title="2. @ConfigurationProperties + @Bean"></a>2. @ConfigurationProperties + @Bean</h4><p>第二种主要适用于对第三方包里面的类进行属性设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">//加入到 IOC 容器中</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;info&quot;)</span> <span class="comment">//添加配置映射信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Info <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SpringBoot-快速开始&quot;&gt;&lt;a href=&quot;#SpringBoot-快速开始&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 快速开始&quot;&gt;&lt;/a&gt;SpringBoot 快速开始&lt;/h2&gt;&lt;h3 id=&quot;导包&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringBoot" scheme="https://xorex.space/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>IDEA-大揭秘</title>
    <link href="https://xorex.space/2021/07/28/473525f83e0b/"/>
    <id>https://xorex.space/2021/07/28/473525f83e0b/</id>
    <published>2021-07-27T16:38:55.000Z</published>
    <updated>2021-07-29T09:44:47.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我要好好学习-IDEA！"><a href="#我要好好学习-IDEA！" class="headerlink" title="我要好好学习 IDEA！"></a>我要好好学习 IDEA！</h2><p>IDEA 是什么，IDEA 是世界上最棒的 Java 开发工具。但是因为我对它的不熟悉，基本上看着各种英文选项都看不懂，所以不可以这样子下去了！我要更好的了解我手上的开发工具，来减少 Debug 的时间！</p><h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><p>对于 IDEA 来说，Project 是一个项目的总称，而 Module 是项目不同部分实现的模块。比如一个电商系统中，需要使用到分布式系统开发多个服务器后台，那么 Project 就是这个电商系统，Module 就是服务器1、服务器2、的开发模块。</p><p>当然也可以一个 Project 只包含一个 Module，那么这个时候两者就是同一个东西了，都指的是当前项目。</p><p>如果想要一个 Project 包含多个 Module，那么就新建一个<strong>空的 Project</strong>，然后在空 Project 中新建各种模块。这个空的 Project 就是起一个约束的作用：</p><p><img src="https://xorex.space/image/312.jpg" alt="312.jpg"></p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>然后就是关于项目下面的模块的单独管理了：</p><p>1 表示选择的相应模块进行设置。</p><p>2 表示模块的目录结构的标识，比如将某些目录标识为源码目录，资源目录等等，作用是让 IDEA 对不同目录的内容做不同的处理，比如源码目录就涉及到代码之间的导入和编译（只有 IDEA 知道此目录是源码目录才会去找 java 编译成 class），比如 Test 目录就是测试的时候和源码目录合并，但是编译到 target 文件夹的时候忽略，等等。</p><p>3 表示不同类型的表示都有哪些文件夹，相当于一个汇总。</p><p><img src="https://xorex.space/image/313.jpg" alt="313.jpg"></p><hr><p>然后在后面就是路径管理，主要就是编译后的输出位置，一般都是 target 文件夹。</p><p><img src="https://xorex.space/image/314.jpg" alt="314.jpg"></p><hr><p>这里主要是管理模块所依赖的外部库的（Libraries），IDEA 整个项目下面有一个 External Libraries 概念的项目外部库，里面有所有模块导入的各种外部库，可以从这里面添加其他模块以来的外部库到自己的模块中。</p><p>而 Export 选项是当我们将模块导出来成 Jar 包的时候，是否将依赖的外部库也打包进去。</p><p><img src="https://xorex.space/image/315.jpg" alt="315.jpg"></p><h3 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h3><p>Libraries 这个主要是本项目（Project）下面的所有外部依赖进行一个管理，所有模块被 <code>add as Libraries</code> 的 Jar 包都会出现在这里（Maven 添加进来的自动导入 Libraries 中）。</p><p>1 表示当前项目中所有模块添加的 Project 级别的依赖仓库，2 表示对这些仓库进行修改和查看下载信息（编译文件，源码，文档）</p><p><img src="https://xorex.space/image/316.jpg" alt="316.jpg"></p><h3 id="Facets"><a href="#Facets" class="headerlink" title="Facets"></a>Facets</h3><p>Facets 的中文是刻面，表示事物的方面特征，在这里表示记录整个项目的一些特征，比如用了哪些框架（Spring），项目是哪一类的（Web 项目），等等：</p><p><img src="https://xorex.space/image/318.jpg" alt="318.jpg"></p><h3 id="Artifacts"><a href="#Artifacts" class="headerlink" title="Artifacts"></a>Artifacts</h3><p>Aritfacts 的意思是制品，表示我们项目最后的输出状态：jar （代码包）或者 war （Web 程序包）。</p><p>比如下面就是 Module1 的 Artifacts 页面，其中 1 表示两种形式，一中是经过压缩的（第一个），一种是不经过压缩的，可以看到目录结构的（第二个，exploded 的）。我们一般选择后者来调整输出内容。</p><p>2 则表示的是项目打包输出的时候的输出内容，也就是我们本机编写的 Module1 的代码，和引入的外部依赖 lib 文件夹。这里的外部依赖是根据 Maven 的配置文件 pom.xml 中读取的，回将默认的 scope compile 类型的仓库添加到 lib 文件夹里面。</p><p>如果我们有一些库是从本地 Jar 包形式或者 Global、Project 范围的 Libraries 中导入的话，因为在 pom.xml 中没有他们的身影，所以在打包的时候也没有他们，这就需要我们用区域 3，从模块已有的依赖库中选择要添加到打包的库文件。</p><p><img src="https://xorex.space/image/319.jpg" alt="319.jpg"></p><h3 id="Platfrom-Settings"><a href="#Platfrom-Settings" class="headerlink" title="Platfrom Settings"></a>Platfrom Settings</h3><p>这个就是关于 IDEA 这个平台的整体的设置了，包括 SDK 的包的选择，还有 Global 级别的 Libraries 的管理。</p><p><img src="https://xorex.space/image/320.jpg" alt="320.jpg"></p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="iml-文件"><a href="#iml-文件" class="headerlink" title="iml 文件"></a>iml 文件</h3><p>Java 中的一个单模块项目或者多模块项目中的每一个模块，都会有一个模块名的 iml 文件，这个文件就是保存本模块的依赖信息的文件，IDEA 也就是根据这个文件将项目依赖的 Jar 包添加到当前项目的 ClassPath 之中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引用 Global 级别的库，所有的项目所有模块都可以引用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;library&quot;</span> <span class="attr">name</span>=<span class="string">&quot;commons-beanutils-1.8.0&quot;</span> <span class="attr">level</span>=<span class="string">&quot;application&quot;</span> /&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--引用 Project 级别的库，只有当前项目下面的所有模块才可以引用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;library&quot;</span> <span class="attr">name</span>=<span class="string">&quot;druid-1.1.9&quot;</span> <span class="attr">level</span>=<span class="string">&quot;project&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;module-library&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">library</span>&gt;</span> <span class="comment">&lt;!--引用 Module 级别的库，只有本模块才可以引用--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">root</span> <span class="attr">url</span>=<span class="string">&quot;jar://$MODULE_DIR$/src/test/java/c3p0-0.9.1.2.jar!/&quot;</span> /&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">library</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">orderEntry</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Maven-管理"><a href="#Maven-管理" class="headerlink" title="Maven 管理"></a>Maven 管理</h3><p>当我们在 Maven 中添加了一个 Jar 包的下载信息之后，Maven 会自动下载 Jar 包到一个<strong>固定的文件夹</strong>（user/.m2/repostory/），下载完成之后，会自动更新 iml 文件，将 Jar 包以 Project 级别引入当前模块。</p><p>因为 Maven 下载的 Jar 包都在固定的文件夹，所以 Maven 也会根据 pom.xml 里面的记录将 Jar 包信息添加到 <code>External Libraries</code> 中，表示 Jar 包来自于外部的文件夹，并不是本项目目录结构里面的。有时候在 pom.xml 添加了下载信息之后，并没有更新 iml 文件，但是更新了 <code>External Libraries</code> 列表，这时候就需要手动将下载好的 Jar 包从 <code>External Libraries</code> 列表中用 <code>add as Library</code> （其实就是写到 iml 文件中）添加到当前模块的依赖中。</p><p>根据当前项目下所有模块的 pom.xml 文件显示的外部库列表：</p><p><img src="https://xorex.space/image/317.jpg" alt="317.jpg"></p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="Library-和-jar-的区别"><a href="#Library-和-jar-的区别" class="headerlink" title="Library 和 jar 的区别"></a>Library 和 jar 的区别</h3><p>jar 包通常用来表示一个小功能的所有 .class 文件，而 Library 更像是 jar 包的文件夹，将若干个 jar 包打包在一起，作为一个 Library （当然单个 jar 包也可以作为 Library）。</p><h3 id="Project-和-Module-的关系"><a href="#Project-和-Module-的关系" class="headerlink" title="Project 和 Module 的关系"></a>Project 和 Module 的关系</h3><p>Project 用来作为一个文件夹约束包含的模块 Module，模块 Module 是实现一个完整功能的最小单位。</p><h3 id="External-Libraries-和-Maven-的关系"><a href="#External-Libraries-和-Maven-的关系" class="headerlink" title="External Libraries 和 Maven 的关系"></a>External Libraries 和 Maven 的关系</h3><p>External Libraries 是从 Maven 文件 pom.xml 中读出来并展示的，表示从外部引入的库（外部指 Maven 下载目录，项目目录为内部引用）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;我要好好学习-IDEA！&quot;&gt;&lt;a href=&quot;#我要好好学习-IDEA！&quot; class=&quot;headerlink&quot; title=&quot;我要好好学习 IDEA！&quot;&gt;&lt;/a&gt;我要好好学习 IDEA！&lt;/h2&gt;&lt;p&gt;IDEA 是什么，IDEA 是世界上最棒的 Java 开发工</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="IDEA" scheme="https://xorex.space/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记</title>
    <link href="https://xorex.space/2021/07/20/6a60c37480ef/"/>
    <id>https://xorex.space/2021/07/20/6a60c37480ef/</id>
    <published>2021-07-20T04:42:34.000Z</published>
    <updated>2021-08-18T14:30:41.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-概念"><a href="#Git-概念" class="headerlink" title="Git 概念"></a>Git 概念</h2><h3 id="分布式与集中式"><a href="#分布式与集中式" class="headerlink" title="分布式与集中式"></a>分布式与集中式</h3><p>其实这两个在版本控制系统里面区别就是历史版本存放位置。</p><p>集中式版本控制系统单的历史版本是存放在一个固定的服务器上面的，每次写代码只是拿到其中的一个版本，写完之后提交。这样一旦服务器挂掉，就无法工作了。</p><p>而分布式版本控制系统的历史版本是所有人都在本地有一份的，服务器的作用是用来方便大家同步本地的版本（合并别人的修改），这样即使服务器挂掉，可以一对一的同步代码，甚至不同步也可以，手里有整个历史版本，可以回退，不影响工作。</p><p>所以这就是 Git 分布式版本控制系统的强大之处！</p><h3 id="Git-历史"><a href="#Git-历史" class="headerlink" title="Git 历史"></a>Git 历史</h3><p>Git 的来源是 Linus 不满意其他人写的版本控制系统，自己花了两个星期写的。牛的牛的！</p><h3 id="Git-工作原理"><a href="#Git-工作原理" class="headerlink" title="Git 工作原理"></a>Git 工作原理</h3><p>Git 将文件分为三个区域：</p><p>工作区的文件 -&gt; git add -&gt; 暂存区的文件 -&gt; git commit -&gt; 本地库的文件 -&gt; git push —&gt; 远程库</p><p>工作区其实就是我们写代码的地方，写好一个代码文件之后添加到暂存区，等到整个版本的很多代码文件都写好并加入暂存区之后，就可以将暂存区里面的所有内容作为一个版本更新提交到本地库里面了。本地有了一个版本的记录，就可以推送到远程库里面，让所有人都看到这次版本更新了。不过具体的实际原理还是看后面的分析吧。</p><h2 id="Git-基础命令"><a href="#Git-基础命令" class="headerlink" title="Git 基础命令"></a>Git 基础命令</h2><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>用来查看当前工作状态，告诉你当前分支 <code>On branch master</code> ，哪些暂存区文件被修改了还没有提交 <code>Changes not staged for commit</code>，哪些文件没有被记录到暂存区 <code>Untracked files</code>。</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p><code>git add FILENAME</code> 将 FILENAME 文件加入暂存区中，实测加入到暂存区之后的文件，修改之后可以不经过 add 直接 commit 该文件。</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p><code>git commit -m &quot;INFO&quot;</code> 将暂存区的所有文件的都提交到本地库中并附上说明 INFO。</p><p><code>git commit -m &quot;INFO&quot; FILENAME</code> 将工作区的 FILENAME 文件提交到本地库并附上说明 INFO。</p><p>所以如果指定文件，是从工作区找的，如果不指定文件，则只会 <strong>将修改后使用 add 命令提交到暂存区的文件们</strong> 提交到本地库！</p><p>当然如果不想指定文件，也想将所有被追踪的工作区文件提交到本地库，而不经过暂存区，就直接用命令： <code>git commit -m &quot;INFO&quot; -a</code></p><h3 id="git-commit-–amend"><a href="#git-commit-–amend" class="headerlink" title="git commit –amend"></a>git commit –amend</h3><p>amend <code>[ə&#39;mɛnd]</code> 修正改善，故名思意，这个命令是用来修复上一次提交的。</p><p>说是修复提交，其实就是合并提交，当你发现上一次提交不足以作为一个版本记录之后，就可以先将代码修改到一个版本记录级别，然后使用命令 <code>git commit --amend -m &quot;AMEND_INFO&quot;</code> 这样回将这次新修改的和上次提交的修改合并为一个新的修改并提交，提交信息为新设置的 AMEND_INFO。</p><h3 id="git-log-relog"><a href="#git-log-relog" class="headerlink" title="git log/relog"></a>git log/relog</h3><p>relog 是用来查看简单的版本记录（只包括版本号，版本名，当前版本和当前指向分支）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">c939839 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: The second commit!</span><br><span class="line">69663c7 HEAD@&#123;1&#125;: commit (initial): Just test commit!</span><br></pre></td></tr></table></figure><p>log 会现实更加详细的内容，包括日期和提交者签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit c939839a1549e2dfd718c3d6bf9ad4b7cc61214b (HEAD -&gt; master)</span><br><span class="line">Author: Xorex &lt;cloudloverain@Foxmail.com&gt;</span><br><span class="line">Date:   Tue Jul 20 13:37:31 2021 +0800</span><br><span class="line"></span><br><span class="line">    The second commit!</span><br><span class="line"></span><br><span class="line">commit 69663c76cc270f8a7e0914730d6d184a66632012</span><br><span class="line">Author: Xorex &lt;cloudloverain@Foxmail.com&gt;</span><br><span class="line">Date:   Tue Jul 20 13:19:49 2021 +0800</span><br><span class="line"></span><br><span class="line">    Just test commit!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>git reset 主要用于当前工作分支的版本回退，格式为：<code>git reset --MODE VERSION_ID</code>。</p><p>用 MODE 级别的模式，回退到 VERSION_ID 的版本（将本分支指针指向对应的版本号）。下面是 MODE 的对应的几种模式：</p><p><a href="https://segmentfault.com/a/1190000012071372">我是看着这篇文章学会的！！！</a></p><ol><li>–soft 等同于将状态恢复到执行 <code>commit</code> 之前（也就是撤销 commit，工作区代码修改完成，全部放到了暂存区，就差 commit 的状态。）</li><li>–mixed 等同于将状态恢复到写好了代码，但是没有 add 和 commit 的状态。（工作区内容不变，暂存区变为指定的版本）</li><li>–keep 比较特殊，工作区的内容根据版本重置（恢复到对应版本状态），但是暂存区还是原来的，和 mixed 相反。</li><li>–hard 将所有状态都同步到当时版本的状态，工作区，暂存区，都是目标版本执行完 commit 之前的状态。</li></ol><h2 id="Git-分支系统"><a href="#Git-分支系统" class="headerlink" title="Git 分支系统"></a>Git 分支系统</h2><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p><code>git branch -v</code> 查看所有的分支。</p><p><code>git branch BRANCH_NAME</code> 创建一个新的分支，BRANCH_NAME 。</p><p><code>git checkout BRANCH_NAME</code> 查看另外一个分支（将指针移动到 BRANCH_NAME 分支上面）</p><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p><code>git merge BRANCH_NAME</code> 会将分支 BRANCH_NAME 合并到当前的分支上面。</p><p>当两个分支的同一个文件的相同行都有修改的时候（不同行被两个分支分别修改没关系，两个修改都会被保留），自动合并就会出问题了，需要我们手动处理冲突。</p><p>出现合并冲突之后，打开冲突的文件，会自动标注冲突的地方，也就是 … 的地方就是冲突的文本。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt; HEAD            //开始分隔符</span><br><span class="line">...</span><br><span class="line">======                 //中间分隔符</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt; MERGED_BRANCE   //结束分隔符</span><br></pre></td></tr></table></figure><p>只需要将分隔符删掉，两个冲突文本选择要保留的，就可以保存了。保存完之后只能添加到暂存区，然后统一提交。（提交 + 文件名的方法不可以，会报错找不到哪个文件）</p><h3 id="Git-游离-Head"><a href="#Git-游离-Head" class="headerlink" title="Git 游离 Head"></a>Git 游离 Head</h3><p>checkout 就是很简单的查看的意思，就是为了查看某个版本的状态。当然我们一般都是查看某个分支所处的状态，然后用 reset 不断切换分支所属的版本。那能不能不切换分支所属版本，也能查看某个版本的状态呢，答案是可以的，让 HEAD 指针不指向分支，而是指向版本（某次提交的版本号）</p><p>比如 <code>git checkout 7ea3922</code> 就直接到了 7ea3922 提交过后的版本状态了，但是这个时候 HEAD 不在任何一个分支上面，是游离的，也就是 Detached HEAD。</p><p>我们到了游离分支也可以发展自己，不断的 commit，或者当作一个分支使用，不过由于都是版本名，不太好进行版本控制，还是直接在游离分支上建立一个真正的 Branch 并取一个名字，方便对这个分支进行版本控制。</p><h2 id="文件忽略"><a href="#文件忽略" class="headerlink" title="文件忽略"></a>文件忽略</h2><p>对于一些不需要版本控制的文件，比如数据库配置文件，IDEA 配置文件，.class 编译的文件，则可以都配置成 <code>git.ignore</code>，然后声明到 .gitconfig 文件里面，让 Git 放弃对这些文件的版本控制。</p><p>而我们设置的 git.ignore 和 .gitconfig 都是在 C 盘的 Users/Xorex 目录下面的，做的是一个全局的配置。</p><p><code>.ignore</code> 使用 # 做注释，支持正则表达式，一行为一句表达式。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for java</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target/</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure><p>然后将这个文件路径在 .gitconfig 中添加配置：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">    excludesfile = C:/Users/Xorex/git.ignore</span><br></pre></td></tr></table></figure><p>一定要多次比对配置信息啊，千万别写错，写错了就执行不了！！！</p><h2 id="代码托管平台"><a href="#代码托管平台" class="headerlink" title="代码托管平台"></a>代码托管平台</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>在 Github 上面创建完一个仓库之后，有两种连接方式：</p><ol><li>HTTP 连接: <code>https://github.com/Administrator-Xorex/Git.git</code></li><li>SSH 连接：<code>git@github.com:Administrator-Xorex/Git.git</code></li></ol><p>因为连接太长，所以可以建立一个别名：<code>git remote add ALIAS https://xxx.xxx</code> ALIAS 就是我们给后面连接设置的别名。</p><p>推送本地库某个分支到仓库里面：<code>git push ALIAS BRANCH_NAME</code> 需要指定推送的分支名。</p><p>拉取仓库代码：<code>git pull ALIAS BRANCH_NAMEs</code> 需要指定拉去的分支名。</p><p>克隆仓库代码：<code>git clone https://xxx.xxx/xx.git</code> 然后就会在当前目录下面将仓库所有代码用仓库名作为文件夹保存下来，克隆之后会创建项目地址的别名 origin。</p><p>对于多人协作的时候，自己编写完代码需要先将远程库里面的代码 pull 下来，解决完冲突之后，才可以将自己的代码 push 上去。</p><hr><p>HTTPS 连接每次都需要输入 Github 的密码，解决方案一个是使用 Windows 自带的 Credential Manager 添加验证，另外一个是在 Git 里面保存一定时常的密码，只需要输入命令：<code>git config --global credential.helper store</code> 即可，下次输入完密码就被保存了。</p><p>或者配置好 SSH 的公钥到 Github 中，走 SSH 连接。</p><h3 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h3><p>第一种团队协作方式就是将另外一个人加入到自己的团队中开发，这就需要 Github 里面的团队邀请机制了，把别人邀请到自己的团队里面，然后给予他 pull 和 push 的权限，一起开发。</p><p>这个只需要在 Manage access 里面添加用户就可以了。</p><hr><p>另外一种就是让另外一个团队复制一份仓库，然后他们开发完之后，请求让仓库主人将开发完的复制仓库拉去到自己的主仓库中。解决完冲突之后，另外团队的开发内容就合并到主仓库里面了。</p><p>复制使用 fork 来将仓库拉过来一份，开发完点击 pull request 发起请求。仓库主人审核完代码自会后，统一请求，向被 forked 出来的仓库发起 pull，从而合并代码。</p><p><img src="https://xorex.space/image/311.jpg" alt="311.jpg"></p><p>比如上面的图片就是对项目 UpStream 进行的一个多团队开发过程。</p><p>先 fork 出来一个 origin 的仓库，然后在 clone 到本地，经过开发之后，向项目 UpStream 发起 Pull Request 请求，项目管理员同意之后，会 pull origin 仓库，完成代码合并。</p><h2 id="和-IDEA-整合"><a href="#和-IDEA-整合" class="headerlink" title="和 IDEA 整合"></a>和 IDEA 整合</h2><h3 id="分支合并-1"><a href="#分支合并-1" class="headerlink" title="分支合并"></a>分支合并</h3><p>原理和命令都是相同的，都是选择分支，然后让其合并到当前的分支上面。</p><h2 id="Git-实现原理"><a href="#Git-实现原理" class="headerlink" title="Git 实现原理"></a>Git 实现原理</h2><p>Git 的实现原理就是通过 HEAD 指针和分支指针所指向内容的变化，来描述当前分支的变化和当前分支所在历史版本的变化。然后每一次 commit 都记录下来此次提交每一行的变化记录，然后根据这个变化记录来计算不同版本的文本内容。</p><p>先看看 Git 的目录：</p><p><img src="https://xorex.space/image/307.jpg" alt="307.jpg"></p><h3 id="hooks-目录"><a href="#hooks-目录" class="headerlink" title="hooks 目录"></a>hooks 目录</h3><p>这个文件夹里面保存了下面这些东西：</p><p><img src="https://xorex.space/image/308.jpg" alt="308.jpg"></p><p>这些都是一些脚本，在执行 git 一些命令的前后执行，所以被称为钩子，来钩在命令的前后，做一些检查之类的工作。</p><h3 id="info-目录"><a href="#info-目录" class="headerlink" title="info 目录"></a>info 目录</h3><p>里面只有 exclude 一个文件，用来配置不纳入 git 管理文件信息。</p><h3 id="logs-目录"><a href="#logs-目录" class="headerlink" title="logs 目录"></a>logs 目录</h3><p>记录提交的提交记录，下属有一个 HEAD 文件和 refs 文件夹，HEAD 文件记录所有的提交记录，而 refs 文件夹分别保存着不同分支的提交记录文件。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| -- refs</span><br><span class="line">|   -- heads</span><br><span class="line">|       -- master //主分支提交记录文件</span><br><span class="line">|       -- feature //featrure 分支提交记录文件</span><br><span class="line">| -- HEAD //所有提交记录文件</span><br></pre></td></tr></table></figure><p>在我们调用 <code>git reflog</code> 和 <code>git log</code> 命令来获取提交记录的时候，就是从这些文件里面读取的。</p><h3 id="objects-目录"><a href="#objects-目录" class="headerlink" title="objects 目录"></a>objects 目录</h3><p>执行完 git add 之后，文件的更改信息（每一行的变化）就会被存储到 objects 目录了，会根据版本名的前两位做一个类似于 HashTable 的分组优化。</p><p><img src="https://xorex.space/image/309.jpg" alt="309.jpg"></p><p>然后里面的文件名为历史版本名（其实就是内容计算 SHA1 作为文件名），文件内容就是此版本文件的每一行变化记录，根据记录来计算不同版本下文件的内容，</p><p>当我们执行了 git gc 或者将代码 push 到远程仓库之后，git 就会将这些零散的文件更改信息打包，放入 pack 文件夹里面，并在 info 文件夹里面的文件留下记录。</p><h3 id="refs-目录"><a href="#refs-目录" class="headerlink" title="refs 目录"></a>refs 目录</h3><p>里面有存储着分支和标签的引用，用来记录当前 HEAD 指针指向的分支和标签内容。实际上根据 HEAD 指针找到当前分支以及当前分支所处的记录节点（历史版本节点）就是在这个目录里面的文件里保存的。</p><h3 id="config-文件"><a href="#config-文件" class="headerlink" title="config 文件"></a>config 文件</h3><p>主要是 Git 的一些配置保存的地方：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = false</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">    symlinks = false</span><br><span class="line">    ignorecase = true</span><br><span class="line">[user]</span><br><span class="line">    username = Tempest</span><br><span class="line">    email = Xorex@Tempest.com</span><br></pre></td></tr></table></figure><h3 id="HEAD-文件"><a href="#HEAD-文件" class="headerlink" title="HEAD 文件"></a>HEAD 文件</h3><p>存储着当前位置的指针，表示当前所在的分支名称，内容为一个 ref 的地址，从 refs 目录里面找分支引用。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><p>目录文件的结果是当前分支 master 的记录节点名（其实就是根据内容计算 SHA1 作为文件名）：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">96e8d208240398683deb39dd4de2aeb576136ca6</span><br></pre></td></tr></table></figure><h3 id="index-文件"><a href="#index-文件" class="headerlink" title="index 文件"></a>index 文件</h3><p>index 在 Git 里面是暂存区记录，并不是真正的暂存区。当我们使用 add 之后，会直接将更改记录添加到 objects 文件夹里面，然后在 index 文件里面留下来记录。commit 的时候是从 index 里面找到缓存区内容的索引信息。</p><h2 id="add-和-commmit-命令分别做了什么"><a href="#add-和-commmit-命令分别做了什么" class="headerlink" title="add 和 commmit 命令分别做了什么"></a>add 和 commmit 命令分别做了什么</h2><p>对于 objects 文件夹里面的东西，虽然名字都是 SHA1 生成的，但是还是有区别的，分为四类：</p><ol><li>Commit 包含提交人、日期、消息还有目录树，作为一个版本的快照。</li><li>Tree 引用其他的 Tree 或者 Blob</li><li>Blob 存储一个文件的修改数据</li><li>Tag 存储某个提交的引用。</li></ol><p>关系如下：</p><p><img src="https://xorex.space/image/310.jpg" alt="310.jpg"></p><p>当我们执行了 add 命令之后，就会在 objects 生成 Blob 文件，文件的数量取决于 add 加入暂存区并修改内容的文件的数量。使用 commit 提交之后，会生成一个快照 Tree 文件，来记录本次提交所有文件修改记录的索引（SHA1 文件名）。生成完快照之后，会生成一个提交记录，里面包括快照的索引（SHA1 文件名），上一次提交记录的索引（SHA1 文件名），本次提交的作者签名（name 和 email），以及提交描述。</p><p>观察上面的图片，有一点点细节，那就是 Blob 文件并不会存储文件名，文件名是交给 Tree 文件保存的，所以一旦移动文件或者改名字，是认不出来的，只会被当作一个新的文件。其次是这个文件需要手动删除，也就是使用命令 <code>git rm test.txt</code> 将其从暂存区删除，不然从另外一个版本跳过来的时候，会根据快照重新生成这个文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Git-概念&quot;&gt;&lt;a href=&quot;#Git-概念&quot; class=&quot;headerlink&quot; title=&quot;Git 概念&quot;&gt;&lt;/a&gt;Git 概念&lt;/h2&gt;&lt;h3 id=&quot;分布式与集中式&quot;&gt;&lt;a href=&quot;#分布式与集中式&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Git" scheme="https://xorex.space/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-04-动态SQL和缓存系统</title>
    <link href="https://xorex.space/2021/07/19/6df2c6bea164/"/>
    <id>https://xorex.space/2021/07/19/6df2c6bea164/</id>
    <published>2021-07-19T07:15:47.000Z</published>
    <updated>2021-07-23T06:03:07.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="if-标签"><a href="#if-标签" class="headerlink" title="if 标签"></a>if 标签</h2><p><code>&lt;if test=&quot;Expression&quot;&gt;&lt;/if&gt;</code></p><p>其中 Expression 为加强版本的 if 表达式，就是 Java 里面的 if 表达式（指可以调用其他方法），并且可以使用 and or 代替 &amp;&amp; || 符号。</p><h2 id="choose、when、otherwise-标签"><a href="#choose、when、otherwise-标签" class="headerlink" title="choose、when、otherwise 标签"></a>choose、when、otherwise 标签</h2><p>故名思意就是很常规的标签罢了。</p><h2 id="trim、where、set-标签"><a href="#trim、where、set-标签" class="headerlink" title="trim、where、set 标签"></a>trim、where、set 标签</h2><p>这三个标签主要是为了拓展 if 标签存在的。</p><p>主要是比如 and , 这些符号在拼接的时候不是很可控，所以多了这些标签。</p><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>where 标签有两个作用：</p><ol><li>在内部有 if 判断成立的时候添加 where 符号</li><li>去掉句子开头的 and or 符号</li></ol><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 标签也有两个作用：</p><ol><li>在内部有 if 判断成立的时候添加 set 符号</li><li>去掉句子结尾的逗号</li></ol><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>trim 其实就是自定义版本的前两者，拥有属性 prefix 和 suffix 来设置内部 if 成立之后添加的关键词，suffixOverrides preffixOverrides 用来去除 if 里面可能会多出来的前后缀 <code>and</code> 或者 <code>,</code> 这些。</p><p>代替 where 的 trim：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代替 set 的 trim：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>forEach 标签主要用来对 Collection 和 Map 进行遍历：</p><ol><li>collection 用来指明遍历的集合或者 Map</li><li>item 单个元素的变量名</li><li>open 遍历内容之前的东西，如 (</li><li>close 遍历内容之后的东西，如 )</li><li>separator 遍历内容之间的分隔符</li><li>index 遍历内容的索引（Map 中是键）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;users&quot;</span> <span class="attr">item</span>=<span class="string">&quot;user&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">index</span>=<span class="string">&quot;i&quot;</span>&gt;</span></span><br><span class="line">    #&#123;user&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><p>大概就这样啦！</p><h2 id="sql-include-标签"><a href="#sql-include-标签" class="headerlink" title="sql include 标签"></a>sql include 标签</h2><p>这两个标签是放在一起使用的，sql 标签用来抽取 SQL 语句， inlcude 标签用来引用被抽取的 SQL 语句。</p><h2 id="OGNL-表达式"><a href="#OGNL-表达式" class="headerlink" title="OGNL 表达式"></a>OGNL 表达式</h2><p>OGNL Object Graph Navigation Language 对象导航图语言，也就是 test 判断里面使用的语言。</p><p>内容有亿点点复杂，先不研究了！</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>在 MyBatis 里面缓存其实就是一个 Map，一个用 SQL 语句作为 Key，查询结果作为 Value 的一个 Map，缓存能减少数据库的压力，大大加快系统的运行速度。</p><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>MyBatis 的一级缓存就是 SqlSession 级别的缓存，是线程级别的缓存，是默认生效的。每个 SqlSession 的连接都有自己单独的一级缓存区域，不同连接的一级缓存不共享。</p><p>对于同一个 Session 连接来说，只要缓存不刷新，缓存就能一直用。当这个 Session 调用了 update delete create 方法之后，一级缓存就会被刷新（Map 清空）。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>二级缓存是一个作用与所有 SqlSession 的共享缓存，二级缓存默认不使用。如果想要打开的话，需要开启全局配置 cacheEnabled 为 true，然后在 mapper.xml 文件里面加入 <code>&lt;cache&gt;&lt;/cache&gt;</code> 标签。</p><p>当一个 SqlSession 被 commit() 或者 close() 之后，它的一级缓存就会被放入二级缓存中。</p><p>二级缓存的刷新是需要设置的，SQL 标签里面有一个选项 flushCache，设置为 true 之后，执行语句会连着二级缓存一起刷新。</p><p>在 <code>&lt;cache&gt;&lt;/cache&gt;</code> 标签里面有一些属性，可以设置缓存回收策略（当缓存空间满了之后处理），返回的缓存是复制出来的还是直接给引用等等。</p><p>MyBatis 使用缓存的原则是先从二级缓存找数据，没有再去一级缓存。</p><p>不过以后我们都是使用第三方的缓存系统的比如 Redis，MyBatis 本身做的有点菜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;if-标签&quot;&gt;&lt;a href=&quot;#if-标签&quot; class=&quot;headerlink&quot; title=&quot;if 标签&quot;&gt;&lt;/a&gt;if 标签&lt;/h2&gt;&lt;p&gt;&lt;code&gt;&amp;lt;if test=&amp;quot;Expression&amp;quot;&amp;gt;&amp;lt;/if&amp;gt;&lt;/c</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-03-XML映射文件</title>
    <link href="https://xorex.space/2021/07/18/bd50545aca34/"/>
    <id>https://xorex.space/2021/07/18/bd50545aca34/</id>
    <published>2021-07-18T08:04:33.000Z</published>
    <updated>2021-07-19T15:48:36.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h2><h3 id="insert-update-delete"><a href="#insert-update-delete" class="headerlink" title="insert update delete"></a>insert update delete</h3><p>这个三个标签分别负责实现：插入更新和删除，三者的属性非常接近。</p><h4 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>此语句绑定接口的方法</td></tr><tr><td>parameterType</td><td>用来说明方法输入的参数类型，但这个类型通过反射可以拿到，所以不需要写</td></tr><tr><td>flushCache</td><td><code>true/false:true</code>此语句被调用之后刷新本地缓存和二级缓存。</td></tr><tr><td>timeout</td><td>整形等待数据库的最长秒数，这个不用填，交给 Spring 控制</td></tr><tr><td>statementType</td><td>执行 SQL 使用的语句类型，可选 STATEMENT，PREPARED 或 CALLABLE，表示 Statement，PreparedStatement 和 CallableStatement，默认PREPARED</td></tr><tr><td>useGeneratedKeys（适用于 insert 和 update）</td><td><code>true/false:false</code> 开启之后，执行完 SQL 会在传入的对象中自动填写数据库生成的主键值（需要设置keyProperty）</td></tr><tr><td>keyProperty（适用于 insert 和 update）</td><td>搭配上面的 useGeneratedKeys 使用，指明传入参数的哪个属性对应数据库主键。</td></tr><tr><td>keyColumn（适用于 insert 和 update）</td><td>对于某些主键列不在第一个的数据库，需要设置这个，指明哪一列是主键的列，才能配合使用上面两项设置。</td></tr><tr><td>databaseId</td><td>用来指明这条 SQL 语句执行的数据库类型。</td></tr></tbody></table><h4 id="获取自增主键"><a href="#获取自增主键" class="headerlink" title="获取自增主键"></a>获取自增主键</h4><p>在 SQL 语句里面设置 useGeneratedKeys 和 keyProperty：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    SQL statement...</span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后用于新插入的对象 user 执行完 SQL 语句之后，就会被自动赋值 id 属性为生成的主键值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">    User user=<span class="keyword">new</span> User(<span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;Tempest&quot;</span>, <span class="keyword">new</span> UserAddress(<span class="string">&quot;Xorex&quot;</span>,<span class="string">&quot;China&quot;</span>));</span><br><span class="line">    mapper.insertUser(user);</span><br><span class="line">    System.out.println(user.getId());</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><h4 id="属性设置-1"><a href="#属性设置-1" class="headerlink" title="属性设置"></a>属性设置</h4><p>这里只说说和上面三条不太一样的：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>resultType</td><td>设置返回值类型，非常用类型必须填写。</td></tr><tr><td>resultMap</td><td>设置结果映射，和 resultType 二选一</td></tr><tr><td>useCache</td><td><code>true/false:true</code> 查询结果会放在二级缓存中</td></tr><tr><td>resultSetType</td><td>用于设置 JDBC 获取的结果集的类型 FORWARD_ONLY 指的是只能用 next() 向下读取，SCROLL_SENSITIVE 可以实现结果前后滚动读取和相对坐标跳跃读取，而选项 SCROLL_INSENSITIVE 的结果集不仅可以前后滚动读取，还可以实时感知数据库的更新（不包括插入和删除），也就是获取的结果集在不同时间调用的时候，拿到的都是最新的数据。一般这个选项不需要我们设置，使用默认的 unset 即可。</td></tr><tr><td>resultOrdered</td><td>和 MyBatis 缓存有关，设置为 true 之后表示数据是根据 key 相同分好组的，MyBatis 就可以进行解析优化。具体用法后面再讨论。</td></tr><tr><td>resultSet</td><td>由于一些特殊语句（比如两条 selete 查询）会返回多个结果集，为了操作不同结果集，就需要区分。这里是按照顺序设置结果集的名称 <code>resultSet=&quot;User,Address&quot;</code> 这样为两条 SQL 返回的不同结果集命名。</td></tr></tbody></table><h2 id="参数映射"><a href="#参数映射" class="headerlink" title="参数映射"></a>参数映射</h2><h3 id="单参数映射"><a href="#单参数映射" class="headerlink" title="单参数映射"></a>单参数映射</h3><p>当我们的方法参数为一个单个参的时候，又分为很多种情况。</p><ol><li><p>为 MyBatis 内置的较为基本的类型的时候，MyBatis 会直接将其返回调用 toString() 填充到 SQL 语句中。</p></li><li><p>为 POJO 类型的时候，会根据 <code>#&#123;VarName&#125;</code> 构造 getVarName() 方法获取 POJO 值，填充 SQL 语句。</p></li><li><p>为 Map 类型的时候，会根据 <code>#&#123;Varname&#125;</code> 名字作为 Key 从 Map 中取出 value，填充到 SQL 语句中。</p></li><li><p>为 List 类型的时候：</p></li><li><p>为 数组类型的时候：</p></li></ol><h3 id="多参数映射"><a href="#多参数映射" class="headerlink" title="多参数映射"></a>多参数映射</h3><h4 id="多参数入参解决方案"><a href="#多参数入参解决方案" class="headerlink" title="多参数入参解决方案"></a>多参数入参解决方案</h4><p>这里主要是 SQL 语句中 parameterType 属性和 @Param 注解的解释。</p><p>其中因为 Java 基本上所有的版本都是支持反射获取方法参数类型 （Method 类 getParameterTypes()），所以对于 parameterType 这个属性完全可以不写，Mybatis 完全可以通过反射拿到。</p><p>但是 Mybatis 拿到的仅仅只是方法参数的类型，是拿不到参数名的，编译之后就成了 var1 var2 这样的，所以对于多个参数进行的映射如 <code>public void insertUser(String userName,String password);</code> 这样，只能用一些特殊的技巧填入 SQL 语句中的 #{} 里面：</p><ol><li>使用数字表示参数顺序</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user (username,password) values (#&#123;0&#125;,#&#123;1&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过数字来表示方法中的第 0 个参数，第 1 个参数等等。</p><ol start="2"><li>使用 @Param(“Name”) 来定义参数名</li></ol><p>使用 Mybatis 提供的注解 @Param 来对方法中的参数起一个别名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(<span class="meta">@Param(&quot;userNameVar&quot;)</span> String userName,<span class="meta">@Param(&quot;passwordVar&quot;)</span> String password)</span></span>;</span><br></pre></td></tr></table></figure><p>然后就可以在 SQL 语句中使用我们在 @Param 中定义的别名了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user (username,password) values (#&#123;userNameVar&#125;,#&#123;passwordVar&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>将多个参数封装为 Map 之后传入</li></ol><p>自己构造一个参数的 参数名-&gt;参数值 的 Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;Tempest&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;userAddress&quot;</span>,<span class="string">&quot;China&quot;</span>);</span><br><span class="line">    mapper.insertUser(map);</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 SQL 里面直接写 Map 的 key 就能获取自己传入的 value。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user (user_name,password)</span><br><span class="line">    values(#&#123;userName&#125;,#&#123;password&#125;);</span><br><span class="line">    insert into address (user_name,user_address)</span><br><span class="line">    values(#&#123;userName&#125;,#&#123;userAddress&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>封装成 POJO 入参</li></ol><p>将所有需要入参的参数封装为一个 POJO，然后就能像使用 Map 一样，用属性名取出参数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">    mapper.insertUser(<span class="keyword">new</span> User(<span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;Tempest&quot;</span>, <span class="keyword">new</span> UserAddress(<span class="string">&quot;Xorex&quot;</span>,<span class="string">&quot;China&quot;</span>)));</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user (user_name,password)</span><br><span class="line">    values(#&#123;userName&#125;,#&#123;password&#125;);</span><br><span class="line">    insert into address (user_name,user_address)</span><br><span class="line">    values(#&#123;userAddress.userName&#125;,#&#123;userAddress.userAddress&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="多参数入参原理"><a href="#多参数入参原理" class="headerlink" title="多参数入参原理"></a>多参数入参原理</h4><p>其实只要你的方法参数数量大于 1 ，那么就会被 MyBatis 封装为 Map 类型，通过 Key-&gt;Value 来在 SQL 中填充值。</p><p>如果在方法参数的地方标注了 @Param(“Alias”)，那么封装 Map 的时候这里的 Key 就是自己设置的 Alias，如果没标注，那么就是 arg1 arg2 这些。</p><p>而从 Map 中取出来的值也是原原本本的传入的参数类型，不会改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="meta">@Param(&quot;user&quot;)</span> User user,<span class="meta">@Param(&quot;address&quot;)</span> String address)</span></span>;</span><br></pre></td></tr></table></figure><p>这里面需要取值的时候，user 取出来一个 User 对象，address 取出来一个 String 对象。</p><h2 id="结果映射"><a href="#结果映射" class="headerlink" title="结果映射"></a>结果映射</h2><p>Java 是可以通过反射拿到方法的返回值类型，但是对于 List Map 这样用到了泛型的，是无法拿到泛型的具体类型，也自然无法进行封装，所以才会引入 resultType 和 resultMap 来解决这个问题，两者将作为反射的一个补充。</p><h3 id="列名和属性一一对应"><a href="#列名和属性一一对应" class="headerlink" title="列名和属性一一对应"></a>列名和属性一一对应</h3><p>当数据库的列名和属性名一一对应的时候，就不需要自定义映射规则了，只需要指定映射结果类型即可。</p><ol><li><p>当设置为 POJO 类型的时候，会根据列名和属性名进行一一映射，如果名字相同，则可以映射成功，如果不相同，则需要引入 resultMap 来自定义映射规则。</p></li><li><p>当设置为 List 类型的时候，resultType 应该填写 <code>List&lt;Type&gt;</code> 里面的数据类型 Type，多条结果会自动封装为 List。</p></li><li><p>当想要将一条数据的列名作为 Key，值作为 Value，返回值类型为 Map&lt;String,Object&gt;，resultType 应该填写 map。</p></li><li><p>当想要将主键作为 Key，剩下其余的值封装为 POJO 作为 Value 的时候，返回值类型为 Map&lt;KeyType,POJOType&gt;，resultType 应该填写 POJO 的类型。并在接口方法出添加注解 <code>@MapKey(&quot;KeyColumn&quot;)</code> 来指明拿哪一列的值作为 Map 中 POJO 的 Key。</p></li></ol><h3 id="列名和属性不对应"><a href="#列名和属性不对应" class="headerlink" title="列名和属性不对应"></a>列名和属性不对应</h3><p>这个时候就无法自动映射了，需要我们指定映射规则，也就是填写 resultMap。</p><p>需要注意的是，当我们设置了驼峰下划线自动映射之后，也就是 mapUnderScoreToCamelCase 之后。这玩意只能在 <strong>自动匹配</strong> 的时候生效，也就是使用 resultType 或者 resultMap 设置属性 autoMapping=ture 的时候，会在自动映射的属性-列中自动进行下划线驼峰转化。</p><p>当你进行手动映射的时候，只能老老实实写 SQL 语句里面的真实列名进行手动映射，mapUnderScoreToCamelCase 不会生效的！！！</p><h4 id="resultMap-标签属性"><a href="#resultMap-标签属性" class="headerlink" title="resultMap 标签属性"></a>resultMap 标签属性</h4><ol><li>id 定义此 resultMap 的 id。</li><li>type 定义此 resultMap 结果映射的类。</li><li>autoMapping <code>true/false:false</code>，在 resultMap 中开启自动映射。</li><li>extends 外部继承一个 resultMap，并在它后面补充（概念上是和 Java 的继承是一样的）</li></ol><h4 id="resultMap-内部标签"><a href="#resultMap-内部标签" class="headerlink" title="resultMap 内部标签"></a>resultMap 内部标签</h4><ol><li>&lt;id&gt; 定义 ID 映射，有特殊优化。</li><li>&lt;result&gt; 定义一个普通的映射</li><li>&lt;association&gt; 关联，定义一个内联的 resultMap，给是属性的 POJO 赋值。</li><li>&lt;constructor&gt; 构造器，利用构造器给结果赋值。</li><li>&lt;collection&gt; 集合，将一对多的查询结果的多的部分封装为集合类型。</li><li>&lt;discriminator&gt; 鉴别器，</li></ol><p>下面主要介绍后三个的用法:</p><h5 id="constructor-构造器"><a href="#constructor-构造器" class="headerlink" title="constructor 构造器"></a>constructor 构造器</h5><p>指的是使用 POJO 里面的构造器进行封装参数，参数传入顺序是按照标签顺序进行的，只需要写 javaType 和 column 两个属性即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;userAddress&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;useraddress&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_address&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想要按照参数名来进行传参而不是顺序，则需要在 POJO 的构造方法的参数里面添加 <code>@Param(&quot;paramName&quot;)</code> 注解，然后在 arg 标签里面指定属性 <code>name=paramName</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserAddress</span><span class="params">(<span class="meta">@Param(&quot;userName&quot;)</span> String userName, <span class="meta">@Param(&quot;userAddress&quot;)</span> String userAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    <span class="keyword">this</span>.userAddress = userAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;userAddress&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;false&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;useraddress&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor</span>&gt;</span> <span class="comment">&lt;!--更换位置之后也不需要担心顺序哦--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_address&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userAddress&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="collection-集合"><a href="#collection-集合" class="headerlink" title="collection 集合"></a>collection 集合</h5><p>collection 主要是用来封装一对多的情况，也就是 POJO 属性有集合类型的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> List&lt;UserAddress&gt; userAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是一对多，所以查出来的条数是多的数量，因此在<strong>对一使用自动映射</strong>的时候，会因为有多条数据无法对应上一而报错。 <code>Expected one result (or null) to be returned by selectOne(), but found: 3</code></p><p>正确的解决方案就是：先手动映射上一列，到后面映射集合元素的时候，就会对应上多条数据，从而避免多条数据无法对应上，手动映射随便一列就行，我这里选的是主键。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;userAddress&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;arraylist&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;useraddress&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>collection 和其他标签<strong>唯一不同</strong>的地方是，标注集合内元素类型使用的是 <code>ofType</code> 属性，而我们在其他标签（比如 association）指明映射类型使用的 javaType 在这里面则是值生成的集合的类型，比如 ArrayList，LinkedList 等等。</p><h5 id="discriminator-鉴别器"><a href="#discriminator-鉴别器" class="headerlink" title="discriminator 鉴别器"></a>discriminator 鉴别器</h5><p>这个东西用的不多，就先不学了。</p><h5 id="分级查询"><a href="#分级查询" class="headerlink" title="分级查询"></a>分级查询</h5><p>记得在配置中有 lazyLoadingEnabled aggressiveLazyLoading 两条关于懒加载，按需加载，延迟加载的配置，这些配置就是作用于分级查询的语句的。</p><p>分级查询针对对象是内联属性，也就是 collection 和 association 标签，实现方式就是将联合查询的 SQL 语句拆分成两句简单的查询，然后分两次调用。不同的是第二次调用是通过配置来完成的：</p><p>还是这样一个 POJO：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> List&lt;UserAddress&gt; userAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将内联查询拆分成两条单独的 SQL 语句，第一条 SQL 只处理非内联属性的值获取，第二条 SQL 负责处理内联属性的值获取。然后在 resultMap 对内联属性进行映射处理的时候，添加数据获取源 <code>select=&quot;&quot;</code> 表明通过另外一条 SQL 查询获取数据，对于此 SQL 的输入参数，则通过上一条 SQL 查询结果获取，设置为属性 column 将上一条结果的某一列的值传给下一条 SQL。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;userAddress&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;useraddress&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getUserAddressByUserName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUserName&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from user where user_name=#&#123;userName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserAddressByUserName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;useraddress&quot;</span>&gt;</span></span><br><span class="line">    select * from address where user_name=#&#123;userName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，指定的数据传递 column 属性之后，回<strong>对这一列数据的自动封装有一定影响</strong>，需要重新手动映射一下，也就是因为 <code>column=&quot;user_name&quot;</code> 多出来的 <code>&lt;result column=&quot;user_name&quot; property=&quot;userName&quot;/&gt;</code>。</p><p>这样分级查询就构建好了！！！</p><p>对于第二级 SQL 的输入为多个参数的情况，使用 <code>column=&#123;key1=column1,key2=column2&#125;</code> 这样来解决，key 为我们在 <code>@Param()</code> 定义的别名，column 为上一条查询结果的列名。</p><hr><p>构建完分级查询之后，最大的意义就是使用延迟加载来提高数据库性能！！！</p><p>只需要将 lazyLoadingEnabled 设置为 true 表明系统可以使用延迟加载，然后将 aggressiveLazyLoading 设置为 false ，关闭延迟加载侵入。这样分级查询的第二级就只会在需要（被调用的时候）进行了！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;标签属性&quot;&gt;&lt;a href=&quot;#标签属性&quot; class=&quot;headerlink&quot; title=&quot;标签属性&quot;&gt;&lt;/a&gt;标签属性&lt;/h2&gt;&lt;h3 id=&quot;insert-update-delete&quot;&gt;&lt;a href=&quot;#insert-update-delete&quot; cla</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-02-全局配置文件</title>
    <link href="https://xorex.space/2021/07/17/10f39f81a384/"/>
    <id>https://xorex.space/2021/07/17/10f39f81a384/</id>
    <published>2021-07-17T07:33:02.000Z</published>
    <updated>2021-07-19T12:55:16.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="properties-属性"><a href="#properties-属性" class="headerlink" title="properties 属性"></a>properties 属性</h2><p>这里的 properties 有三种配置方式：</p><ol><li>在 properties 内部标签定义：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Xorex&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;https://xorex.space/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;space.xorex.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>引入外部的配置文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;JDBC.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在创建 SqlSessionFactory 的时候，给 Builder 传入一份配置文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, Properties properties)</span></span>;</span><br></pre></td></tr></table></figure><p>这三种方式传入的配置信息的优先级是依次递增的，后面的会覆盖前面的配置条目的信息，只需要注意第一种和第二种的优先级关系，有点反常 QAQ。</p><h2 id="settings-设置"><a href="#settings-设置" class="headerlink" title="settings 设置"></a>settings 设置</h2><h3 id="cacheEnabled"><a href="#cacheEnabled" class="headerlink" title="cacheEnabled"></a>cacheEnabled</h3><p><code>true/false:true</code></p><p>允许缓存：全局性的打开或者关闭缓存设置。</p><h3 id="lazyLoadingEnable"><a href="#lazyLoadingEnable" class="headerlink" title="lazyLoadingEnable"></a>lazyLoadingEnable</h3><p><code>true/false:false</code></p><p>允许延迟加载：全局性的打开或者关闭数据库延迟加载，可被 fetchType 覆盖。</p><h3 id="aggressiveLazyLoading"><a href="#aggressiveLazyLoading" class="headerlink" title="aggressiveLazyLoading"></a>aggressiveLazyLoading</h3><p><code>true/false:false</code></p><p>侵入式延迟加载：开启时，任一方法的调用都会加载该对象的所有延迟加载属性（被侵入了就不懒加载了）。 否则，每个延迟加载属性会按需加载（所以要懒加载这条必须是 false）</p><h3 id="multipleResultSetsEnable"><a href="#multipleResultSetsEnable" class="headerlink" title="multipleResultSetsEnable"></a>multipleResultSetsEnable</h3><p><code>true/false:true</code></p><p>是否允许单语句查询返回多结果集（需要数据库支持），比如一条 &lt;select&gt; 标签里面有两条 select 语句，查询到了两个结果集。</p><h3 id="useColumnLabel"><a href="#useColumnLabel" class="headerlink" title="useColumnLabel"></a>useColumnLabel</h3><p><code>true/false:true</code></p><p>使用列标签代替列名，是解决查询结果映射集的一种方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> userName <span class="keyword">as</span> <span class="keyword">user</span> <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure><p>这样就给 userName 起了一个别名（列标签）user，在进行结果映射的时候，如果开启了 useColumnLabel，那么就用别名 user 去找结果映射填充而不是原名的 userName。<strong>建议一直开着</strong>。</p><h3 id="useGeneratedKeys"><a href="#useGeneratedKeys" class="headerlink" title="useGeneratedKeys"></a>useGeneratedKeys</h3><p><code>true/false:false</code></p><p>在调用 insert 和 update 语句更新数据库的时候，允许 JDBC 自动生成主键，并将主键内容返回给传入参数的 keyProperty 一项。</p><p>也就是传入一个 User 实例后，利用 userName 和 password 插入数据库，数据库生成的主键回赋值给传入参数 id 属性。</p><p>这个在 settings 设置之后，只对接口映射器有效（也就是在 Mapper 接口处使用注解开发），而对 XML 映射器无效。因此如果想要 XML 处实现，则需要到具体的 insert 和 update 语句里面设置：<code>useGeneratedKyes=&quot;true&quot; keyProperty=&quot;id&quot;</code> 打开开关并指定赋值主键的属性。</p><h3 id="autoMappingBehavior"><a href="#autoMappingBehavior" class="headerlink" title="autoMappingBehavior"></a>autoMappingBehavior</h3><p><code>NONE/PARTIAL/FULL:PARTIAL</code></p><p>表示自动结果映射行为的等级，none 表示不自动映射，partial [pɑːrʃl] 局部的，表示只会自动映射没有定义嵌套结果映射的字段，FULL 自动映射任何复杂的结果集，无论是否有嵌套。</p><p>不过一般默认的 PARTIAL 级别就够用了，FULL 就有点不太可控了，对于嵌套映射，还是自己写一个 ResultMap 爽。</p><h3 id="autoMappingUnknowColumnBehavior"><a href="#autoMappingUnknowColumnBehavior" class="headerlink" title="autoMappingUnknowColumnBehavior"></a>autoMappingUnknowColumnBehavior</h3><p><code>NONE/WARNING/FAILING:NONE</code></p><p>表示开启自动映射的时候，遇到未知列或者未知属性的时候，应该怎么做。</p><p>NONE 表示什么都不做，WARNING 表示日志输出 WARN 级别，FAILING 表示抛出 SqlSessionException。</p><h3 id="defaultExecutorType"><a href="#defaultExecutorType" class="headerlink" title="defaultExecutorType"></a>defaultExecutorType</h3><p><code>SIMPLE/REUSE/BATCH:SIMPLE</code></p><p>配置默认的执行器，SIMPLE 为简单执行器，没执行一句 SQL 就创建一个新的 Statement 实例。REUSE 为重复使用执行器，将执行过的 Statement 实例放入 Map 中缓存，方便下次相同 SQL 语句使用。BATCH 为批量执行器，会将多个 SQL 一次性执行。</p><h3 id="defaultStatementTimeout"><a href="#defaultStatementTimeout" class="headerlink" title="defaultStatementTimeout"></a>defaultStatementTimeout</h3><p><code>正整数:null</code></p><p>设置 Mybatis 等待数据库响应的最长时间，默认没有设置，单位秒。</p><h3 id="defaultFetchSize"><a href="#defaultFetchSize" class="headerlink" title="defaultFetchSize"></a>defaultFetchSize</h3><p><code>正整数:null</code></p><p>设置 Mybatis 获取 SQL 结果集的缓冲区大小的建议值，避免因为结果集数据过大，单位为条。</p><h3 id="mapUnderScoreToCamelCase"><a href="#mapUnderScoreToCamelCase" class="headerlink" title="mapUnderScoreToCamelCase"></a>mapUnderScoreToCamelCase</h3><p><code>true/false:false</code></p><p>设置将数据库列里面的下划线命名法和 Java 中的驼峰命名法进行映射匹配。</p><p>……</p><p>其实还有很多很多设置，但是时间和精力关系，就先这样了，等学到后面回把这些补上的。</p><h2 id="typeAliases-别名"><a href="#typeAliases-别名" class="headerlink" title="typeAliases 别名"></a>typeAliases 别名</h2><p>TypeAliases 主要作用就是为我们自己写的 POJO 起别名，这样只要遇到需要写全类名的地方，都可以用别名来代替。需要注意的是，所有的别名都是<strong>不区分大小写</strong>的！！！</p><h3 id="单独指定"><a href="#单独指定" class="headerlink" title="单独指定"></a>单独指定</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;space.xorex.mybatis.POJO.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>单独给某一个类指定<strong>任意</strong>一个名字作为他的别名。</p><hr><p>或者使用注解 <code>@Alias(&quot;name&quot;)</code> 标注在需要别名的 POJO 的申明类上面，也可以起别名。</p><h3 id="整个包执行"><a href="#整个包执行" class="headerlink" title="整个包执行"></a>整个包执行</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;space.xorex.mybatis.POJO&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>会将 <code>space.xorex.mybatis.POJO</code> 下面所有的 POJO 都起一个和<strong>类名相同</strong>不区分大小写的别名。</p><h3 id="MyBatis-内部设置的别名"><a href="#MyBatis-内部设置的别名" class="headerlink" title="MyBatis 内部设置的别名"></a>MyBatis 内部设置的别名</h3><p>MyBatis 给 Java 常见的一些类设置了别名，包含几乎所有的数据类型，不过对于基本类型和包装器类型，因为本来差距就是首字母大小写，所以两者的别名有所不同。基本类型的数据别名<strong>前面多了下划线</strong>。</p><table><thead><tr><th>别名</th><th>映射的类型</th></tr></thead><tbody><tr><td>_byte</td><td>byte</td></tr><tr><td>_long</td><td>long</td></tr><tr><td>_short</td><td>short</td></tr><tr><td>_int</td><td>int</td></tr><tr><td>_integer</td><td>int</td></tr><tr><td>_double</td><td>double</td></tr><tr><td>_float</td><td>float</td></tr><tr><td>_boolean</td><td>boolean</td></tr><tr><td>string</td><td>String</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>integer</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>date</td><td>Date</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr><tr><td>bigdecimal</td><td>BigDecimal</td></tr><tr><td>object</td><td>Object</td></tr><tr><td>map</td><td>Map</td></tr><tr><td>hashmap</td><td>HashMap</td></tr><tr><td>list</td><td>List</td></tr><tr><td>arraylist</td><td>ArrayList</td></tr><tr><td>collection</td><td>Collection</td></tr><tr><td>iterator</td><td>Iterator</td></tr></tbody></table><h2 id="typeHandlers-类型处理器"><a href="#typeHandlers-类型处理器" class="headerlink" title="typeHandlers 类型处理器"></a>typeHandlers 类型处理器</h2><p>类型处理器主要的工作内容就是将 SQL 数据库中的数据类型和 Java 的数据类型做一个转化，MyBatis 本身已经内置了很多类型处理器了，基本足够我们使用，但是如果想要实现自己的 typeHandler 的话，也不是不可以，只需要实现 TypeHandler 接口或者继承 BaseTypeHandler 即可。</p><p>实现完自己 typeHandler 后，需要将其加入 MyBatis 全局配置文件的 <code>&lt;typeHandlers&gt;</code> 里面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;space.xorex.handlers.MyHandler&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="objectFactory-对象工厂"><a href="#objectFactory-对象工厂" class="headerlink" title="objectFactory 对象工厂"></a>objectFactory 对象工厂</h2><p>这个没啥可说的，就是单纯的用来创造一个填充数据库查询来的数据的对象实例。这个选项的意义就是当自己实现了 objectFactory 之后，将自己的实现的工厂替换 MyBatis 自带的工厂。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;space.xorex.mybatis.objectFactorys.MyObjectFactory&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins 插件"></a>plugins 插件</h2><p>插件的作用其实就是一个拦截器，它可以拦截 MyBatis 里面的四大组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executor(update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) <span class="comment">//负责 SQL 语句的执行</span></span><br><span class="line">ParameterHandler(getParameterObject, setParameters) <span class="comment">//负责参数的填充</span></span><br><span class="line">ResultSetHandler(handleResultSets, handleOutputParameters) <span class="comment">//负责查询结果集的映射</span></span><br><span class="line">StatementHandler(prepare, parameterize, batch, update, query) <span class="comment">//负责 SQL 语句的构造</span></span><br></pre></td></tr></table></figure><p>我们只要实现了 Interceptor 接口，就可以在这个拦截器里面对上面类里面的任意执行方法进行拦截，比如执行器 Executor 的更新方法 update()，然后加入一些自定义的东西。最后加入到配置中就生效了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;space.xorex.mybatis.interceptors.MyInterceptors&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="environment-环境"><a href="#environment-环境" class="headerlink" title="environment 环境"></a>environment 环境</h2><p>MyBatis 里面的环境就是数据库相关的配置，在 <code>&lt;environments&gt;</code> 标签里面可以添加多个数据库环境配置，然后在 default 选项里面指明要使用的环境 id 即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;Dep-Env&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;Test-Env&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;Dep-Env&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 transactionManager 标签主要是设置事务管理的级别，其属性 type 有两个选项 <code>JDBC/MANAGED</code> ，JDBC 指的是使用 JDBC 自带的 commit rollback 进心事务管理，而 MANAGED 表示啥都不做。</p><p>当我们单独使用 MyBatis 的时候，可以用 JDBC 来控制事务。而和 Spring 整合之后，所以这条可以不配置（Spring 的事务控制的配置会直接覆盖 MyBatis 的！）</p><p>其次的 dataSource 用来配置数据源，其属性 type 有 <code>UNPOOLED/POOLED/JNDI</code>，UNPOOLED 表示一次访问新建一个连接，POOLED 表示使用连接池来优化连接，JNDI 是在 EJB 服务器上使用的，这个可以先不管。</p><p>然后 dataSource 里面就是设置各种数据源的信息了。</p><hr><p>当我们使用 Spring 进行整合的时候，上面的配置其实都没啥用（也不需要配置），我们将数据源和事务管理都交给 Spring 来完成，MyBatis 做好自己的 CRUD 即可。</p><h2 id="databaseIdProvider-数据库厂商标识"><a href="#databaseIdProvider-数据库厂商标识" class="headerlink" title="databaseIdProvider 数据库厂商标识"></a>databaseIdProvider 数据库厂商标识</h2><p>这个主要是用来设置多数据库连接的时候，一个数据库厂商标识别名的问题，其中属性 type 的值 DB_VENDOR 是固定的，表示通过方法 <code>DatabaseMetaData#getDatabaseProductName()</code> 自动获取当前数据库连接的数据库厂商标识。</p><p>获取标识之后，会在下面 property 标签里面的 name 属性匹配相同的数据库厂商标识，然后给它设置一个别名，为 value 里面的值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;MySQL&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;SQL Server&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlserver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置别名是为了方便，但是要在那里需要这个数据库厂商标识别名呢，答案就是在 Mapper.xml 的 SQL 语句映射文件里面，每一句 SQL 标签都有一个属性 databaseId 里面可以填写数据库厂商标识别名，标识这句 SQL 是在对应数据库上执行的。这样面对不停切换的数据库源，可以轻松的用不同 SQL 语句来应对。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">    select * from users;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;sqlserver&quot;</span>&gt;</span></span><br><span class="line">    select * from users;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="mappers-映射器"><a href="#mappers-映射器" class="headerlink" title="mappers 映射器"></a>mappers 映射器</h2><p>用来找 SQL 的 mapper.xml 映射文件的，分为单个配置和批量配置：</p><h3 id="单个配置"><a href="#单个配置" class="headerlink" title="单个配置"></a>单个配置</h3><p>使用 mapper 标签，resource 是从类路径下面开始找的指定配置文件，class 根据接口全类名在同级目录下找同名配置文件的，url 是从磁盘（格式为本地文件传输协议 <code>file:///</code> ）或者网络上根据路径找的映射文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;space/xorex/mybatis/Mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.mybatis.Mapper.UserMapper&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///D:/MyBatis/src/main/java/space/xorex/mybatis/Mapper/UserMapper.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="批量配置"><a href="#批量配置" class="headerlink" title="批量配置"></a>批量配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;space.xorex.mybatis.Mapper&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 package 标签，设置一个包名，然后会自动在包的同级目录下面找到所有的 xml 映射文件，根据类和 xml 文件名称相同进行匹配。</p><h3 id="优先级问题"><a href="#优先级问题" class="headerlink" title="优先级问题"></a>优先级问题</h3><p>需要注意的是，四者完全冲突，建议一个 mapper 只使用一种方法进行映射。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;properties-属性&quot;&gt;&lt;a href=&quot;#properties-属性&quot; class=&quot;headerlink&quot; title=&quot;properties 属性&quot;&gt;&lt;/a&gt;properties 属性&lt;/h2&gt;&lt;p&gt;这里的 properties 有三种配置方式：&lt;/p</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
</feed>
