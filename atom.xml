<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xorex</title>
  
  <subtitle>要成为世界上最幸福的人啊！</subtitle>
  <link href="https://xorex.space/atom.xml" rel="self"/>
  
  <link href="https://xorex.space/"/>
  <updated>2021-06-05T16:47:14.015Z</updated>
  <id>https://xorex.space/</id>
  
  <author>
    <name>Xorex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为美好的世界献上祝福</title>
    <link href="https://xorex.space/2022/05/20/567f91f8bbba/"/>
    <id>https://xorex.space/2022/05/20/567f91f8bbba/</id>
    <published>2022-05-20T11:58:03.000Z</published>
    <updated>2021-06-05T16:47:14.015Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="689bfc10a9fed57c789bc7685d36a5d9d75f31b34cafe041b99ff510386c6242">8a972074cb8fb594adf191142c932486f63d9db6a4bbbbf65eb58b44e7f3a502ca39de9d3c1e3d9c70fdc9a01ad868dc3486910eced5f4e34f64df4c5155d0e28740e7f637329c5391f9bbe6ff64e653a789e2cef71c949e21aa63f2fba5c2f8909ab81d64320e8cb4384ed74fbebab2050cb82c4a7d22b4b9fd24d8a61fc8d8029f2ecbce16d7ac4071fe5c0ae2c3425b4c421b4a82a69b6012152d7d464a3624e786c960a03a52f9cd3453ffde3f9e7f7f8db1b21b9fd158b70d49126036880e6f581475aa1c9265c50093981c7c70663d0a1e3bede2870b4a7e0a6dc0d1a1ce8dbc658189e95bd6888f0f4d48bc8d7fa179df02ce8435ed223754c508e2b86eb7748ba754993eb71d24a37e5f551d0164956aa4d5dd5f723185894b6581fdc9638900b4666fa18e9bd6f6874b22c630932f62849d260f383329527390267e1ae61d8591c4aeb352f4b29108c2465a5e074d349edb5a9af79cb59ade636bb557cc6cdecd797157def65921204d200554354bc3d381c49d4097e92d1d51fd01c2313cff9d6502cf7e7f4b2399cc1e6be251d80c7050309bf346d386a7b536645f5c4c96178bc331da5740a42b0bd02b9968ce31b992b998e972e1dd06841a9d53b1d8280616027ac636ce646b67ae2c98a4b2ce990afefc45bd9b4d068c8fde09917cd2e84b9ffdf59606a1a60816d2f994703dfbbad7039e96e0b658292bacb1858ba7d9e49eb3187431fa4a1f8363915dc73aad3d519447f7cc0ff818de1453e2ab8257e0057131b57981825fc2c9f788e75c5564eb2ad8404bab6a82c47ab0a53249beb3b2306c2e5554ac2302070a4190176ddf1f1a7c9f4e483174777de2b527a91c806a1327390ff9a7eb985697c66546afc772628cec06b528dccdd1cb1d1d13ad8f74668fa5f5d0195cde6adade74f3ee1870b9a5da2542345b0f3ccb4e45aa3e4ca19ee469c348bc52b7c915f9fd94f14a9ce369c3d58e5c0e6550c9e6944437b122bacc312d2eaf41ec6165983d4afd819eb351ba8b730ee916f9cd78fef8008dcb9c56e63761799af98a3a7f796a1fa589fb9951d440a514e59ecf489a527c3a856fb48273361bc634d065d3e1833fc4a3b59e3f44008e8a1565a63506724732b84253673b58773214fb18c6f216ce7f94a3000979160f8fbe89f7300870c0103288288d986af8c35cf489154c5116b9e29ea3806b83fb4fb5c13bf5fac94b9fbb3d4dbc0a39cf185ce78c526bc7ed204162cdae47a4d016b2d81ea2ba9fc9830fb3527f1841ccf23061c0b80b53f3ae74c11c56b01d7711482081a2fcee250f16af2cb412ec812dc57d4d1d6985a692f17764a8bda6787d62fb8612eb25c70420071fd319dbc83c5d7f8ab892ebe088697c5f2833a61978a2b3c68e6916e569324b6bba4123401b6cccf173cb6f5f16b310bd23c631794739ed100cba1697a02e0cd558489edd5b9fb774265919385617ef45af3e351137e2be1db5a0dc536cc5ab5a80897d655a4da942de4a3fc9462a7d2eb6b49a288980210c8bf4649156b1e7d1f2c6e6eb1b8cb056067a2306541b7828ad3c48713b7ddcd33bdc4c83aec20ea2f4812ad03fedb8d33e6214f83ca38ffcbb55ca3859cd0cf07b65dd04174589117adf9d5c76448c6786447889122c612fb0ba366bfd64384a5162e27375fa7747622c6cf3b1c9c09bae41d179b1ac15d3cdd3254c2498e37f38e8b43b6620a7898afadb4e74414a7783ae2ffefd6aaac8cd082f33fa0abb3c8271690175664331e3053092c2b6abbf7e66adb0530ddde01a965e6abe809db7bd6d79229a09bd7df84c25da01c92e73a035e2667a75229c48e889842fbd0a1d7dbf7c579292b8557b8f400157e95b2864450dc73474ca6520544b623d98a0445e62a98d184853b6cf236e48ffe6ede26b4ca737f3f8c2f19701125867ec08135ca682b3cedc732362def3eefbf16d0327fedf680a5dc50bbb5590feeffc83a065c7c09fee680f2395508e418e59c28bcce45dcb357e95c2590a7ef9049d04d6bdbebce82c03d09be7d60c90ff409231a5b8df0091ede2ea2abe007dce72a5565fa7792a143ea45e0f14c3eed8ac989811cb44a0cb0fa483aa5f25831ccd3124d07a5558b126178f10f3600a554228513b55f48fdc6ca3d88c9a4203c3f729197919ecaff8376f9535fd87232cb896294f9fc4fdb1c094dc5b8c13fc9c0af0f6d5d0649aceb4beec719f7032a9d68ec16a1f386654f29e0adf7ade3d6d883067a74baa45dd07ca46c074be4a2d4d3cedd9cb43aa79ea8605e4a843d693cd9a062524820c3ae94cd3ba631d7d2c844b4cfd17570d07e02bb79c647880cb8f4a0614ff595bd22cff36fae33ba66ff6b9614ce43b5e2c2e2103b2a7c36dee450c0294e61645f1ff62b02acba1a876583591a53d9995c97318865eac82e9ab2d7daaee2edc69d2f6240b9cb98c8f3cc1c140d3ccfdb1894a3a9ae4db3704f4bef50c79ed660d72c4d76ca15c7b090c3a3ec8b6a1663e8ef6b80b33a790d75a8f2cab63863cfbab878fb45829ac4b30877f4b44ebb6fb1bd3deef6d4bb492d9e8dcd8f44dfda2afc59f9957524ddc5a9d26235be96e405f99fc668073799bfc29c611f3d097c9bef8404dfd98753bd059c4ccb2dc28284fa4d26f7388f29f063c5924d5d793e65af69eea2a654c3ca088ed576cea7a496de608c7fdc8adf94e22690d642584b9d121a80980bff1d66f2dbc7abf03c7272b4bd1f74df56756a806d0e76f293912b968b023f95efc0779c20497e818842577470c33cf1f1412cea0944a4fa2cd2a145d2a4dc588712f11729cb1233d6eabd234e0556425985afe3cf2518e4f70bbf31c038d5c335f500e0125cd3429ce768886381d9bf7fa0236a3449fd423c501be99daf36e54f58f09e63462c975afb417a015bd5f4a918f66f022aa79981cb82c29087351b1afe7b5051ad3712c3150e62f9d01f429d0b1050f348592d09d22cd5dc3409e3d11e7664dc114d8c37160b9d39f7d594813fd90cd23ac43c86cce7f22a0ecc46e9c77c1a1097fab3af5c9e0bbd893630d1db32066c3aeb8544e5a3b1e9f4905a3685a041e7921c29f7eb36041f276e3de9da457c90c0a4e9b1ec38db531d7887628745c5f26194ad2c2bc892a0e62a63be8e7162540b04696ee38d1ffa3deef3f110517e9813d259eb2617581819a50a37da390650ba8a86f576db6036fe772c8f8d2b15633f5d1905f11d452d62d67121d9a7d30cf26419c7100f2f51a3f0f8597048cda90b68b1b86116671fed5953d70fa552b04bcd54001afaaa291346a9eef0cb871f350a08a2e2ad3ead37fbe7af6c5ea3fbb4e2af874efb0d4f33d149f83b525500d0d106ae12249119307c0242bcfff7425822d2f61aae575154c5499f03b06da9bdfabf4707602c20b2eb9173a7f01dd7ea77e0b44303670982c11b53a5603e22cc74ca166846ef28697572ae88504db22754792584f45a2a559813081ab34c8641550dc1259ba7cc55de0d8ea0ae7ab83afc533113272ad893f0106a087e6bd0eb90c464eca576a7a217ef654ea365834f37076cec52bb40f7c2ec76ca2fdfd93511f3132b68d5279d42422d4562ad20cba8e76ddf4570fdeb4a0b1e63f2b87edf688afd4f51ae842b14864a528c57686385e5e763d175bf04d26ffd612a90f5d5ed0d49d6dbd4e472a192665afa263e1d9c2dfafb17858b59b5957992af881daf5231757ae0a3733d0e032415f2e6147113228b4c342045de3f73e08d00f893f7c05ab15b64603ef42b1e300b879fe6a8703d130048a0ef4c43a0f5aae256cfbd422f76818720e45572b16b6aae06c7c9a8a2be60d6bc205e8a0bccfea6660196c6ccb73571d9fce6aec0dbf9a211c12769ce9f1d4d2dcaccffc5049e92fc42abc59c6b952abf55ce944bd619f23f17700a194a95daeae67c69a289b48ac154619c185012cae1d913657e9fcc2ea89ededbd49813fddef2a842336a0a62385844b872a5c648b7ab23e2015579b053780d4c2fc01e621dfdb0f169723e26e319948f6355a3d52c26774488a5f43a1d574e80c78730f8b825210e3a93d5b904cd14d74f09255b74f5e5185d35713038bfecaff6c4cbc9c3e6b3638c64ed1af85cd0746586e41377fa167c73f22a605639878844d9a73dc5c244e02e359c3ae6cb62540b36a4b5e2150898258f2f86d881fb21d0e5c1c4e3552eb48159529396d53cc96ff48320c1406acc328fe9c1cddb62363481ed658ec32273b5f6149e80d7f111cad43e8f989c6f9609f194d18319b7932ce1854265e28c93ad307ee5f638c795b49f625b6783187862743df526a3da373e9e814846ea92343d3d5979772a38dec79be44317f0c75efadac03409fc473af07b7c47adb8170959bb5d20d41362e96ff110bbecd6edb3a7fef4bab4470423113aa367d0e8a2425c87bd98550ac0e7db65c9c7d32db12cff2bcfa81cda4e41d0b308f9578b4b1e5d5794d5ce80ad0ef7eed3cf3039f85c28d6fc247f3e04e4da416c126c6a7453431952565dbd973ceb410451246d221b4c4c59bb45dc1e8f01d15456e4bc59b26feee41aa8ef0356eab5d03e4a9cced9df106708a16de62ca4bf2d9ca503747ed9f4b6b664916a7bf851b7392e1e71ded53d2576c775e15be1a4502a80dd2f5c34808e17f642d8a987ec273b5d0868a114466b331e563ac674abec48fd6783c8624a06a92dc359b3efbc0e9c28aa832f4a61417ff2859ddbda7ccc5617d1a9d17ce2843ea48c7b5bddf9e2d79aeae9d844002cae5545cceded9192bb31c3b49b7723b30da30318015acd6f16cabae11f2f2d197f0b0097fe222019bd1e82d6fb82b1b7a240b0be445cef0404adc7c55a1ff0bf296c88b6be1ce1b0083dd453c5a91cf01c0abe097a59f9f5771310187ee251f978945d21311f01ed29eb1ded81deda69d472642b543e0e8bf92781a96f9e576e3172770483f69c15fea7ec986b796d1a5c1f0a08e96b1090dd9119f840d9c016ac32b8cf483f3986934121380be1af639c7efc0ce4f4429aa99eabaf015c4f81a232aa9d030faa9c401c118532146e91ea4ccb77bbe21995fcdb4f16409a41715920a010d8adbca438d7c94852563dc36af172bd19e552fe44a45222fc43fe10e7ba6d4d857156399cd143de7caaeb001e14fcb3d03be87ea1717c748bce8c47ad170f8170c159e37f533dc7f0415eeb55dd07c7c28b7358f4cf62b257b6e3d972ee8d75e04c673e0cd267ac89badebc34fa445f6cac623c9ee9447556c5149db450291ba01c3dc62ebc7661da869d3c7f23b853f29af418a41890aab8c1093ba44d46019deb75043ee8b76f9fc9fbd149ad4b77ccbade7d360c94eba7766b1650414c48088892abb236903bac42fa1c32d90d972ef54da2a2d87b8e0f2ddbf5b006e6ff79660d4122fdb8332e5ec80a90bcd95db27fcf79376ed0baaea37dc99c00194e35cd48c3f93a78000fbbead43982ed3dacbea40785414ac60d9281353479cee2cae86b73a3769ebd29736f9dff2ca6be49d2908d7517f4f11d6145e23cab64929ca877bb055d9a547e4f13dfb1cc300487538fe065df2eb6cad120563d809978f54eb6337ddab9e509fd1ffb27217ccc59f8bdc582037569b46a1d88ca9641b721f5177a10abb2038b60945f5ddc42f0433c0062cf5410a8ca84a91930718f1ba1a0bb879da6130740911c5a7431c19985ea8a6f6a64ee53399cb40a1252e2dee4a36178fa2e25826e8787db25c33b3c11a1574a0bc8b5f58cb6f7bc7b31878ac035bce91319ed0f5bbef3e7b249ca8c7ecae0ed40e38f8881f73125aa4058883ed2e3241d9706bc3c185c9fe9f0c9a64318a0e848ad08864b747a38a166cfa55dbaf417deaf2781a8223d6b3856a69a48e53f3bea85f02eaab5a61d8185e7856ff545e2e666b839bac6ca08a34a9ed391eb859330148e35f0a9221f8000f1ba42a55a545688868027c4a34cf2d05dc12f3e512500e853e853fc713465766e55741d58b28a9b994fd03cb213d1475e84189329170f0160ed9f5cf75260be695c74fa812375c6f0ad329adc909e5f76cb3f12a98b4128d5b17677cbc9322360667ad6f2268f49e6c70f905adae18ef1a10b8ebcc6c5df15fbcaee97e5bf039a683af766b7ee350eeb564f7df1159c0cfc7b863ed7844ab0f55c147028bbc125822720807d0da21387520376d1f581235ae9887f952ee49b5d746989ce8d9378aa6bee5faf12d9ac3b2f79e3a684361dba69b657884b8cab25daec678f004f793a845fbe5bdec336aa74d05948fbafca14c7ec43a6569883b0ad31a801c38d78173453b632b65ccb08ac379aa6f0dcf7a11035415c58b39557dff5a4246860f5ce80cc862218a43986e3b9f27ceebcdd62f7fb645f5c77b7450995789545edb0a5c11119e87691691478b9d939ac95c43e2245d4c448e806b01c0918ed18805edd519d2a927adb92fbfd2c9dfc5d564d82f5b092b5203547ed28d731726e47fe054cecfa6b4137024e8ca9b943d46aac7b792bfdb857831de16281dc4b15ccf73a6774799cada60cd4e964b3ec56b057df054ac12f14c886dc99ffbe46426607d8b754058f944304ffa6dd7a19e96ff9fb9630948e0526ab72cad0633b507a48ed58f7d34cfb0dc68c6fd9523246b3b63d4db3ee7a6563787fc9f7cbd88966881671abf8c037f15d362a7ae43e3174ccd05716e3e595a36b45b42d16059f1ffe3f85acb416942c0d82de9db439b96e08aacf890b61a936c285397eef3e83ad4a47f00059c0e0e9675e6dd257f5db2cd06bdb0506cb696f9a698c85a95cd95aee8c354456a8fcc055818e2b4da0b44376810cd607b3809f03d7af96ea963adaf4a8abaae66ec2b993cff102c57380bb41030f6192163a8076dbd2e7b037553d1f3928804847b1f359563a0e752c3b9b80dad8102cf77d3f7100a6e881e52db01c42d9694c3cd6afc86a77fda767232b2e66a393b2011ac6af6f9d00d9be3d31e1065b61a118319daa5422a78bf06ba773bb2a5f9343b948483ad66b781222d9bcb211e13d4c851d5bbf7328025b38ca63c4907945cedf110a838aba27cad851f73ddc5c5ee6538ebecb22454cde54cefd0d808263364a9d3fab55df73b11e0ac7f426f22d3050163fecf163512def63d06ede8f842fc5a41bd7b65915eb55bf776e7460d8675ce525a3bd8ce12fb42134dbd97321fea31444376355c9163a30d28d09c43be25fc49d7c9286e4b13c4dde2ec4f425d2f8a50c5f9229d2d6714e05d41eac3f8c2df13b25af2d912472a5ad9b600ff739bec4386b96fbf28767a19cd7696cf194bb1822b0bba1d55ecb053024fbfaf595ffb2b62114e56608cb119c3d6b26f3800998e20c7697e33087f223d6cef191cdc11a61009321aeac4c757fccb57ad6880f05302b00c7c12309e882126ee82c2d65f236d6aba8297a9fa113ddeecfaec3bf578f964449f208f86a55e7c7fc680104ccacc8b51731eac235142f937d68d117766c6b97a0890c2f0c5906269d463b70a27fcf042d702d6a84816c0b04c615e4641b37b352a5bdef59f27ceb05fe42f15f85ee9d3a3cb109fc07f4ea42d8577921315a1d57995acda377a83a95277869401d204d0154e45231dfa418ba19565adeb6f947f85ba84ead98fd9f72ddf24173d8bb6c675d60eb4c0bd019e2c2e04904ec56b0570662f7686ee4cd789bb9bf9a7cdc6cd155be5bc6dcbc548914afaa55553e6c8f9f7eac4ae6a9b43d0f42e810250d9812b6726d59c7a2adcf70a051bd6b970a701e7385972939f42c34c08676b778787a96fceb316a48b9e94efb3cece703aef605279442697282a777b97a5aa22ca2cfbd694d2e7e786878bd5b67cccff6e6763c52b8b0a4e5485fdee23ad79007c7201371e010c8a24d80b18e7d35d4d7d9335f4990dc027a096d5cf811f8fa3e21fe8146307e98fe97bcca6bcc11a0a67d7e65288ef112033b9f13248cdf8634ea67d6051e92933aacad2e4bac99ba8ae764a3c63cfc1069d1922f47f3e48f46c7d818682b51c92e31caf6977926dd3df0e6e9dc65d9858133186907b94939e288f46cee43adb7ff69d369c5828e043d10f3f132d5098c687633080f027dd73f34b4f070299a2ed3579eb2f7068d66a7485f3e20c2e9bb963d760467cfba67fd1cc253e97c8c0cb054fd06b2ed7d612388a50e59b2268f7094783f19103c8ed86d86ada4fd4d6b63eee59240d19cc566d83b3d499f86f0da374362dd17b24eeef5f8ff2536f431a0ba9c5fe7955508bf5824b9829e38687448f2e83c726931838c4d038ff25d171486f5ba4fbb2499edb41fa89c2113701003cfd6703d040acdcf83c87324d33778e217d37da1d2b072c39067b23f9e980d59f1b73757168124746a5c3b15eb75b41c0ba004ffa77b12ba35b1e9b5d141348c39d499d0621b12e1aa022bd569cb2bb30e15e82b458f336e2f3285f10e0a7859f824af87fe5d65159e0ec969ecc2161bb0e33dc9125fbac004c2705a85be85bdba10b86ce22b7b06cf08757792e8592bf397398fc9627094221440b4ecdab198583376f3393bd5ddf19c9f6ec3ac94aa6c9a44aa6509508f9c1a242158084e475c6819ce401816f785a6bcb3e553fb0917355e92c2cabf25b2bcd4d4f1443a3fa3330a3a8f46534b8dd466ec18fc4bafe757f0980c35cd260cf7cc46518f4813bf5614c82709a99ed68cd32a17aa97b99a1ba9f468fa44ffc29202d4baf93b9240d6c34d7d2349feedbcb34e6f28d6d6cff003d28b319ae4c153bb5b82e286feb73638187bd02e9b6b21a3ef2281ae8d589c921d426330cf693eb80eb45e3dd83df3f7e5f92268351885c3aff655d09df11c9e4aa4e011bb1ddcbc715673f4308b76e281aed3335c8447f82667fcd64089ca564d199b96b826a8425c15d033b37a437595111808f946326a4a7547e1afc1f60bf5d6881d5682048fd3fda3cc034b8962e8e3ab397e167e4e7a67fb5f6405170cb7b8a93a151963957a0c7e5a10f5c831de7608f2dc4742e10a0bff962ba5509b2c987e644e866f968538ada9b9dc173f7d06c13d7fd976a9556c0b92399da6389a79920bd7a6449c10bc99c4d8621f8d82237e635025391224151ae2808e73c2955a60e60c501d0e9fa96b55ce0677e57fdbf149aecd83033c72896390072961db8da0c5f683ba2308d0815acd5b23311c530e15a5ec406435cbabf12617615ddde9db78f91be2c139a96e354f7e1276393d6b0e1f0f5c98b2ea4c5f13e925201dd683080379e5c1e52c244a7b61937b3acda4e40ceb5c1b879fa0fa3f556f2b8cd0b978169299c61fa2bd70bd8d4699dcbe70818945a8e36b234e554d92705390e9639b926e87bb1fcf22a60833cf2fd5e97c245a383e05c0a1b13f75135b3a742f652cd2e7da3e73e8da53493ee51fb001e7f12618f8cd52e05e4f653b88338bb3f50649e351b6fc9cefdcbcb40903acea8e572bfcae0b0571ce2e3d5363e578d13e6acb598d176f392a60638490f32c5e128fa2e7e444511e8281829cc11a39d59d789abd84b6002e84ce4ef485957b48b3210fa04f4552cad85f28be845f3812d72e86190af94b9c370c2a30d3b6eabcc3fdebd1b5f4e1258f054466cdfa2ba30aaf845046cc19db80c200ae27f90532be1526717f3a4152a78985c93e735f46edad5be9899b890368c7443bd8bf0ac52f33c0388d906d1ae2778dc9415f48fe5b4d0eb8dfbdf96400fc43247b8fc8603302649fd9938f5d8be1fd266a32d4bc33f07cadf49933d016ff6463617e1968bb04dcad750ff91fff3ddaa7eac57728aa4fda71b6562d5285138a90e7bfcd1c190684f8a4832c4bb77737b81cf021e01abe5a7371a0ebbe5617235503f804212feed8fcb82fc2eaee5dccff4c0423fd78e874c30ce500e1fe9c6722f768561c3c903cf1193342660764081c81cdf0a7cfa9e519becba3ab8fd7cb705ee5930d61f732151414f9ed04a548f1b6d7fdaa22ff84f94f787afd2bfcfbef75830dabadcd44d3db76f40e1e5f25bb08fb979499873f8e12d53976af844bf4b9d041a2784a23b4824b329a9cc7098605eb815c475fd8f7c525ec8879decce1c48dbb8250e58b9e3057bb355c954fd92034065744a2f2b9fc1970d4f61eec37d842e0ac703585960b13237e87d94764e9db6bc45918fde2a365ee5308c52f01576712f31ba9a8b0dcc27cae382</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Encrypted</summary>
    
    
    
    <category term="阶段性总结" scheme="https://xorex.space/categories/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="幸福" scheme="https://xorex.space/tags/%E5%B9%B8%E7%A6%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring 框架学习笔记</title>
    <link href="https://xorex.space/2022/01/01/d68ebc25d776/"/>
    <id>https://xorex.space/2022/01/01/d68ebc25d776/</id>
    <published>2022-01-01T09:53:05.000Z</published>
    <updated>2021-05-06T07:46:52.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-Spring-框架"><a href="#关于-Spring-框架" class="headerlink" title="关于 Spring 框架"></a>关于 Spring 框架</h2><blockquote><p>暂时放弃更新，完全学完 Spring 之后再来总结。</p></blockquote><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="set-方法属性注入"><a href="#set-方法属性注入" class="headerlink" title="set 方法属性注入"></a>set 方法属性注入</h3><p>具体方法就是使用 IOC 获取到对象之后，调用对象的 setXXX() 方法设置属性。</p><h3 id="lt-property-gt-注入"><a href="#lt-property-gt-注入" class="headerlink" title="&lt;property&gt; 注入"></a>&lt;property&gt; 注入</h3><p>在 Spring 的 Bean XML 文件的 <code>&lt;bean&gt;&lt;/bean&gt;</code> 标签里面添加属性标签，<code>&lt;property&gt;</code> 标签内部有属性 name 和 value，用于设置属性值。这种方法本质上使用的是 <strong>setXXX()</strong> 方法完成的。</p><h3 id="lt-constructor-arg-gt-注入"><a href="#lt-constructor-arg-gt-注入" class="headerlink" title="&lt;constructor-arg&gt; 注入"></a>&lt;constructor-arg&gt; 注入</h3><p>在 Spring 的 Bean XML 文件的 <code>&lt;bean&gt;&lt;/bean&gt;</code> 标签里面添加属性标签，<code>&lt;constructor-arg&gt;</code> 标签内部有属性 name 和 value，用于设置属性值。这种方法本质上使用的 <strong>构造方法</strong> 完成的，使用的时候一定要检查以下所对应的构造方法是否正确。</p><h3 id="p-名称空间注入"><a href="#p-名称空间注入" class="headerlink" title="p 名称空间注入"></a>p 名称空间注入</h3><p>本质上使用 <strong>getXXX()</strong> 方法完成的，首先需要在 xml 头添加一条固定的属性：<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code> 然后就可以在 <code>&lt;bean&gt;</code> 里面通过给属性 <code>p:XXX</code> 来 set 对象的属性值了（这里 XXX 为对象属性名称）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于-Spring-框架&quot;&gt;&lt;a href=&quot;#关于-Spring-框架&quot; class=&quot;headerlink&quot; title=&quot;关于 Spring 框架&quot;&gt;&lt;/a&gt;关于 Spring 框架&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;暂时放弃更新，完全学完 Sprin</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Spring" scheme="https://xorex.space/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-02-全局配置文件</title>
    <link href="https://xorex.space/2021/07/16/0df908575ba7/"/>
    <id>https://xorex.space/2021/07/16/0df908575ba7/</id>
    <published>2021-07-16T07:33:02.000Z</published>
    <updated>2021-07-17T04:41:21.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="properties-属性"><a href="#properties-属性" class="headerlink" title="properties 属性"></a>properties 属性</h2><p>这里的 properties 有三种配置方式：</p><ol><li>在 properties 内部标签定义：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Xorex&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;https://xorex.space/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;space.xorex.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>引入外部的配置文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;JDBC.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在创建 SqlSessionFactory 的时候，给 Builder 传入一份配置文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, Properties properties)</span></span>;</span><br></pre></td></tr></table></figure><p>这三种方式传入的配置信息的优先级是依次递增的，后面的会覆盖前面的配置条目的信息，只需要注意第一种和第二种的优先级关系，有点反常 QAQ。</p><h2 id="settings-设置"><a href="#settings-设置" class="headerlink" title="settings 设置"></a>settings 设置</h2><h3 id="cacheEnabled"><a href="#cacheEnabled" class="headerlink" title="cacheEnabled"></a>cacheEnabled</h3><p><code>true/false:true</code></p><p>允许缓存：全局性的打开或者关闭缓存设置。</p><h3 id="lazyLoadingEnable-No"><a href="#lazyLoadingEnable-No" class="headerlink" title="lazyLoadingEnable No"></a>lazyLoadingEnable No</h3><p><code>true/false:false</code></p><p>允许延迟加载：全局性的打开或者关闭数据库延迟加载，可被 fetchType 覆盖。</p><h3 id="aggressiveLazyLoading-No"><a href="#aggressiveLazyLoading-No" class="headerlink" title="aggressiveLazyLoading No"></a>aggressiveLazyLoading No</h3><p><code>true/false:false</code></p><p>侵入式延迟加载：开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载（参考 lazyLoadTriggerMethods)。</p><h3 id="multipleResultSetsEnable-No"><a href="#multipleResultSetsEnable-No" class="headerlink" title="multipleResultSetsEnable No"></a>multipleResultSetsEnable No</h3><p><code>true/false:true</code></p><p>是否允许单语句查询返回多结果集（需要数据库支持）</p><h3 id="useColumnLabel"><a href="#useColumnLabel" class="headerlink" title="useColumnLabel"></a>useColumnLabel</h3><p><code>true/false:true</code></p><p>使用列标签代替列名，是解决查询结果映射集的一种方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> userName <span class="keyword">as</span> <span class="keyword">user</span> <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure><p>这样就给 userName 起了一个别名（列标签）user，在进行结果映射的时候，如果开启了 useColumnLabel，那么就用别名 user 去找结果映射填充而不是原名的 userName。<strong>建议一直开着</strong>。</p><h3 id="useGeneratedKeys"><a href="#useGeneratedKeys" class="headerlink" title="useGeneratedKeys"></a>useGeneratedKeys</h3><p><code>true/false:false</code></p><p>在调用 insert 和 update 语句更新数据库的时候，允许 JDBC 自动生成主键，并将主键内容返回给传入参数的 keyProperty 一项。</p><p>也就是传入一个 User 实例后，利用 userName 和 password 插入数据库，数据库生成的主键回赋值给传入参数 id 属性。</p><p>这个在 settings 设置之后，只对接口映射器有效（也就是在 Mapper 接口处使用注解开发），而对 XML 映射器无效。因此如果想要 XML 处实现，则需要到具体的 insert 和 update 语句里面设置：<code>useGeneratedKyes=&quot;true&quot; keyProperty=&quot;id&quot;</code> 打开开关并指定赋值主键的属性。</p><h3 id="autoMappingBehavior"><a href="#autoMappingBehavior" class="headerlink" title="autoMappingBehavior"></a>autoMappingBehavior</h3><p><code>NONE/PARTIAL/FULL:PARTIAL</code></p><p>表示自动结果映射行为的等级，none 表示不自动映射，partial [pɑːrʃl] 局部的，表示只会自动映射没有定义嵌套结果映射的字段，FULL 自动映射任何复杂的结果集，无论是否有嵌套。</p><p>不过一般默认的 PARTIAL 级别就够用了，FULL 就有点不太可控了，对于嵌套映射，还是自己写一个 ResultMap 爽。</p><h3 id="autoMappingUnknowColumnBehavior"><a href="#autoMappingUnknowColumnBehavior" class="headerlink" title="autoMappingUnknowColumnBehavior"></a>autoMappingUnknowColumnBehavior</h3><p><code>NONE/WARNING/FAILING:NONE</code></p><p>表示开启自动映射的时候，遇到未知列或者未知属性的时候，应该怎么做。</p><p>NONE 表示什么都不做，WARNING 表示日志输出 WARN 级别，FAILING 表示抛出 SqlSessionException。</p><h3 id="defaultExecutorType"><a href="#defaultExecutorType" class="headerlink" title="defaultExecutorType"></a>defaultExecutorType</h3><p><code>SIMPLE/REUSE/BATCH:SIMPLE</code></p><p>配置默认的执行器，SIMPLE 为简单执行器，没执行一句 SQL 就创建一个新的 Statement 实例。REUSE 为重复使用执行器，将执行过的 Statement 实例放入 Map 中缓存，方便下次相同 SQL 语句使用。BATCH 为批量执行器，会将多个 SQL 一次性执行。</p><h3 id="defaultStatementTimeout"><a href="#defaultStatementTimeout" class="headerlink" title="defaultStatementTimeout"></a>defaultStatementTimeout</h3><p><code>正整数:null</code></p><p>设置 Mybatis 等待数据库响应的最长时间，默认没有设置，单位秒。</p><h3 id="defaultFetchSize"><a href="#defaultFetchSize" class="headerlink" title="defaultFetchSize"></a>defaultFetchSize</h3><p><code>正整数:null</code></p><p>设置 Mybatis 获取 SQL 结果集的缓冲区大小的建议值，避免因为结果集数据过大，单位为条。</p><h3 id="mapUnderScoreToCamelCase"><a href="#mapUnderScoreToCamelCase" class="headerlink" title="mapUnderScoreToCamelCase"></a>mapUnderScoreToCamelCase</h3><p><code>true/false:false</code></p><p>设置将数据库列里面的下划线命名法和 Java 中的驼峰命名法进行映射匹配。</p><p>……</p><p>其实还有很多很多设置，但是时间和精力关系，就先这样了，等学到后面回把这些补上的。</p><h2 id="typeAliases-别名"><a href="#typeAliases-别名" class="headerlink" title="typeAliases 别名"></a>typeAliases 别名</h2><p>TypeAliases 主要作用就是为我们自己写的 POJO 起别名，这样只要遇到需要写全类名的地方，都可以用别名来代替。需要注意的是，所有的别名都是<strong>不区分大小写</strong>的！！！</p><h3 id="单独指定"><a href="#单独指定" class="headerlink" title="单独指定"></a>单独指定</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;space.xorex.mybatis.POJO.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>单独给某一个类指定<strong>任意</strong>一个名字作为他的别名。</p><hr><p>或者使用注解 <code>@Alias(&quot;name&quot;)</code> 标注在需要别名的 POJO 的申明类上面，也可以起别名。</p><h3 id="整个包执行"><a href="#整个包执行" class="headerlink" title="整个包执行"></a>整个包执行</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;space.xorex.mybatis.POJO&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>会将 <code>space.xorex.mybatis.POJO</code> 下面所有的 POJO 都起一个和<strong>类名相同</strong>不区分大小写的别名。</p><h3 id="MyBatis-内部设置的别名"><a href="#MyBatis-内部设置的别名" class="headerlink" title="MyBatis 内部设置的别名"></a>MyBatis 内部设置的别名</h3><p>MyBatis 给 Java 常见的一些类设置了别名，包含几乎所有的数据类型，不过对于基本类型和包装器类型，因为本来差距就是首字母大小写，所以两者的别名有所不同。基本类型的数据别名<strong>前面多了下划线</strong>。</p><table><thead><tr><th>别名</th><th>映射的类型</th></tr></thead><tbody><tr><td>_byte</td><td>byte</td></tr><tr><td>_long</td><td>long</td></tr><tr><td>_short</td><td>short</td></tr><tr><td>_int</td><td>int</td></tr><tr><td>_integer</td><td>int</td></tr><tr><td>_double</td><td>double</td></tr><tr><td>_float</td><td>float</td></tr><tr><td>_boolean</td><td>boolean</td></tr><tr><td>string</td><td>String</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>integer</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>date</td><td>Date</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr><tr><td>bigdecimal</td><td>BigDecimal</td></tr><tr><td>object</td><td>Object</td></tr><tr><td>map</td><td>Map</td></tr><tr><td>hashmap</td><td>HashMap</td></tr><tr><td>list</td><td>List</td></tr><tr><td>arraylist</td><td>ArrayList</td></tr><tr><td>collection</td><td>Collection</td></tr><tr><td>iterator</td><td>Iterator</td></tr></tbody></table><h2 id="typeHandlers-类型处理器"><a href="#typeHandlers-类型处理器" class="headerlink" title="typeHandlers 类型处理器"></a>typeHandlers 类型处理器</h2><p>类型处理器主要的工作内容就是将 SQL 数据库中的数据类型和 Java 的数据类型做一个转化，MyBatis 本身已经内置了很多类型处理器了，基本足够我们使用，但是如果想要实现自己的 typeHandler 的话，也不是不可以，只需要实现 TypeHandler 接口或者继承 BaseTypeHandler 即可。</p><p>实现完自己 typeHandler 后，需要将其加入 MyBatis 全局配置文件的 <code>&lt;typeHandlers&gt;</code> 里面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;space.xorex.handlers.MyHandler&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="objectFactory-对象工厂"><a href="#objectFactory-对象工厂" class="headerlink" title="objectFactory 对象工厂"></a>objectFactory 对象工厂</h2><p>这个没啥可说的，就是单纯的用来创造一个填充数据库查询来的数据的对象实例。这个选项的意义就是当自己实现了 objectFactory 之后，将自己的实现的工厂替换 MyBatis 自带的工厂。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;space.xorex.mybatis.objectFactorys.MyObjectFactory&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins 插件"></a>plugins 插件</h2><p>插件的作用其实就是一个拦截器，它可以拦截 MyBatis 里面的四大组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executor(update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) <span class="comment">//负责 SQL 语句的执行</span></span><br><span class="line">ParameterHandler(getParameterObject, setParameters) <span class="comment">//负责参数的填充</span></span><br><span class="line">ResultSetHandler(handleResultSets, handleOutputParameters) <span class="comment">//负责查询结果集的映射</span></span><br><span class="line">StatementHandler(prepare, parameterize, batch, update, query) <span class="comment">//负责 SQL 语句的构造</span></span><br></pre></td></tr></table></figure><p>我们只要实现了 Interceptor 接口，就可以在这个拦截器里面对上面类里面的任意执行方法进行拦截，比如执行器 Executor 的更新方法 update()，然后加入一些自定义的东西。最后加入到配置中就生效了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;space.xorex.mybatis.interceptors.MyInterceptors&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="environment-环境"><a href="#environment-环境" class="headerlink" title="environment 环境"></a>environment 环境</h2><p>MyBatis 里面的环境就是数据库相关的配置，在 <code>&lt;environments&gt;</code> 标签里面可以添加多个数据库环境配置，然后在 default 选项里面指明要使用的环境 id 即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;Dep-Env&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;Test-Env&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;Dep-Env&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 transactionManager 标签主要是设置事务管理的级别，其属性 type 有两个选项 <code>JDBC/MANAGED</code> ，JDBC 指的是使用 JDBC 自带的 commit rollback 进心事务管理，而 MANAGED 表示啥都不做。</p><p>当我们单独使用 MyBatis 的时候，可以用 JDBC 来控制事务。而和 Spring 整合之后，所以这条可以不配置（Spring 的事务控制的配置会直接覆盖 MyBatis 的！）</p><p>其次的 dataSource 用来配置数据源，其属性 type 有 <code>UNPOOLED/POOLED/JNDI</code>，UNPOOLED 表示一次访问新建一个连接，POOLED 表示使用连接池来优化连接，JNDI 是在 EJB 服务器上使用的，这个可以先不管。</p><p>然后 dataSource 里面就是设置各种数据源的信息了。</p><hr><p>当我们使用 Spring 进行整合的时候，上面的配置其实都没啥用（也不需要配置），我们将数据源和事务管理都交给 Spring 来完成，MyBatis 做好自己的 CRUD 即可。</p><h2 id="databaseIdProvider-数据库厂商标识"><a href="#databaseIdProvider-数据库厂商标识" class="headerlink" title="databaseIdProvider 数据库厂商标识"></a>databaseIdProvider 数据库厂商标识</h2><p>这个主要是用来设置多数据库连接的时候，一个数据库厂商标识别名的问题，其中属性 type 的值 DB_VENDOR 是固定的，表示通过方法 <code>DatabaseMetaData#getDatabaseProductName()</code> 自动获取当前数据库连接的数据库厂商标识。</p><p>获取标识之后，会在下面 property 标签里面的 name 属性匹配相同的数据库厂商标识，然后给它设置一个别名，为 value 里面的值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;MySQL&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;SQL Server&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlserver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置别名是为了方便，但是要在那里需要这个数据库厂商标识别名呢，答案就是在 Mapper.xml 的 SQL 语句映射文件里面，每一句 SQL 标签都有一个属性 databaseId 里面可以填写数据库厂商标识别名，标识这句 SQL 是在对应数据库上执行的。这样面对不停切换的数据库源，可以轻松的用不同 SQL 语句来应对。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">    select * from users;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;sqlserver&quot;</span>&gt;</span></span><br><span class="line">    select * from users;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="mappers-映射器"><a href="#mappers-映射器" class="headerlink" title="mappers 映射器"></a>mappers 映射器</h2><p>用来找 SQL 的 mapper.xml 映射文件的，分为单个配置和批量配置：</p><h3 id="单个配置"><a href="#单个配置" class="headerlink" title="单个配置"></a>单个配置</h3><p>使用 mapper 标签，resource 是从类路径下面开始找的指定配置文件，class 根据接口全类名在同级目录下找同名配置文件的，url 是从磁盘（格式为本地文件传输协议 <code>file:///</code> ）或者网络上根据路径找的映射文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;space/xorex/mybatis/Mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.mybatis.Mapper.UserMapper&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///D:/MyBatis/src/main/java/space/xorex/mybatis/Mapper/UserMapper.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="批量配置"><a href="#批量配置" class="headerlink" title="批量配置"></a>批量配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;space.xorex.mybatis.Mapper&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 package 标签，设置一个包名，然后会自动在包的同级目录下面找到所有的 xml 映射文件，根据类和 xml 文件名称相同进行匹配。</p><h3 id="优先级问题"><a href="#优先级问题" class="headerlink" title="优先级问题"></a>优先级问题</h3><p>需要注意的是，四者完全冲突，建议一个 mapper 只使用一种方法进行映射。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;properties-属性&quot;&gt;&lt;a href=&quot;#properties-属性&quot; class=&quot;headerlink&quot; title=&quot;properties 属性&quot;&gt;&lt;/a&gt;properties 属性&lt;/h2&gt;&lt;p&gt;这里的 properties 有三种配置方式：&lt;/p</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-01-基础与配置</title>
    <link href="https://xorex.space/2021/07/16/3074f743feb9/"/>
    <id>https://xorex.space/2021/07/16/3074f743feb9/</id>
    <published>2021-07-16T02:56:51.000Z</published>
    <updated>2021-07-16T08:02:23.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MyBatis-概述"><a href="#MyBatis-概述" class="headerlink" title="MyBatis 概述"></a>MyBatis 概述</h2><p>Mybatis 是一种持久层的框架，通过建立接口的方法和 XML 注册的 SQL 语句的映射关系来实现对数据库的操作。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="获取数据库连接之前"><a href="#获取数据库连接之前" class="headerlink" title="获取数据库连接之前"></a>获取数据库连接之前</h3><p>首先获取数据库的连接实例 SqlSession 的连接池 SqlSessionFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory factory; <span class="comment">//连接池</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String resource=<span class="string">&quot;MyBatis-config.xml&quot;</span>; <span class="comment">//连接池的配置文件</span></span><br><span class="line">        InputStream inputstream = Resources.getResourceAsStream(resource); <span class="comment">//将配置文件读入流中</span></span><br><span class="line">        factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputstream); <span class="comment">//按照配置文件建造 SqlSession 连接池</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSession</span><span class="params">()</span> </span>&#123; <span class="comment">//从连接池获取连接</span></span><br><span class="line">        <span class="keyword">return</span> factory.openSession();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取连接池需要在服务器启动的时候进行，所以放到静态代码块里面执行。上面的 <code>SqlSessionFactoryBuilder</code> 作用就是按照配置文件建造连接池，此实例用完就扔，所以不给外部引用，让 GC 把它回收了。留着 <code>SqlSessionFactory</code> 作为单独一个连接池管理 SQL 连接。</p><h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><p>在 <code>MyBatis-config.xml</code> 连接池配置中加入数据库连接环境，其中 <code>&lt;property&gt;</code> 标签中的 value 中依次填入所有的信息即可。</p><p>或者外部引入一个 properties 文件，里面写上数据库连接数据，然后用 <code>$&#123;PropertyName&#125;</code> 的方式引用。</p><p>外部文件 <code>DataBase.properties</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>然后配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;DataBase.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span> <span class="comment">&lt;!--引入外部的文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="建立-DAO-层方法和-SQL-语句的映射"><a href="#建立-DAO-层方法和-SQL-语句的映射" class="headerlink" title="建立 DAO 层方法和 SQL 语句的映射"></a>建立 DAO 层方法和 SQL 语句的映射</h3><p>DAO 层的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUserByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">queryUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">queryUserByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建数据库操作接口映射的 XML 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;space.xorex.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;space.xorex.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意上面的 <code>namespace</code> 是下方的 SQL 语句映射的<strong>执行方法</strong>名称所在的定义空间（就是定义这些方法的接口），接口只能写完整的类名，不可以用别名。然后每一条就是执行方法映射的 SQL 语句。</p><p>对于这些映射标签，比如下面的，就一定要注意对应的接口方法名称的 参数 和 返回值，写对应的信息，而对于常见的数据类型，MyBatis 进行了别名映射，可以<strong>不区分大小写</strong>的使用这些别名。然后就是占位符的填充，使用 <code>#&#123;&#125;</code> 里面写数据名，是从 parameterType 中寻找的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByUserName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;space.xorex.pojo.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--这里 string 就是一个规定好的 java.lang.String 的别名--&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from user</span><br><span class="line">    where userName=#&#123;userName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="获取-Mapper-实例"><a href="#获取-Mapper-实例" class="headerlink" title="获取 Mapper 实例"></a>获取 Mapper 实例</h3><p>直接用 MybatisUtils 里面的 getSession() 获取连接，然后调用 SqlSession 的 getMapper() 获取对应 Mapper 接口的实现对象。都用完之后，SqlSession 需要提交 commit() 和关闭 close()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;</span><br><span class="line">    SqlSession session=MybatisUtils.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserMapper mapper=session.getMapper(UserMapper.class);</span><br><span class="line">        mapper.insertUser(<span class="string">&quot;This&quot;</span>, <span class="string">&quot;That&quot;</span>);</span><br><span class="line">        session.commit(); <span class="comment">//修改完数据库需要提交</span></span><br><span class="line">        session.close(); <span class="comment">//使用完连接记得关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>需要说一下的是，这里获取的 Mapper 接口实现类，其实是一个动态代理类，叫作 MapperProxy，这个动态代理类是 Mybatis 根据配置文件自动生成的。</p><h2 id="参数映射"><a href="#参数映射" class="headerlink" title="参数映射"></a>参数映射</h2><h3 id="多参数在-SQL-中的映射"><a href="#多参数在-SQL-中的映射" class="headerlink" title="多参数在 SQL 中的映射"></a>多参数在 SQL 中的映射</h3><p>这里主要是 SQL 语句中 parameterType 属性和 @Param 注解的解释。</p><p>其中因为 Java 基本上所有的版本都是支持反射获取方法参数类型 （Method 类 getParameterTypes()），所以对于 parameterType 这个属性完全可以不写，Mybatis 完全可以通过反射拿到。</p><p>但是 Mybatis 拿到的仅仅只是方法参数的类型，是拿不到参数名的，编译之后就成了 var1 var2 这样的，所以对于多个参数进行的映射如 <code>public void insertUser(String userName,String password);</code> 这样，只能用一些特殊的技巧填入 SQL 语句中的 #{} 里面：</p><ol><li>使用数字表示参数顺序</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user (username,password) values (#&#123;0&#125;,#&#123;1&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过数字来表示方法中的第 0 个参数，第 1 个参数等等。</p><ol start="2"><li>使用 @Param(“Name”) 来定义参数名</li></ol><p>使用 Mybatis 提供的注解 @Param 来对方法中的参数起一个别名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(<span class="meta">@Param(&quot;userNameVar&quot;)</span> String userName,<span class="meta">@Param(&quot;passwordVar&quot;)</span> String password)</span></span>;</span><br></pre></td></tr></table></figure><p>然后就可以在 SQL 语句中使用我们在 @Param 中定义的别名了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user (username,password) values (#&#123;userNameVar&#125;,#&#123;passwordVar&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MyBatis-概述&quot;&gt;&lt;a href=&quot;#MyBatis-概述&quot; class=&quot;headerlink&quot; title=&quot;MyBatis 概述&quot;&gt;&lt;/a&gt;MyBatis 概述&lt;/h2&gt;&lt;p&gt;Mybatis 是一种持久层的框架，通过建立接口的方法和 XML 注册的 S</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-架构解析</title>
    <link href="https://xorex.space/2021/07/15/39ec926b82d1/"/>
    <id>https://xorex.space/2021/07/15/39ec926b82d1/</id>
    <published>2021-07-15T13:09:31.000Z</published>
    <updated>2021-07-16T07:34:06.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringMVC-工作流程"><a href="#SpringMVC-工作流程" class="headerlink" title="SpringMVC 工作流程"></a>SpringMVC 工作流程</h2><iframe src="https://www.xmind.net/embed/969fGv" width="800px" height="540px" frameborder="0" scrolling="no"></iframe><h2 id="流程图补充说明"><a href="#流程图补充说明" class="headerlink" title="流程图补充说明"></a>流程图补充说明</h2><p>待更新…</p><h2 id="DispatcherServlet-九大组件"><a href="#DispatcherServlet-九大组件" class="headerlink" title="DispatcherServlet 九大组件"></a>DispatcherServlet 九大组件</h2><h3 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h3><p>多媒体解析器，一般用来实现上传下载的功能</p><h3 id="LocaleResolver"><a href="#LocaleResolver" class="headerlink" title="LocaleResolver"></a>LocaleResolver</h3><p>国际化解析器，自动从请求头中的地区和语言信息解析并获取 Locale 对象，并设置到响应内容中，来实现国际化。</p><h3 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h3><p>主题解析器，主题是样式、图片及它们所形成的显示效果的集合。一套主题对应一个 properties文件，里面存放着与当前主题相关的所有资源。</p><h3 id="List-lt-HandlerMapping-gt"><a href="#List-lt-HandlerMapping-gt" class="headerlink" title="List&lt;HandlerMapping&gt;"></a>List&lt;HandlerMapping&gt;</h3><p>请求映射处理的集合，作用是判断请求和对应的处理器之间的映射关系，确保请求能找到对应的处理器。</p><h3 id="List-lt-HandlerAdapter-gt"><a href="#List-lt-HandlerAdapter-gt" class="headerlink" title="List&lt;HandlerAdapter&gt;"></a>List&lt;HandlerAdapter&gt;</h3><p>处理器适配器集合，因为在 SpringMVC 中 Handler 可以是任意形式的，比如 @RequestMapping 的方法，实现 Controller 接口的类，为了将这些 Handler 统一规格给 SpringMVC 使用，就需要能转化这些 Handler 的 Adapter。</p><h3 id="List-lt-HandlerExceptionResolver-gt"><a href="#List-lt-HandlerExceptionResolver-gt" class="headerlink" title="List&lt;HandlerExceptionResolver&gt;"></a>List&lt;HandlerExceptionResolver&gt;</h3><p>异常处理解析器集合，判断是否能处理所抛出来的异常，转化为目标的 ModelAndView，如果不能处理，则会将异常抛给 Tomcat。</p><h3 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h3><p>请求名到视图名翻译器，当我们自己写的 Handler 没有定义 viewName 的时候，就会调用它，将请求的目标截取，作为 viewName，供 ViewResolver 进行解析。</p><h3 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h3><p>重定向参数传递，当我们将 Post 请求进行重定向为 Get 请求的时候（防止重复提交），为了将 Post 数据体现在 Get 请求页面中，用 FlashMapManager 实现重定向参数传递。  </p><h3 id="List-lt-ViewResolver-gt"><a href="#List-lt-ViewResolver-gt" class="headerlink" title="List&lt;ViewResolver&gt;"></a>List&lt;ViewResolver&gt;</h3><p>视图解析器集合，用来通过视图名解析成视图 View 的解析器，从而进行渲染页面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SpringMVC-工作流程&quot;&gt;&lt;a href=&quot;#SpringMVC-工作流程&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC 工作流程&quot;&gt;&lt;/a&gt;SpringMVC 工作流程&lt;/h2&gt;&lt;iframe src=&quot;https://www.</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常阅读</title>
    <link href="https://xorex.space/2021/07/06/cb7f2bf06a64/"/>
    <id>https://xorex.space/2021/07/06/cb7f2bf06a64/</id>
    <published>2021-07-06T03:22:24.000Z</published>
    <updated>2021-07-06T05:51:44.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常信息解读"><a href="#异常信息解读" class="headerlink" title="异常信息解读"></a>异常信息解读</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;level 1 exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fun1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;level 2 exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Test().fun2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: level 2 exception</span><br><span class="line">    at space.xorex.SSM_CRUD.DAO.Test.fun2(Test.java:15)</span><br><span class="line">    at space.xorex.SSM_CRUD.DAO.Test.main(Test.java:21)</span><br><span class="line">Caused by: java.io.IOException: level 1 exception</span><br><span class="line">    at space.xorex.SSM_CRUD.DAO.Test.fun1(Test.java:8)</span><br><span class="line">    at space.xorex.SSM_CRUD.DAO.Test.fun2(Test.java:13)</span><br><span class="line">    ... 1 more</span><br></pre></td></tr></table></figure><p>对于整个异常栈来说，最下面的 Caused by 就是异常最初被抛出来的类型和原因。然后依次向上的 Caused by 就是上一个异常被捕获之后，catch 语句里面抛出来的其他的异常。每一个 Caused by 都是捕获下一层抛出的异常，经过分析后被抛出的新异常。而没有 Caused by 修饰的最顶层异常，就是没有被任何程序捕捉处理的异常。</p><p>异常栈里每一层都有这些信息组成：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Caused by] 异常名 自定义异常出现原因 </span><br><span class="line">异常在被捕获之前经过的第一个方法</span><br><span class="line">异常在被捕获之前经过的第二个方法</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>需要注意的是，异常中会有 <code>XXX more</code> 的语句，这是指没有被打印出来的方法对异常的抛接过程，是不重要的信息，可以不用管。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;异常信息解读&quot;&gt;&lt;a href=&quot;#异常信息解读&quot; class=&quot;headerlink&quot; title=&quot;异常信息解读&quot;&gt;&lt;/a&gt;异常信息解读&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="异常" scheme="https://xorex.space/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>SSM_CRUD 搭建架构（一）</title>
    <link href="https://xorex.space/2021/07/03/f4ad326f7d77/"/>
    <id>https://xorex.space/2021/07/03/f4ad326f7d77/</id>
    <published>2021-07-03T02:26:45.000Z</published>
    <updated>2021-07-16T07:34:04.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>等完全搭建好了再更新。</p><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>一个基于 SSM 整合的 CRUD，并使用 Mybatis-Generator 自动生成数据库代码。bootstrap 和 jQuery 作为前端框架。</p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><ol><li><p>三大框架的核心包 Spring-Core Spring-WebMVC Mybatis</p></li><li><p>用于自动分页的 Pagehelper ，生成代码的 Mybatis-Generator-Core</p></li><li><p>数据库原生的 Mysql-Connector-Java 数据库连接池 c3p0</p></li><li><p>实现 jsp 中 JSTL 标签语言的 JSTL 库</p></li></ol><h2 id="Spring-和-SpringMVC-配置"><a href="#Spring-和-SpringMVC-配置" class="headerlink" title="Spring 和 SpringMVC 配置"></a>Spring 和 SpringMVC 配置</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>在 Web.xml 中配置一启动服务器就创建 Spring 容器的 Listener 和指定 Spring 配置文件位置的 context-param 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>contextLoaderListener 监听启动后执行内容：</p><blockquote><p>Initialize Spring’s web application context for the given servlet context, using the application context provided at construction time, or creating a new one according to the “contextClass” and “contextConfigLocation” context-params.</p></blockquote><h3 id="配置杂七杂八"><a href="#配置杂七杂八" class="headerlink" title="配置杂七杂八"></a>配置杂七杂八</h3><ol><li>Filter 字符编码 CharacterEncodingFilter 设置初始参数，encoding=utf-8，forceRequestEncoding 和 forceResponseEncoding 都设置为 true 。拦截路径为全路径 <code>/*</code> 。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--字符编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Filter REST 风格，HiddenHttpMethodFilter，拦截路径为全路径 <code>/*</code> 。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--REST风格实现过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="关于两个容器分工问题"><a href="#关于两个容器分工问题" class="headerlink" title="关于两个容器分工问题"></a>关于两个容器分工问题</h3><p>Spring 的容器是一个父容器，SpringMVC 的容器是子容器。<strong>子容器可以访问父容器</strong>，<strong>而父容器不能访问子容器</strong>。</p><p>所以这就决定了用于自动注入的对象必须放入 Spring 容器中（放入到 SpringMVC 容器 Spring 访问不到），而又因为 Spring 并没有区分四大组件： @Controller @Service @Component @Repository 的功能，所以虽然 SpringMVC 可以访问到 Spring 的容器，但是却无法找到 Controller 的实例。</p><p>总之就是 Controller 必须放到 SpringMVC 的容器中，其他的组件可以随意放置两个容器中。</p><p>但是一般来说我们会把其他的组件都放到 Spring 的容器中，因为 Spring 可以轻易和其他框架进行整合。</p><h2 id="整合-Mybatis"><a href="#整合-Mybatis" class="headerlink" title="整合 Mybatis"></a>整合 Mybatis</h2><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>整合 Mybatis 的核心就是将 SqlSessionFactory 以及 Mybatis 自动生成的 DAO 接口实现实例交给 IOC 容器进行管理。Mybatis 有和 Spring 的整合包： Mybatis-Spring.jar。</p><p>Spring 中配置实现了 BeanFactory 接口的 SqlSessionFactoryBean 实例加入 IOC 容器中，负责获取 SqlSessionFactory。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--实现了BeanFactory，调用getBean() 返回 sqlSessionFactory 用于获取连接--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:Mybatis-config.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;pooledDataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:space.xorex.SSM_CRUD.DAO*&quot;</span> /&gt;</span> <span class="comment">&lt;!--将Mapper和映射文件放到同级目录下面--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DAO-接口实现"><a href="#DAO-接口实现" class="headerlink" title="DAO 接口实现"></a>DAO 接口实现</h3><p>MapperScannerConfigurer 扫描 DAO 中规定的接口，并加入 IOC 容器中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将Mybatis生成的DAO接口实现类加入 IOC 容器中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperScannerConfigurer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描所有 DAO 接口的实现--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;space.xorex.SSM_CRUD.DAO&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h3><h4 id="基于命名空间"><a href="#基于命名空间" class="headerlink" title="基于命名空间"></a>基于命名空间</h4><p>这里使用 Spring 的 tx 包和 aop 功能实现事务的控制，</p><p>首先使用 tx 注解进行配置确定对于被标注使用 AOP 功能的方法中，哪些是需要进行事务管理的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 选择控制事务的方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 搞个 get 优化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后就是配置 AOP 的切入点表达式，声明哪些包下面的哪些类的哪些方法需要进行 AOP 管理，其实就是 DAO 包下面所有接口的所有方法，同时将事务管理配置的 AOP 配置进行一个整合。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPoint&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(public * space.xorex.SSM_CRUD..*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务增强，也就是将 AOP 和 TX 所选择的方法进行一个整合--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPoint&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h4><p>直接无脑标注 @Trancational 即可。</p><p>然后在 Spring 中进行扫描。</p><h2 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h2><p>数据库方面原本是想要使用 Mybatis Generator 进行实现的，但是出现了不知道为什么的错误，所以决定自己写代码：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本流程&quot;&gt;&lt;a href=&quot;#基本流程&quot; class=&quot;headerlink&quot; title=&quot;基本流程&quot;&gt;&lt;/a&gt;基本流程&lt;/h2&gt;&lt;p&gt;等完全搭建好了再更新。&lt;/p&gt;
&lt;h2 id=&quot;实现目标&quot;&gt;&lt;a href=&quot;#实现目标&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="项目记录" scheme="https://xorex.space/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="SSM" scheme="https://xorex.space/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-07-拦截器/异常处理</title>
    <link href="https://xorex.space/2021/06/16/0372728335e9/"/>
    <id>https://xorex.space/2021/06/16/0372728335e9/</id>
    <published>2021-06-16T13:14:45.000Z</published>
    <updated>2021-07-15T15:45:01.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>加强版本的 Filter，MVC 中的接口为 HandlerInterceptor 处理拦截器，一共有三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">()</span></span>; <span class="comment">//执行请求处理方法之前执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">()</span></span>; <span class="comment">//执行请求处理方法之后执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">()</span></span>; <span class="comment">//视图渲染完成之后执行</span></span><br></pre></td></tr></table></figure><p>自己实现 HandlerInterceptor 之后，需要在 SpringMVC 中配置拦截器的信息才可以使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/Interceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.SpringMVC_01.Interceptor.MyInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多重拦截器"><a href="#多重拦截器" class="headerlink" title="多重拦截器"></a>多重拦截器</h3><p>当有多个拦截器匹配到某个方法的时候，整体拦截器的工作顺序是按照在 SpringMVC 配置的顺序执行的。</p><p>而对于 preHandle() 和 postHandle() 则是按照一层一层套娃执行的，拦截器执行顺序靠前的在最外层，拦截器配置 01 在 02 前面：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">01 preHandle() is invoked!</span><br><span class="line">02 preHandle() is invoked!</span><br><span class="line">testInterceptor() is invoked!</span><br><span class="line">02 postHandle() is invoked!</span><br><span class="line">01 postHandle() is invoked!</span><br><span class="line">02 afterCompletion() is invoked!</span><br><span class="line">01 afterCompletion() is invoked!</span><br></pre></td></tr></table></figure><p>而 afterCompletion() 作为最后执行的擦屁股方法，和 try-catch-finally 里面的 finally 代码块类似，等待前面的套娃执行完毕，再单独按照顺序套娃从内到外执行最后的处理。可以记忆为，prehandle 顺序执行，postHandle() 和 afterCompletion() 逆序执行。</p><h3 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h3><p>对于配置了一个拦截器的执行方法被 preHandler() return 了 false，那么后面的请求处理方法、postHandle() 和 afterCompletion() 都停止执行。</p><p>如果多个拦截器的执行方法被某一个 preHandler() return 了 false，那么这个 preHandler() 所在的截断了的拦截器的<strong>后面拦截器的</strong>所有方法（preHandler()、postHandle() 和 afterCompletion()）都不会再执行。而<strong>前面所有放行了的拦截器</strong>的 afterCompletion() 方法作为拦截器的结尾处理还是会被执行的！</p><p>举个例子，01、02 和 03 三个拦截器，02 的 preHandler() return false，进行截断，那么方法的执行结果为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01 preHandle() is invoked!</span><br><span class="line">02 preHandle() is invoked!</span><br><span class="line">01 afterCompletion() is invoked! //因为 01 的 preHandle() 放行了，所以需要执行收尾方法、</span><br></pre></td></tr></table></figure><p>所以如果一旦被拦截，整个请求就不会被处理了，也不会有有效的响应。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p>SpringMVC 的异常处理是通过 <code>List&lt;HandlerExceptionResolver&gt;</code> 来解决的，如果在调用请求处理方法的时候抛出了异常，那么会依次枚举实现了 HandlerExceptionResolver 接口的类，如果抛出来的这些异常能被这些异常处理解析器解决，那么就交给他们，如果不能解决，那么会直接抛出异常到 Tomcat，最终在页面上显示一个丑丑的 500 服务器内部错误的页面。</p><p>在 SpringMVC 中，有三个默认加载的 HandlerExceptionResolver 实现：ExceptionHandlerExceptionResolver、ResponseStatusExceptionResolver 和 DefaultHandlerExceptionResolver。</p><ol><li>ExceptionHandlerExceptionResolver</li></ol><p>第一个处理类可以处理的异常为所有使用了注解 <code>@ExcpetionHandler(Class)</code> 中参数输入的异常。也是我们用来自定义异常处理的方式，详情看下面介绍。</p><ol start="2"><li>ResponseStatusExceptionResolver</li></ol><p>用于设置当我们出现了自定义异常的时候，应该返回什么状态码和错误信息，而使用核心就是注解 <code>@ResponseStatus</code>：</p><p>我们首先自定义一个异常，并使用注解 <code>@ResponseStatus</code> 来定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus(value = HttpStatus.NOT_ACCEPTABLE,reason = &quot;拒绝访问！&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanNotAccsessException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/exception&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CanNotAccsessException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后当我们抛出我们自定义的异常 CanNotAccessException 无法被 ExceptionHandlerExceptionResolver 里面的异常处理方法处理之后，就会交给 ResponseStatusExceptionResolver ，发现异常拥有注解 <code>@ResponseStatus</code> 之后，会读取注解信息，然后返回一个自定义的错误页面， 406 拒绝访问。</p><p><img src="https://xorex.space/image/306.jpg" alt="306.jpg"></p><ol start="3"><li>DefaulthandlerExceptionResolver</li></ol><p>是用来处理和 SpringMVC 相关的异常，我们可以忽略它，比如这些异常：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">handleNoSuchRequestHandlingMethod</span><br><span class="line">handleHttpRequestMethodNotSupported</span><br><span class="line">handleHttpMediaTypeNotSupported</span><br><span class="line">handleMissingServletRequestParameter</span><br><span class="line">handleServletRequestBindingException</span><br><span class="line">handleTypeMismatch</span><br><span class="line">handleHttpMessageNotReadable</span><br><span class="line">handleHttpMessageNotWritable</span><br><span class="line">handleMethodArgumentNotValidException</span><br><span class="line">handleMissingServletRequestParameter</span><br><span class="line">handleMissingServletRequestPartException</span><br><span class="line">handleBindException</span><br></pre></td></tr></table></figure><h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><p>只需要在某个方法前面加上 <code>@ExceptionHandler</code> 这个注解，就可以让这个方法变为异常处理器。处理的异常取决于注解里面的参数填写的异常种类。可以自己在异常处理器中返回 ModelAndView 来自定义视图，不写也没关系。获取异常实例通过异常处理器的参数处获取，参数类型一定要匹配被 catch 异常的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/exception&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CanNotAccsessException(); <span class="comment">//抛出异常供下面处理器处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler(CanNotAccsessException.class)</span> <span class="comment">//指明这个方法是处理 CanNotAccessException 异常的处理器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">mathException</span><span class="params">(Exception exception)</span> </span>&#123; <span class="comment">//获取被抛出来的实例</span></span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;Hello/error&quot;</span>);</span><br><span class="line">    mv.addObject(<span class="string">&quot;error&quot;</span>, exception);</span><br><span class="line">    <span class="keyword">return</span> mv; <span class="comment">//当然如果不想跳转页面的话也可以不返回 ModelAndView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h3><p>可以将多个 ExceptionHandler 异常处理器方法集中到一个类中去，然后使用注解 <code>@ControllerAdvice</code> 告诉 SpringMVC 这个类里面的东西都是控制层的建议方法。这个属于全局的异常处理器，而上面在 <code>@Controller</code> 里面定义的处理器则是局部处理器，只能处理本类里面抛出的异常。</p><p>当 <code>@Controller</code> 和 <code>@ControllerAdvice</code> 都拥有能处理异常的方法的时候，本类处理器优先级高于全局处理器。而对于两个在同一个地方的异常处理器，则是优先选择匹配精度最高的那一个。</p><h3 id="SimpleMappingExceptionHandlerResovler"><a href="#SimpleMappingExceptionHandlerResovler" class="headerlink" title="SimpleMappingExceptionHandlerResovler"></a>SimpleMappingExceptionHandlerResovler</h3><p>这个异常处理解析器是通过配置的方式来对某些异常进行指定页面处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span> <span class="comment">&lt;!--设置捕捉异常之后前往的页面--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.NullPointerException&quot;</span>&gt;</span>Hello/error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> <span class="comment">&lt;!-- 设置将异常实例放入请求域的 Key --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;exception&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;拦截器&quot;&gt;&lt;a href=&quot;#拦截器&quot; class=&quot;headerlink&quot; title=&quot;拦截器&quot;&gt;&lt;/a&gt;拦截器&lt;/h2&gt;&lt;h3 id=&quot;基础使用&quot;&gt;&lt;a href=&quot;#基础使用&quot; class=&quot;headerlink&quot; title=&quot;基础使用&quot;&gt;&lt;/a&gt;基础使</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-06-AJAX支持/文件上传</title>
    <link href="https://xorex.space/2021/06/15/de23fc4f3bd1/"/>
    <id>https://xorex.space/2021/06/15/de23fc4f3bd1/</id>
    <published>2021-06-15T14:46:38.000Z</published>
    <updated>2021-06-18T05:36:50.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="响应-AJAX-的-Json-类型"><a href="#响应-AJAX-的-Json-类型" class="headerlink" title="响应 AJAX 的 Json 类型"></a>响应 AJAX 的 Json 类型</h2><h3 id="设置响应内容"><a href="#设置响应内容" class="headerlink" title="设置响应内容"></a>设置响应内容</h3><p>只需要在请求处理方法前面加上 <code>@ResponseBody</code> 表示将方法返回值添加到响应体中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ajax&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAjax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;AJAX!&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会在响应体里面看到一串 JS 代码了。</p><h3 id="Json-处理"><a href="#Json-处理" class="headerlink" title="Json 处理"></a>Json 处理</h3><p>SpringMVC 支持自动将对象转化为 Json 格式的字符串，需要导入三个包：<code>jackson-core</code>，<code>jackson-annotations</code>，<code>jackson-databind</code>。然后对于将自定义对象返回的方法，会自动转化为 Json 字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ajax/get&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title">returnAjax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> employeeDao.getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法返回的值是一个 <code>Collection&lt;Employee&gt;</code> 对象，但是标注了 <code>@ResponseBody</code> 之后，这个对象会经过转换器转化为 Json 格式（因为我们引入的 <code>jackson-core</code> 里面的 Json 转化器被添加到了转化器列表里面）</p><p>还可以使用一些其他关于 Json 的注解来控制转化的过程，如 <code>@JsonIgnore</code> 用于标注被省略转化的字段，使用 <code>JsonFormat(pattern=&quot;XXXX&quot;)</code> 来规定向 Date Time 这样的字段的转化格式等等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"><span class="meta">@JsonIgnore</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure><p>然后响应体里面返回的转化 Json 就是按照我们的要求的了，没有 password，时间按照 yyyy-MM-dd 格式： <code>&#123;&quot;userName&quot;:&quot;Tempest&quot;,&quot;email&quot;:&quot;cloudloverain@Foxmail.com&quot;,&quot;date&quot;:&quot;2021-06-16&quot;&#125;</code></p><h3 id="获取请求内容"><a href="#获取请求内容" class="headerlink" title="获取请求内容"></a>获取请求内容</h3><p>只需要在请求处理方法的参数前面加上 <code>@RequestBody</code> 表示将请求中的请求体放入参数中，比如我们设置一个 userName 的 Post 提交，按照 SpringMVC 参数填充规则，是无法填充到 <code>String body</code> 上面的，没有设置注解，参数名也不匹配，但是我们标注 <code>@RequestBody</code> 之后，整个 Post 的请求体会作为一个 String 字符串填充到 body 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;ajax/post&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAjax</span><span class="params">(<span class="meta">@RequestBody</span> String body)</span> </span>&#123;</span><br><span class="line">    System.out.println(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果，为 Post 所有内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tempest=Xorex&amp;Submit=Submit</span><br></pre></td></tr></table></figure><hr><p>而 <code>@RequestBody</code> 也支持自动转化格式的功能，比如将请求体中的 Json 数据转化为对象：</p><p>请求体：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;userName&quot;</span>:<span class="string">&quot;Tempest&quot;</span>,<span class="attr">&quot;password&quot;</span>:<span class="string">&quot;Xorex&quot;</span>,<span class="attr">&quot;email&quot;</span>:<span class="string">&quot;cloudloverain@Foxmail.com&quot;</span>,<span class="attr">&quot;date&quot;</span>:<span class="string">&quot;2021-06-16&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>接收请求的处理方法，将 Json 自动转化为 User 对象并传入参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;ajax/post&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAjax</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Body-数据转化原理"><a href="#Body-数据转化原理" class="headerlink" title="Body 数据转化原理"></a>Body 数据转化原理</h2><h3 id="HttpMessageConverter-lt-T-gt"><a href="#HttpMessageConverter-lt-T-gt" class="headerlink" title="HttpMessageConverter&lt;T&gt;"></a>HttpMessageConverter&lt;T&gt;</h3><p>对于请求 Body 和响应 Body 和 Java 对象的数据转化流程如下：</p><p><img src="https://xorex.space/image/302.jpg" alt="302.jpg"></p><p>对于任意一个涉及到 Body 数据转换的请求或者响应，SpringMVC 会遍历自己拥有的所有 <code>HttpMessageConverter&lt;T&gt;</code>，去一一确认是否能处理此转换，默认实现了的转换器如下：</p><p><img src="https://xorex.space/image/303.jpg" alt="303.jpg"></p><h3 id="使用-HttpEntity-lt-T-gt-代替-RequestBody"><a href="#使用-HttpEntity-lt-T-gt-代替-RequestBody" class="headerlink" title="使用 HttpEntity&lt;T&gt; 代替 @RequestBody"></a>使用 HttpEntity&lt;T&gt; 代替 @RequestBody</h3><p>将这个类作为请求参数，泛型 T 写为 RequestBody 需要被转化的类型（会依次寻找能处理 T 的Converter）。然后调用 <code>getBody()</code> 、<code>getHeaders()</code> 等来获取更加完整的请求信息（请求头）;</p><h3 id="使用-ResponseEntity-lt-T-gt-代替-ResponseBody"><a href="#使用-ResponseEntity-lt-T-gt-代替-ResponseBody" class="headerlink" title="使用 ResponseEntity&lt;T&gt; 代替 @ResponseBody"></a>使用 ResponseEntity&lt;T&gt; 代替 @ResponseBody</h3><p>只需要将这个这个类作为请求处理方法的返回类型，泛型 T 为向响应体写入的数据类型，也就是 Object-&gt;String 转化的 Object 类型。</p><p>比如下面设置请求头（setcookie），设置请求体（User 用 Json 格式转 String），设置响应码（200 OK）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/Entity&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">getEntity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;cloudloverain@foxmail.com&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    MultiValueMap&lt;String,String&gt; headers=<span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    headers.set(HttpHeaders.SET_COOKIE, <span class="string">&quot;Temespt=Xorex&quot;</span>);</span><br><span class="line">    HttpStatus status=HttpStatus.OK;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(user, headers, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>对于多媒体文件的处理在 SpringMVC 中使用的是 MultipartResolver 这个组件来解决的，当我们需要处理文件上传的时候，就需要给这个组件设置一个实现类去处理。</p><p>从 MultipartResolver 的创建过程可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.multipartResolver = (MultipartResolver)context.getBean(<span class="string">&quot;multipartResolver&quot;</span>, MultipartResolver.class);</span><br></pre></td></tr></table></figure><p>我们只需要在 ioc 容器中注册一个 id 为 multipartResolver 的 Bean 即可，这里使用的是：<code>CommonsMultipartResolver</code> 这个实现类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;1024*1024*100&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置最大上传文件大小为100MB--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="单文件接收"><a href="#单文件接收" class="headerlink" title="单文件接收"></a>单文件接收</h3><p>然后使用 <code>MultipartFile</code> 类作为参数来接受请求发过来的文件，需要注意的是 <code>getName()</code> 指的是文件上传的 key 值 file，而 <code>getOriginalFileName()</code> 指的是文件本身的名字 <code>XXX.jpg</code>，使用它自带的 <code>transferTo(File)</code> 方法将上传来的文件转移到指定的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEntity</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    file.transferTo(<span class="keyword">new</span> File(<span class="string">&quot;D:\\Pictures\\Saved Pictures\\Tempest.jpg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>注意需要将文件上传的表单里面添加一项 <code>enctype=&quot;multipart/form-data&quot;</code>，其不对字符编码。当使用有文件上传控件的表单时，该值是必需的。</p><p>如果不加编码规则，那么上传的就是 <code>file=fileName</code>，并不包含多媒体数据（上传文件本身），惨痛结果：</p><p><img src="https://xorex.space/image/304.jpg" alt="304.jpg"></p><p>加了之后（没找到请求体 QAQ）：</p><p><img src="https://xorex.space/image/305.jpg" alt="305.jpg"></p><h3 id="多文件接收"><a href="#多文件接收" class="headerlink" title="多文件接收"></a>多文件接收</h3><p>这里的多文件指的是一个 name 对应多个文件的情景，这个时候只需要使用 <code>MultipartFile[]</code> 来接收文件即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEntity</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file,<span class="meta">@RequestParam(&quot;files&quot;)</span> MultipartFile[] files)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(file.getOriginalFilename());</span><br><span class="line">    <span class="keyword">for</span> (MultipartFile multipartFile : files) &#123;</span><br><span class="line">        System.out.println(multipartFile.getOriginalFilename());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;响应-AJAX-的-Json-类型&quot;&gt;&lt;a href=&quot;#响应-AJAX-的-Json-类型&quot; class=&quot;headerlink&quot; title=&quot;响应 AJAX 的 Json 类型&quot;&gt;&lt;/a&gt;响应 AJAX 的 Json 类型&lt;/h2&gt;&lt;h3 id=&quot;设置响应内</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-05-数据绑定/转化/校验</title>
    <link href="https://xorex.space/2021/06/11/4130a9517564/"/>
    <id>https://xorex.space/2021/06/11/4130a9517564/</id>
    <published>2021-06-11T06:16:40.000Z</published>
    <updated>2021-06-15T14:48:05.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="静动态资源处理管理"><a href="#静动态资源处理管理" class="headerlink" title="静动态资源处理管理"></a>静动态资源处理管理</h2><p>我们最初在配置 <code>DispatcherServlet</code> 来作为处理方法映射的时候，因为静态资源无法找到对应的处理方法，所以无法访问，针对这个问题，使用 <code>&lt;mvc:default-servlet-handler/&gt;</code> 之后，SpringMVC 将在容器中中定义一个 SimpleUrlhandlerMapping，它的作用就是将请求交给 WEB 应用服务器默认的 Tomcat 处理，这样静态资源的访问就得到了解决。</p><p>但是我们标注了 <code>&lt;mvc:default-servlet-handler/&gt;</code> 之后，会覆盖 SimpleUrlHandlerMapping 为我们处理方法映射的 DefaultAnnotationHandlerMapping。这样处理动态资源访问的映射关系就没有了，因此动态资源无法访问。</p><p>解决方法就是：使用 <code>&lt;mvc:annotation-driven/&gt;</code>，添加这个设置之后，就会多出来一个优先级最高的 RequestMappingHandlerMapping，专门处理动态资源访问和处理方法之间的映射关系。只有这个 Mapping 无法处理的资源（静态资源），才会交给后面的 SimpleUrlHandlerMapping 处理（交给 Tomcat）。</p><h2 id="lt-mcv-anntation-driven-gt"><a href="#lt-mcv-anntation-driven-gt" class="headerlink" title="&lt;mcv:anntation-driven&gt;"></a>&lt;mcv:anntation-driven&gt;</h2><p>这个配置的字面意思就是 MVC 注解驱动。那么这个配置有什么用呢？</p><ul><li><p><code>&lt;mvc:annotation-driven/&gt;</code> 会自动注册： RequestMappingHandlerMapping 、 RequestMappingHandlerAdapter 与 ExceptionHandlerExceptionResolver 三个 bean。</p></li><li><p>还将提供以下支持：</p></li></ul><ol><li>支持使用 ConversionService 实例对表单参数进行类型转换</li><li>支持使用 @NumberFormat、@DateTimeFormat 注解完成数据类型的格式化</li><li>支持使用 @Valid 注解对 JavaBean 实例进行 JSR 303 验证</li><li>支持使用 @RequestBody 和 @ResponseBody 注解实现 AJAX</li></ol><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>数据绑定指的是从请求的数据到处理方法中的参数这个过程，在 SpringMVC 中，数据绑定的流程大概如下：</p><ol><li>SpringMVC 主框架将 ServletRequest 对象及目标方法的入参实例传递给 WebDataBinderFactory 实例，以创建 DataBinder 实例对象</li><li>DataBinder 调用装配在 SpringMVC 上下文中的 ConversionService 组件进行数据类型转换、数据格式化工作。将 Servlet 中的请求信息填充到入参对象中</li><li>调用 Validator 组件对已经绑定了请求消息的入参对象进行数据合法性校验，并最终生成数据绑定结果 BindingData 对象</li><li>SpringMVC 抽取 BindingResult 中的入参对象和校验错误对象，将它们赋给处理方法的参数。</li></ol><p>也就是过程如下：</p><p><img src="https://xorex.space/image/301.jpg" alt="301.jpg"></p><p>在 SpringMVC 的 ConversionService 数据转化服务中，有大量的转化器 Converter 可以作为用于将 String 类型的数据转化为 Java 常间的类型，但是对于我们自己设置的类型，如果需要转化则需要我们手动实现 Converter 接口。</p><p>比如我们想要将 String 类型转化为 User 类型；<code>&quot;Xorex-Tempest-Xorex@Tempest.com&quot;</code> -&gt; <code>User&#123;username=Xorex,password=Tempest,email=Xorex@Tempest.com&#125;</code> 需要这样实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToUserConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] datas=s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(datas[<span class="number">0</span>],datas[<span class="number">1</span>],datas[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了 Converter 之后，需要将我们自己实现的 Converter 放入执行转化服务的 ConversionService 中。而麻烦之处在于 ConversionService 是由 ConversionServiceFactoryBean 生成的，那么我们最终其实是将 Converter 交给 FormattingConversionServiceFactoryBean，由这个工厂来生成含有自定义 Converter 的 ConversionService。</p><p>所以我们需要 SpringMVC 配置文件中，声明：将自定义 Converter 交给 FormattingConversionServiceFactoryBean 并告诉 SpringMVC 用这个含有我们自定义 Converter 的 FactoryBean 来生成 ConversionService:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.SpringMVC_01.Conversion.StringToUserConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数据格式化"><a href="#数据格式化" class="headerlink" title="数据格式化"></a>数据格式化</h2><p>前面介绍了通过实现 Converter 来实现自定义数据和请求数据的绑定。下面来介绍一下请求数据的格式化，也就是将请求发过来的数据转化为格式化的数据，比如将 <code>2021-06-01</code> 转化为 Date 对象。将 <code>$12,123,234.3242</code> 转化为 Double 对象等等。</p><p>这里使用的 Format 注解：<code>@DateTimeFormat</code> 和 <code>@NumberFormat</code> 等，只需要标注到需要接收格式化的参数或者字段前面，被 SpringMVC 自动填充的时候，就会根据 ConversionService 里面定义的 Format 规则进行格式化了。</p><p>而我们上面配置的 FormattingConversionServiceFactoryBean 这个工厂生成的 ConversionService 就包含一系列 Format 类型的 Class 用于数据格式化，而不同的注解也有不同的格式化方法，需要在注解参数 <code>pattern</code> 中填写。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/date&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDate</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date)</span> </span>&#123;</span><br><span class="line">    System.out.println(date);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/number&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNumber</span><span class="params">(<span class="meta">@NumberFormat(pattern = &quot;$#,###.##&quot;)</span> Double money)</span> </span>&#123;</span><br><span class="line">    System.out.println(money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间用 <code>yyyy-MM-dd</code> 规定传入的时间字符串格式，浮点数用 <code>$#,###.##</code> 规定传入的金钱的格式，对于 JavaBean 里面的数据使用格式化，则直接在 Bean 里面的字段加上注解即可，SpringMVC 进行参数填充的时候会读取上面的注解的。</p><h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><h3 id="JSR-303"><a href="#JSR-303" class="headerlink" title="JSR-303"></a>JSR-303</h3><p>对于数据在服务端进行的数据校验工作，我们自己写真的是太麻烦了，于是在 JAVA6 里面推出了一种规范：JSR-303，JSR 是 Java Specification Requests 的缩写，意思是 Java 规范提案，又叫做 Bean Validation。JSR 303 是 Java 为 bean 数据合法性校验提供的标准框架。</p><p>对于 JSR-303 的基本内容，Spring 本身就实现了，只需要 MVC 设置里面添加 Spring 的本地 validator 到 IOC 容器中并告诉注解驱动器用指定搞得 validator 去处理 JSR-303 的注解。validator 实现来源则是 LocalValidatorFactoryBean 生成的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;localValidatorFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> <span class="comment">&lt;!--IOC 中注册 validator 来源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">validator</span>=<span class="string">&quot;localValidatorFactoryBean&quot;</span>/&gt;</span>  <span class="comment">&lt;!--告诉注解驱动用哪个 validator 处理 JSR-303 驱动--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JavaBean-校验"><a href="#JavaBean-校验" class="headerlink" title="JavaBean 校验"></a>JavaBean 校验</h3><p>然后我们就可以利用 JSR-303 定义的注解，去去进行数据校验了，这里的所有注解可以查看文档。对于自定义 Bean ，在 Bean 的声明处向内部标校验注解，然后参数处标注 <code>@Valid</code> 表示需要要校验这个 Bean,并<strong>紧接着</strong>被校验的 Bean 声明一个参数：<code>BindingResult result</code> 或者 <code>Errors errors</code>，这个  两个类可以记录校验的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@Past</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/valid&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testValid</span><span class="params">(<span class="meta">@Valid</span> User user,BindingResult result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.hasErrors()) &#123; <span class="comment">//从校验结果中查看是否校验成功</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非自定义-JavaBean-校验"><a href="#非自定义-JavaBean-校验" class="headerlink" title="非自定义 JavaBean 校验"></a>非自定义 JavaBean 校验</h3><p>对于非自定义类型的数据，首先需要在 IOC 容器中注册一个 MethodValidationPostProcessor 用来校验方法参数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.validation.beanvalidation.MethodValidationPostProcessor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在处理方法所在的 Controller 类中加入注解 <code>@Validated</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmplController</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将 JSR-303 注解标注到对应参数头上，如果校验失败，则会抛出异常（javax.validation.ConstraintViolationException），需要注意的是，这里无法使用 BindingResult 和 Errors 来查看错误，只能拦截异常 （好麻烦啊！！！）</p><h3 id="自定义错误消息"><a href="#自定义错误消息" class="headerlink" title="自定义错误消息"></a>自定义错误消息</h3><p>最简单的方法就是在任何一个校验的注解里面添加 message 属性，里面填写需要自定错误的消息。这样我们取出来的 Message 就是我们自己设置的错误了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull(message = &quot;老哥不能空啊！&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="meta">@NotNull(message = &quot;老哥不能空啊！&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@Email(message = &quot;老哥你邮箱不对啊！&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure><p>但是如果需要实现国际化的话，具体的流程和 JstlView 实现国际化的流程都是一样的，唯一的不同是对国际化文件的 Key 进行一定的规则限制。</p><p>因为我们在回显错误信息的时候，比如使用 <code>&lt;form:errors path=&quot;email&quot;&gt;</code> 来现实隐含模型中属性为 email 的校验错误的时候，他会根据一定的规则从国际化文档中寻找对应的 Key：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Email.user.email=XXXX //在隐含模型的 user 对象的 email 字段使用 @Email 校验时，匹配此国际化错误信息</span><br><span class="line">Email.email=XXXX //在隐含模型任意对象中的 email 字段使用 @Email 校验时，匹配此国际化错误信息</span><br><span class="line">Email.java.lang.String=XXXX //字段为 String 的值使用 @Email 校验时，匹配此国际化错误信息</span><br><span class="line">Email=XXXX //任意字段使用 @Email 校验时，匹配此国际化错误信息</span><br></pre></td></tr></table></figure><p>当有多个国际化 Key 得到匹配的时候，同样按照精确度决定匹配优先级。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;静动态资源处理管理&quot;&gt;&lt;a href=&quot;#静动态资源处理管理&quot; class=&quot;headerlink&quot; title=&quot;静动态资源处理管理&quot;&gt;&lt;/a&gt;静动态资源处理管理&lt;/h2&gt;&lt;p&gt;我们最初在配置 &lt;code&gt;DispatcherServlet&lt;/code&gt; 来作为</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-04-视图/视图解析器</title>
    <link href="https://xorex.space/2021/06/09/b91e91480bcd/"/>
    <id>https://xorex.space/2021/06/09/b91e91480bcd/</id>
    <published>2021-06-09T14:54:23.000Z</published>
    <updated>2021-06-16T14:37:36.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h2><h3 id="forward-转发"><a href="#forward-转发" class="headerlink" title="forward: 转发"></a>forward: 转发</h3><p>和原本的 SpringMVC 一样，写在方法的返回值处，不过不同的是 forward: 不会被拼串，并且是以项目地址为相对路径的。</p><p>原：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/TestRequest/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView requestScope = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> requestScope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forward:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/TestRequest/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView requestScope = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;forward:/WEB-INF/pages/hello.jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> requestScope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redirect-重定向"><a href="#redirect-重定向" class="headerlink" title="redirect: 重定向"></a>redirect: 重定向</h3><p>使用方法和 <code>forward:</code> 转发是一样的，和使用 <code>response.sendRedirect(&quot;/XXX&quot;)</code> 唯一不同的是，相对地址会自动加上项目地址，方便浏览器解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/TestRequest/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView requestScope = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;redirect:/WEB-INF/pages/hello.jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> requestScope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="视图解析原理"><a href="#视图解析原理" class="headerlink" title="视图解析原理"></a>视图解析原理</h3><blockquote><p>这一段转自与知乎，其实自己也写了总结，但是觉得不太行，没有下文理解的清晰。</p></blockquote><ol><li><p>当我们对 SpringMVC 控制的资源发起请求时，这些请求都会被 SpringMVC 的 org.springframework.web.servlet.DispatcherServlet 处理，接着 SpringMVC 会分析看哪一个 HandlerMapping 定义的请求映射中存在对该请求的最合理的映射。然后通过该 HandlerMapping 取得其对应的 Handler（也就是我们定义的处理请求方法），接着再通过相应的 HandlerAdapter 处理该 Handler。HandlerAdapter 再对Handler 进行处理。</p></li><li><p>之后会返回一个 ModelAndView 对象。在获得了 ModelAndView 对象之后，Spring 就需要把该 View 渲染给用户，即返回给浏览器。在这个渲染的过程中，发挥作用的就是 ViewResolver 和 View。当 Handler 返回的 ModelAndView 中不包含真正的视图，只返回一个逻辑视图名称，ViewResolver 会把该逻辑视图名称解析为真正的视图 View 对象。View 真正进行视图渲染，把结果返回给浏览器。</p></li></ol><p>而 ViewResolver 和 View 都是一个接口，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">View <span class="title">resolveViewName</span><span class="params">(String var1, Locale var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125; <span class="comment">//用于解析 ModelAndView 里面保存的 viewName 然后根据解析结果生成一个合适的 View 实现对象。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String, ?&gt; var1, HttpServletRequest var2, HttpServletResponse var3)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125; <span class="comment">//实现 View 接口只需要实现 render() 方法即可，render 渲染，将获取的数据和展示模板一起渲染成一个用户收到的页面。</span></span><br></pre></td></tr></table></figure><p>调用 View 对象的 render 渲染（指生成用户看到的 html 页面）方法，进行请求转发（并将模型输入放入 Request 域中），或者请求重定向。SpringMVC 主要负责的是生成 View 的过程，至于不同的 View 接口实现可以五花八门，实现了视图层的解耦。</p><h2 id="使用-JstlView-实现国际化"><a href="#使用-JstlView-实现国际化" class="headerlink" title="使用 JstlView 实现国际化"></a>使用 JstlView 实现国际化</h2><p>在 Spring 中导入 taglibs-standard-impl 和 taglibs-standard-spec 这两个包之后，在 Spring 中配置的 InternalResourceViewResolver 中，添加 viewClass 属性值为 JstlView 之后，ViewResolver 将生成的 View 实例从原本的 InternalResourceView 更改为更强大的子类：JstlView。</p><p>这个 View 强大之处就是大大简化了国际化的配置与使用。</p><p>首先搞几个不同国家地区的文字：<code>i18n_en_US.properties</code> 和 <code>i18n_zh_CN.properties</code> 。然后在 Spring 中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;i18n&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意 id 一定要是 <code>messageSource</code> ，Spring 是根据这个 id 名字来寻找绑定的国际化信息的。然后在相关的 jsp 页面引入 fmt 标签，然后使用  <code>&lt;fmt:message&gt;</code> 来输出国际化信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">fmt:message</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fmt:message</span> <span class="attr">key</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="请求页面跳转访问"><a href="#请求页面跳转访问" class="headerlink" title="请求页面跳转访问"></a>请求页面跳转访问</h2><p>因为很多强大的功能只有经过 SpringMVC 才能实现，比如上面的国际化，这就需要我们对一些直接访问的资源经过 SpringMVC 处理，或者访问 WEB-INF 下面的资源，也需要进行请求转发才可以获取资源。那么大量的仅仅只进行请求转发的处理方法写起来太乱了，可以直接用一条 Spring 的配置解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/Login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Login&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringMVC 支持通过配置的方法，来实现访问地址直接向 WEB-INF 下资源的访问：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;Login&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>但是需要注意的是，使用了 <code>mvc:view-controller</code> 来接管对请求路径的访问之后，会打断原本注解标注的 <code>@RequestMapping</code>，需要额外添加一个 <code>mvc:annotation-driven</code> 来进行扫描注解接管请求映射。</p><h2 id="自定义视图解析器"><a href="#自定义视图解析器" class="headerlink" title="自定义视图解析器"></a>自定义视图解析器</h2><p>大致过程：首先实现 ViewResolver 和 View 两个接口。ViewResolver 还需要实现 Ordered ，来将优先级提高到高于 InternalResourceViewResolver，只需要获取的 order 值越低，权重越高！</p><p>如果开头是 Tempest ，则确认为本 ViewResolver 处理对象，返回一个本 ViewResolver 生成的 View 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewResolver</span> <span class="keyword">implements</span> <span class="title">ViewResolver</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> order;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">resolveViewName</span><span class="params">(String s, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.startsWith(<span class="string">&quot;Tempest:&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyView(s.substring(<span class="number">8</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">(<span class="keyword">int</span> order)</span> </span>&#123; <span class="comment">// 这个 order 值是在 Spring 的配置文件里面设置的</span></span><br><span class="line">        <span class="keyword">this</span>.order=order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 View 的渲染方式就是转发请求到指定的页面中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">implements</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    MyView(String address) &#123;</span><br><span class="line">        <span class="keyword">this</span>.address=address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String, ?&gt; map, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/pages/&quot;</span>+address+<span class="string">&quot;.jsp&quot;</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后记得将自己实现的 ViewResolver 添加到 IOC 容器（配置文件注册 bean 的 class 即可）中，Spring 会根据是否实现 ViewResolver 接口决定此类是否为视图解析类，并在控制 View 生成的时候，依次调用所有的 ViewResolver 的 resolveViewName() 方法。所以必须让 Spring 知道自己才有可能被调用去生成 View。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.SpringMVC.ViewResolver.MyViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们再进行请求映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Tempest:hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当我们发起 <code>XXXX/test/</code> 的请求的时候，就会将 <code>Tempest:hello</code> 视图名根据 order 权重依次传入 ViewResolver 的 resolveViewName() 中，我们写的 ViewResolver 看到了 <code>Tempest:</code> 的开头，匹配成功并返回我们自己实现的 View：MyView，最后调用 MyView 的渲染方法 render() 并执行我们指定的请求转发代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;视图层&quot;&gt;&lt;a href=&quot;#视图层&quot; class=&quot;headerlink&quot; title=&quot;视图层&quot;&gt;&lt;/a&gt;视图层&lt;/h2&gt;&lt;h3 id=&quot;forward-转发&quot;&gt;&lt;a href=&quot;#forward-转发&quot; class=&quot;headerlink&quot; title=&quot;f</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-03-处理模型数据</title>
    <link href="https://xorex.space/2021/06/07/70114f9842ce/"/>
    <id>https://xorex.space/2021/06/07/70114f9842ce/</id>
    <published>2021-06-07T14:17:56.000Z</published>
    <updated>2021-06-15T09:14:56.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h2><h3 id="操作-Map-系列参数"><a href="#操作-Map-系列参数" class="headerlink" title="操作 Map 系列参数"></a>操作 Map 系列参数</h3><p>方法参数加上 <code>Map&lt;String,Object&gt;</code>、<code>Model</code>、<code>ModelMap</code> 三个中的任意一个即可，我们只要将数据保存到这些的参数实例中，Spring 会自动帮我们把数据放到 <strong>Request</strong> 域中。</p><p>关于这三个有什么关系呢：</p><p><img src="https://xorex.space/image/300.jpg" alt="300.jpg"></p><p>其实 Spring 传入参数中的是 BindingAwareModelMap 实例，所以才能三个中任意一个作为参数都能实现数据的转发。</p><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h3><p>这里需要重点说一下用来处理隐含数据模型 bindingAwareModelMap 的注解 <code>@ModelAttribute</code>，此注解可被应用在方法或方法参数上。</p><h4 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h4><p>当 <code>@ModelAttribute</code> 标注到一个方法上面的时候，就意味着这个方法为数据模型处理方法，这个方法是用来在隐藏数据模型添加一些数据的。所以被这个注解标注的方法会在当前类下面的<strong>任意一个请求映射方法</strong>被调用<strong>之前运行</strong>。</p><p><code>@ModelAttribute</code> 标注方法有两种风格：</p><ul><li>在第一种写法中，方法通过返回值的方式默认地将添加一个属性；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute(&quot;Xorex&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;XXX&quot;</span>,<span class="string">&quot;XXX&quot;</span>,<span class="number">324234</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将返回的 User 对象添加到隐藏数据模型中，key 为我们在注解中设置的 <code>Xorex</code>，如果不设置，那么默认为添加的数据类型 User 的首字母小写 user。</p><ul><li>在第二种写法中，方法接收一个 Model 对象，然后可以向其中添加任意数量的属性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    model.addAtribute(<span class="string">&quot;Xorex&quot;</span>,<span class="keyword">new</span> User());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数注释"><a href="#参数注释" class="headerlink" title="参数注释"></a>参数注释</h4><p>标注在方法参数上的 <code>@ModelAttribute</code> 说明了该方法参数的值将由 model 中取得。如果 model 中找不到，那么该参数会先被实例化，然后被添加到 model 中。在 model 中存在以后，请求中所有名称匹配的参数都会填充到该参数中。</p><p>就是用来从隐含数据模型中取数据用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/XXX/XXX&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(<span class="meta">@ModelAttribute(&quot;Xorex&quot;)</span> User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;XXX/XXX&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而参数 user 可能来自于：</p><ol><li>因为 <code>@SessionAttributes</code> 标注的使用已经存在于 model 中</li><li>它可能因为在同个控制器中使用了 <code>@ModelAttribute</code> 方法已经存在于 model 中，正如上面所叙述的将注解标注到方法上面。</li><li>它可能是调用了自身的默认构造器被实例化出来的，在 model 中找不到实例，只能创建。</li></ol><h3 id="使用-ModelAndView"><a href="#使用-ModelAndView" class="headerlink" title="使用 ModelAndView"></a>使用 ModelAndView</h3><p>ModelAndView 模型（页面需要用到的数据）和视图（数据的展示），这个东西会同时起到两个作用，那就是 request 域数据的保存和页面的转发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/Test/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;hello&quot;</span>); <span class="comment">//确认转发的 View 层地址</span></span><br><span class="line">    mv.addObject(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>); <span class="comment">//向 request 域中写数据</span></span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 ModelAndView 作为方法返回对象，设置实例的转发 View 页面，设置 Model 数据。</p><h3 id="Session-中的数据"><a href="#Session-中的数据" class="headerlink" title="Session 中的数据"></a>Session 中的数据</h3><p>这里推荐还是使用原生的 API HttpSession 进行存取数据，更加方便安全。</p><p>而 SpringMVC 提供了两种和 Session 进行数据交互的注解，为标注在类上面的注解 <code>@SessionAttributes</code> 和标注在参数上面的注解 <code>@SessionAttribute</code>。</p><p>对于 <code>@SessionAttributes</code>：是用于在请求之间的 HTTP Servlet 会话中<strong>存储</strong> model 属性。其 Value 用来填写放入 Session 中的 Key，然后 Spring 会在隐含数据模型中寻找相同的 Key，并把里面的值复制一份放入 Session 中。也就是说 Session 有的，隐含数据域中也必须有。而注解的另外一个参数则是 Types，这个不是去隐含数据模型中寻找 Key 了，而是值的类型，将符合 Types 类型的数据放入 Session 中。这个很危险，不建议使用。</p><p>而且一旦在隐含数据模型中找不到指定的数据，那么 <code>@SessionAttributes</code> 注解就会报错。</p><hr><p>然后就是从 Session 中获取数据了，使用的是 <code>@SessionAttribute</code> 。</p><p>需要将 <code>@SessionAttribute(&quot;XXX&quot;)</code> 就可以将 Session 中保存的 key 为 XXX 的数据放入被标注的方法参数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/XXX/XXX&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(<span class="meta">@SessionAttribute(&quot;Xorex&quot;)</span> User user)</span> </span>&#123; <span class="comment">// 从 Session 中取出 key 为 Xorex 的值。</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;XXX/XXX&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据转发&quot;&gt;&lt;a href=&quot;#数据转发&quot; class=&quot;headerlink&quot; title=&quot;数据转发&quot;&gt;&lt;/a&gt;数据转发&lt;/h2&gt;&lt;h3 id=&quot;操作-Map-系列参数&quot;&gt;&lt;a href=&quot;#操作-Map-系列参数&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-02-请求数据获取</title>
    <link href="https://xorex.space/2021/06/06/fd142553b621/"/>
    <id>https://xorex.space/2021/06/06/fd142553b621/</id>
    <published>2021-06-05T16:36:36.000Z</published>
    <updated>2021-06-16T14:37:41.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>REST 即表述性状态传递（Representational State Transfer），是一种软件架构风格，指代使用不同的请求方式来表示这次请求需要完成的 CURD 的种类，然后在 URL 中携带被操作对象，</p><p>比如：</p><table><thead><tr><th>URL</th><th>请求方式</th><th>目的</th></tr></thead><tbody><tr><td>/book/1</td><td>get</td><td>获取 1 号图书</td></tr><tr><td>/book</td><td>post</td><td>添加图书</td></tr><tr><td>/book/1</td><td>put</td><td>更新图书</td></tr><tr><td>/book/1</td><td>delete</td><td>删除 1 号图书</td></tr></tbody></table><p>这里面要说一下 Post 和 Put 的区别，在官方 HTTP 协议中，规定 Put 为 idempotent（幂等） 方法，也就是多次连续请求造成结果应该相同。因此 Put 应该执行更新方法，而 Post 应该执行非幂等（多次执行添加请求会添加多个）的添加方法。</p><h3 id="实现-REST"><a href="#实现-REST" class="headerlink" title="实现 REST"></a>实现 REST</h3><p>因为 HTML 发起请求的方式只有 GET 和 POST，所以为了实现 REST，我们可以曲线救国。在 GET 或者 POST 里面添加请求参数，<code>_method</code>，放入 delete 和 put 作为参数，然后在 web.xml 中配置一个 Srping 的 Filter：<code>HiddenHttpMethodFilter</code>，过滤范围为所有的请求。</p><p>这个 Filter 会去查找是否拥有 <code>_method</code> 参数并且数据的请求类型是否为合法（指是否为 HTTP 协议里面的类型），如果合法，那么这个 Filter 会将 HttpRequest 里面的请求方法修改为我们设置的 <code>_method</code> 参数数据。</p><p>最后需要注意的是，在大于等于 8.0 版本的 Tomcat 里面使用 REST 的时候，因为 JSP 认为不是 Get 或者 Post 的请求都是有问题的，会爆出错误页面，为了掩盖这个问题，将当前 JSP 页面的页头添加设置 <code>isErrorPage=&quot;true&quot;</code>，就可以让 Tomcat 忽略这个问题了。</p><h2 id="获取请求信息"><a href="#获取请求信息" class="headerlink" title="获取请求信息"></a>获取请求信息</h2><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><h4 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h4><ol><li>方法声明变量名，参数名和变量名匹配的话就会将参数值传入方法中，比如下面当有参数： <code>username=XXX</code> 的时候，发现方法参数和请求参数名相匹配，就会将 XXX 传入方法中，没带则传入 null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>@RequestParam</code> 注解标注方法参数。</li></ol><p><code>(RequestParam(value = &quot;user&quot;,required = false,defaultValue = &quot;No_Name&quot;) String username)</code> 主要是解决方法参数名和请求参数名不一样的问题，给 value 附上别名即可（当然附上别名就<strong>只能使用别名</strong>来让方法参数接收数据了），required 则是标注这个参数是否必须要有（如果没有页面会报错 Required Parameter XXX）</p><hr><h4 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h4><p>SpringMVC 支持 POJO 类型的请求自动封装，会自动将符合匹配条件（名字一样）的请求参数放入 POJO 中。还支持 POJO 的级联封装，只需要加 <code>.</code> 即可：<code>address.home=Xorex&amp;address.school=CUIT</code> 就是对 Address 里的两个 String 进行赋值。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求：username=Xorex&amp;password=Xorex&amp;address.home=Xorex&amp;address.school=CUIT&amp;Xorex=Tempest</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">(User user,String username)</span>  </span>&#123;<span class="comment">// 两个封装并不冲突</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原生参数"><a href="#原生参数" class="headerlink" title="原生参数"></a>原生参数</h4><p>SpringMVC 支持自动传入原生 ServletAPI，直接写在方法的参数里面即可，会按照类型填入，支持类型：</p><ol><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li><li>java.security.Principal</li><li>Locale</li><li>InputStream</li><li>OutputStream</li><li>Reader</li><li>Writer</li></ol><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>使用 <code>@RequestHeader</code> 注解获取请求头信息，value 填写请求头名称， required 和 defaultValue 参考上面。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>使用 <code>@CookieValue</code> 注解获取请求中的 Cookie 信息，value 填写 Cookie 的 key，required 和 defaultValue 参考上面。</p><h2 id="请求响应乱码"><a href="#请求响应乱码" class="headerlink" title="请求响应乱码"></a>请求响应乱码</h2><ol><li>GET 请求乱码：</li></ol><p>GET 乱码主要是 Tomcat 中 Connector 对请求的解析的问题，只需要在 8080 端口的 Connector 的设置（在 server.xml 中）里添加 URLEncoding=”UTF-8” 即可、</p><ol start="2"><li>POST 请求乱码：\</li></ol><p>在 HttpServletRequest 实例设置 setCharacterEncoding(“UTF-8”)，或者写一个 Filter 将所有的请求提前设置一下。</p><p>最最最重要的是，Spring 内置了这个 Filter，不需要我们自己写！是 CharacterEncodingFilter ，直接配置到 web.xml 中即可，可选配置请求乱码 encoding 和相应乱码 forceEncoding 一起改:</p><p>更更更重要的是，这个 Filter 要<strong>放到其他的 Filter 前面</strong>，因为可能其他 Filter 回对请求里面的数据进行处理，应该修改完编码类型之后才可以！！！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;REST&quot;&gt;&lt;a href=&quot;#REST&quot; class=&quot;headerlink&quot; title=&quot;REST&quot;&gt;&lt;/a&gt;REST&lt;/h2&gt;&lt;p&gt;REST 即表述性状态传递（Representational State Transfer），是一种软件架构风格，指代使用不</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-01-基础请求处理</title>
    <link href="https://xorex.space/2021/06/05/28d8300ff21a/"/>
    <id>https://xorex.space/2021/06/05/28d8300ff21a/</id>
    <published>2021-06-05T08:49:25.000Z</published>
    <updated>2021-06-11T06:05:10.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先拿张图，这里面就是 Spring 可以胜任的功能，其中 Web 模块其实就是我们接下来要学习的 SpringMVC，使用 Spring 来控制 Web 项目里面的 Model View Controller 三层模型。</p><p><img src="https://xorex.space/image/298.jpg" alt="298.jpg"></p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>首先需要导入 Spring 的核心包，也就是支持 Spring 运作的 Beans Core Context SpEL 和用于测试 Spring 的 Test 包。</p><p>而对于 SpringMVC 来说，实现基础的功能只需要导入 Web 和 Servlet 两个包即可。</p><p>SpringMVC 的模式和传统的 MVC 有一点点不同，那就是多了一个前端控制器，这个控制器也是 SpringMVC 控制整个 Web MVC 流程的实现基础。而这个前端控制器本身是一个 Servlet，交给 Tomcat 控制。然后 Tomcat 会拦截所有的 Servlet 请求，全都交给前端控制器这个 Servlet，前端控制器则根据 SpringMVC 的框架标准，控制处于 Spring 容器中的各种对象来完成业务的实现。</p><p><img src="https://xorex.space/image/299.jpg" alt="299.jpg"></p><p>所以先在 web.xml 中配置 DispatcherServlet ，初始化参数给 spring 配置文件的地址，也就是 applicationContext.xml 用来控制 IOC 容器（如果不配置的话会默认去 WEB-INF/springDispathcherServlet-servlet.xml 读配置文件，其中文件前缀就是配置的 DispathcerServlet 的 servlet-name），并配置拦截 / 下的所有 Serlvet 请求（/* 会拦截所有资源的请求，包括 jsp， / 不会拦截 jsp），当然除了拦截 Servlet 请求，静态资源的请求也从 Tomcat 手里抢了过来，这个问题以后回补充解决方案。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispathcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispathcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>搞好了前端控制器之后，就可以写 Controller 层的控制器了，只需要随便写一个类，然后标注 @Controller ，就可以被 IOC 容器标注为控制层了，等到 DispathcerServlet 调用自己即可。</p><p>而对于这个伪装的 Servlet 如何有选择的处理不同的请求呢，这就依靠 @RequestMapping 注解，也就是请求映射，将请求和处理方法建立映射。</p><p>因为我们将请求映射配置为 /，所以 Spring MVC 将捕获 WEB 容器的所有请求，包括静态资源的请求， SpringMVC 会将他们当成一个普通请求处理，因找不到对应处理器将导致错误。解决方案就是在 SpringMVC 的配置文件中配置 <code>&lt;mvc:default-servlet-handler/&gt;</code> 的方式解决静态资源的问题：<br><code>&lt;mvc:default-servlet-handler/&gt;</code> 将在 SpringMVC 上下文中定义一个 DefaultServletHttpRequestHandler，它会对进入 DispatcherServlet 的请求进行筛查，如果发现是没有经过映射的请求，就将该请求交由 WEB 应用服务器默认的 Servlet 处理，如果不是静态资源的请求，才由 DispatcherServlet 继续处理。</p><h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&#123;&quot;/index.jsp&quot;,&quot;/index&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;WEB-INF/pages/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是将 <code>/index.jsp</code> 和 <code>/index</code> 两处的请求，转发到 return 里面填写的地址上面，这里使用的是请求转发。</p><h3 id="RequestMapping-相关"><a href="#RequestMapping-相关" class="headerlink" title="RequestMapping 相关"></a>RequestMapping 相关</h3><p>RequestMapping 定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;path&quot;)</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标注位置"><a href="#标注位置" class="headerlink" title="标注位置"></a>标注位置</h4><p>RequestMapping 可以被标注到 TYPE 也就是 Class 上和方法上，标注到 Class 上面是为了更大范围的前置约束，比如可以写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/fisrt&quot;,method=&quot;post&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/one&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;one&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/two&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">two</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;two&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样首先访问为 <code>/first/XXX</code> 的 POST 请求都会被定位到 FirstController 这个类中，然后根据 <code>/XXX</code> 的值精细化定位处理方法。</p><h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><ol><li><p>value/path 设置处理此方法映射的访问地址。详情请看：<a href="https://xorex.space/2021/06/05/28d8300ff21a/#%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84">请求路径</a></p></li><li><p>method 设置映射的访问方法，可以设置 <code>public enum RequestMethod</code> 里面设定的几种访问方法。</p></li><li><p>params 设置请求中的参数要求，必须包含某参数或者某参数为 XXX 值等。详情请看：<a href="https://xorex.space/2021/06/05/28d8300ff21a/#%E5%8F%82%E6%95%B0%E9%99%90%E5%88%B6">参数限制</a></p></li><li><p>headers 设置请求头包含 “请求头：设置” 的请求被本方法处理。</p></li><li><p>consumes 设置消费类型，是根据 Content-Type 请求头里面进行比对的，比如设置 application/json 就限制了请求里面的数据必须是 application/json 类型的请求才会被此方法处理</p></li><li><p>produces 设置要求生产类型，是根据 Accept 请求头进行比对的。根据请求想要获得的数据类型来决定本方法是否处理此请求。</p></li></ol><h4 id="请求路径"><a href="#请求路径" class="headerlink" title="请求路径"></a>请求路径</h4><p>其中可以使用 <code>&#123;VariableName&#125;</code> 的方式从 URI 中截取数据，保存到 VariableName 的变量中，然后下面通过注解 <code>@PathVariable</code> 将保存的截取数据送入方法参数中，如果参数名和截取数据所保存的变量名相等，就可以不在注解里面填写数据。如果注解标注的位置是 Map 类型，则会将<strong>所有</strong>截取的数据放入 Map 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/index/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toIndex</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对截取的数据加以正则限制，则可以使用：<code>&#123;varName:regex&#125;</code> 来对某部分进行正则表达式限制。或者比较粗暴的使用 <code>*</code> 来省略被限制的部分路径。</p><hr><p>当一个请求被多个方法映射成功之后，遵循的原则是映射匹配精确度越高，方法处理的优先级越高。</p><h4 id="参数限制"><a href="#参数限制" class="headerlink" title="参数限制"></a>参数限制</h4><p>在 params 上设置只有用户名为 Xorex 的用户才会被处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(params=&quot;username=Xorex&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toAdmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Admin] Xorex login.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <code>username!=XXX</code> 表示参数 username 不等于某个值即可（包括没有 username 参数），<code>!username</code> 表示必须没有 username 参数。<code>password</code> 表示必须要有密码参数。</p><h3 id="return-地址"><a href="#return-地址" class="headerlink" title="return 地址"></a>return 地址</h3><p>请求映射方法的 return 值（为 String）就是此方法处理完请求之后会被转发到的地址（一般是 View 层）。</p><p>而转发地址里面有很多都是重复的，如 <code>WEB-INF/pages/</code> 和 <code>.jsp</code> 所以就可以再搞一个内部资源视图控制器，也就是 jsp 的一个小的控制器，只需要将其放入 IOC 容器中，这个控制器就可以设置对视图资源的访问，设置一个前缀和后缀即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 放入 IOC 容器之后，这个实例会在转发 return 后面的地址之前自动被调用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先拿张图，这里面就是 Spring 可以胜任的功能，其中 Web 模块其实就是我们接下来要学习的 SpringMVC，使用 Spring </summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>《一课经济学》读书笔记</title>
    <link href="https://xorex.space/2021/06/03/85d5c9bb45a9/"/>
    <id>https://xorex.space/2021/06/03/85d5c9bb45a9/</id>
    <published>2021-06-03T12:29:50.000Z</published>
    <updated>2021-06-05T16:47:59.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本书内容"><a href="#本书内容" class="headerlink" title="本书内容"></a>本书内容</h2><p>由于在一段时间内的生产力综合是不变的，那么对一个群体的经济政策作用代价是所有人承受的，经济政策需要考虑所有的影响者。</p><p>换句话说：经济政策既需要考虑短时影响，也需要考虑长远影响，不能只关注任意一方。不仅要想行为的好处，也要想事实行为的代价承担着。</p><h2 id="破窗谬论"><a href="#破窗谬论" class="headerlink" title="破窗谬论"></a>破窗谬论</h2><p>破窗谬论：“打碎窗户虽然损失了钱，但是玻璃工人拿到了这份钱，提供了其他消费，刺激了生产。所以这是有好处的。”</p><p>原理：这份钱的消费可以由窗户所有者提供，但社会的所有财产综合损失了一扇窗户，原有的消费不变的情况，总财产损失，反而不利。这是因为忽视了金钱原本持有者的消费能力。</p><h2 id="战祸之福"><a href="#战祸之福" class="headerlink" title="战祸之福"></a>战祸之福</h2><p>战祸之福：“经过战争的国家战后经济会高速发展，因为战后带来了巨大的需要，重建不但贡献了经济，也有后来居上的作用（最新的工厂和大楼），因此也带来了更加先进的社会生产力。”</p><p>原理：战争摧毁了很多东西，带来了某方面的巨大需要，这些需要改变了人战后的努力方向，改变了工业结构。这些被需要工业结构拿到了大量的投资，人们因为迫切的生存需要而贡献了大量的生产力，使得造成了某些被迫切需要的产业的高速发展，但焦点被转移的产业生产力是大幅度下降的。总的来说由于战争破坏，社会的总体生产力下降，整体财富下降，只是因为努力方向的转移造成了部分被迫切需要的产业的快速发展，造成了战祸之福的假象。</p><p>此外，需求和需要时不相等的。需要是客观的，比如需要房子，需要汽车。而需求是一种意愿，必须需求居住能力更高的住所，需求更快的交通工具。需求=购买力（生产力）+ 购买欲望（需要），一个没有支付能力的购买意愿并不构成需求。印度比美国有更多的需要，但是需求并没有美国多。</p><p>也可以将国家经历放到个人身上，个人的财产被毁掉之后，开始拼命工作建造房子。你可以看到它的房子每天都在快速建成，但他只是在恢复到以前的状态，本身还是很贫穷。并且由于努力方向的转移，导致了生产其他东西的能力下降。</p><h2 id="公共工程建设"><a href="#公共工程建设" class="headerlink" title="公共工程建设"></a>公共工程建设</h2><p>公共工程建设：“工程建设增加了工作机会，如果没有工程建设，工作机会也会变少”</p><p>原理：不仅仅要考虑工程的直接影响者：被雇佣者，工程对当地的积极作用等，还要考虑其他影响者，也就是付出代价的人，全体纳税者人。这些代价在原本纳税人手里会产生其他的需求，而政府则是将这些需求转移到了工程的直接影响者。这种转移意味着没创造一个公共工作机会，就会破坏掉一个私人就业机会。而如果这些直接影响者带来的收益低于付出代价，那么工程就是不值得的，这也是因为只看到了直接影响者，而没有看到更广泛的影响者（那些出钱的全体纳税人）</p><h2 id="税收与生产"><a href="#税收与生产" class="headerlink" title="税收与生产"></a>税收与生产</h2><p>税收的作用就是拿出一部分社会整体的生产力，去生产一些个人和公司无法生产的东西，比如基础设施建设，全民医保等。</p><p>适量的税收去生产这些在一定程度上是有利于整体的社会生产力的发展的。但过量的税收会导致个人和公司在相同的投入下，有大量的生产力被政府抽走，自己剩余的生产力就会过低，整体会抑制社会对扩大生产的投资，从而影响生产力的发展。实际中需要寻找一个合适的平衡点。</p><h2 id="诅咒机器"><a href="#诅咒机器" class="headerlink" title="诅咒机器"></a>诅咒机器</h2><p>诅咒机器：“人们认为使用机器带来的生产力提升使得人们失去了工作机会，所以拒绝使用机器是保住就业的好方法。”</p><p>原理：更先进的生产力破坏了原有的生产关系，导致了一部分人失去工作机会。但更加先进的生产力意味着更加强大的购买力，这部分购买力会随着购买欲望一起变成新的需求，而新的需求就意味着工作机会。在这个过程之中，因为更加先进的生产力使得整个社会的财富变得更多了，意味着能够养活的人口变多了。按照原有的工作机会水平（生产力-需求）来看，社会的工作机会不减反增。</p><p>失去的工作机会是被关注的短期和局部影响，背后带来的社会生产力提高是长远的影响，两者都应该被同等的重视，而不是过分的关注一方。</p><h2 id="关税保护"><a href="#关税保护" class="headerlink" title="关税保护"></a>关税保护</h2><p>关税是对购买国外商品的国人进行征税。对国家内部来说，关税的好处只有提高本国某行业在全世界的生产力分配额度。</p><p>如日本高得离谱的农业进口税，作用仅仅只是维持本国的部分农业供给，保证一定程度的粮食安全。而为此付出的代价就是日本国内的一部分生产力需要被消耗在低效的日本农业上面，如果取消关税，那么国外农业优势国家（相同的投入获取更多的收益）的农业生产力将会更加发达，而日本本国的消费者可以将投入本国农业的低效生产力以消费的形式转移到其他的优势产业，如制造业。从全世界来看，国外的农业和日本的制造业生产力都得到了提升，创造出来了更多的财富，所有人都收益（当然收益程度是不同的，关税的本质就是通过抑制优势生产力的流动来调整国际生产力发展带来的收益）</p><p>长远来看并不利于全世界的整体生产力的提升，因此也制约了本国的整体生产力。但在全世界并没有出现一个统一的，以全人类发展为最终目标的，拥有最高权力的全球政府之前，人类还需要忍受关税带来的内耗。<br>但上面说的只是理想的情况啦，实际即使所有国家都开放市场，因为地理，国界，文化，发展水平等等因素限制，虽然整体上是利于全世界的发展，但开放市场带来的收益会很不平衡，可能会发达国家吃肉，强发展中国家喝汤，弱发展中国家吐血。</p><h2 id="进出口"><a href="#进出口" class="headerlink" title="进出口"></a>进出口</h2><p>最好的对外贸易状态就是进口等于出口，过多的贸易顺差会造成国内资源不断外流，抑制国内需求，带来本国货币升值压力。而过多的贸易逆差会造成本国货币贬值，国内生产力不足。</p><p>所以最好是出口等于进口，是当前经济最好的状态。但因为当前最好状态不太表最终最好状态，中国靠着贸易顺差积累了原始资本，大幅度的提高了生产力，为未来获取高附加值产业奠定了基础等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本书内容&quot;&gt;&lt;a href=&quot;#本书内容&quot; class=&quot;headerlink&quot; title=&quot;本书内容&quot;&gt;&lt;/a&gt;本书内容&lt;/h2&gt;&lt;p&gt;由于在一段时间内的生产力综合是不变的，那么对一个群体的经济政策作用代价是所有人承受的，经济政策需要考虑所有的影响者。&lt;/p&gt;</summary>
      
    
    
    
    <category term="杂七杂八" scheme="https://xorex.space/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="读书笔记" scheme="https://xorex.space/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>计组-IO系统</title>
    <link href="https://xorex.space/2021/06/01/ac17795a00ed/"/>
    <id>https://xorex.space/2021/06/01/ac17795a00ed/</id>
    <published>2021-06-01T09:54:49.000Z</published>
    <updated>2021-06-05T16:47:39.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO-基本概念"><a href="#IO-基本概念" class="headerlink" title="IO 基本概念"></a>IO 基本概念</h2><p>I/O 即输入／输出，通常指数据在存储器（内部和外部）或其他周边设备之间的输入和输出，输入是系统接收的信号或数据，输出则是从其发送的信号或数据。</p><h3 id="IO-系统的发展"><a href="#IO-系统的发展" class="headerlink" title="IO 系统的发展"></a>IO 系统的发展</h3><p>早期的 IO 系统是直接和 CPU 连接，由 CPU 直接控制 IO 系统，极大的降低了 CPU 的性能。</p><p>后来将一些和内存数据交换比较频繁的外设单独建立了 DMA （Direct Memory Access 直接存储访问） 总线。</p><p>再后来发展出了 IO 通道结构，主机只需要和 IO 上面的通道部件进行数据交换即可，再次加快了速度。</p><p>现在一般开始采用 IO 处理机，承担主机的功能来管理各种外设，基本拥有和 CPU 一样的结构。</p><p><img src="https://xorex.space/image/293.jpg" alt="293.jpg"></p><h3 id="IO-系统工作方式"><a href="#IO-系统工作方式" class="headerlink" title="IO 系统工作方式"></a>IO 系统工作方式</h3><p>IO 系统一般来说有三种工作方式，分别是：程序查询方式，程序中断方式，DMA 方式。三种方式的不同的地方就是使用了不同的设计来分担了一部分 CPU 对 IO 设备的控制，使得 IO 系统对 CPU 越来越简单，从而提升性能。</p><p><img src="https://xorex.space/image/294.jpg" alt="294.jpg"></p><h2 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h2><p>关于外设的各种信息，因为和生活比较接近，所以就不写了。</p><h2 id="IO-接口"><a href="#IO-接口" class="headerlink" title="IO 接口"></a>IO 接口</h2><p>IO 接口的相关结构，主要的作用就是建立起一个 CPU 和外设之间通讯的桥梁，来提高整个设备的性能和可拓展性，让各个部件都专注与自己本身的工作：</p><p><img src="https://xorex.space/image/295.jpg" alt="295.jpg"></p><p>以及 IO 接口结构的工作流程，CPU 只和接口进行交互，并且相关数据的获取都是从绿色的数据缓冲寄存器和设备状态标记寄存器，这也是为了减少 CPU 实际读取数据的时间，和通过主控芯片来提高外接设备的性能。</p><p><img src="https://xorex.space/image/296.jpg" alt="296.jpg"></p><p>这里需要注意一个概念，我们将上面绿色部分的寄存器称为端口 Prot，分为 数据端口，控制端口，状态端口。剩下的蓝色部分和控制逻辑电路作为控制逻辑。</p><p><img src="https://xorex.space/image/297.jpg" alt="297.jpg"></p><p>也就是说，CPU 实际上和外设进行数据交换的时候，本质上是和接口里面的端口进行数据交换，所以获取数据只需要知道数据所在的端口的地址即可。统一端口设计模式之后，CPU 就完全不需要关心实际外部设备的内部设计了，这些交给端口的控制逻辑解决即可。</p><hr><p>对不起，实在不想学了，以后学了操作系统，之后再来看看 IO 系统这一章吧！</p><p>一定会补完的，QAQ</p><p>滚去学 Spring 了……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IO-基本概念&quot;&gt;&lt;a href=&quot;#IO-基本概念&quot; class=&quot;headerlink&quot; title=&quot;IO 基本概念&quot;&gt;&lt;/a&gt;IO 基本概念&lt;/h2&gt;&lt;p&gt;I/O 即输入／输出，通常指数据在存储器（内部和外部）或其他周边设备之间的输入和输出，输入是系统接收</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-总线设计</title>
    <link href="https://xorex.space/2021/05/31/1b7d3a309aca/"/>
    <id>https://xorex.space/2021/05/31/1b7d3a309aca/</id>
    <published>2021-05-31T12:43:50.000Z</published>
    <updated>2021-06-05T16:47:20.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总线（Bus）概念"><a href="#总线（Bus）概念" class="headerlink" title="总线（Bus）概念"></a>总线（Bus）概念</h2><p>总线是主机为了解决不同可更换设备之间的通信问题而产生的，计算机各种功能部件之间传送信息的公共通信干线。</p><h3 id="总线分类"><a href="#总线分类" class="headerlink" title="总线分类"></a>总线分类</h3><p>总线可以根据不同的特征进行不同的分类：</p><ol><li><p>机械特性：尺寸，形状，管脚数量，排列顺序。</p></li><li><p>电气特性：传输方向（单向 or 双向）和有效的电平范围（0 - 0.5 低电平 0.5 - 1 V 高电平）</p></li><li><p>功能特性：地址总线，数据总线，控制总线。</p></li><li><p>时间特性：信号和时序的关系。</p></li></ol><p>以及下图：</p><p><img src="https://xorex.space/image/284.jpg" alt="284.jpg"></p><p>数据传输格式：里面串行总线和并行总线的区别就是同时传输数据的位数，串行总线一次传输一位数，并行总线一次可以传输多位数。</p><p>总线的功能：主要内容看下图。</p><p><img src="https://xorex.space/image/285.jpg" alt="285.jpg"></p><h3 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h3><p>总线的结构：总线的结构设计分为单总线设计，双总线设计，三总线设计。当然这里的单总线指的是每种总线（数据总线，控制总线，地址总线）只有一根。</p><p>单总线结构，就是最基本的总线：</p><p><img src="https://xorex.space/image/286.jpg" alt="286.jpg"></p><p>双总线结构，将 CPU 与主存的总线和 IO 总线分离开来，高速的用一根，低速的用一根，从而提高整体的效率。</p><p>注意里面的通道是一个小控制器，它有自己的控制系统，负责控制 IO 和内存之间的交互。</p><p><img src="https://xorex.space/image/287.jpg" alt="287.jpg"></p><p>三总线结构，思路还是将不同的速度分级，从而提高整体的速度。这里多出来的就是 DMA 总线，也就是 Direct Memory Access 直接内存访问总线。将 IO 里面速度较快的部分（硬盘）单独和内存使用总线连接，提高硬盘速度。</p><p><img src="https://xorex.space/image/288.jpg" alt="288.jpg"></p><h2 id="总线性能指标"><a href="#总线性能指标" class="headerlink" title="总线性能指标"></a>总线性能指标</h2><p>总线带宽：也就是总线的数据传输速率，单位时间内总线上可传送数据的速率。</p><p>总线复用：有些总线是将地址总线和数据总线放在一起复用。</p><h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><p>因为在同一时间之内只能由一个设备控制总线发出信号，同一时间内只能由一个或多个设备接收总线的信号。</p><p>所以当多个设备想要向总线发送信号的时候，就需要决定哪个设备来使用总线，这便是总线仲裁。</p><h3 id="集中仲裁"><a href="#集中仲裁" class="headerlink" title="集中仲裁"></a>集中仲裁</h3><p>指的是使用一个单独的仲裁器，用它来决定谁获取总线的使用权限。当一个设备正在使用总线的时候，发出 BS 总线忙信号，仲裁器停止分配总线。当没有总线忙信号并且有设备正在请求总线的时候，发出 BG 总线允许信号，需要总线的设备接收到 BG 信号之后，开始使用总线并发出 BS 总线忙信号。这就是集中仲裁的基本原型。</p><p><img src="https://xorex.space/image/289.jpg" alt="289.jpg"></p><h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2><p>总线标准就是国际上公布过推荐的一种模块设计标准，设计设备和总线的通信的时候，只需要遵守相关的模块设计标准，就可以接入任何一条总线。</p><p>PCI 总线，局部总线：</p><p><img src="https://xorex.space/image/290.jpg" alt="290.jpg"></p><p>PCI-E 总线，</p><p><img src="https://xorex.space/image/291.jpg" alt="291.jpg"></p><p>最后用一个奔腾3的主板设计模式，来大概感受一下总线：</p><p><img src="https://xorex.space/image/292.jpg" alt="292.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;总线（Bus）概念&quot;&gt;&lt;a href=&quot;#总线（Bus）概念&quot; class=&quot;headerlink&quot; title=&quot;总线（Bus）概念&quot;&gt;&lt;/a&gt;总线（Bus）概念&lt;/h2&gt;&lt;p&gt;总线是主机为了解决不同可更换设备之间的通信问题而产生的，计算机各种功能部件之间传送信</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-中央处理器</title>
    <link href="https://xorex.space/2021/05/16/46406054684d/"/>
    <id>https://xorex.space/2021/05/16/46406054684d/</id>
    <published>2021-05-16T14:47:32.000Z</published>
    <updated>2021-05-31T12:45:13.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU-的主要职责分析"><a href="#CPU-的主要职责分析" class="headerlink" title="CPU 的主要职责分析"></a>CPU 的主要职责分析</h2><p>CPU 需要有运算器和控制器两个基本的结构，然后完成大概下面的任务：</p><ul><li><p><strong>指令控制</strong>：完成取指令，分析指令和指令执行的操作，即程序的顺序控制。</p></li><li><p><strong>操作控制</strong>：控制产生操作信号，然后传送到所对应的部件上，让其来配合完成整条指令。</p></li><li><p><strong>时间控制</strong>：对各种操作加以时间上的控制。</p></li><li><p><strong>数据加工</strong>：对数据进行算数和逻辑运算，这里主要由运算器完成。</p></li><li><p><strong>中断处理</strong>：处理异常情况和特殊请求。</p></li></ul><h2 id="运算器-Calculator-的基本结构"><a href="#运算器-Calculator-的基本结构" class="headerlink" title="运算器 Calculator 的基本结构"></a>运算器 Calculator 的基本结构</h2><p>下图可以看出运算器 Calculator 主要是由 ALU 和各类寄存器组成的：</p><p><img src="https://xorex.space/image/255.jpg" alt="255.jpg"></p><p>主要部件 ALU 的工作原理在前面章节的数据表示和运算里面已经说明了，下面主要说一下运算器的工作流程。</p><p>首先引入了一个叫作 CPU 内部总线的东西，这个东西负责整个 CPU 内部的数据传输，但是 CPU 有很多个部件，同一时间只能有一个数据信号发送方，为了防止数据传送冲突，就在每个部件上都接入一根 in 和一根 out 控制线，负责控制元器件数据信号的发送和接收。只有 in 控制线有电流，元器件才会从总线上接收数据，只有 out 控制线有电流，元器件才能将自己存储的数据传送到数据总线上去。</p><p>这样通过控制器控制对应元器件的 in 和 out 线路，实现元器通过总线的数据传输。</p><h2 id="控制器-Controlor-的基本结构"><a href="#控制器-Controlor-的基本结构" class="headerlink" title="控制器 Controlor 的基本结构"></a>控制器 Controlor 的基本结构</h2><p>下面的内容都是控制器的所有包括内容，PC：Program Counter，IR：Instruction Register，ID：Instruction Decoder，PSW：Program Status Word，MAR，MDR，CU而里面的核心：微操作信号发生器</p><p><img src="https://xorex.space/image/256.jpg" alt="256.jpg"></p><p>同样也是利用了 CPU 的内部总线，需要注意的是上面的 PSW，是一组程序状态字寄存器，上面的图片是有介绍的，用来记录当前程序运行所产生的特殊的状态。</p><p>因为 MAR 和 MDR 都是集成在 CPU 的内部，所以在和主存进行通信的时候，需要额外的数据总线和地址总线，用来传输信息。</p><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p>我们首先引入一系列的周期概念，主要分为运行时间决定的时间周期，和指令执行过程的指令周期。</p><h4 id="周期概念"><a href="#周期概念" class="headerlink" title="周期概念"></a>周期概念</h4><p><strong>时钟周期</strong> CLK，也被称为节拍，是 CPU 的最基本单位，也就是我们常用的 GHZ 单位。</p><p><strong>机器周期</strong> 是一个微指令完成的实现，由若干个时钟周期组成，如从 PC 中取出指令并送入 MAR 中为一个取址机器周期.</p><p><strong>指令周期</strong> 是通过执行若干个机器周期完成一条明确的指令所需要的时间被称为一个指令周期。</p><p><img src="https://xorex.space/image/257.jpg" alt="257.jpg"></p><p>我们将一个指令拆分成不同的周期就是为了能够利用执行不同机器周期所需要的硬件资源不同，从而实现多个指令同时执行的并行效果。要实现并行就要记录指令正在执行的机器周期，这里使用不同的触发器来记录。</p><p>就是上面的 FE IND EX INT 几种不同的触发器来记录目前的程序有什么特殊的状态。</p><h4 id="取址周期"><a href="#取址周期" class="headerlink" title="取址周期"></a>取址周期</h4><p>非常普通的一个周期，PC -&gt; MAR -&gt; 地址总线 -&gt; 内存 -&gt; 数据总线 -&gt; MDR -&gt; IR ，其中 PC 会自增。</p><h4 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h4><p>没啥好说的，就是多了个间址。</p><h4 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h4><p>中断的目的就是暂停当前正在执行的任务，转去执行其他的任务（这也是多线程的实现基础），为了恢复当前任务，会使用堆栈保存当前任务的断点，将当前的程序指令的地址（从 PC 中获取），压入堆栈中，然后通过<strong>向量地址</strong>来获取下一个程序要执行的指令的地址，将其放入 PC 中，然后继续取址执行等等。</p><h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><p>执行方案指的是指令的运行顺序和时间的设计方案。</p><ul><li><p>单指令周期：所有指令使用相同的执行时间，只需要一个计数器数够次数即可，电路设计简单，是但是因为所有的指令使用的执行时间都是耗时最长的那个指令的执行时间，所以速度会很慢。</p></li><li><p>多指令周期：指每个不同的指令使用不同的执行时间，虽然电路设计会复杂一点，但是相较于单指令周期，整体的效率是提高了。</p></li><li><p>流水线模式：每间隔一段时间都启动一个指令的执行，让指令并行执行，效率最高，但也最难设计。（原理是指令执行的不同截断会使用不同的硬件）</p></li></ul><h3 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h3><ul><li>总线模式</li></ul><p>一条总线负责整个 CPU 内部的所有的数据的传输，电路设计简单，但是没有办法实现数据的并行传输，效率低。</p><p><img src="https://xorex.space/image/258.jpg" alt="258.jpg"></p><ul><li>专线模式</li></ul><p>每个部件之间的数据传输使用部件之间的专有线路，可以并行传输，效率高。</p><p><img src="https://xorex.space/image/259.jpg" alt="259.jpg"></p><h3 id="CU-的输入输出"><a href="#CU-的输入输出" class="headerlink" title="CU 的输入输出"></a>CU 的输入输出</h3><p><img src="https://xorex.space/image/269.jpg" alt="269.jpg"></p><p>控制单元就是根据当前执行指令内容（IR），当前执行时期（标志位），执行时间间隔（时钟周期），突发情况（外来信号），结合这些信息之后，发出来合适的控制信号给各种部件来完成指令的执行。</p><p>而输入进来的数据其实是下面这样的：</p><p><img src="https://xorex.space/image/270.jpg" alt="270.jpg"></p><p>其中多了操作码译码器和节拍发生器对输入进来的数据进行处理，其中前者我们已经非常清楚了，而节拍发生器的作用则是将内部的统一时钟信号 CLK 转化为 T0 ~ Tm 的固定周期的电路信号，从而组成一个机器周期：</p><p><img src="https://xorex.space/image/260.jpg" alt="260.jpg"></p><h2 id="控制器-CU-设计"><a href="#控制器-CU-设计" class="headerlink" title="控制器 CU 设计"></a>控制器 CU 设计</h2><p>一般来说 CU 就是解析指令，然后根据解析的结果，像各个部件发出控制信号，指挥它们去完成指令的执行。</p><p>而生成控制型号的 CU 单元，有两种不同的设计模式，分别是硬布线设计模式和微指令设计模式。</p><p>硬布线设计模式：CU 控制信号是依靠输入进来的指令信息，时序系统，标志等经过内部复杂电路的计算之后，得到的一个控制信号的输出。是依靠硬件电路设计得到控制信号的，因此也叫硬布线。因为只要电流流过相应的电路，结果就直接被计算出来了，所以速度很快。</p><p>微指令设计模式：CU 控制信号是被完整的存储到了一个微指令存储器中，输入指令，直接从微指令内存中读取相应的控制信号，然后输出。因为涉及到微指令存储器的读取，所以速度会慢一点。但是这样设计的电路会简单一些。</p><p>比对图：<img src="https://xorex.space/image/273.jpg" alt="273.jpg"></p><h2 id="硬布线-CU"><a href="#硬布线-CU" class="headerlink" title="硬布线 CU"></a>硬布线 CU</h2><h3 id="CU-设计流程"><a href="#CU-设计流程" class="headerlink" title="CU 设计流程"></a>CU 设计流程</h3><ol><li>分析每个阶段应该执行的微操作序列，举个例子，加法指令应该执行的微操作序列如下：</li></ol><p><img src="https://xorex.space/image/271.jpg" alt="271.jpt"></p><ol start="2"><li><p>选择 CPU 的控制方式，即：产生不同的微操作命令序列所用的时序控制方式。后面会介绍三种不同的 CPU 控制方式。</p></li><li><p>安排微操作时序。</p></li><li><p>电路设计。</p></li></ol><h4 id="CPU-的控制方式"><a href="#CPU-的控制方式" class="headerlink" title="CPU 的控制方式"></a>CPU 的控制方式</h4><p>CPU 控制方式：产生不同的微操作命令序列所用的时序控制方式。作用就是用来控制微指令在执行过程中消耗的时间。</p><ul><li><p><strong>同步控制方式</strong>：整个系统的控制信号均来自于一个<strong>统一的时钟信号</strong>，也就是 CPU 的主频。这样的话所有的微指令执行时间长度都必须是主频周期的整数倍，可能会有点慢。</p></li><li><p><strong>异步控制方式</strong>：这里是使用应答机制来确定微指令的执行时间，当一个微指令执行完毕，就会发送信号给 CU，然后 CU 启动下一条微指令的执行进程。这种方式微指令执行周期不受 CPU 主频的约束，但是电路设计会复杂很多。</p></li><li><p><strong>联合控制方式</strong>：将上面两种控制方式结合在一起，大部分使用同步控制方式，小部分使用异步执行方式。</p></li></ul><h4 id="微操作时序"><a href="#微操作时序" class="headerlink" title="微操作时序"></a>微操作时序</h4><p>微操作时序也就是设定一个指令所需要执行的所有微操作被执行的顺序和时间段，然后才能按照设定的时间去执行。</p><p>设计原则：</p><ol><li>微操作的<strong>先后顺序</strong>不得被随意更改。</li><li><strong>被控对象不同</strong>的微操作尽量被安排到一个节拍中完成</li><li><strong>占用时间较短</strong>的微操作尽量安排在一个节拍中完成，并允许有先后顺序。</li></ol><p>下面的 T0 T1 T2 就是节拍时间，后面跟着这个节拍中需要被执行的微操作，PC+1 被控对象和主存寻址不同，所以一起安排到了 T1 节拍中，4 5 指令执行占用时间较短，所以也被安排到了一个节拍中：</p><p><img src="https://xorex.space/image/272.jpg" alt="272.jpg"></p><p>而这个安排节拍就是上面一个 CLK 生成的一个 Tn 周期，上图所安排的 T0 T1 T2 三个节拍指令会在三个 CLK 的时间内完成指令的执行。这三个节拍指令组成了一个机器指令完成所需要的时间的机器周期。</p><h4 id="电路设计"><a href="#电路设计" class="headerlink" title="电路设计"></a>电路设计</h4><p>因为微操作的数量是有限的，所以我们的基本设计思路就是用电路来计算在当前状态和时间，当前指令下，应该发出的控制型号是否为某种微操作。</p><p>这样计算出来的为 true 的微操作，就可以直接向外界发送自己对应的控制信号了。</p><p>状态的话有三个变量：工作周期标记，当前节拍，和状态标记。</p><p>剩下的输入就是 IR 提供的指令内容了，通过译码器会被转化为某一根线的电信号，代表着某个指令。</p><p>我们将指令作为横坐标，整个机器周期的工作周期，工作周期的节拍，节拍对应可能微操作命令作为纵坐标，列一个表格。然后将指令和对应的微操作命令符合的地方写上 1 ，表示一个指令的微操作命令的组合（当然这是一个简化的版本，省略了很多其他的指令，也没有特殊的状态条件）。</p><p><img src="https://xorex.space/image/274.jpg" alt="274.jpg"></p><p>我们就根据当前正在执行的指令，当前的工作周期，节拍，条件状态，判断某个微操作是否要将自己执行的控制信号发送出去。用 M(MAR)-&gt;MDR 这条微操作为例子，计算是否发送本微操作的控制信号的计算公式如下：</p><p><code>FE*T1+IND*T1*(ADD+STA+LDA+JMP+BAN)+EX*T1(ADD+LDA)</code></p><p>首先看 <code>FE*T1</code> 这里是指在取指周期 FE 中的 T1 节拍的所有机器指令都需要执行 M(MAR)-&gt;MDR 这个微操作。所以将 FE 周期信号线和 T1 节拍信号线做 and 运算，如果结果为 true 那么就确定此状态为取值周期中的 T1 节拍，因为无论任何指令都需要执行 M(MAR)-&gt;MDR 这个微操作，所以仅凭 FE 和 T1 两个信号就可以决定是否发送 M(MAR)-&gt;MDR 这个微指令的控制信号了。</p><p>后面的则是对其他周期可能执行情况的计算。分别是处于间址周期 IND 的 T1 节拍的 ADD STA LDA JMP BAN 指令，还有处于执行周期 EX 的 T1 节拍的 ADD LDA 指令。</p><p>将上面的计算式子进行化简，也就是将 T1 提出来，简化电路，然后就可以根据这个画出来计算电路了，只要有电路能够流入 IV 中，他就会向控制总线中发送自己存储的 M(MAR)-&gt;MDR 微操控制信号。</p><p><img src="https://xorex.space/image/275.jpg" alt="275.jpg"></p><h3 id="微指令-CU"><a href="#微指令-CU" class="headerlink" title="微指令 CU"></a>微指令 CU</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>将每一条机器指令编写成一个微程序，这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。</p><p>我们应该很清楚了微操作命令这个东西，比如上面一直使用的 M(MAR)-&gt;MDR 就是一个微操作命令。我们将能同时执行的微操作命令称为相容性微操作命令，不能同时执行的称为互斥性微操作命令。</p><p>我们可以将我们所需要的若干个相容性微操作命令组合编码成一个<strong>微指令</strong>，因为微指令控制器的核心就是将机器指令转化为若干个微指令，这若干个微指令组成的一个集合就是此机器指令的微程序。读取到机器指令之后从控制存储器中读取对应机器指令执行的微程序，然后依次解析微程序的组成：微指令，微指令里面就记录了该向控制总线发送哪个微操作的控制信号。</p><p>这里微指令里面微操作的组成类似于硬布线对微操作进行节拍安排，会将可容性微操作命令放到一个节拍中执行，同理，可以将可容性微操作命令放到一个微指令中执行。</p><p>就像下面这样，微指令中为 1 的位表示此位对应的微操作需要被执行：</p><p><img src="https://xorex.space/image/276.jpg" alt="276.jpg"></p><hr><ul><li><p><strong>微操作</strong>：一条机器指令可以分解成一个微操作序列，这些微操作是计算机中最基本的、不可再分解的操作。比如寻址中将 PC 地址放入 MAR 中：PC-&gt;MAR，就是一个不可分解的微操作。</p></li><li><p><strong>微命令</strong>：在微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为微命令，它是构成控制序列的最小单位。每个微操作都对应一个自己的微命令。</p></li><li><p><strong>微指令</strong>：此概念只存在于微指令控制器中，微指令是若干微命令的集合，微指令又分为操作控制字段和顺序控制字段，操作控制地段决定本微指令在一个节拍中需要被执行的所有微操作，顺序控制字段决定下一条微指令的地址。</p></li><li><p><strong>微程序</strong>：微指令的有序集合，一条机器指令的功能由一段微程序来实现。</p></li><li><p><strong>微周期</strong>：微周期通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。</p></li></ul><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>微指令控制器内部像是一个砍掉了 CU 和 ALU 的小主机，任务就是将传入的机器指令解析成对应微程序在控制存储器中的地址，在顺序逻辑器的控制下，依次读取微程序在存储器里面的每一条微指令，然后解析微指令将对应的微操作的控制信号发送给控制总线，作为整个大主机的控制信号。</p><p>需要说明的是，微指令里面不仅仅包括要之心干的微操作，还有下一条微指令的地址，下地址会被送入顺序逻辑器中，顺序逻辑器会自己判断使用微地址形成部件的地址还是 CMDR 送来的微地址，作为地址中转传入 CMAR 中，控制微程序的完整读取。</p><p><img src="https://xorex.space/image/277.jpg" alt="277.jpg"></p><h4 id="控制存储器"><a href="#控制存储器" class="headerlink" title="控制存储器"></a>控制存储器</h4><p>这里比较值得一说的就是控制存储器里面的结构，首先会将所有指令都会有的取值周期放到控制存储器的一个公共的部分，来减少存储占用。而组成指令的其他微程序则每个单独存储在一块中。</p><p><img src="https://xorex.space/image/278.jpg" alt="278.jpg"></p><h4 id="微指令"><a href="#微指令" class="headerlink" title="微指令"></a>微指令</h4><h5 id="水平和垂直"><a href="#水平和垂直" class="headerlink" title="水平和垂直"></a>水平和垂直</h5><p>水平型微指令：一次能够定义并执行多个并行操作。<code>操作控制 + 顺序控制</code> 微程序短，速度快。</p><p>垂直型微指令：微操作码决定微指令的功能。<code>微操作码 + 目的地址 + 源地址</code> 微指令短，速度慢。</p><h4 id="水平微指令编码"><a href="#水平微指令编码" class="headerlink" title="水平微指令编码"></a>水平微指令编码</h4><p>我们直接讲字段直接编码方式，水平微指令组成是 <code>操作控制 + 顺序控制</code>，我们先来看操作控制。</p><p>这里讲操作控制部分分段，每段经过<strong>译码</strong>之后发出一个微操作控制信号，分了多少段就能同时执行多少个微操作。所以分段原则为：</p><p><img src="https://xorex.space/image/279.jpg" alt="279.jpg"></p><p>（当然直接编码方式可以看图）</p><h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>设计原理如下图，具体的我也不会……</p><p><img src="https://xorex.space/image/280.jpg" alt="280.jpg"></p><h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><h3 id="指令流水线设计概念"><a href="#指令流水线设计概念" class="headerlink" title="指令流水线设计概念"></a>指令流水线设计概念</h3><p>流水线的设计是通过将机器指令的执行过程拆分成多个步骤，然后将每个步骤错开运行，来保证最大的硬件使用率。</p><p>比如将机器指令周期拆分为：取指，解码，执行，定位，回写。这五个步骤所用位置是不一样的，就可以同时执行不同的指令。一些设计的细节可以看图：</p><p><img src="https://xorex.space/image/281.jpg" alt="281.jpg"></p><h3 id="流水线设计影响因素"><a href="#流水线设计影响因素" class="headerlink" title="流水线设计影响因素"></a>流水线设计影响因素</h3><h4 id="资源冲突"><a href="#资源冲突" class="headerlink" title="资源冲突"></a>资源冲突</h4><p>指两个指令在同一时间争夺同一硬件资源导致的冲突。</p><p>解决方法：</p><ol><li>后一指令运行暂停一个周期。</li><li>进行硬件分组，比如将指令和数据分别存储到不同的存储器中，两个周期访问的硬件资源分开，从而避免资源冲突。</li></ol><h4 id="数据冲突"><a href="#数据冲突" class="headerlink" title="数据冲突"></a>数据冲突</h4><p>即前一个指令的计算结果，是下一个指令所需要的内容。这就导致下一个指令的执行必须等上一个指令完整执行结束才可以进行。</p><p>解决方法：</p><ol><li>硬件阻塞：发现这种情况的时候，就然下一条指令无限等待，直到上一条指令执行结束，数据能被访问到后再执行下一条指令。</li><li>软件插入 NOP：也就是编译器在编译代码的时候，就考虑这样的问题，在两个有数据冲突的指令之间，插入合适数量的不执行的空指令 NOP</li><li>数据旁路：将上一条指令执行出结果，但没存储的数据直接用旁路给下一条指令，不过这样电路设计就过于复杂了。</li><li>编译优化：编译器调整指令顺序，将两个数据冲突指令之间，插入不影响执行顺序的其他需要被执行的指令，尽可能利用资源。</li></ol><h4 id="控制冲突"><a href="#控制冲突" class="headerlink" title="控制冲突"></a>控制冲突</h4><p>由于控制相关的转移指令的存在，导致了流水线断流。</p><p>断流的解决方法就是尽快的将流接上，尽量不影响效率：</p><ol><li>尽早判断转移是否发生，然后填入应该执行的指令到流水线里。</li><li>将转移和不转移两种情况的指令都放到流水线里。</li><li>用统计学统计转移概率，然后将概率大的指令放入流水线中。</li></ol><h3 id="多发技术"><a href="#多发技术" class="headerlink" title="多发技术"></a>多发技术</h3><p>指令流水线的多发技术指的是：</p><h4 id="超标量技术"><a href="#超标量技术" class="headerlink" title="超标量技术"></a>超标量技术</h4><p>通过一种元器件复制多份，从而在实现流水线的同时，每个流水线阶段又能同时执行多个指令。如下图：</p><p><img src="https://xorex.space/image/282.jpg" alt="282.jpg"></p><p>这样的实现就需要对指令的顺序做一个优化，在编译程序的时候，将能够同时执行的指令放到一起。</p><h4 id="超流水技术"><a href="#超流水技术" class="headerlink" title="超流水技术"></a>超流水技术</h4><p>在一个时钟周期之内，在细分多段，也就是能在同一个时钟周期，将一个部件功能同时使用多次。</p><p><img src="https://xorex.space/image/283.jpg" alt="283.jpg"></p><h4 id="超长指令字"><a href="#超长指令字" class="headerlink" title="超长指令字"></a>超长指令字</h4><p>由编译器分析一些可以同时执行的指令，然后将这些指令的执行阶段合并成一条超长的指令字，然后设计多个相同部件来同时执行它们。</p><p><img src="https://xorex.space/image/284.jpg" alt="284.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CPU-的主要职责分析&quot;&gt;&lt;a href=&quot;#CPU-的主要职责分析&quot; class=&quot;headerlink&quot; title=&quot;CPU 的主要职责分析&quot;&gt;&lt;/a&gt;CPU 的主要职责分析&lt;/h2&gt;&lt;p&gt;CPU 需要有运算器和控制器两个基本的结构，然后完成大概下面的任务：</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-指令系统</title>
    <link href="https://xorex.space/2021/05/12/53570cd3ff73/"/>
    <id>https://xorex.space/2021/05/12/53570cd3ff73/</id>
    <published>2021-05-12T13:36:40.000Z</published>
    <updated>2021-05-17T06:52:19.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指令构成"><a href="#指令构成" class="headerlink" title="指令构成"></a>指令构成</h2><p>指令是由指令集架构定义的单个的 CPU 操作，指令包括一个操作码和地址码，操作码用来指示这条指令执行什么任务，地址码用来表示这条指令作用的对象的所在位置。</p><p>下面是对于指令的基本分析：</p><iframe src="https://www.xmind.net/embed/PNfh5B" width="800px" height="540px" frameborder="0" scrolling="no"></iframe><p>定长操作码很简单，按照指令数量的最大长度编号即可，但是地址码不是定长的，所以这样的话虽然操作码定长了，但是整体的指令不会定长。</p><p>而变长操作码，下面的图就是规划变长操作码对应不同数量的地址指令的一种方式，通过让操作码变长来适应不同长度的地址码，从而让整个指令定长：</p><p><img src="https://xorex.space/image/251.jpg" alt="251.jpg"></p><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><p>指令寻址指的是 CPU 去获取指令的方式，目前来说有两种寻址模式，分别为顺序寻址和跳跃寻址。</p><p>顺序寻址：借助于 PC (Programme Counter) 不断的地址 +1 实现的，实现也很简单，只需要将所有要执行的指令按照顺序在内存中放在一起即可。</p><p>跳跃寻址：当遇到跳跃指令的时候，往往会给出要 PC 跳到的指令的地址，就需要修改 PC 里面的内容，然后跳到对应的地址读取指令。</p><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><p>数据寻址方式就是指令在计算机中寻找要操作的对象的过程，有很多种：</p><p>大概的图：</p><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>立即寻址指形式地址 A 表示的就是操作数本身，也就是立即数，用补码表示，常用于常量的操作。</p><p>比如 C 语言里面写 X=2+5; 那么这条代码执行背后的指令一定是使用立即寻址的，不需要去内存中寻找数据，操作码后面就跟着数据 2 和 5 ，速度相当快，只需要访问一次主存即可。</p><p>但是这样就会导致数据可表示范围大大缩小，毕竟操作码占用了不少地方。</p><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>直接寻址：指的是地址码表示的就是数据在内存中的实际地址，直接按照地址码的标识去内存中找就可以拿到数据了。</p><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>间接寻址：指的是地址码表示并不是数据的地址，数据地址的地址。</p><p>需要先根据地址码表示的地址从内存中拿到另外一个地址，这个地址才是数据的真实地址，所以叫作间接寻址。当然间接寻址也分间接多少次，可以是一重间接寻址，二重间接寻址等等。</p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><h4 id="寄存器直接寻址"><a href="#寄存器直接寻址" class="headerlink" title="寄存器直接寻址"></a>寄存器直接寻址</h4><p>和直接寻址唯一不同的就是，它的地址表示的不是内存的地址，而是寄存器的地址，这样可以以最快的数据获取想要的数据。</p><h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>和间接寻址唯一不同的就是，它的地址表示的不是内存的地址，而是寄存器的地址，这样可以以最快的数据获取想要的数据。</p><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><p>就是可以通过操作码推断出来所需要的数据在什么地方，比如加法指令，相加是需要两个输入数的地址和结果写入的目的地址一共三个。但是因为加法器的设计就隐含了其中一个输入数就在 ACC 中，结果写入目的地址也在 ACC 中，所以因为隐含了两个的寻址，最终只需要一次寻址即可。</p><p><img src="https://xorex.space/image/252.jpg" alt="252.jpg"></p><h3 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h3><p>偏移寻址指的是地址码里面表示的地址都需要进行加法运算才可以获取到真正的地址，优点就是可以扩大寻址范围，并且用户不需要关心自己的实际地址在哪里，只要有相对于某个地址的偏移量即可。</p><h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><p>相对寻址，会直接在地址码的地方给出偏移量，这个偏移是相对于<strong>当前指令的下一条指令的地址</strong>做偏移的，因此会将偏移量和 PC 中的当前地址送入 ALU 中进行相加，获取真实地址。</p><p>之所以是下一条指令的地址的原因是 PC 在取出当前指令之后，会将自身的内容自动加一，所以实际上从 PC 中取出来的东西是当前执行的指令的下一条指令的地址。</p><p><img src="https://xorex.space/image/254.jpg" alt="254.jpg"></p><h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><p>首先先引入一个寄存器，基址寄存器（BR），里面存放的地址将作为基准地址。首先基址寻址的地址码表示一个偏移量，用补码表示，寻址的时候会将偏移量和基址寄存器一起放进 ALU 中执行加法运算。然后获取的结果作为一个内存地址去寻找操作数。</p><p>当然用通用寄存器代替基址寄存器也是可以的，那么就需要在地址码里面多加一个寄存器编号了，指明去哪个通用寄存器中寻找基本地址。</p><h4 id="改变址寻址"><a href="#改变址寻址" class="headerlink" title="改变址寻址"></a>改变址寻址</h4><p>首先引入一个寄存器，变址寄存器（IX），里面存放偏移量，而操作码里面的地址 A 表示基本地址，和 IX 里面的偏移量进行相加运算之后，获取真实地址。</p><p><img src="https://xorex.space/image/253.jpg" alt="253.jpg"></p><p>这玩意和上面的基址寻址基本相反，里面的变址寄存器是用户可控的，常用于遍历数组，将 A 作为数组首地址，不断迭代基址寄存器，就可以快速遍历整个数组了。</p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><p>属于隐含寻址的一部分，它隐含了地址为堆栈指针（StackPointer）的地址，没啥可讲的。</p><h2 id="CISC-和-RISC"><a href="#CISC-和-RISC" class="headerlink" title="CISC 和 RISC"></a>CISC 和 RISC</h2><p>Complex Instruction Set Computer 复杂指令集：X86。</p><p>复杂指令集的设计思路就是让一条指令执行一个复杂的任务。因此有以下特点：复杂庞大，指令不定长，不太好实现指令流水线。</p><p>Reduced Instruction Set Computer 精简指令集：RISC。</p><p>精简指令集的设计思路就是让一个复杂任务被多条指令执行。因此有以下特点：简单精简，指令定长，必须实现指令流水线。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;指令构成&quot;&gt;&lt;a href=&quot;#指令构成&quot; class=&quot;headerlink&quot; title=&quot;指令构成&quot;&gt;&lt;/a&gt;指令构成&lt;/h2&gt;&lt;p&gt;指令是由指令集架构定义的单个的 CPU 操作，指令包括一个操作码和地址码，操作码用来指示这条指令执行什么任务，地址码用来表示</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-深入虚拟内存</title>
    <link href="https://xorex.space/2021/05/12/d1cccaf324ae/"/>
    <id>https://xorex.space/2021/05/12/d1cccaf324ae/</id>
    <published>2021-05-12T13:36:22.000Z</published>
    <updated>2021-05-20T10:36:16.484Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文转自与 知乎-安佳玮 <a href="https://zhuanlan.zhihu.com/p/61587598">深入虚拟内存（Virtual Memory，VM）</a></li></ul><p>我们应该知道<strong>物理内存（Physical Memory）</strong>指的是硬件上的内存，即 RAM。它通常指的是插在主板上的内存条，给进程提供临时数据存储的设备。因为 CPU 可以直接从物理内存中读取数据和指令，所以物理内存又叫做主存。</p><p><strong>虚拟内存（virtual memory，VM）</strong>又叫做虚拟存储 **(virtual storage)**，是一种内存管理技术。它是操作系统提供的一种对主存的抽象。虚拟内存的实现由操作系统软件和硬件结合完成，包括硬件异常、地址翻译、磁盘文件、内核程序等。</p><p>本文将深入虚拟内存的实现机制，讨论它是怎么将磁盘和主存结合共同提供这种抽象的。</p><h2 id="虚拟内存解决了什么问题？"><a href="#虚拟内存解决了什么问题？" class="headerlink" title="虚拟内存解决了什么问题？"></a>虚拟内存解决了什么问题？</h2><p>1）虚拟内存给进程提供了一个更大的内存空间，不再受物理内存大小的限制。它将物理内存看作是存储在磁盘上的地址空间的缓存。 现在的电脑好一点的差不多就是 16GB 或者 32GB 的内存，而且内存越大，肯定就越贵。那如果只有物理内存，在很多情况下根本不够用，特别是需要运行很多程序的情况下。而磁盘空间相对来说是很便宜的，即使是 SSD，在同样的容积下也便宜太多了。虚拟内存技术在主存中只保留活动区域，然后根据需要在磁盘和主存之间来回传送数据，这样，它就可以更加高效的利用主存。</p><p>2）虚拟内存为程序提供内存管理。我们在敲代码的时候，不需要考虑这个变量会不会被其它程序错误的修改。因为虚拟内存帮我们做了这些事情，它给程序提供了内存隔离，为程序提供了安全的共享物理内存的途径。使得每个进程的地址空间不会被其它进程破坏。 比如说我们在程序中定义了一个指针，并且为它分配了空间，这块内存最终会分配到物理内存上。你不用担心其它程序会分配相同的物理内存。</p><p>3）虚拟内存技术也给每个进程提供了一致的、完整的地址空间。比如在操作系统上执行若干个进程，每个进程都有相同的地址空间，都在同样的起始位置放置了堆、栈以及代码段等。这样，它简化了像链接器、加载器这样的程序的内存管理。</p><h2 id="内存管理单元——页（Page）"><a href="#内存管理单元——页（Page）" class="headerlink" title="内存管理单元——页（Page）"></a>内存管理单元——页（Page）</h2><p>前文我们已经了解过，虚拟内存将主存视为磁盘的缓存，主存和磁盘上会通过数据传输来完成同步。然而，磁盘（特别是机械磁盘）的设计不能快速的读取或者写入一个字节一个字节的数据，因为它的<strong>随机读写</strong>性能比较差。比如系统要读取一个数组的所有数据，它就要访问数组的所有内存，而如果这些内存不在主存中，就得从磁盘上去装载数据到主存。那么如果是一个字节一个字节的读，可能就要在磁盘和主存之间传输 N 次数据，这样就会导致性能变得很差。</p><p>另外我们得为每个字节记录点什么信息，才可以知道这个内存是否已经被分配了，是否已经存在于主存中了。如果是按照一个字节一个字节的记录，那我们的大部分内存空间会用在了信息记录上面，而不是用于数据存储。</p><p>所以要想虚拟内存获得比较高的性能和内存利用率，必须由另外一种机制来提供。通过将虚拟内存分割为<strong>虚拟页（Virtual Page, VP）</strong>的大小固定的块来解决这些问题。也就是说，在磁盘和主存中传输数据，每次至少传输一个虚拟页，记录内存信息，也是按照虚拟页来记录。即虚拟页是磁盘和主存的数据传输和管理单元。这样如果是访问刚才那个数组，大部分情况下只要在磁盘和主存之间传输一次数据就够了（当然如果你的数组内存占用比较大，超过了一个虚拟页所能表示的大小，就要传输多次，但也比一个字节一个字节传输来得快非常多）。</p><p>和虚拟页对应的还有<strong>物理页</strong>，概念和虚拟页基本相同，除了它是存储在主存中的。因为是按照页作为传输单元的，所以物理页和虚拟页的大小一致。</p><p>一个虚拟页的大小通常通常由处理器的结构决定，一般情况下系统中的页大小都是一致的，比如说都是 4KB。当然，有些处理器还支持同时存在多个页大小。虚拟页的大小可以通过 sysconf 函数查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* sysconf(3) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The page size for this system is %ld bytes.\n&quot;</span>,</span><br><span class="line">           sysconf(_SC_PAGESIZE)); <span class="comment">/* _SC_PAGE_SIZE is OK too. */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="虚拟寻址"><a href="#虚拟寻址" class="headerlink" title="虚拟寻址"></a>虚拟寻址</h2><p>那一个进程可以用的内存究竟是多大呢？这主要受两方面的限制：</p><p>1）设置的<strong>交换空间</strong>的大小与物理内存大小的总和，虚拟内存存储在磁盘上面的空间就叫做交换空间，它通常对应一个文件或者是一个分区。所有进程共享同一个交换空间。如果交换空间和物理内存都被耗尽了，那么就不能再分配内存了。</p><p>2）进程可用的内存大小还受<strong>虚拟地址空间</strong>大小的影响。当一个进程的虚拟地址空间的所有地址都被分配了，那也不能再分配内存了。</p><p>在 32 位的程序中，由于指针的大小是 4 字节，所以它只能访问地址为 [0, 2^32) 的内存，它的地址数的总和是 4GB。而在 64 位的程序中，它能访问的地址范围是 [0, 2^64)，地址数的总和为 16EB (E = 2^60,exa,千兆兆)。</p><p>上面说的范围，如 [0, 2^32）表示的就是<strong>虚拟地址空间</strong>，指的是进程所能访问的所有的虚拟内存地址的集合。虚拟地址空间主要受程序的位数影响。除此之外，它还受 CPU 的实现的影响，比如 i7 处理器，它所支持的虚拟地址空间的范围是 [0, 2^48），即 256TB，不过一般这也够了。</p><p>除了虚拟地址空间之外，还有一个叫做<strong>物理地址空间</strong>的东西。顾名思义，物理地址空间表示的是所有能访问的物理地址的集合，它受计算机的主存大小影响。比如说，计算机的内存是 4GB，那么物理地址空间就是 [0, 2^32)。</p><p><strong>虚拟寻址</strong> 的意思就是将 <strong>虚拟地址空间</strong> 中的地址翻译成 <strong>物理地址空间</strong> 中的地址，然后再执行相关的读指令或者写指令。</p><h3 id="页表（Page-Table）"><a href="#页表（Page-Table）" class="headerlink" title="页表（Page Table）"></a>页表（Page Table）</h3><p>页表是记录页的状态的表，不同的进程间的页表是独立的。页表中的项叫做<strong>页表项（Page Table Entry, PTE）</strong>。</p><p>PTE 的数量为 <code>X=N/P</code>，其中 N 表示虚拟地址空间中的地址数量，P 表示页的大小。可以看出，在虚拟地址空间大小不变的情况下，页的大小越大，那么 PTE 的数量就越少；页的大小越小， PTE 的数量就越多。</p><p>PTE 记录了很多信息，这里列举几个重要的：</p><ol><li>有效位(P)，它标识对应的虚拟页面是否在物理内存中。</li><li>关联的物理页地址（Base addr），它表示的是对应的虚拟页存储在物理内存中的哪一页。</li><li>读写访问权限（R/W），表示对应的页是否为只读的，或者是可读可写的。</li><li>超级权限（U/S）表示该页是否只允许内核模式访问，还是用户模式也可以访问。</li><li>修改位（D），表示被加载到物理内存之后，页面的内容是否发生了修改。</li></ol><h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>PTE 按照<strong>虚拟页索引（VPN）</strong>排序，比如第 0 页位于的起始位置，第 1 页位于第 0 页后面，依此类推。VPN 是根据虚拟地址、页大小算出来的，比如页大小为 4KB，那第 0 页的地址就是页表的起始地址，第 1 页的地址就是页表地址+页大小，即 0x00001000。位于第 0 页和第 1 页之间的地址都属于第 0 页。</p><p>假设页大小为 4KB，地址空间为 32 位。系统将虚拟地址视为两部分组成，前 20 位表示页索引（VPN），后 12 位表示页偏移（VPO）。如果根据虚拟地址(VA)来写一个获取页索引(VPN)的公式就是： <code>VPN=VA&gt;&gt;12</code>。因为页大小是 4KB，所以一个虚拟地址需要使用 12（ 2^12=4KB ）位来描述这个地址在某页中的偏移量。那么剩下的位就用来索引 PTE。</p><p>在 CPU 中地址翻译由一个叫做 <strong>MMU（Memory Management Unit，内存管理单元）</strong>的硬件完成。 MMU 接收一个虚拟地址，并且输出一个物理地址。如果这个虚拟地址在物理内存中存在，那么就叫做页命中。如果这个虚拟地址在物理内存中不存在，那么 MMU 将产生一个<strong>缺页错误</strong>。</p><p>下图展示了 MMU 如何利用页表来实现虚拟地址到物理地址的映射。n 位的虚拟地址包括两个部分：一个 p 位的虚拟 VPO，和一个 n-p 位的 VPN。MMU 利用 VPN 来选择适当的 PTE。将 PTE 中的<strong>物理页号（PPN）</strong>与 VPO串联起来，就得到了相应的物理地址。注意：<strong>物理页面偏移（PPO）</strong>和 VPO 是相同的。</p><p><img src="https://xorex.space/image/243.jpg" alt="243.jpg"></p><p>下面具体描述页命中和缺页的处理流程。</p><h4 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h4><p>页命中指的是当 MMU 需要根据虚拟地址输出物理地址时，这个地址所在的页已经被装载到物理内存中了。即对应的 PTE 的有效为为 1。</p><p>下面是页命中时的地址翻译的过程：</p><ol><li>处理器生成一个虚拟地址，并把它传送给 MMU</li><li>MMU 生成根据虚拟地址生成 VPN，然后请求高速缓存/主存，获取 PTE 的数据。</li><li>高速缓存/主存向 MMU 返回 PTE 的数据</li><li>从 PTE 获取对应的物理页号 PPN。用物理页的基址加上页偏移 PPO（假设页大小为 4KB，那么页偏移就是虚拟地址的低 12 位，物理页的页偏移和虚拟页的页偏移相同），获取对应的物理地址。</li><li>主存/高速缓存将数据返回给 CPU。</li></ol><p><img src="https://xorex.space/image/244.jpg" alt="244.jpg"></p><h4 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h4><p>缺页是指当 CPU 请求一个虚拟地址时，虚拟地址所对应的页在物理内存中不存在。此时 MMU 会残生缺页错误，然后由内核的缺页处理程序从磁盘中调入对应的页到主存中。在处理完成后，CPU 会重新执行导致错误的指令，从而读取到对应的内存数据。</p><p>下面是缺页时的地址翻译的过程（第 1 步到第 3 步与页命中时相同）：</p><ol><li>处理器生成一个虚拟地址，并把它传送给 MMU</li><li>MMU 生成根据虚拟地址生成 VPN，然后请求高速缓存/主存，获取 PTE 的数据。</li><li>高速缓存/主存向 MMU 返回 PTE 的数据</li><li>由于判断出 PTE 的有效位是 0，所以 CPU 将出发一次异常，将控制权转移给内核中的缺页异常处理程序。</li><li>缺页异常处理程序确定出物理内存中的牺牲页，如果这个页面被修改过了（D 标志位为 1），那么将牺牲页换出到磁盘。</li><li>缺页处理程序从磁盘中调入新的页面到主存中，并且更新 PTE</li><li>缺页处理程序将控制权返回给原来的进程，再次执行导致缺页的指令。再次执行后，就会产生页命中时的情况了。</li></ol><p><img src="https://xorex.space/image/245.jpg" alt="245.jpg"></p><h4 id="翻译加速"><a href="#翻译加速" class="headerlink" title="翻译加速"></a>翻译加速</h4><p>从页命中的流程图中可以看出，CPU 每次需要请求一个虚拟地址，MMU 就需要从内存/高速缓存中获取 PTE ，然后再根据 PTE 的内容去从物理内存中加载数据。</p><p>这样在最坏的情况下，相当于从内存/高速缓存中多读取了一次数据。许多 MMU 包含了一个关于 PTE 的小缓存，叫做 <strong>TLB（Translation Lookaside Buffer，翻译后备缓冲器）</strong>来消除这样的开销。</p><p>TLB 将虚拟内存的 VPN 视为由索引和标记组成，<strong>索引部分（TLBI）</strong>用来定位 TLB 中的缓存数据项，<strong>标记部分（TLBT）</strong>用来校验存储的数据项是否为指定的 VPN 对应的数据。</p><p><img src="https://xorex.space/image/246.jpg" alt="246.jpg"></p><p>如果 TLB 命中了，那么所有的地址翻译步骤都是在 MMU 中执行的，所以非常快。下面是 TLB 命中时的操作流程</p><ol><li>处理器生成 1 个虚拟地址</li><li>MMU 向 TLB 请求 PTE</li><li>TLB 返回 PTE 到 MMU</li></ol><p>如下图所示，其中第 4 步和第 5 步与之前的流程一致。</p><p><img src="https://xorex.space/image/247.jpg" alt="247.jpg"></p><p>如果 TLB 未命中，MMU 就必须从高速缓存/内存中获取相应的 PTE，然后将新取出来的 PTE 放在 TLB 中。如下图所示</p><p><img src="https://xorex.space/image/248.jpg" alt="248.jpg"></p><p>理解 TLB 需要注意的是，因为不同进程的页表内容是不一致的，因此内核在切换上下文时，会重置 TLB。</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>前文有提到过，PTE 的数量由虚拟地址空间的大小和页大小决定。也就是：X=N/P。那如果我们有一个 32 位的物理地址空间、4KB 的页面和 一个 4 字节的 PTE。即使程序只使用了一小部分虚拟地址空间，也总是需要一个 4MB （ 4*2^32/2^12 )的页表常驻主存。对于 64 位的系统来说，情况将变得更加复杂。</p><p>设计者非常聪明，它将页表设计成一个包括多级的层次结构来解决这个问题。</p><p>下图展示了一个两级页表的层次结构。二级页表中的每个 PTE 项都负责一个 4KB 页面，而一级页表中的每个 PTE 负责 1024 个二级页表项。</p><p><img src="https://xorex.space/image/249.jpg" alt="249.jpg"></p><p>注意，常驻内存的只是一级页表，系统可以在需要时才创建、页面调入二级页表。这样就减少了主存的压力。另外如果一级页表中的一个 PTE 是空的，那么相应的二级页表就根本不存在。这样在一个只需要少量内存的程序上，绝大部分二级页表是不存在的。</p><p>下图展示的是一个 k 级层次页表的结构图，起始就是将 VPN 部分划分为多个段，每个段都代表某一级页表。而每一级中的 PTE 的 Base addr 为下一级提供入口地址。最后一级的 Base addr 则表示最终物理地址的 PPN。</p><p><img src="https://xorex.space/image/250.jpg" alt="250.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;本文转自与 知乎-安佳玮 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/61587598&quot;&gt;深入虚拟内存（Virtual Memory，VM）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们应该知道&lt;strong&gt;物理内存（Physica</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
