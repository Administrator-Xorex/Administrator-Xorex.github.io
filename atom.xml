<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xorex</title>
  
  <subtitle>要去热爱每一天的生活啊！</subtitle>
  <link href="https://xorex.space/atom.xml" rel="self"/>
  
  <link href="https://xorex.space/"/>
  <updated>2021-03-09T12:42:11.406Z</updated>
  <id>https://xorex.space/</id>
  
  <author>
    <name>Xorex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>创建形模式笔记</title>
    <link href="https://xorex.space/2021/03/09/6c55278fa9ef/"/>
    <id>https://xorex.space/2021/03/09/6c55278fa9ef/</id>
    <published>2021-03-09T11:49:46.000Z</published>
    <updated>2021-03-09T12:42:11.406Z</updated>
    
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="设计模式" scheme="https://xorex.space/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>新笔记计划</title>
    <link href="https://xorex.space/2021/03/09/44081a19925f/"/>
    <id>https://xorex.space/2021/03/09/44081a19925f/</id>
    <published>2021-03-09T11:45:19.000Z</published>
    <updated>2021-03-09T12:40:23.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于笔记记录的一点思考"><a href="#关于笔记记录的一点思考" class="headerlink" title="关于笔记记录的一点思考"></a>关于笔记记录的一点思考</h2><p>今天在记录创建型模式的时候发现这种需要大段文字描述的知识点并不适合使用思维导图，所以后面讲解设计模式具体的案例的时候，会重新回归笔记的方式，emmmm，或者说是，笔记+思维导图。</p><p>自己以前好像一直在滥用思维导图，现在想想思维导图应该是为了帮助自己更加清晰的梳理关系，归纳知识点，而不是一味的将所有的学习内容都用思维导图罗列表示出来。</p><p>所以应该两者一起使用，并再多学习一些 XMind 的模板，主要将思维导图作为关系展示图。而对于详细某些知识点的理解，应该还是要用文字和代码一起说明。</p><p>新的笔记应该聚焦于一些核心知识点的记录，而不是用来引导萌新的新手教程，尽可能写的简练而又全面。笔记的目的是为了自己以后遗忘了某块知识，需要查阅的时候，可以快速定位并快速提取出来需要的信息。</p><p>目前的打算是，对于一个全新的知识点，首先有一个概览笔记，主要是梳理所有内容的联系和一些基本名词的解释，然后再用若干篇小文章来分别阐述不同的具体知识。而对于一些类的方法的列出，或者命令的集合，还是使用思维导图比较合适归纳。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于笔记记录的一点思考&quot;&gt;&lt;a href=&quot;#关于笔记记录的一点思考&quot; class=&quot;headerlink&quot; title=&quot;关于笔记记录的一点思考&quot;&gt;&lt;/a&gt;关于笔记记录的一点思考&lt;/h2&gt;&lt;p&gt;今天在记录创建型模式的时候发现这种需要大段文字描述的知识点并不适合使</summary>
      
    
    
    
    <category term="阶段性总结" scheme="https://xorex.space/categories/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="笔记" scheme="https://xorex.space/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="规划" scheme="https://xorex.space/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>设计模式原则思维导图</title>
    <link href="https://xorex.space/2021/03/09/ebff1b4e77e7/"/>
    <id>https://xorex.space/2021/03/09/ebff1b4e77e7/</id>
    <published>2021-03-09T11:44:41.000Z</published>
    <updated>2021-03-09T12:17:50.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式原则思维导图"><a href="#设计模式原则思维导图" class="headerlink" title="设计模式原则思维导图"></a>设计模式原则思维导图</h2><iframe src="https://www.xmind.net/embed/73pZXu" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设计模式原则思维导图&quot;&gt;&lt;a href=&quot;#设计模式原则思维导图&quot; class=&quot;headerlink&quot; title=&quot;设计模式原则思维导图&quot;&gt;&lt;/a&gt;设计模式原则思维导图&lt;/h2&gt;&lt;iframe src=&quot;https://www.xmind.net/embed/</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="设计模式" scheme="https://xorex.space/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>中文编码与开发</title>
    <link href="https://xorex.space/2021/03/07/b688fb992b28/"/>
    <id>https://xorex.space/2021/03/07/b688fb992b28/</id>
    <published>2021-03-07T09:42:27.000Z</published>
    <updated>2021-03-08T12:59:51.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>其实原本是想写一个 Java 脚本来帮我处理下载视频的名字更改，但是因为编码的问题让我非常生气，Windows 文件用 GBK 编码，再加上和 char 的 Unicode、String 的 byte[] 以及输入法输入的编码问题，直接把我搞蒙了，String 自带的一些方法用的云里雾里，能否正确全看玄学。为了能够一劳永逸的解决中文编码问题，于是此文就这样诞生了。</p></blockquote><h2 id="编码发展历史"><a href="#编码发展历史" class="headerlink" title="编码发展历史"></a>编码发展历史</h2><h3 id="ASCII-编码时代"><a href="#ASCII-编码时代" class="headerlink" title="ASCII 编码时代"></a>ASCII 编码时代</h3><p>最开始的开始，因为计算机发明在美国，所以计算机的字符是使用 ASCII 作为编码方式的，这让英语系国家们用的很开心，只需要 1 个字节就可以轻松的表示自己所有的字符，只占用 0-127，其中有 33 个控制字符，94 个可显字符。</p><p>后来，为了加入一些其他必要的符号，比如带重音的字母（法国人狂喜），希腊字母（希腊人狂喜），特殊的拉丁符号（罗马人狂喜），特殊的计算符号（科学家狂喜）等等等等。欧洲的发达国家开始打 ASCII 没有使用到的 128-255 这个区间的主意，出现了一堆各种各样的 EASCII 编码方式，即拓展 ASCII，用的比较多的有两个：OEM EASCII 和 ANSI EASCII 。</p><p>虽说扩展了整整一倍，但是因为所能表示的字符还是太少了，其他国家并不乐意，所以 EASCII 就很快的退出历史舞台，现在搜索 ASCII 一般搜索的都是 0-127 的初始版本。</p><h3 id="ANSI-编码时代"><a href="#ANSI-编码时代" class="headerlink" title="ANSI 编码时代"></a>ANSI 编码时代</h3><p>而非英语国家的人们为了使用计算机，也纷纷开始开发自己本国的文字编码方式，在 ANSI (American National Standards Institute) 的牵头下，各国的文字编码方式被 ANSI 承认之后，会作为该国文字的国际标准编码，叫作 ANSI 编码。 ANSI 编码是一种基于 ASCII 的变长编码，而且是固定的两个字节大小，前 128 个是 ASCII ，后面的是本国的文字。</p><p>虽然不同的国家都有了自己文字的编码方式也都快乐的用上了计算机，但各个文字的 ANSI 编码并不互通，导致了一种 ANSI 文字编码的文件里面不可以有其他国家的文字，否则就会乱码。</p><h4 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h4><p>中国显然也参与了这个过程中来，在 1980 年的时候，中国指定了汉字的 ANSI 编码：GB2312 即国标 2312 ，一共收录了 6763 个汉字，一级汉字 3755 个，二级汉字 3008 个，同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的 682 个字符。这个字符集基本上覆盖了中国大陆 99.75% 的使用频率（因为繁体中文不在里面）。而 GB2312 的编码方式如下：</p><ul><li><p>GB2312 将稀少的两个字节分为了区字节（0xB0-0xF7 87个区）和位字节（0xA1-0xFE 94个位），用一个区字节和一个位字节结合起来来表示一个汉字。</p></li><li><p>之所以从 0x80 128 和 0xA1 161 开始表示区字节和位字节，就是为了照顾 ASCII 字符可以被单个字节表示，只要检测到字符大小小于 128 ，那么这就是一个 ASCII 字符，读取一个字节即可。如果大于等于 128，那么就说明这是一个汉字，读取两个字节，并按照组合出来的编号显示汉字。</p></li></ul><h4 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h4><p>但是，可怜的 GB2312 当时设置的比较草率，还有很多的空间没有使用，再加上 6763 个汉字真的是太少了，于是在 1995 年的时候，又搞了一个汉字的 ANSI 编码，叫作 GBK 编码，国(G)标(B)扩展(K)。这个 GBK 编码覆盖了 21886 个字符，增加了额外的汉字，繁体字，日文假名等等（但是不支持朝鲜字），现在还是 Windows 默认的文字编码方式。</p><ul><li>GBK 完全兼容 GB2312。并将位字节从 0x00 开始表示汉字，因为只要区字节大于 128 即可确定后面跟着的就是位字节而不是 ASCII，然后很好的利用了 GB2312 没有分配的空间，成功的容纳了绝大部分日常使用汉字。</li></ul><h4 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h4><p>但是，两个字节的极限就是容纳 2^16 个字符，是不可能容纳所有的汉字的，所以后来又改良 GBK 出来了一个 GB18030 ，这玩意终于将整个汉字+少数民族文字全部都编到了一起。</p><ul><li>GB18030 之所以能把中国所有的文字都搞到一起，是因为它最大长度是四个字节，其中一个字节和两个字节和 GBK 基本兼容。四个字节扩充了 6k+ 的字符，完成了汉字的所有收录（注意 GB18030 是没有三个字节的情况的）。</li></ul><h3 id="Unicode-时代"><a href="#Unicode-时代" class="headerlink" title="Unicode 时代"></a>Unicode 时代</h3><p>虽说 ANSI 解决了非英语国家使用计算机的问题，但是对于网上传输其他国家的文字，因为使用 ANSI 编码不同，会导致无法解析，比如韩国电脑解析不出来 GBK 编码的文字，打开直接乱码。</p><p>随着计算机存储元器件价格的大幅度下降和全球互联网的快速发展，统一文字编码方式让不同文字的展现无障碍越来越重要。为了将所有的文字都制定一个标准之中，让所有人都能解析所有文字，Unicode 字符集就诞生了，立志于给所有文字都编上号。最初版本的 Unicode 只有两个字节，而分给 CJK 系列字符的只有两万个，导致只有最常用的 CJK 字符才能被编写到 Unicode 里面，后来经过一段曲折与斗争，Unicode 终于扩展字节，发展成为了真正的万国码。</p><ul><li><p>现在 Unicode 字符集的空间规划是按照空间平面的方式进行的，为 0-16 平面，每个平面占用两个字节，可以表示 2^16 个字符。其中最初版本的 Unicode 表示的字符为 0 号平面，被称为 BMP <code>Basic Multilingual Plane</code> 基本语言平面，表示范围为：U+0000 到 U+FFFF，可以省略最前面的平面编号，占用两个字节。而剩下的字符都在辅助平面 SMP 上面，从 U+010000 一直到 U+10FFFF，占用三个字节。</p></li><li><p>基本上 BMP 就覆盖了世界上大多数语言的绝大多数使用情景，但是要明白的是 SMP 的产生，对于 CJK 国家来说意义重大。这意味着在通用的语言字符集里面，东亚文化可以完整的保留下来，一个汉字的不同书写、演化方式，各种生僻字，这些都是绝对不允许被科技的发展而被忽略和抛弃的。</p></li></ul><p>需要注意的是，Unicode 并不是一种编码方式，而是一个字符集，它只会给字符一个独一无二的编号，而不会规定这个字符如何在计算机种存储。规定如何在计算机中存储的是编码方式，如比较早的 UTF-16 编码，它使用两个字节或者四个字节来编码字符，对于 BMP 平面上的字符，使用两个字节，对于 SMP 平面上的字符，使用四个字节。</p><ul><li>UTF-16 中，两个字节和四个字节读取区分很简单，首先都按照两个字节读取，如果读取结果在 BMP 上面有实际的字符，那么就断定这是一个 BMP 字符。如果没有实际的字符，即 U+D800 到 U+DBFF（此区间为空区间），那么就四个字节连在一起读取，判断为 SMP 平面字符。四个字节一共保存了 2^20 位有效信息，对应着 16 个 2^16 个 SMP 字符。</li></ul><p>Unicode 并没有在英语系国家快速发展开来，因为他们的大量内容都是使用 ASCII 来编码的，UTF-16 不但不兼容 ASCII，还要让他们白白的多使用一个字节的空间来存储一个字符，于是基于 Unicode 字符集的新编码方式： UTF-8 就诞生了。</p><p>UTF-8 的最大特性就是可变字符长度，对于 ASCII 的字符，编码方式和 ASCII 相同，都只占用一个字节的空间。非 ASCII 的字符也根据 Unicode 编码占用 2-4 个字符，这样就不但不需要改变原来使用 ASCII 编码的信息，还符合和其他文字一起用的标准，并且能节省大量的空间。由于这些优良的特性，使得 UTF-8 编码快速成为了互联网上最流行的文字编码形式。</p><ul><li>UTF-8 规定，对于 ASCII 的字符，占用一个字节，开头标识为 0，后面 7 位存储数据。对于非 ASCII 字符，占用几个字节，那么第一位字节开头就有几个 1，用 0 标识结束，后面跟着的字节开头设为 10。比如三字节的汉字：1110XXXX 10XXXXXX 10XXXXXX 。</li></ul><h2 id="Windows-编码"><a href="#Windows-编码" class="headerlink" title="Windows 编码"></a>Windows 编码</h2><p>因为计算机的内存中需要使用固定长度来保存字符，所以使用了 Unicode 字符集的 UTF-16 来编码存储数据，而对于内容的存储，则会将内存中的 UTF-16 转化为 GBK/UTF-8/GB18030 这些编码方式然后保存，使用 UTF-16 一是因为当时最新的 Unicode 标准就是 UTF-16 ，其次是当时 UTF-16 定长编码，无论是什么数字，都是两个字节，对于在内存中快速定位非常方便（当然现在随着 Unicode 的扩充，UTF-16 还有四个字节的），使用 GBK/UTF-8/GB18030 存储是为了节省存储空间和方便网上传输。</p><p>在 Windows 里面，打开文档的时候，会将硬盘里面用 GBK/UTF-8/GB18030 存储的数据转化为 UTF-16 ，然后放进内存里。我们看到的东西其实都是存在于内存中的。互联网上的网页也是，返回请求的数据使用 UTF-8 编码，浏览器接收之后，会解码为 UTF-16 并放到内存中，然后才能展示给我们看。我们在复制显示的数据的时候，其实都是 UTF-16 编码，粘贴到文档里面的时候，也是将 UTF-16 编码转移到对应应用程序的内存区中，最后这个应用程序将数据保存到硬盘的时候，才会将内存的 UTF-16 数据转化为定义的保存编码格式。</p><p>所以根本不需要担心复制粘贴的可以看见的数据的编码问题，只要我们能看见（打开到了内存中），不是乱码，就全部都是正确的 UTF-16。我们唯一需要担心的是保存在硬盘里面的数据，因为不知道保存的时候是按照 GBK/UTF-8/GB18030 等等的哪种编码方式保存，所以打开的时候选择的解码方式，<strong>复制</strong>的时候也需要注意前后文件存储编码是否相同（因为直接复制文本，没有经过内存的 UTF-16 转化）。</p><h2 id="输入法原理"><a href="#输入法原理" class="headerlink" title="输入法原理"></a>输入法原理</h2><p>输入法作为一个应用程序，本质上还是向另外一个应用程序的内存中写入 UTF-16 编码，因为其他的应用程序用拿到的都是确定的 UTF-16 所以输入法输入时不需要担心编码问题的。</p><h2 id="Java-中的编码"><a href="#Java-中的编码" class="headerlink" title="Java 中的编码"></a>Java 中的编码</h2><p>在创造 Java 的时候，当时最流行的 Unicode 编码就是两个字节的 UTF-16，所以就给 Java 的 char 类型设置了两字节的空间，并使用 UTF-16 作为 char 类型的存储方式，所以 Char 只能标识 BMP 范围里面的字符。</p><p>对于 String 来说，同样是使用 UTF-16 作为编码方式，不过内部存储时使用 byte[] 而不是 char[]。这是因为以前使用 char[] 来实现 String 的时候，对于 SMP 的字符因为受 char 两个字节大小的制约而部分四字节编码无法显示，改为 byte[] 之后，就没有这个问题了，即使是四字节的 SMP 字符，一样可以很好的处理。</p><p>而<strong>最需要注意</strong>的是，String 保存的 UTF-16 格式的开头，会有一个 BOM byte-order mark 字节顺序标记，用一 0xff 和 0xfe 的顺序标识。0xfe 0xff 标识大端序（位数大的在左边，适合人阅读），反之标识小端序（位数小的在左边，适合计算机阅读）。我们平时处理获取的 UTF-16 编码一般来说是大端序，直接忽略最前面返回的 0xfe 和 0xff 两个字符即可。</p><p>而 JVM 打开 <code>.java</code> 文件进行编译运行的时候，会使用系统默认的编码方式打开文件，比如 Windows 存储中文到硬盘里面的默认编码方式就是 GBK，使用 Vscode 写的 UTF-8 编码的中文无法让 JVM 正确解码，就会出错。要么更改 VScode 保存编码为 GBK，要么编译加参数更改打开文件编码为 UTF-8。或者直接用 IDEA，保存打开方式都是 UTF-8，不存在编码问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;其实原本是想写一个 Java 脚本来帮我处理下载视频的名字更改，但是因为编码的问题让我非常生气，Windows 文</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="笔记" scheme="https://xorex.space/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="中文编码" scheme="https://xorex.space/tags/%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java函数式编程</title>
    <link href="https://xorex.space/2021/03/05/728260c40cfe/"/>
    <id>https://xorex.space/2021/03/05/728260c40cfe/</id>
    <published>2021-03-05T08:01:05.000Z</published>
    <updated>2021-03-05T10:22:05.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><blockquote><p>搞了两天的函数式编程终于弄完了，也明白了这种设计方法和理念，下一步，Java 设计模式！</p></blockquote><iframe src="https://www.xmind.net/embed/bvBmma" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; title=&quot;函数式编程&quot;&gt;&lt;/a&gt;函数式编程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;搞了两天的函数式编程终于弄完了，也明白了这种设计方法和理念，下一步，Java 设计模式！&lt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="函数式" scheme="https://xorex.space/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JDBC思维导图</title>
    <link href="https://xorex.space/2021/03/02/9a53fb3643d5/"/>
    <id>https://xorex.space/2021/03/02/9a53fb3643d5/</id>
    <published>2021-03-02T14:43:19.000Z</published>
    <updated>2021-03-02T14:50:56.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDBC-思维导图"><a href="#JDBC-思维导图" class="headerlink" title="JDBC 思维导图"></a>JDBC 思维导图</h2><blockquote><p>在 JAVA 中，如何用代码和数据库进行交互呢？JDBC 告诉你答案！</p></blockquote><iframe src="https://www.xmind.net/embed/y3kVuZ" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JDBC-思维导图&quot;&gt;&lt;a href=&quot;#JDBC-思维导图&quot; class=&quot;headerlink&quot; title=&quot;JDBC 思维导图&quot;&gt;&lt;/a&gt;JDBC 思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在 JAVA 中，如何用代码和数据库进行交互呢？JDBC </summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SQL" scheme="https://xorex.space/tags/SQL/"/>
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="JDBC" scheme="https://xorex.space/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>SQL基本语句思维导图</title>
    <link href="https://xorex.space/2021/03/02/726651d44320/"/>
    <id>https://xorex.space/2021/03/02/726651d44320/</id>
    <published>2021-03-02T14:40:32.000Z</published>
    <updated>2021-03-02T14:50:59.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL-基本语句思维导图"><a href="#SQL-基本语句思维导图" class="headerlink" title="SQL 基本语句思维导图"></a>SQL 基本语句思维导图</h2><blockquote><p>其实暑假学习安全的时候，就学过一部分 SQL 的相关语句，但是都忘了，好在有了前面的基础，很快就复习好了，并且完成了这个思维导图，感觉更清晰了一点。</p></blockquote><iframe src="https://www.xmind.net/embed/wB36P6" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL-基本语句思维导图&quot;&gt;&lt;a href=&quot;#SQL-基本语句思维导图&quot; class=&quot;headerlink&quot; title=&quot;SQL 基本语句思维导图&quot;&gt;&lt;/a&gt;SQL 基本语句思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;其实暑假学习安全的时候，就学过一部</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SQL" scheme="https://xorex.space/tags/SQL/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库概念思维导图</title>
    <link href="https://xorex.space/2021/03/02/8adb5d7ef601/"/>
    <id>https://xorex.space/2021/03/02/8adb5d7ef601/</id>
    <published>2021-03-02T14:36:52.000Z</published>
    <updated>2021-03-02T14:51:38.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-数据库概念思维导图"><a href="#MySQL-数据库概念思维导图" class="headerlink" title="MySQL 数据库概念思维导图"></a>MySQL 数据库概念思维导图</h2><blockquote><p>还是要了解一下什么是数据库才好啊！！！</p></blockquote><iframe src="https://www.xmind.net/embed/eZ6P3x" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL-数据库概念思维导图&quot;&gt;&lt;a href=&quot;#MySQL-数据库概念思维导图&quot; class=&quot;headerlink&quot; title=&quot;MySQL 数据库概念思维导图&quot;&gt;&lt;/a&gt;MySQL 数据库概念思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;还是要了解</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SQL" scheme="https://xorex.space/tags/SQL/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>TodoList:2021-03</title>
    <link href="https://xorex.space/2021/02/23/e301ee97b31a/"/>
    <id>https://xorex.space/2021/02/23/e301ee97b31a/</id>
    <published>2021-02-23T13:34:24.000Z</published>
    <updated>2021-03-08T10:23:50.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于我寒假里面学习效率过低的问题"><a href="#关于我寒假里面学习效率过低的问题" class="headerlink" title="关于我寒假里面学习效率过低的问题"></a>关于我寒假里面学习效率过低的问题</h2><blockquote><p>因为想了想自己好像年后基本上就没怎么学东西了，即使看上去学习时间很长，但是效率真的是有些惨不忍睹，所以想了想还是需要努力提高自己的效率问题。那么大概总结了以后在学习的过程中，一些需要注意的方面。而每天结束的时候，都要看一看自己是否做到了下面的注意事项，最后将一天的学习内容和完成度记录下来，不断的提高自己的学习能力。加油，要成为一名优秀的软件工程师啊！</p></blockquote><ol><li><p>保证清醒的时间</p><ul><li>寒假光睡觉估计快把自己给睡傻了。所以以后作息必须严格要求自己，晚上 12:00 必须准时睡觉，寝室里小伙伴们在打游戏的话那可以适当的推迟睡觉的时间，然后按照保证大概 7.5 小时的晚上睡眠时间来规划早上起床的时间，保证不赖床！！！</li></ul></li><li><p>要有足够的休息。</p><ul><li>因为常常因为在出现问题的时候，会忍不住尝试一口气解决它，然后就会盯着屏幕看好几个小时，眼睛感到酸涩，头晕脑胀也舍不得停下来。但这实际上是降低了解决问题的效率的，还会有损身体健康，所以必须在软件绿屏的时候，停下来自己手头正在做的事情，去休息一小段时间。(刚刚在写下这段文字的时候就做到了，好耶！)</li></ul></li><li><p>要真正学懂里面的内容</p><ul><li>其实就是对于自己要学的东西，不是光看一边文档就行了（光看不思考怎么可能学会呢）。需要在看的同时使用思维导图来做笔记，从而达到强迫自己思考，最终加深理解。（自己学习的所有的东西都需要，注意是所有！）</li></ul></li><li><p>减少摸鱼的时间</p><ul><li>完全封禁 <code>weibo.com</code> <code>bilibili.com</code> <code>zhihu.com</code> 三个网站，只要坐在电脑面前，需要保证<strong>只能学习</strong>，绝对<strong>不做摸鱼</strong>的事情，而拿到手机，也不要漫无目的的刷新信息流，去看 bilibili 里面缓存的各种技术教程啊。以及 <a href="http://www.ruanyifeng.com/blog/">阮一峰</a> 博客上面的一些技术文章，闲暇的时候多看看嘛！</li></ul></li><li><p>每天一定量的运动</p><ul><li>运动是必不可少的，在学校规划到晚自习下课和 rfy 一起去操场跑步运动,要记住身体是革命的本钱哇。</li></ul></li><li><p>和道格的小伙伴们搞好关系</p><ul><li>虽说在一个实验室里面学习，但是到头来两个月都没有怎么说过话，想想还是要和道格的小伙伴们多交流，不然光和 IOTU 交流的话也太孤独了吧。（这个东西也要每天记录进度）</li></ul></li></ol><h2 id="关于我接下来学习方向的问题"><a href="#关于我接下来学习方向的问题" class="headerlink" title="关于我接下来学习方向的问题"></a>关于我接下来学习方向的问题</h2><blockquote><p>将接下来需要学习的知识点列一下，完成了就划掉。</p></blockquote><h3 id="大型阶段性目标"><a href="#大型阶段性目标" class="headerlink" title="大型阶段性目标"></a>大型阶段性目标</h3><ul><li><p><del>SQL 数据库的各种命令复习</del></p></li><li><p><del>JDBC 内容的学习</del></p></li><li><p><del>函数式编程</del></p></li><li><p>Java 设计模式</p></li></ul><h3 id="小型随意目标"><a href="#小型随意目标" class="headerlink" title="小型随意目标"></a>小型随意目标</h3><ul><li><p><del>Windows10 C盘目录</del></p></li><li><p><del>Windows 开机流程</del></p></li><li><p><del>编码历史和运用</del></p></li></ul><h2 id="每日进度记录"><a href="#每日进度记录" class="headerlink" title="每日进度记录"></a>每日进度记录</h2><h3 id="03-01"><a href="#03-01" class="headerlink" title="03-01"></a>03-01</h3><ul><li><p>今天第一天开学，开心的是终于回到了校园里面，学习效率可以提高了，不开心的是，上课真的是太无聊了。早上因为没有课起床比较晚，明天要 7 点半起床，起来之后直接去实验室！摸鱼的时间还是有一点，不过时间利用还是挺高的，空闲时间看了几篇技术博客。因为没有晚自习就没有运动……，还是没有和道格的小伙伴们交流QAQ。</p></li><li><p>今天主要学习了 SQL 的一些拓展命令，还有 JDBC 的一些基础用法，感觉效率同样不是特别高的样子，还需要提高啊。明天要学 SQL 事务和 JDBC 事务，加油啊！！！</p></li></ul><h3 id="03-02"><a href="#03-02" class="headerlink" title="03-02"></a>03-02</h3><ul><li><p>今天主要学了 JDBC 的大部分内容，总算把数据库相关的内容给搞结束了，好耶！早上同样因为没有课程，所以起床比较晚，运动的话，晚自习是有的，但是因为下雨了，所以就没有去跑步，明天一定！！！</p></li><li><p>学习效率仍然不是非常高，明天仍然要加油啊，函数式编程，冲啊！！！</p></li></ul><h3 id="03-03"><a href="#03-03" class="headerlink" title="03-03"></a>03-03</h3><ul><li><p>今天的学习并不是非常的顺利，我觉的最主要的原因就是因为不理解教程里面写的东西，导致学习进度非常缓慢，根本看不懂教程（或者说在看的时候并没有认真分析，只是大概看过了）。所以为了解决这个问题，决定在看教程的时候，先看视频理解整个框架，然后在<strong>细致的</strong>研究教程，并做好笔记。这里的细致研究指的是每一句话都是必须理解的，不能出现我感觉好像能理解，就放弃深究了，要明白教程上面写的每一个词语的意思！！！</p></li><li><p>其次就是摸鱼，主要是在电脑上面看视频的时候，会注意力难以集中，忍不住的开其他网页看，以后一定要改正啊！！！摸鱼真的是太浪费时间了！！！</p></li><li><p>好消息是今天没有睡懒觉，晚自习结束的时候和饶飞扬一起跑了步，还申请了学校的邮箱，以后有免费的 IDEA 白嫖了，好耶！</p></li></ul><h3 id="03-04"><a href="#03-04" class="headerlink" title="03-04"></a>03-04</h3><ul><li><p>早上去上了一节近代史就溜了，在实验室看了看昨天没弄懂的函数式编程，下午在寝室里面摸鱼看了一下午的咒术回战，晚上认真学了学（中途摸鱼看了一会肉肉姐的动态），但是学习时间太短了，虽说回寝室加了班，但还是没完成函数式编程的学习任务了（我以后再也不摸鱼了，哭.jpg）</p></li><li><p>但是晚上跑步了，和他人交流也更主动了一点，早上也没有赖床，定时休息眼睛，完全弄懂了所学的知识。emmmm，总的来说今天还是有不少收获的！</p></li><li><p>明天要加油啊！！！</p></li></ul><h3 id="03-05"><a href="#03-05" class="headerlink" title="03-05"></a>03-05</h3><ul><li>今天结束了函数式编程的学习，下午也没有做什么，晚上道格面试，人又多又杂，学不了，鸽了。</li></ul><h3 id="03-06"><a href="#03-06" class="headerlink" title="03-06"></a>03-06</h3><ul><li>今天上午周六，给自己放了一个小假期，和 rfy 一起伪造假条跑出去领了一张肥宅快乐卡（招商银行的花嫁卡），然后去学校北街改善了一下伙食，下午在寝室里面修养了一下，放假真的是太爽了。</li></ul><h3 id="03-07"><a href="#03-07" class="headerlink" title="03-07"></a>03-07</h3><ul><li>上午看了看设计模式，发现看的不是太懂，下午就回寝室下载缓存了一堆视频，为了改这一堆视频的名字，就想着写一个 Java 的脚本处理，但是遇到了关于编码的问题，于是为了一劳永逸的解决平时用到的编码问题，就开始研究字符编码的历史，运用等等。</li></ul><h3 id="03-08"><a href="#03-08" class="headerlink" title="03-08"></a>03-08</h3><ul><li>上午和下午一直在研究编码方面的问题，最后完成了 <img src="https://xorex.space/2021/03/07/b688fb992b28/" alt="编码与开发"> 这篇博客，真的可以说是一劳永逸的弄明白了开发所涉及到的编码问题，晚上继续看了设计模式，内容好多啊……</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于我寒假里面学习效率过低的问题&quot;&gt;&lt;a href=&quot;#关于我寒假里面学习效率过低的问题&quot; class=&quot;headerlink&quot; title=&quot;关于我寒假里面学习效率过低的问题&quot;&gt;&lt;/a&gt;关于我寒假里面学习效率过低的问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;因</summary>
      
    
    
    
    <category term="阶段性总结" scheme="https://xorex.space/categories/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="规划" scheme="https://xorex.space/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Java的XML和JSON思维导图</title>
    <link href="https://xorex.space/2021/02/21/ea621b64d07c/"/>
    <id>https://xorex.space/2021/02/21/ea621b64d07c/</id>
    <published>2021-02-20T18:06:18.000Z</published>
    <updated>2021-02-21T16:25:51.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据文档思维导图"><a href="#数据文档思维导图" class="headerlink" title="数据文档思维导图"></a>数据文档思维导图</h2><blockquote><p>思维导图主要介绍了两种数据文档 XML 和 JSON 在 Java 中的数据解析方法。</p></blockquote><iframe src="https://www.xmind.net/embed/rc4VPM" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据文档思维导图&quot;&gt;&lt;a href=&quot;#数据文档思维导图&quot; class=&quot;headerlink&quot; title=&quot;数据文档思维导图&quot;&gt;&lt;/a&gt;数据文档思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思维导图主要介绍了两种数据文档 XML 和 JSON 在 Java</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="XML" scheme="https://xorex.space/tags/XML/"/>
    
    <category term="JSON" scheme="https://xorex.space/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程思维导图</title>
    <link href="https://xorex.space/2021/02/21/4766679f53f7/"/>
    <id>https://xorex.space/2021/02/21/4766679f53f7/</id>
    <published>2021-02-20T18:02:42.000Z</published>
    <updated>2021-02-21T16:25:47.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络编程思维导图"><a href="#网络编程思维导图" class="headerlink" title="网络编程思维导图"></a>网络编程思维导图</h2><blockquote><p>主要记录了使用 Java 实现服务端和客户端之间进行 TCP 协议和 UDP 协议之间通信的方法。</p></blockquote><iframe src="https://www.xmind.net/embed/QXFXMQ" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网络编程思维导图&quot;&gt;&lt;a href=&quot;#网络编程思维导图&quot; class=&quot;headerlink&quot; title=&quot;网络编程思维导图&quot;&gt;&lt;/a&gt;网络编程思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;主要记录了使用 Java 实现服务端和客户端之间进行 TCP 协议</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="计算机网络" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java的Maven基础思维导图</title>
    <link href="https://xorex.space/2021/02/21/21924715f1a8/"/>
    <id>https://xorex.space/2021/02/21/21924715f1a8/</id>
    <published>2021-02-20T18:02:24.000Z</published>
    <updated>2021-02-21T16:25:54.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven基础思维导图"><a href="#Maven基础思维导图" class="headerlink" title="Maven基础思维导图"></a>Maven基础思维导图</h2><blockquote><p>思维导图主要介绍了 Maven 的一些基本使用方法。</p></blockquote><iframe src="https://www.xmind.net/embed/eyFDrU" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Maven基础思维导图&quot;&gt;&lt;a href=&quot;#Maven基础思维导图&quot; class=&quot;headerlink&quot; title=&quot;Maven基础思维导图&quot;&gt;&lt;/a&gt;Maven基础思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思维导图主要介绍了 Maven 的一些基本</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="Maven" scheme="https://xorex.space/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Java加密与安全思维导图</title>
    <link href="https://xorex.space/2021/02/21/1b4cc7a4e155/"/>
    <id>https://xorex.space/2021/02/21/1b4cc7a4e155/</id>
    <published>2021-02-20T18:02:01.000Z</published>
    <updated>2021-02-21T16:23:56.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加密与安全思维导图"><a href="#加密与安全思维导图" class="headerlink" title="加密与安全思维导图"></a>加密与安全思维导图</h2><blockquote><p>思维导图主要记录了使用 Java 对数据进行各种加密解密的方法。</p></blockquote><iframe src="https://www.xmind.net/embed/yVNPMU" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;加密与安全思维导图&quot;&gt;&lt;a href=&quot;#加密与安全思维导图&quot; class=&quot;headerlink&quot; title=&quot;加密与安全思维导图&quot;&gt;&lt;/a&gt;加密与安全思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思维导图主要记录了使用 Java 对数据进行各种加密解密的</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="加密与安全" scheme="https://xorex.space/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java正则表达式思维导图</title>
    <link href="https://xorex.space/2021/02/21/1521f5df53d5/"/>
    <id>https://xorex.space/2021/02/21/1521f5df53d5/</id>
    <published>2021-02-20T18:01:19.000Z</published>
    <updated>2021-03-09T12:38:48.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式思维导图"><a href="#正则表达式思维导图" class="headerlink" title="正则表达式思维导图"></a>正则表达式思维导图</h2><blockquote><p>思维导图主要记录了一下正则表达式的一些简单的使用方法。</p></blockquote><iframe src="https://www.xmind.net/embed/cFDKCv" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;正则表达式思维导图&quot;&gt;&lt;a href=&quot;#正则表达式思维导图&quot; class=&quot;headerlink&quot; title=&quot;正则表达式思维导图&quot;&gt;&lt;/a&gt;正则表达式思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思维导图主要记录了一下正则表达式的一些简单的使用方法。&lt;/</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="正则表达式" scheme="https://xorex.space/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java单元测试思维导图</title>
    <link href="https://xorex.space/2021/02/21/4555c3a37b23/"/>
    <id>https://xorex.space/2021/02/21/4555c3a37b23/</id>
    <published>2021-02-20T18:00:53.000Z</published>
    <updated>2021-02-21T16:26:44.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单元测试思维导图"><a href="#单元测试思维导图" class="headerlink" title="单元测试思维导图"></a>单元测试思维导图</h2><blockquote><p>思维导图主要介绍了如何使用 Junit 测试框架对代码进行测试。大概和 OI 中的测评差不多。</p></blockquote><iframe src="https://www.xmind.net/embed/9sFrRD" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单元测试思维导图&quot;&gt;&lt;a href=&quot;#单元测试思维导图&quot; class=&quot;headerlink&quot; title=&quot;单元测试思维导图&quot;&gt;&lt;/a&gt;单元测试思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思维导图主要介绍了如何使用 Junit 测试框架对代码进行测试。大</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="测试" scheme="https://xorex.space/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java日期与时间思维导图</title>
    <link href="https://xorex.space/2021/02/21/7e7fe64348b1/"/>
    <id>https://xorex.space/2021/02/21/7e7fe64348b1/</id>
    <published>2021-02-20T18:00:24.000Z</published>
    <updated>2021-02-21T16:26:20.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><blockquote><p>emmmm，因为自己是一只老懒狗了，发现完整的写博客真的是非常消耗时间的行为，所以想了想就改为只完成知识点的思维导图。这样的话花在记录的时间能减少很多，而且效果也非常接近，以后各种知识点大概都会以这样的方式来记录了！</p></blockquote><h2 id="旧版本的日期和时间思维导图"><a href="#旧版本的日期和时间思维导图" class="headerlink" title="旧版本的日期和时间思维导图"></a>旧版本的日期和时间思维导图</h2><blockquote><p>此思维导图记录了早期 Java 使用的日期和时间类，现在部分地方仍在使用，所以需要学习。</p></blockquote><iframe src="https://www.xmind.net/embed/KfjibH" width="800px" height="540px" frameborder="0" scrolling="no"></iframe><h2 id="新版本的日期和时间思维导图："><a href="#新版本的日期和时间思维导图：" class="headerlink" title="新版本的日期和时间思维导图："></a>新版本的日期和时间思维导图：</h2><blockquote><p>此思维导图是新版本的日期和时间类，相较于过去的类更加好用了。</p></blockquote><iframe src="https://www.xmind.net/embed/isNRTN" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;emmmm，因为自己是一只老懒狗了，发现完整的写博客真的是非常消耗时间的行为，所以想了想就改为只完</summary>
      
    
    
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="日期与时间" scheme="https://xorex.space/tags/%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程学习笔记</title>
    <link href="https://xorex.space/2021/02/21/575347381561/"/>
    <id>https://xorex.space/2021/02/21/575347381561/</id>
    <published>2021-02-20T17:59:38.000Z</published>
    <updated>2021-03-09T07:59:57.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p><strong>线程</strong>：<code>Thread</code>，是操作系统中能够进行任务调度的最小单位，一般来说是一条单独的任务，比如 bilibili 的视频解码器是一个线程，音频解码器是一条线程，弹幕显示器是一条线程，它们被一起包装在 bilibili 这个进程中，作为正在运行的应用程序。因此线程指的是进程中的一个单一顺序的控制流，一个进程中可以有多条线程，每条线程执行不同的任务。</p><p><strong>进程</strong>：<code>Process</code>， 是指计算机中运行的程序，直观体现是任务管理器中的一个个进程，进程本身不是基本运行单位，而是线程的容器，多个运行不同的线程组成了一个进程。而一个 Java 程序就是一个 JVM 进程，这个 JVM 进程中，主线程执行 main() 方法，而在 main() 线程中，又可以调用其他的线程实现多线程。</p><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p><strong>并发</strong>：<code>Concurrent</code>，是指计算机能够具备处理多个任务的能力，反义词是顺序。顺序执行时只能在执行完一个任务之后才能执行第二个任务，而并发可以“同时”执行多个任务，无论这个是通过将多个大任务分为一个个小任务，然后快速切换执行不同大任务的小任务运行实现的“同时”执行，还是真正的用两个处理器核心，不同核心专注执行不同任务实现的同时执行。两种方法都被成为并发。</p><p><strong>并行</strong>：<code>parallel</code> ，是指计算机真正意义上的同时处理两个任务，这在物理基础上需要 CPU 的两个单独的核心，然后使得两个任务的不同执行在同一时间在不同的核心上面被执行。并行是并发的一种情况（上面实现并发的第二种方法就是并行）。</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p><strong>分时调度</strong>：所有的线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p><p><strong>抢占式调度</strong>：根据优先度来分配线程的使用时间，优先度高的占用时间长，Java 采用此机制。</p><h3 id="两者的特点"><a href="#两者的特点" class="headerlink" title="两者的特点"></a>两者的特点</h3><p>对于一个复杂的应用程序，肯定是需要实现并发，也就是不同的小任务同时执行，比如 bilibili 的弹幕任务，视频解码任务和音频解码任务等。这些小任务的同时运行实现方法就是多个进程或者线程之间并发，亦或者两者一起。</p><p>创建一个进程的开销要比创建一个线程开销大很多，而且一个进程内部的多个线程之间的通信 开销很小（因为访问的是同一个变量），进程与进程之间的的通信开销就要大很多。</p><p>正是因为进程之间有一定的隔离，所以稳定性比多线程好很多。多个进程之间崩溃是互不影响的，而一个进程里面的线程一旦崩溃，这个进程中的所有线程都要受到影响。</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="main-线程"><a href="#main-线程" class="headerlink" title="main 线程"></a>main 线程</h3><p>在一个 Java 程序被执行的时候，是从 main 函数开始执行的，而 main 函数被执行的时候就是一个单独的线程，它的名字就叫做 main 线程。</p><p>首先 main 函数的代码会被放到内存的栈空间中，然后将这个空间和 CPU 建立一个桥梁，CPU 可以通过此桥梁读取此内存空间中的数据和指令，然后执行它。而这个桥梁就是线程，名字为 main 线程。</p><p>在执行 main 线程的时候，main 函数可能有创建一个新的线程的代码，当 CPU 运行 main 线程到此部分的时候，就会按照线程指令执行，开辟一个新的内存空间，放入数据和指令，然后建立一个自己到这个空间的桥梁命名为 func1 线程，用来读取数据和执行放入的指令。这就成功的在 JVM 进程的 main 线程中新建了第二个线程 func1 到此进程中，实现了多线程。</p><p>这个两个线程组成的多线程是可以实现并发的，也就是两个线程 main 和 func1 的任务可以“同时”运行。这是单独一个线程无法实现的，单独一个线程只能顺序执行里面的指令。</p><h3 id="线程建立过程"><a href="#线程建立过程" class="headerlink" title="线程建立过程"></a>线程建立过程</h3><h4 id="方法一：继承Thread"><a href="#方法一：继承Thread" class="headerlink" title="方法一：继承Thread"></a>方法一：继承Thread</h4><p>建立一个新的线程的方法就是新建一个类，继承于 Thread 类。然后在子类中重写 Thread 类里的 run() 方法，这个方法里面是需要新线程同步执行的代码。然后调用子类实例的 start() 方法，就成功的建立了一个新的线程，此线程和 main 线程并发执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread Xorex=<span class="keyword">new</span> WorkTogether(<span class="string">&quot;The Second Thread.&quot;</span>);</span><br><span class="line">        Xorex.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkTogether</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkTogether</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Tempest&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是新建了一个继承于 <code>Thread</code> 的线程类 <code>WorkTogether</code>，然后建立一个名为 <code>The Second Thread.</code> 的线程，通过 <code>start()</code> 的调用开始并发执行此线程的 <code>run()</code> 方法和 main 线程 后面的代码 。</p><p>程序运行的结果就是 Tempest 和 Xorex 两个字符串随机被打印出来，因为是并发，所以可以看作两个循环在“同时”运行，至于某一个细小的时间段具体是在运行谁，则完全由 CPU 随机决定。两个线程的运行是互不干扰的，因为建立一个新的线程的时候，就会开辟一块新的栈空间，因为内存空间不同，则运行相互独立。</p><p>如果我们不调用新线程类实例的 <code>start()</code> 方法而是直接调用 <code>run()</code> 方法，则不会启动新线程，而是把 <code>run()</code> 方法代码压栈到 main 线程的栈空间中，在 main 线程中顺序执行 <code>run()</code> 方法，执行完毕之后，再执行后面的代码而不是一起并发运行。</p><h4 id="方法二：传入Runnable"><a href="#方法二：传入Runnable" class="headerlink" title="方法二：传入Runnable"></a>方法二：传入Runnable</h4><p>Runnable 是一个接口，实现这个 Runnable 接口只需要重写一个 run() 类，和继承 Thread 的重写 run() 几乎相同，不同的是 ，这里实现了线程和执行内容的分离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span></span>;</span><br></pre></td></tr></table></figure><p>直接在 Thread 的构造方法中，传入一个实现了 Runnable 的类的实例即可，然后调用 Thread 实例的 start() 方法启动并运行线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread Xorex=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;This is an another thread!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Xorex.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面方法传入的 Runnable 实现类就是一个匿名类，传入 Thread 的构造方法之后创建线程，再用实例 Xorex 的 start() 方法启动线程。</p><h4 id="方法三：使用-Lambda-表达式"><a href="#方法三：使用-Lambda-表达式" class="headerlink" title="方法三：使用 Lambda 表达式"></a>方法三：使用 Lambda 表达式</h4><p>其实方法三和上面的方法二本质上是一样，唯一的不同就是使用了 Java8 新加入的 Lambda 表达式简化了代码。</p><p>首先忽略 λ Lambda 这个奇奇怪怪的名字，这个代码简化其实贼简单，就是个<strong>实例化匿名类</strong>的语法糖，它可以将所有能够逻辑推断出来的东西全部省略，但只有一个限制，就是这个类里面<strong>只能有一个方法</strong>，下面是使用 Lambda 表达式简化的线程建立：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread Xorex=<span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;This is an another thread&quot;</span>)); <span class="comment">//</span></span><br><span class="line">        Xorex.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是最简状态的实例化匿名类的代码，少了 <code>new Runnable()</code> 因为编译器可以通过 Thread 构造方法接收 Runnable 接口对象来推断出来这个类实现了 Runnable 接口。少了重写方法的签名 <code>public void run()</code> 是因为这个接口只有一个抽象方法等待重写，肯定是它。少了<code>&#123;;&#125;</code> 大括号和分号是因为里面只有一句语句，当然如果有多语句的话，还是需要 <code>&#123;&#125;</code> 来确定语句范围，需要 <code>;</code> 来将多个语句分隔开来。至于剩下的 Lambda 表达式标志 <code>() -&gt;</code> 其中 <code>()</code> 表示是一个方法，里面用来填写参数（可省略类型，因为可以根据抽象方法推断出来），没有参数就空着。而 <code>-&gt;</code> 则是 Lambda 的根本标志符号，必不可少。</p><p>如果需要返回参数呢，有两种方式，一种是单表达式语句，这种就按照最简写即可，而会自动返回表达式计算的结果，如果是多语句，则需要自己写 return 返回值。</p><p>下面是对 Lambda 表达式的三种情况总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">( params ) -&gt; expression</span><br><span class="line">( params ) -&gt; statement</span><br><span class="line">( params ) -&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure><p>第一种举个例子：<code>(int e) -&gt; e*e</code> 因为是一个 expression 直接返回这个表达式计算值。</p><p>第二种举个例子：<code>(int e) -&gt; e=e*e</code> 是一个单语句 statement 则返回空 void 。</p><p>第三种举个例子：只要有大括号，就必须手写 return 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> e) -&gt; &#123;<span class="keyword">return</span> e*e;&#125;</span><br><span class="line">(<span class="keyword">int</span> e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> e2=e*e;</span><br><span class="line">    <span class="keyword">return</span> e2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda 表达式里面的各种特性还有很多，以后遇到了会好好总结一下的！</p><h3 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a>Thread 类</h3><p>上面只是利用 Thread 类新建了一个线程，而 Thread 类中还有很多好用的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span></span>; <span class="comment">//构造方法，设置线程名称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>; <span class="comment">//设置线程名称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span></span>; <span class="comment">//构造方法，设置线程运行代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span></span>; <span class="comment">//设置线程优先级，1-10，默认5</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>; <span class="comment">//运行此进程，并执行run()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="comment">//静态方法，正在执行的线程以毫秒数暂停</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span> <span class="comment">//返回对当前正在执行的线程对象的引用</span></span></span><br></pre></td></tr></table></figure><ul><li>首先对于 <code>setPriority</code> 方法并不能保真正优先执行此线程，而是增加了此线程被执行的概率，总体来说被执行次数会高于优先级低的线程。</li><li>其次是 <code>sleep</code> 方法是一个静态方法，在被当前线程执行的时候，当前线程就会暂停执行对应毫秒，因为此方法被执行肯定是在某个线程中被执行的，所以暂停的线程也肯定是它所在的线程。</li><li>最后 <code>currentThread</code>  方法会返回当前执行的线程对象的引用，需要用 Thread 来接收，本质上和正在运行的线程是一个实例。</li></ul><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>对于一个线程来说，它也有自己的声明周期，在 Java 中，一个线程的声明周期有以下几种：</p><ul><li><code>New</code> 新建状态：线程处于正在被生成的过程。</li><li><code>Runnable</code> 就绪状态：线程处于可以被执行状态。</li><li><code>Timeed Waiting</code> 等待时间状态：线程处于基于时间的等待状态。</li><li><code>Waiting</code> 等待状态：线程处于等待唤醒状态。</li><li><code>Blocked</code> 阻塞状态：线程处于无法被执行状态。</li><li><code>Terminated</code> 死亡状态：线程处于被终止的状态。</li></ul><p><img src="https://xorex.space/image/157.jpg" alt="preview"></p><h3 id="Runnable-状态"><a href="#Runnable-状态" class="headerlink" title="Runnable 状态"></a>Runnable 状态</h3><p>其实 Runnable 是两种子状态的一个概括，总的来说是可被执行状态分为就绪状态和被执行状态，也就是上图对应的 Ready 和 Running 状态。</p><p>我们不需要关心程序处于 Runnable 的时候，具体是在等待 CPU 调度还是正在 CPU 上运行，因为这是我们无法控制的，分配计算资源完全是操作系统干的，作为上层的应用程序我们无法干涉，所以就统称为 Runnable 可运行状态。</p><h3 id="Waiting-和-Timed-Waiting-状态"><a href="#Waiting-和-Timed-Waiting-状态" class="headerlink" title="Waiting 和 Timed Waiting 状态"></a>Waiting 和 Timed Waiting 状态</h3><p>这两个状态基本相同，都是主动的放弃 CPU 被执行权，主动进入了等待状态。不同的是，Waiting 是无限期等待，需要被另外一个线程唤醒才能进入 Runnable 状态，而 Timed  Waiting 是主动放弃我们设定的一定时间的 CPU 被执行权，过了这段时间，它会自己醒来，进入 Runnable 状态。</p><h3 id="Blocked-状态"><a href="#Blocked-状态" class="headerlink" title="Blocked 状态"></a>Blocked 状态</h3><p>这个状态被称为阻塞状态，无法进入 Runnable 并不是因为主动放弃，而是无法获得执行权，或者说此线程被锁上了并且钥匙不在自己的手上。一旦此线程拿到钥匙，就会解锁进入 Runnable 状态。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>多线程虽然很棒，不仅仅能通过 CPU 的快速切换实现“同时”执行多个连续任务，还能利用 CPU 本身硬件支持的多核多线程来真正同时执行多个线程，大幅度提高计算效率。比如 R5 4500U 就拥有六个核心，对于一个任务开六个线程可以让这六个核心同时去处理它，从而获得六倍的运行速度。</p><p>但是要知道对于处理器在运行语句的时候，不知道快速切换或者多核心实际运行位置所在之处。当多个线程需要同时对统一数据进行写入的时候，就会导致线程安全的问题。硬核一点，看一个语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n=n+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//对应了下面三个指令：</span></span><br><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure><p>如果有两个线程同时对 n 变量进行上述语句的运行，因为不知道啥时候就丧失了 CPU 运行权，由另外一个线程运行，所以就可能出现下面的运行情况，在 Thread1 执行完 ILOAD 指令之后，丧失 CPU 执行权，由 Thread2 执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌───────┐    ┌───────┐</span><br><span class="line">│Thread1│    │Thread2│</span><br><span class="line">└───┬───┘    └───┬───┘</span><br><span class="line">    │            │</span><br><span class="line">    │ILOAD (100) │</span><br><span class="line">    │            │ILOAD (100)</span><br><span class="line">    │            │IADD</span><br><span class="line">    │            │ISTORE (101)</span><br><span class="line">    │IADD        │</span><br><span class="line">    │ISTORE (101)│</span><br><span class="line">    ▼            ▼</span><br></pre></td></tr></table></figure><p>两个线程两次执行 <code>n=n+1</code> ，但是 n 的值只加了 1 ，这就是因为线程在读取写入数据的不同步导致的，这可是个大问题。我们再看一个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Runnable RunCode=()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(Tempest.count!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Tempest.count--;</span><br><span class="line">                System.out.println(Tempest.count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Thread Th1=<span class="keyword">new</span> Thread(RunCode);</span><br><span class="line">        Thread Th2=<span class="keyword">new</span> Thread(RunCode);</span><br><span class="line"></span><br><span class="line">        Th1.start();</span><br><span class="line">        Th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码在同时执行  Th1 和 Th2 两个线程的时候，都会对同一个数据 count 进行读写操作，因为线程执行权切换可能发生在 count– 和输出 count 之间发生，所以看输出结果就会发现顺序是乱的，这就是因为线程代码不同步造成的，</p><p>线程同步，也就是一个线程中，某个过程应该连续同步完成，不允许中断。而实现线程同步，就需要将同步代码上锁，保证只有一个线程有钥匙打开并执行它，其它线程无法打开执行。</p><h3 id="1-同步代码块"><a href="#1-同步代码块" class="headerlink" title="1. 同步代码块"></a>1. 同步代码块</h3><p>一种是使用同步代码块这种语法将需要同步执行的一些代码框到里面，然后加上一个锁，只有拿到钥匙才能执行里面的内容，只需要保证钥匙的唯一性，就可以保证在同一时间，因为只有一个线程拥有钥匙，所以只有一个线程会执行锁里面的代码。当里面代码执行完毕之后，会将钥匙随机传给下一个线程，这个线程打开自己的锁，执行锁里面的代码。在这里，锁就是 <code>synchronized</code> 关键词，它锁住了代码块里面的代码，钥匙就是参数 <code>key</code> ，它需要是一个唯一的实例，用来解锁并执行内部代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object key) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Runnable RunCode=()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="string">&quot;Xorex&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(Tempest.count!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Tempest.count--;</span><br><span class="line">                    System.out.println(Tempest.count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread Th1=<span class="keyword">new</span> Thread(RunCode);</span><br><span class="line">        Thread Th2=<span class="keyword">new</span> Thread(RunCode);</span><br><span class="line"></span><br><span class="line">        Th1.start();</span><br><span class="line">        Th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就将同步代码使用 <code>synchronized</code> 语句上锁，然后设置字符串实例 <code>&quot;Xorex&quot;</code> 作为钥匙。在代码执行的时候，只有拥有钥匙的线程才能打开锁执行代码，锁代码执行完毕之后，会释放钥匙，释放的钥匙会随机传给下一个线程，注意可能会出现自己传给自己的情况，毕竟是随机传。</p><h3 id="2-同步方法"><a href="#2-同步方法" class="headerlink" title="2. 同步方法"></a>2. 同步方法</h3><p>同步方法和同步代码块的使用原理是一模一样的，但是不同的是这里将 <code>synchronized</code> 修饰词词用于某个方法的签名，这样在调用这个方法的时候，默认为这个方法里面的代码上了锁，只有此线程有钥匙才能解锁执行，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">Eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tempest.count--;</span><br><span class="line">    System.out.println(<span class="string">&quot;The rest count:&quot;</span>Tempest.count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为不能传 key 参数，所以这里面的钥匙是不能自定义的，是固定的。</p><p>对于像上面一样的普通方法，key 为拥有此方法的实例 <code>this</code> 。</p><p>而对于静态方法，因为和实例无关，只和类有关，所以 key 为此类的 Class 实例。</p><h3 id="3-同步锁-Lock"><a href="#3-同步锁-Lock" class="headerlink" title="3. 同步锁 Lock"></a>3. 同步锁 Lock</h3><p>同步锁是一个接口，它的作用和 <code>synchronized</code> 有一样的地方，但是 Lock 的功能更强大，至于强大的功能以后再说，先看 Lock 接口的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>; <span class="comment">//开始获取锁，如果其他线程已经占用，则等待</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>; <span class="comment">//尝试获取锁，如果成功返回 true，如果锁被占用返回 false 并等待锁。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>; <span class="comment">//解锁</span></span><br></pre></td></tr></table></figure><p>大概就先了解这几个就可以了，需要注意的是这个是不会自动返还锁的，所以一旦在获取锁之后的代码里面，遇到了异常，就会中断代码，后面的释放锁操作就无法执行，所以在使用 Lock 的时候，需要配合这 try-catch 语句，将 unlock() 放到 finally 里面。</p><p>实现 Lock 接口的唯一类为：<code>ReentrantLock</code>，使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">        Runnable RunCode=()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(Tempest.count&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Tempest.count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        Tempest.count--;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  &quot;</span>+Tempest.count);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread Th1=<span class="keyword">new</span> Thread(RunCode,<span class="string">&quot;Thread01&quot;</span>);</span><br><span class="line">        Thread Th2=<span class="keyword">new</span> Thread(RunCode,<span class="string">&quot;Thread02&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Th1.start();</span><br><span class="line">        Th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>在 <code>synchronized</code> 同步代码块或者同步方法的地方，只要这个线程获取了唯一的钥匙，那么遇到相同的锁，都可以打开，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="string">&quot;Xorex&quot;</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="string">&quot;Xorex&quot;</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码，最内层的代码一定是可以执行的，因为两个锁的钥匙相同，只要获取了第一个锁的钥匙 <code>&quot;Xorex&quot;</code>  String 实例，那么第二个锁也因为有了钥匙可以打开。这样的锁叫作可重入锁。</p><h3 id="产生死锁"><a href="#产生死锁" class="headerlink" title="产生死锁"></a>产生死锁</h3><p>死锁是因为两个线程在等待钥匙的时候，资源获取进入僵局，使得无法结束等待的情况称为死锁。</p><p>比如：两个线程，分别持有钥匙1和钥匙2，有钥匙1的同时在请求钥匙2，有钥匙2的同时在请求钥匙1。两个线程都进入了等待钥匙的状态，而自己持有的钥匙无法释放，导致了对方也陷入僵局。</p><p>一旦出现了死锁，只能停止执行代码，所以一定要尽力避免出现死锁的情况。</p><h2 id="变量的多线程安全"><a href="#变量的多线程安全" class="headerlink" title="变量的多线程安全"></a>变量的多线程安全</h2><p>对于多个线程对同一个变量进行操作的时候，因为 CPU 缓存的原因，变量经过更改之后是放在缓存中的，从缓存写入到内存的时间是不确定的。所以可能一个线程更改了数据之后，另外一个线程从内存中读取的还是旧的信息。为了保证涉及到多线程的数据的安全，可以在声明变量的时候添加关键词 volatile 不稳定的。标志完之后，所有对此数据的修改都会立刻写入内存中，保证其他线程的读取正确。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="普通线程池"><a href="#普通线程池" class="headerlink" title="普通线程池"></a>普通线程池</h3><p>线程池就是线程的集合体，通过将线程保存在线程池中来反复利用已经有的线程。因为单独的一个线程的新建和销毁都需要消耗很多资源，所以这样将线程集合在一起，需要了就给他分配任务执行的方式能很好的管理线程。</p><p>新建线程池是通过 Executors 类的三个静态方法来返回一个 ExecutorService 接口的实现实例，一共有三种线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newFixedThreadPool(<span class="keyword">int</span> nThreads) <span class="comment">// 固定数量线程池需要输入参数线程数量</span></span><br><span class="line">newCachedThreadPool() <span class="comment">// 可变数量线程池，会自己根据任务调整</span></span><br><span class="line">newSingleThreadExecutor() <span class="comment">// 单线程线程执行器</span></span><br></pre></td></tr></table></figure><p>通过静态方法得到一个 ExecutorService 接口实现类的实例之后，调用 submit(Runnable) 并传入一个 Runnable 实现实例之后线程会自动运行。</p><p>最后需要调用线程池的方法 shutdown() 来关闭线程池，不然 Java 程序不会结束运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService Xorex=Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        Runnable task=() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Xorex.submit(task);</span><br><span class="line">        Xorex.submit(task);</span><br><span class="line">        Xorex.submit(task);</span><br><span class="line">        Xorex.submit(task);</span><br><span class="line"></span><br><span class="line">        Xorex.shutdown();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反复线程池"><a href="#反复线程池" class="headerlink" title="反复线程池"></a>反复线程池</h3><p>当线程任务需要不断地重复执行的时候，就需要反复线程池了，接口为 ScheduledExecutorService ，而获取线程池的实例还是依靠 Executors 类的静态方法，不过这里只需要找名字里带有 Scheduled 的即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService Xorex=Executors.newScheduledThreadPool(<span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>拿到了一个反复线程池之后，自然要分配任务并且设定反复执行的时间之类的参数。这里 ScheduledExecutorService 接口启动线程方法变成了好几个，对应不同的反复模式：</p><p>延迟执行设定，delayTime 之后开始运行，执行 Runnable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schedule(Runnable,<span class="keyword">int</span> delayTime, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>固定速率执行设定，delayTime 之后开始运行，每次执行完任务每隔 RepeatDelayTime 之后再次重复执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduleAtFixedRate(Runnable,<span class="keyword">int</span> delayTime,<span class="keyword">int</span> RepeatDelayTime, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>固定时间执行设定，delayTime 之后开始运行，每隔 RepeatStartTime 重启线程任务，不管此线程是否执行完任务，都会重启线程，重新执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ses.scheduleWithFixedDelay(Runnable,<span class="keyword">int</span> delayTime,<span class="keyword">int</span> RepeatStartTime, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><iframe src="https://www.xmind.net/embed/uW3Rg8" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;h3 id=&quot;线程和进程&quot;&gt;&lt;a href=&quot;#线程和进程&quot; class=&quot;headerlink&quot; title=&quot;线程和进程&quot;&gt;&lt;/a&gt;线程和进</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="笔记" scheme="https://xorex.space/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="多线程" scheme="https://xorex.space/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java输入输出流学习笔记</title>
    <link href="https://xorex.space/2021/02/21/6b113700fd3d/"/>
    <id>https://xorex.space/2021/02/21/6b113700fd3d/</id>
    <published>2021-02-20T17:58:59.000Z</published>
    <updated>2021-02-21T16:25:43.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件-File-类"><a href="#文件-File-类" class="headerlink" title="文件 File 类"></a>文件 File 类</h2><h3 id="创建-File-实例"><a href="#创建-File-实例" class="headerlink" title="创建 File 实例"></a>创建 File 实例</h3><p>首先在进行输入输出处理之前，我们来看看数据的载体——文件。</p><p>因为我们在内存中存储的数据都是暂时的，一旦断电，都会消失，所以通常我们会把数据以文件的形式存储到永久存储的硬盘中，可以说，数据的操作单位就是文件。而 Java 中的 File 类就是专门对文件进行概括的一个类，它能很好的控制一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File file=<span class="keyword">new</span> File(<span class="string">&quot;Xorex.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面我们通过给构造方法传入一个文件的路径，成功实例化了 File 类。这个实例就是 <code>Xorex.txt</code> 这个文件，上面我们传入了 <code>Xorex.txt</code>  这个文件的相对路径，可以唯一确定这个文件，当然绝对路径也是可以的：<code>E:\\Java\\Xorex.txt</code> 。</p><p>需要注意的是，在不同的操作系统中，路径的表示是不同的，Windows 里面使用 <code>\</code> 表示路径分隔符，而 Linux 里面使用 <code>/</code> 表示路径分隔符。又因为在字符串中 <code>\</code> 表示转义，所以在写绝对路径或者相对路径的时候，需要用 <code>\\</code> 来分隔路径。</p><h3 id="得到文件路径"><a href="#得到文件路径" class="headerlink" title="得到文件路径"></a>得到文件路径</h3><p>得到文件路径中，File 类里面有三种不同的方法，分别是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getPath(); <span class="comment">// 返回构造方法传入的的路径</span></span><br><span class="line">getAbsolutePath(); <span class="comment">// 若构造方法为相对路径，则和当前路径拼接成绝对路径之后返回。若为绝对路径，则直接返回构造方法传入的绝对路径。</span></span><br><span class="line">getCanonicalPath(); <span class="comment">// 返回标准的绝对路径，会将 .// ..// 这些转化。</span></span><br></pre></td></tr></table></figure><h3 id="获取-File-实例的信息"><a href="#获取-File-实例的信息" class="headerlink" title="获取 File 实例的信息"></a>获取 File 实例的信息</h3><p>对于一个通过路径得到的 File 实例，如果路径结尾是一个文件名，那么 File 实例就是这个文件，如果是一个文件夹的名字，那么 File 实例就是这个文件夹。两者都可以被 File 类表示。</p><p>对于确定了一个文件/文件夹的 File 实例，我们可以通过方法获取一些这个文件/文件夹的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> 是否为文件</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span> 是否为文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span> 是否可读</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span> 是否可写</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canExecute</span><span class="params">()</span> 是否可执行/可列出来（可执行指 JVM 是否有权限读取、修改它）</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> 文件大小</span></span><br></pre></td></tr></table></figure><p>如果确定了这个实例是一个文件夹，那么还可以使用下面的方法来获取文件夹里面的东西。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] list() <span class="comment">// 以字符串列出所有内容 </span></span><br><span class="line">String[] list(FileNameFilter) <span class="comment">// 传入 FilenameFilter 接口的实例过滤列出内容</span></span><br><span class="line">File[] listFiles() <span class="comment">// 以 File 文件列出所有内容 </span></span><br><span class="line">File[] listFiles(FileFilter) <span class="comment">// 传入 FileFilter 接口的实例过滤列出内容</span></span><br><span class="line">File[] listFiles(FileNameFilter) <span class="comment">// 传入 FilenameFilter 接口的实例过滤列出内容</span></span><br></pre></td></tr></table></figure><h3 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h3><p>如果我们给的路径源文件不存在，可以直接创建，如果存在了，可以直接删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="comment">// 文件路径的所有文件夹必须全部都存在才能创建成功</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span> <span class="comment">// 删除文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">deleteOnExit</span><span class="params">()</span> <span class="comment">// JVM 结束运行时删除此文件</span></span></span><br></pre></td></tr></table></figure><p>我们还可以用 File 的静态方法创建一个临时文件，这个临时文件默认保存在 C 盘用户文件夹下面等等等的一个叫作 Temp 的文件夹。我们可以自定义这个临时文件的前缀和后缀，甚至是保存地点，这个临时文件的名字会在前缀和后缀之间加上一串随机数，且不会自动删除，所以最好获得临时文件的实例之后直接调用 <code>deleteOnExit()</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">File <span class="keyword">static</span> <span class="title">createTempFile</span><span class="params">(prefix,suffix,[File])</span> </span></span><br></pre></td></tr></table></figure><p>可选参数 File ，为是否改变默认的保存地址为 File 的地址（需要传入的 File 实例是一个文件夹，然后临时文件创建到这个文件夹中）。</p><h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span> <span class="comment">//创建文件夹，必须前面路径的文件夹存在才能创建成功。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> <span class="comment">//创建全路径文件夹，若前面路径不存在则自动创建。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span> <span class="comment">// 文件夹目录为空才能删除。</span></span></span><br></pre></td></tr></table></figure><h2 id="字节-IO-流"><a href="#字节-IO-流" class="headerlink" title="字节 IO 流"></a>字节 IO 流</h2><h3 id="try-resource-catch-语句"><a href="#try-resource-catch-语句" class="headerlink" title="try(resource)-catch 语句"></a>try(resource)-catch 语句</h3><p>InputStrean 和 OutputStream 这种流 IO 在运行的时候会占用各种资源，所以在结束流之后关闭流来释放资源是很有必要的。但是对于这种操作，往往可能关闭的不太顺利，可能出现流正在被使用无法关闭的情景，所以 <code>try-catch</code> 语句也就常常伴随着 close() 的调用而出现，来解决流关闭失败后的处理。</p><p>但是用一次 close() 就写一个  <code>try-catch</code> 有点麻烦了，Java 就给了一个小语法糖：<code>try(resource)-catch</code> 语句。这个语句和 <code>try-catch</code> 的区别就是对于在<code>(resource)</code> 这里开启的资源，结束运行之后，会自动调用资源的 close() 方法。因此能使用 <code>try(resource)-catch</code> 的语句必须拥有 close() 方法，也就是实现 closeable 接口。</p><p>正巧 IOStream 都实现了这个接口，就可以使用上面的语句是申请 IO 流资源而不用写关闭代码，因为编译器会自动帮忙写，所以也是一个语法糖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="keyword">new</span> InputStream(File)) &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">&#125; <span class="comment">// 结束运行之后会自动调用 close() 来关闭流</span></span><br></pre></td></tr></table></figure><p>看源代码发现，这个 InputStream 和 OutputStream 抽象类实现了 Closeable 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span></span></span><br></pre></td></tr></table></figure><p>而这个 Colseable 接口只有一个方法，就是 close() 方法， 也是我们对 IOStream 类操作的时候，最后需要释放资源时使用的 close() 方法。只要这个类实现了 Closeable 接口，那么就可以应用在 <code>try(resource)-catch</code> 语句里面，运行结束之后自动关闭流。</p><h3 id="InputStream：FileInputStream"><a href="#InputStream：FileInputStream" class="headerlink" title="InputStream：FileInputStream"></a>InputStream：FileInputStream</h3><p>对于从文件中读取，使用 InputStream 的子类 FileInputStream，在构造方法传入 File 实例或者一个文件路径的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="comment">//自己根据路径找文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="comment">//借助File实例找文件</span></span></span><br></pre></td></tr></table></figure><p>确认文件之后就可以使用内置的 read() 方法读取文件内容了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="comment">//一次读取一个字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="comment">//一次读取b数组大小的字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//off是指读取的内容写入b数组中的起始位置，len表示写入的字节长度</span></span></span><br></pre></td></tr></table></figure><h3 id="OutputStream：FileOutputStram"><a href="#OutputStream：FileOutputStram" class="headerlink" title="OutputStream：FileOutputStram"></a>OutputStream：FileOutputStram</h3><p>对于向文件写入，使用 OutputStream 的子类 FileOutputStream，在构造方法传入 File 实例或者一个文件路径的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name)</span> <span class="comment">//传入文件路径覆盖写入</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name, <span class="keyword">boolean</span> append)</span> <span class="comment">//append为true时往文件末尾写入</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file)</span> <span class="comment">//传入File实例获取路径</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span> <span class="comment">//append为true时往文件末尾写入</span></span></span><br></pre></td></tr></table></figure><p>确认文件之后就可以使用内置的 write() 方法向文件中写入内容了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="comment">//读取一个字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="comment">//读取一个字节数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//设置写入文件的数据中，在b数组的起始位置off以及总长度len</span></span></span><br></pre></td></tr></table></figure><p>在 Java 中为了效率，有了输入输出的缓冲区，只有缓冲区内数据到达一定程度，才会真正的写入到文件中，但是有些情况我们需要即使写入，那么就可以调用 flush() 来将缓冲区的数据直接写入到文件中。</p><h3 id="Filter-设计模式"><a href="#Filter-设计模式" class="headerlink" title="Filter 设计模式"></a>Filter 设计模式</h3><p>因为对于 IO 的输入输出来说，有的时候我们想要在输入输出的同时添加一些额外的工作，比如加密，解码等等。在通常情况下，解决方法就是单独写一个类继承于 IOStream 然后添加新功能，但当各种小功能需要排列组合使用的时候，就会引起功能类数量爆炸的情况，所以这里引入了 Filter 的设计模式，来对功能类进行排列组合。</p><p>首先要实现的功能需要继承于 FilterInputStream/FilterOutputStream ，然后功能类的构造方法参数为 IOStream 并用 super() 传给 Filter 类的构造方法，最后就可以重写 read() 和 write() 方法，使用原输入输出就用 in.read() 或者 out.write() ，只需要前后添加新功能即可，类似于普通代理。</p><p>有了功能类之后，就可以利用在构造方法中不停套娃其他的功能类，实现功能的排列组合，一个简单的对输出数据进心 base64 加密的功能类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FilterOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file=<span class="keyword">new</span> File(<span class="string">&quot;Xorex.Tempest&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>(Base64OutputString BaseOut=<span class="keyword">new</span> Base64OutputString(<span class="keyword">new</span> FileOutputStream(file))) &#123; </span><br><span class="line">            BaseOut.write(<span class="string">&quot;I like coding!&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base64OutputString</span> <span class="keyword">extends</span> <span class="title">FilterOutputStream</span> </span>&#123;</span><br><span class="line">    Base64OutputString(OutputStream out) &#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.write(Base64.getEncoder().encode(b));       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Filter 父类里面的构造方法其实就是将传入的输入流实例赋值给 in 或者 out，然后这个可以被子类重写方法的时候调用，从而实现功能的组合。</p><p>剩下的东西不太想写了，鸽了。以后直接上传思维导图好了。</p><p>主要 IO 框架的思维导图：</p><iframe src="https://www.xmind.net/embed/kSC5hQ" width="800px" height="540px" frameborder="0" scrolling="no"></iframe><p>IO 相关类的继承关系的思维导图：</p><iframe src="https://www.xmind.net/embed/wLEzaX" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件-File-类&quot;&gt;&lt;a href=&quot;#文件-File-类&quot; class=&quot;headerlink&quot; title=&quot;文件 File 类&quot;&gt;&lt;/a&gt;文件 File 类&lt;/h2&gt;&lt;h3 id=&quot;创建-File-实例&quot;&gt;&lt;a href=&quot;#创建-File-实例&quot; cla</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="笔记" scheme="https://xorex.space/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="IO" scheme="https://xorex.space/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习笔记【二】</title>
    <link href="https://xorex.space/2021/02/21/3fb2b83273fd/"/>
    <id>https://xorex.space/2021/02/21/3fb2b83273fd/</id>
    <published>2021-02-20T17:58:13.000Z</published>
    <updated>2021-02-21T08:02:24.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>因为这个和 IO 的流输入流输出有关，所以日后再来补坑。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>首先来看看 Queue 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里可以看到是和 List 同级别的接口，都继承了 collection，顾名思义啊，这个 Queue 就是一个实现了队列功能的集合，First In First Out 先进先出。</p><p>而在 Java 中，实现 Queue 接口的类是：LinkedList，虽说它叫作  LinkedList ，但是它实际上是实现了 List 和 Queue 两个接口。我们可以向上转型为 Queue，然后把它当作队列的实例使用。</p><p>看一看 Queue 里面封装的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">//向队列尾部加入元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>; <span class="comment">//向队列尾部加入元素</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>; <span class="comment">//返回队头元素，并删除</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>; <span class="comment">//返回队头元素，并删除</span></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>; <span class="comment">//返回队头元素，但不删除</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>; <span class="comment">//返回队头元素，但不删除</span></span><br></pre></td></tr></table></figure><p>上面相同的功能有两种不同的方法实现，一个是常用词（add，remove，element），另一个是非常用词（offer，poll，peek），两者的区别就是前者出错时直接抛出异常，后者时返回 null。</p><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>优先队列，在 Java 中使用堆结构实现。为 PriorityQueue 类，并实现了 Queue 接口。其所拥有的的方法和 Queue 差不多，唯一的不同是队列开头的元素是按照自己要求排出来的第一。</p><p>因为涉及到了比较，所以和 TreeMap 以及 Collections.sort() 一样，要么在元素的类中实现 Comparable 接口中的 compareTo() 方法，要么在建立 PriorityQueue 实例的时候传入一个 Comparator 的匿名类进去。</p><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>Deuqe 是个双端队列，双端队列故名思意就是可以在队列头和队列尾都添加元素的队列，同样是实现了FIFO先进先出的特性。ArrayDeque 和 LinkedList 两者实现了 Deque 接口（好家伙 LinkedList 也太全能了吧），而 Deque 接口规定了必须要实现的方法：</p><table><thead><tr><th align="left">功能</th><th align="left">Deque</th></tr></thead><tbody><tr><td align="left">添加元素到队尾</td><td align="left">addLast(E e) / offerLast(E e)</td></tr><tr><td align="left">取队首元素并删除</td><td align="left">E removeFirst() / E pollFirst()</td></tr><tr><td align="left">取队首元素但不删除</td><td align="left">E getFirst() / E peekFirst()</td></tr><tr><td align="left">添加元素到队首</td><td align="left">addFirst(E e) / offerFirst(E e)</td></tr><tr><td align="left">取队尾元素并删除</td><td align="left">E removeLast() / E pollLast()</td></tr><tr><td align="left">取队尾元素但不删除</td><td align="left">E getLast() / E peekLast()</td></tr></tbody></table><p>用法和优先队列的 Queue 完全相同，而且 Deque 也是继承于 Queue 接口的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以 Deque 也可以使用 offer() 添加元素到队尾，但是并不推荐这样写，对于这种双端队列，还是写成 offerLast() 这样更明确一些。</p><p>因为像 LinkedList 这样实现了很多不同接口的类，我们具体要把它当作某一个接口使用的时候，因该让它向上转型为对应的接口，然后按照接口拥有的功能进行操作，这种尽量持有接口的方法才是面向对象的思想。</p><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>众所周知，栈是一个先进后出的数据结构，和叠碗筷差不多。在 Java 中并没有单独搞一个叫作 Stack 的接口，这是因为历史遗留问题，有一个单独叫作 Stack 的类，因为这个 Stack 类所拓展的 Vector 类是一个早期 Java 写的一个不太行的类，里面很多方法都是线程安全的，速度很慢，所以就直接废弃不用了。</p><p>那如何实现栈结构呢？当然是使用万能的双端队列 Deque 啦，Deque 接口就封装了栈所需要的一些方法，如：</p><ul><li>把元素压入栈中： push(E)/addFirst(E)</li><li>把元素弹出栈：pop(E)/removeFirst(E)</li><li>取栈顶元素但不弹出： peek(E)/peekFirst(E)</li></ul><p>如果将 Deque 当作 Stack 使用的时候，尽量用 push pop peek 这样的方法，更直接清晰。</p><p>栈数据结构的用途非常多，以后会慢慢学的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Properties&quot;&gt;&lt;a href=&quot;#Properties&quot; class=&quot;headerlink&quot; title=&quot;Properties&quot;&gt;&lt;/a&gt;Properties&lt;/h2&gt;&lt;p&gt;因为这个和 IO 的流输入流输出有关，所以日后再来补坑。&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="笔记" scheme="https://xorex.space/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="集合" scheme="https://xorex.space/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习笔记【一】</title>
    <link href="https://xorex.space/2021/02/21/ea646ab3cd00/"/>
    <id>https://xorex.space/2021/02/21/ea646ab3cd00/</id>
    <published>2021-02-20T17:58:12.000Z</published>
    <updated>2021-02-21T09:32:32.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合导论"><a href="#集合导论" class="headerlink" title="集合导论"></a>集合导论</h2><p>集合 Collection</p><p>用来存储数据使用，对应着不同类型的需求，拥有着不同的集合来处理它。Collection 是一个顶层接口，下面继承他的还有两个接口，分别是 List 接口和 Set 接口，其中 List 接口实现的是有序可重复的列表，Set 接口实现的是无序不可重复的列表。剩下的就是实现 List 和 Set 接口的各种类了，这些类五花八门，可以根据需要选择使用。</p><p><img src="https://xorex.space/image/156.jpg" alt="img"></p><h2 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h2><h3 id="Collection-的定义"><a href="#Collection-的定义" class="headerlink" title="Collection 的定义"></a>Collection 的定义</h3><p>首先我们看 Collection 接口的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span></span><br></pre></td></tr></table></figure><p>继承了一个 Iterable 的接口，并使用了泛型，泛型用于定义此集合存储的数据类型，而继承的接口 Iterable 可以先不管，一会再看它。接口里面定义了所有实现这个接口的类所必须要有的方法，因为 Collection 接口是所有集合都要实现的接口，因此所有的集合都有 Collection  接口里面的方法，下面是一些主要的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 返回集合元素数量</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">// 返回集合是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>; <span class="comment">// 返回是否包含某个元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">// 加入某个元素并返回是否加入成功</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>; <span class="comment">// 删除某个元素并判断是否删除成功</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 删除所有的元素</span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>; <span class="comment">// 返回此集合的一个迭代器</span></span><br></pre></td></tr></table></figure><p>研究 Collection 接口里面的方法是因为这些方法在所有集合里面都是通用的，无论我们拿到一个什么样的集合，都可以使用 Collection 接口里面定义的方法来对此集合进行操作，而 Collection 接口的存在，除了方便规定集合以外，还可以用来玩多态，无论是啥集合，统一向上转型，然后当作 Collection 实例处理。</p><h3 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h3><p>仔细观察 Collection 接口的主要方法，里面是没有用来返回元素的，这是因为有些集合，是没有索引的，比如 <code>set</code> 接口下面实现的几种集合。他们不能通过对下标的遍历来遍历整个集合。面对千万种不同的集合，一种统一的用于集合的迭代接口就必不可少了，把具体的迭代细节封装起来，留下统一的方法接口，只管调用即可。</p><p>而 Iteratior 接口就是这种标准的迭代接口，在 Collection 接口种就规定了一个方法用来返回用于此集合遍历的迭代器 <code>Iterator&lt;E&gt; iterator();</code>。而 Iteratior 接口规定了实现迭代统一而必不可少的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>; <span class="comment">// 返回是否还有下一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>; <span class="comment">// 返回下一个元素并移动指针指向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，只有这两个方法就够了，判断还有下一个元素没有了，如果有就取出来，如果没有那就迭代完成！我们不需要关心集合是啥，只要 hasNext 和 next ，闭着眼都能遍历它。</p><h3 id="增强-For-循环"><a href="#增强-For-循环" class="headerlink" title="增强 For 循环"></a>增强 For 循环</h3><p>对于数组和集合来说，可以使用普通 for 循环和迭代器来迭代它，首先建立一个集合并添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; Tempest=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Tempest.add(<span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">Tempest.add(<span class="string">&quot;Asuna&quot;</span>);</span><br><span class="line">Tempest.add(<span class="string">&quot;Yukino&quot;</span>);</span><br><span class="line">Tempest.add(<span class="string">&quot;Megumi&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后对集合进行遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; Ti =Tempest.iterator();Ti.hasNext();) &#123;</span><br><span class="line">    String i=Ti.next();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是利用了普通 for 循环和迭代器实现了集合的遍历。</p><p>那么这样的写法一般是比较固定的，于是 Java 就加入了一个语法糖，增强 for 循环。使用格式就是 <code>for(集合元素类型 变量名 : 集合实例名);</code> ，然后遍历代码就可以简化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String i:Tempest) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上还是用了迭代器，只不过这部分代码是编译器帮助我们生成的，我们只写语法糖部分即可。</p><h2 id="List-接口及其实现"><a href="#List-接口及其实现" class="headerlink" title="List 接口及其实现"></a>List 接口及其实现</h2><h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><p>上面说了 Collection 接口被 List 和 Set 两个接口继承，从而将集合分为了两大结构，这里我们就开始讨论一下这个 List 接口，以及 List 接口的一些实现。首先我们看一下官方给 List 的介绍：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* An ordered collection (also known as a &lt;i&gt;sequence&lt;/i&gt;).  The user of this</span><br><span class="line">* interface has precise control over where in the list each element is</span><br><span class="line">* inserted.  The user can access elements by their integer index (position in</span><br><span class="line">* the list), and search for elements in the list.&lt;p&gt;</span><br></pre></td></tr></table></figure><p>首先 List 是一个 ordered collection 即<strong>有序列表</strong>，这意味着元素的取出顺序和放入顺序是相同的。并且可以 precise control over where 精确的控制元素的插入位置，使用元素 integer index <strong>坐标</strong>来访问和搜索。</p><p>然后我们来看看 List 区别与 Collection 的主要方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 获取在某坐标的元素</span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; <span class="comment">// 在某坐标替换元素（删除原元素），并返回原元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;<span class="comment">// 在某坐标插入元素，原元素后移一位</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 移除某坐标的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;<span class="comment">// 获取某元素第一次出现的坐标值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;<span class="comment">// 获取某元素最后一次出现的坐标值</span></span><br></pre></td></tr></table></figure><p>不同的地方自然是有序列表和坐标的引入了，那么就会有上面针对于坐标的操作。</p><h3 id="List-和-Array-互换"><a href="#List-和-Array-互换" class="headerlink" title="List 和 Array 互换"></a>List 和 Array 互换</h3><p>第一种是从 List 转换为 Array，方法自然是使用 List 接口里面的 <code>toArray(T[])</code> 传入一个和元素类型相同的数组，然后返回一个将 List 元素转化过的数组。当然如果我们传入的数组大小和 List 元素数量不一样的话，它也会自动处理的，小的话它会新建一个刚刚好的数组复制之后返回回来，大的话它会把没有容纳 List 元素的位置填成 null。当然我们可以直接写个大小刚刚好的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] array = Tempest.toArray(<span class="keyword">new</span> String[Tempest.size()]);</span><br></pre></td></tr></table></figure><h3 id="ArrayList-集合"><a href="#ArrayList-集合" class="headerlink" title="ArrayList 集合"></a>ArrayList 集合</h3><p>ArrayList 是对 List 接口的一个实现类，而它的实现方法是使用数组，数组的缺点就是在插入元素的时候，后面的元素都要全部后移，造成了性能消耗比较大：</p><table><thead><tr><th align="left">执行请求</th><th align="left">资源消耗</th></tr></thead><tbody><tr><td align="left">获取指定元素</td><td align="left">速度很快</td></tr><tr><td align="left">添加元素到末尾</td><td align="left">速度很快</td></tr><tr><td align="left">在指定位置添加/删除</td><td align="left">需要移动元素</td></tr><tr><td align="left">内存占用</td><td align="left">少</td></tr></tbody></table><h3 id="LinkedList-集合"><a href="#LinkedList-集合" class="headerlink" title="LinkedList 集合"></a>LinkedList 集合</h3><p>LinkedList 也同样是对 List 接口的一个实现类，而它的实现方法是使用链表，链表的缺点就是查询的时候，需要遍历一边链表才能查到，造成了性能消耗比较大：</p><table><thead><tr><th align="left">执行请求</th><th align="left">资源消耗</th></tr></thead><tbody><tr><td align="left">获取指定元素</td><td align="left">需要从头开始查找元素</td></tr><tr><td align="left">添加元素到末尾</td><td align="left">速度很快</td></tr><tr><td align="left">在指定位置添加/删除</td><td align="left">不需要移动元素</td></tr><tr><td align="left">内存占用</td><td align="left">较大</td></tr></tbody></table><h2 id="Set-接口及其实现"><a href="#Set-接口及其实现" class="headerlink" title="Set 接口及其实现"></a>Set 接口及其实现</h2><h3 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h3><p>讨论完 List 接口之后来看看 Set 接口，同样作为继承于 Collection 的好孩子，Set 接口有什么特点呢，看看官方文档吧：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* A collection that contains no duplicate elements.  More formally, sets</span><br><span class="line">* contain no pair of elements &#123;@code e1&#125; and &#123;@code e2&#125; such that</span><br><span class="line">* &#123;@code e1.equals(e2)&#125;, and at most one null element.  As implied by</span><br><span class="line">* its name, this interface models the mathematical &lt;i&gt;set&lt;/i&gt; abstraction.</span><br></pre></td></tr></table></figure><p>no duplicate elements 表示 Set 里面<strong>没有重复</strong>的元素，也就是两个 equals() 能判断相等的两个元素，null 也只能有一个。并且此集合没有索引，也就不存在了各种有关索引操作的方法了。</p><p>至于这个接口规定的一些方法，其实没啥好讲的，和 Collection 差不多，下面直接研究实现 Set 接口的两个重要的类，分别是 HashSet 和 LinkedHashSet 。</p><h3 id="HashSet-集合"><a href="#HashSet-集合" class="headerlink" title="HashSet 集合"></a>HashSet 集合</h3><h4 id="HashSet内部实现"><a href="#HashSet内部实现" class="headerlink" title="HashSet内部实现"></a>HashSet内部实现</h4><p>HashSet 是 Set 的一个实现类，故名思意，实现 Set 的方法就是用了 Hash，确切的说，使用了 Hash 实现的 Map，即 HashMap。这可是个好东西，通过 Map 构建了键值对映射之后，就意味着我们对于 List 的查询和添加效率不可得兼的问题就得到了解决。使用 HashMap 可以高效的完成添加和查询，但是牺牲就是里面无法存储重复的元素。</p><p>这里对上面的名词进行解释一下， Hash，哈希表，又叫做散列表，是用来计算唯一特征值的一种算法，每一个实例都可以计算出来自己独一无二的 Hash 值，我们将这个 Hash 值作为键，将实例作为值，然后用 Map 结构来存储两者，通过 Map 结构可以用 Hash 值作为键值快速获得实例。</p><p>因此我们总结出来了，使用 HashSet 有两个必须要的条件：</p><ol><li>可以计算一个实例的 Hash 值，并且尽可能地独一无二。</li><li>拥有判断两个实例是否相等地算法，保证集合元素不会重复。</li></ol><p>第一个在 Java 里面，需要自己在写类的时候就重写继承于 Object 的方法 hashCode()，第二个则需要重写 Object 的 equals() 方法。</p><h4 id="重写-hashCode"><a href="#重写-hashCode" class="headerlink" title="重写 hashCode()"></a>重写 hashCode()</h4><p>首先我们看看 Object 里面的 hashCode() 是怎么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>使用了 native 关键词，说明是调用了系统来返回一个十进制整数，作为这个实例的 Hash 值。</p><p>而我们的重写就需要自己计算 Hash 值了，这个算法需要保证两点</p><ul><li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li><li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li></ul><p>Java 为我们提供了一个利器来实现 Hash 的计算，因为不同的实例本质上是字段的值不同，所以我们就根据字段来计算 Hash 值，而计算的方法则是利用 Objects.hash()，它使用是可变参数，往里面把所有的字段都填进去即可返回一个合适的 Hash 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object... values)</span></span>;</span><br></pre></td></tr></table></figure><p>简单的重写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(age,name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重写-equals"><a href="#重写-equals" class="headerlink" title="重写 equals()"></a>重写 equals()</h4><p>编写 equals() 当然也有一些原则，不过我认为这些原则都没啥用，只要能合理的重写 equals 方法即可。我们比较 两个实例是否相等的方式就是依次比较它的字段值，如果每个字段值都相等，那么就认为这两个实例是相等的，字段值有两种，一种是基本类型，一种是引用类型。对于基本类型，我们可以直接用 <code>==</code> 进行判断，但是引用类型就不可以了。</p><p>引用类型使用 <code>==</code> 判断比较的是引用地址是否相同，假使两个实例的所有字段都相同，但是由两个 new 语句建立的，那么引用地址就肯定不相同，导致使用 <code>==</code> 判断也不相同。所以对于引用类型的字段来说，我们使用它自带的 equals() 进行比对，但是，如果比对 equals() 的一方的引用类型字段为 null，那么调用它的 equals() 就会抛出异常，所以我们还需要单独判断是否为 null，这就太麻烦了。</p><p>麻烦的东西自然有人帮助我们处理，直接使用 Objects 类种的静态方法 equals() 传入两个引用类型，它会自动返回是否相等。因此我们就可以得到重写 equals() 的步骤了。</p><ol><li>首先判断传入的  <code>Object</code> 是不是此类的实例，如果是则开始下一步。</li><li>然后将传入的 <code>Object</code> 向下转型为当前类的实例，方便比较字段。</li><li>然后比较字段，引用类型使用 <code>Objects.equals(Object a,Object b)</code>，基本类型直接使用 <code>==</code> 。</li></ol><p>简单的重写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Tempest) &#123;</span><br><span class="line">            Tempest P=(Tempest)o;</span><br><span class="line">            <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name,P.name)&amp;&amp;<span class="keyword">this</span>.age==P.age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-HashSet-集合"><a href="#使用-HashSet-集合" class="headerlink" title="使用 HashSet 集合"></a>使用 HashSet 集合</h4><p>这里就可以看出来 Set 和 List 的使用区别了，如果需要存储重复的元素，那么只能使用 List ，如果没必要存储重复元素，则使用 Set 。 Set 虽然有着无序和无法通过下标访问的缺点，但是因为使用了映射机制，实现了 List 的无法全部获得的优点：同时实现插入和查询的高效。</p><p>因此如果没有必须要重复存储一些元素，那我们直接使用 Set 类。</p><h3 id="LinkedHashSet-集合"><a href="#LinkedHashSet-集合" class="headerlink" title="LinkedHashSet 集合"></a>LinkedHashSet 集合</h3><p>LinkedHashSet 集合和 HashSet 集合之间的区别仅仅就是在前者比后者内部多了一个链表用来记录存储元素的先后顺序，这个链表仅仅只在迭代器工作的时候使用，它可以保证迭代的顺序和插入元素的顺序是相同的。而 HashSet 因为只有一个哈希表，所以迭代顺序可能会随着插入了元素而变化。</p><h2 id="Collections-集合工具"><a href="#Collections-集合工具" class="headerlink" title="Collections 集合工具"></a>Collections 集合工具</h2><p>集合工具，故名思意，就是用于操作集合的工具，这个类里面拥有很多直接操作集合的方法，帮助我们更好使用集合。</p><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1. 排序"></a>1. 排序</h3><p>对一个集合进行排序的时候，如果集合里面拥有排序方法，那么就可以调用集合里面的排序方法对集合进行排序。如果没有的话，则可以利用 Collections 类的静态方法 sort() 对集合进行排序操作，需要注意的是，这里的排序只能用于列表 List ，而不能用于 Set 。</p><p>实现排序最根本的要求就是知道如何比较集合里面两个元素的大小，对于 Collections 类里面有两种排序方法，一种是 <code>sort(List&lt;T&gt; list)</code> ，直接传入一个列表既可，但需要列表的元素类实现 <code>interface Comparable&lt;T&gt;</code> 接口并重写 <code>compareTo()</code> 方法。另外一种则是使用 <code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> 里面传入列表和对应元素类型需要的比较器 Comparator 。</p><ul><li>首先我们介绍第一种，在类中实现 <code>interface Comparable&lt;T&gt;</code> 接口，并重写里面的 <code>compareTo()</code> 方法。<code>public int compareTo(T o);</code>  ，如果返回<strong>零</strong>则表示两者相等，返回<strong>正数</strong>表示自己大于比较对象 o ，返回<strong>负数</strong>表示自己小于比较对象。</li><li>第二种的优势在于可以定义临时的比较方法，不在类中将比较方法写死了，使用匿名类传入参数 <code>Comparator&lt;? super T&gt; c</code>  ，只需要重写 <code>public int compare(T o1, T o2);</code> 方法即可。下面展示一下：</li></ul><p>这里代码的主要思路就是对一个元素类型是 Tempest 类的列表进行排序，而我们的类 Tempest 考虑到不同的用途有不同的比较方法，就没有实现 <code>compareTo()</code> ，因此这里使用 Collections 里面的 <code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> ，其中第二个参数就是我们临时生成的匿名类，里面实现了 compare 方法。这个比较规则是首先按照年龄排序，如果年龄相同，则按照姓名排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Tempest&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Xorex&quot;</span>,<span class="number">19</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Asuna&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Yukino&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Megumi&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Origami&quot;</span>,<span class="number">17</span>));</span><br><span class="line">        Collections.sort(list,<span class="keyword">new</span> Comparator&lt;Tempest&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Tempest o1,Tempest o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1.getAge()==o2.getAge()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    Tempest(String name,<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&#x27;:&#x27;</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洗牌-shuffle"><a href="#洗牌-shuffle" class="headerlink" title="洗牌 shuffle"></a>洗牌 shuffle</h3><p>洗牌故名思意，就是将列表里面的元素顺序打乱，这种打乱是随机的，每次都不同的打乱。这种方法则是使用 Collections 中的静态方法：<code>Collections.shuffle(List&lt;?&gt; list)</code> 。</p><h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p>再 Collections 中，可以封装三种类型非不可变集合：</p><ul><li>封装成不可变 List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li><li>封装成不可变 Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li><li>封装成不可变 Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li></ul><p>调用这些方法，传入集合，然后返回一个不可变集合。需要注意的是，原来的集合实例还是可以修改的，而且修改之后，也同样会会修改返回的不可变实例。因此我们如果想要把一个集合变成不可变的，那么应该直接扔掉可变实例的引用，只留下来返回的不可变实例。</p><h2 id="Map-容器"><a href="#Map-容器" class="headerlink" title="Map 容器"></a>Map 容器</h2><h3 id="基本-Map-的概念"><a href="#基本-Map-的概念" class="headerlink" title="基本 Map 的概念"></a>基本 Map 的概念</h3><p>需要注意的是，这里的 Map 并不是地图的意思，而是<strong>映射</strong>。我们看看 Map 的定义：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里接口 Map 并没有继承与 Collection 或者 Iterator，而是作为默认继承了 Object，说明它并不是 “集合” 的一个下属，而是和 Collection 同级别的存在。我们一般的集合指的都是 Collection 实现的子类，而 Map，我认为被叫做容器更为合适一点，但是大家都叫做它集合。</p><p>Map 映射，从它的定义就能看出来，拥有两个泛型 <code>&lt;K, V&gt;</code> 表示 key 和 value 的一个键值对的映射。这种映射是拥有一定要求的，最重要的一点就是 Key 是不允许重复的，我们通过键访问值，键因此不能重复。</p><p>Map 集合里面拥有一些方法可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回Map中拥有的映射数量</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">//返回Map是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>; <span class="comment">//返回是否存在键key</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>; <span class="comment">//返回是否存在值value</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>; <span class="comment">//输入key返回value</span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>; <span class="comment">//输入一个键值对，建立一个null,如果key不存在返回null,存在返回原来value</span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>; <span class="comment">//输入键，移除此键值对映射</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>; <span class="comment">//将一个现成Map存入当前Map</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">//清空Map</span></span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>; <span class="comment">//返回一个Set集合，里面为Map的键</span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>; <span class="comment">//返回一个集合，里面为Map的值</span></span><br><span class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); <span class="comment">//返回一个Set集合，里面元素为Map.Entry&lt;K,V&gt;实例，每个实例保存了一个键值对映射。</span></span><br></pre></td></tr></table></figure><p>上面的方法中，需要注意的是 <code>V put(K key, V value);</code> ，因为 key 的唯一性，当我们使用 put 方法传入一个 key 已经存在 Map 里面的 key-value2 映射的时候，这个 key 映射的 value1 会被新的 value2 覆盖，并且 put 方法会把这个 value1 给返回回来。如果 key 不存在与 Map 的时候，新添加一个 key-value 只会返回 null。</p><h3 id="迭代-Map"><a href="#迭代-Map" class="headerlink" title="迭代 Map"></a>迭代 Map</h3><p>因为 Map 没有继承 Iterator 接口，所以自然不存在 iterator() 来返回迭代器，所以如果想要迭代 Map 的话，有两种方法可以实现：</p><ul><li>第一种是使用 <code>Set&lt;K&gt; keySet();</code> 方法，获取一个 装满 key 的 Set 集合，用 Set 的迭代器迭代出来 Map 所有的 key ，再通过 key 和 <code>V get(Object key);</code> 方法获取 value。</li><li>第二种是使用 <code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</code> 返回一个装满 <code>Map.Entry&lt;K,V&gt;</code> 实例的 Set 集合，然后迭代这个集合，对于集合中的每个 <code>Map.Entry&lt;K,V&gt;</code> 实例，使用它的 <code>K getKey();</code> 和 <code>V getValue();</code> 来获取键值对信息即可。</li></ul><h3 id="Map-接口实现-HashMap"><a href="#Map-接口实现-HashMap" class="headerlink" title="Map 接口实现 HashMap"></a>Map 接口实现 HashMap</h3><p>HashMap 是使用哈希算法来实现 Map 接口的一种集合，这里 HashMap 和 HashSet 使用的技术是一模一样的，都为哈希，不同之处就是 Map 为存储键值对的映射容器，而 Set 为存储单一元素的集合，Map 对于单个元素的访问可以通过键或者值，而 Set 对于单个元素的访问只能通过值。</p><p>我们使用 Map 的时候都是通过 HashMap 来实现的，不过因为采用了 Hash 技术，和前面的 HashSet 一样，想要存储自定义数据类型，必须实现 key 类自己的 equals() 和 hashCode() ，两者的实现方法在上面已经写过了。而 value 无需实现两者，因为其实现是针对 key 进行计算位置的以及是否哈希冲突的。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>首先观察此类的定义，发现它是继承于 HashMap 的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这意味着这个类拥有 HashMap 所有的方法，他们之间的不同之处就是 LinkedHashMap 自己内部通过链表实现了一个加入顺序的记录，也就是说，我们如果直接输出 LinkedHashMap 的实例，发现里面的元素顺序和我们添加的顺序是相同的，这就是 Linked 的意义所在。而且这个输出顺序同样体现在： <code>Set&lt;K&gt; keySet();</code> 方法和<code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</code> 方法返回的 Set 集合里元素的顺序，同样是按照输入的顺序保留下来的。（其实返回来的本质上是 LinkedHashSet 来保证顺序的）</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>我们来看看 TreeMap 在 Map 家族里面的关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">       │Map│</span><br><span class="line">       └───┘</span><br><span class="line">         ▲</span><br><span class="line">    ┌────┴─────┐</span><br><span class="line">    │          │</span><br><span class="line">┌───────┐ ┌─────────┐</span><br><span class="line">│HashMap│ │SortedMap│</span><br><span class="line">└───────┘ └─────────┘</span><br><span class="line">               ▲</span><br><span class="line">               │</span><br><span class="line">          ┌─────────┐</span><br><span class="line">          │ TreeMap │</span><br><span class="line">          └─────────┘</span><br></pre></td></tr></table></figure><p>这里 TreeMap 是实现了 SortedMap 接口里面的内容，表示它通过了树结构，实现了可排序的 Map。因为本身 HashMap 这样的类一是不像 ArrayList 一样内置了 sort() 方法，二是不像 Collection 大家族拥有 Collections 类来对其进行排序操作。因此 Map 家族就直接搞了一个 TreeMap 来实现 Map 的排序。</p><p>TreeMap 内部实现是利用红黑树实现查询和排序的，因此相对于 HashMap，他获得了 Key 排好顺序的同时，失去了 O(1) 复杂度的查询，变成了O(Logn) 。因此，如果没有必须的排序要求，还是建议使用 HashMap。因为实现方法不是哈希算法，所以自然不需要对 key 类进行实现 hashCode() 和 equals() 。</p><p>使用 TreeMap 的时候，因为要排序，所以需要 key 类实现接口 comparable 的 compareTo()，或者在建立 TreeMap 实例的时候，直接给构造方法传入一个比较器 Comparator ，这里原理都和 Collections 排序集合一样。</p><hr><p>集合的内容好多啊，所以就又拆分出来了一篇文章，第二篇的内容就比较少了，而且体系化相对来说比较弱一点，都是一些零零散散的工具集合，加油吧少年！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;集合导论&quot;&gt;&lt;a href=&quot;#集合导论&quot; class=&quot;headerlink&quot; title=&quot;集合导论&quot;&gt;&lt;/a&gt;集合导论&lt;/h2&gt;&lt;p&gt;集合 Collection&lt;/p&gt;
&lt;p&gt;用来存储数据使用，对应着不同类型的需求，拥有着不同的集合来处理它。Collecti</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="笔记" scheme="https://xorex.space/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="集合" scheme="https://xorex.space/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
</feed>
