<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xorex</title>
  
  <subtitle>要成为世界上最幸福的人啊！</subtitle>
  <link href="https://xorex.space/atom.xml" rel="self"/>
  
  <link href="https://xorex.space/"/>
  <updated>2021-06-05T16:47:14.015Z</updated>
  <id>https://xorex.space/</id>
  
  <author>
    <name>Xorex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为美好的世界献上祝福</title>
    <link href="https://xorex.space/2022/05/20/567f91f8bbba/"/>
    <id>https://xorex.space/2022/05/20/567f91f8bbba/</id>
    <published>2022-05-20T11:58:03.000Z</published>
    <updated>2021-06-05T16:47:14.015Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="689bfc10a9fed57c789bc7685d36a5d9d75f31b34cafe041b99ff510386c6242">8a972074cb8fb594adf191142c932486f63d9db6a4bbbbf65eb58b44e7f3a502ca39de9d3c1e3d9c70fdc9a01ad868dc3486910eced5f4e34f64df4c5155d0e28740e7f637329c5391f9bbe6ff64e653a789e2cef71c949e21aa63f2fba5c2f8909ab81d64320e8cb4384ed74fbebab2050cb82c4a7d22b4b9fd24d8a61fc8d8029f2ecbce16d7ac4071fe5c0ae2c3425b4c421b4a82a69b6012152d7d464a3624e786c960a03a52f9cd3453ffde3f9e7f7f8db1b21b9fd158b70d49126036880e6f581475aa1c9265c50093981c7c70663d0a1e3bede2870b4a7e0a6dc0d1a1ce8dbc658189e95bd6888f0f4d48bc8d7fa179df02ce8435ed223754c508e2b86eb7748ba754993eb71d24a37e5f551d0164956aa4d5dd5f723185894b6581fdc9638900b4666fa18e9bd6f6874b22c630932f62849d260f383329527390267e1ae61d8591c4aeb352f4b29108c2465a5e074d349edb5a9af79cb59ade636bb557cc6cdecd797157def65921204d200554354bc3d381c49d4097e92d1d51fd01c2313cff9d6502cf7e7f4b2399cc1e6be251d80c7050309bf346d386a7b536645f5c4c96178bc331da5740a42b0bd02b9968ce31b992b998e972e1dd06841a9d53b1d8280616027ac636ce646b67ae2c98a4b2ce990afefc45bd9b4d068c8fde09917cd2e84b9ffdf59606a1a60816d2f994703dfbbad7039e96e0b658292bacb1858ba7d9e49eb3187431fa4a1f8363915dc73aad3d519447f7cc0ff818de1453e2ab8257e0057131b57981825fc2c9f788e75c5564eb2ad8404bab6a82c47ab0a53249beb3b2306c2e5554ac2302070a4190176ddf1f1a7c9f4e483174777de2b527a91c806a1327390ff9a7eb985697c66546afc772628cec06b528dccdd1cb1d1d13ad8f74668fa5f5d0195cde6adade74f3ee1870b9a5da2542345b0f3ccb4e45aa3e4ca19ee469c348bc52b7c915f9fd94f14a9ce369c3d58e5c0e6550c9e6944437b122bacc312d2eaf41ec6165983d4afd819eb351ba8b730ee916f9cd78fef8008dcb9c56e63761799af98a3a7f796a1fa589fb9951d440a514e59ecf489a527c3a856fb48273361bc634d065d3e1833fc4a3b59e3f44008e8a1565a63506724732b84253673b58773214fb18c6f216ce7f94a3000979160f8fbe89f7300870c0103288288d986af8c35cf489154c5116b9e29ea3806b83fb4fb5c13bf5fac94b9fbb3d4dbc0a39cf185ce78c526bc7ed204162cdae47a4d016b2d81ea2ba9fc9830fb3527f1841ccf23061c0b80b53f3ae74c11c56b01d7711482081a2fcee250f16af2cb412ec812dc57d4d1d6985a692f17764a8bda6787d62fb8612eb25c70420071fd319dbc83c5d7f8ab892ebe088697c5f2833a61978a2b3c68e6916e569324b6bba4123401b6cccf173cb6f5f16b310bd23c631794739ed100cba1697a02e0cd558489edd5b9fb774265919385617ef45af3e351137e2be1db5a0dc536cc5ab5a80897d655a4da942de4a3fc9462a7d2eb6b49a288980210c8bf4649156b1e7d1f2c6e6eb1b8cb056067a2306541b7828ad3c48713b7ddcd33bdc4c83aec20ea2f4812ad03fedb8d33e6214f83ca38ffcbb55ca3859cd0cf07b65dd04174589117adf9d5c76448c6786447889122c612fb0ba366bfd64384a5162e27375fa7747622c6cf3b1c9c09bae41d179b1ac15d3cdd3254c2498e37f38e8b43b6620a7898afadb4e74414a7783ae2ffefd6aaac8cd082f33fa0abb3c8271690175664331e3053092c2b6abbf7e66adb0530ddde01a965e6abe809db7bd6d79229a09bd7df84c25da01c92e73a035e2667a75229c48e889842fbd0a1d7dbf7c579292b8557b8f400157e95b2864450dc73474ca6520544b623d98a0445e62a98d184853b6cf236e48ffe6ede26b4ca737f3f8c2f19701125867ec08135ca682b3cedc732362def3eefbf16d0327fedf680a5dc50bbb5590feeffc83a065c7c09fee680f2395508e418e59c28bcce45dcb357e95c2590a7ef9049d04d6bdbebce82c03d09be7d60c90ff409231a5b8df0091ede2ea2abe007dce72a5565fa7792a143ea45e0f14c3eed8ac989811cb44a0cb0fa483aa5f25831ccd3124d07a5558b126178f10f3600a554228513b55f48fdc6ca3d88c9a4203c3f729197919ecaff8376f9535fd87232cb896294f9fc4fdb1c094dc5b8c13fc9c0af0f6d5d0649aceb4beec719f7032a9d68ec16a1f386654f29e0adf7ade3d6d883067a74baa45dd07ca46c074be4a2d4d3cedd9cb43aa79ea8605e4a843d693cd9a062524820c3ae94cd3ba631d7d2c844b4cfd17570d07e02bb79c647880cb8f4a0614ff595bd22cff36fae33ba66ff6b9614ce43b5e2c2e2103b2a7c36dee450c0294e61645f1ff62b02acba1a876583591a53d9995c97318865eac82e9ab2d7daaee2edc69d2f6240b9cb98c8f3cc1c140d3ccfdb1894a3a9ae4db3704f4bef50c79ed660d72c4d76ca15c7b090c3a3ec8b6a1663e8ef6b80b33a790d75a8f2cab63863cfbab878fb45829ac4b30877f4b44ebb6fb1bd3deef6d4bb492d9e8dcd8f44dfda2afc59f9957524ddc5a9d26235be96e405f99fc668073799bfc29c611f3d097c9bef8404dfd98753bd059c4ccb2dc28284fa4d26f7388f29f063c5924d5d793e65af69eea2a654c3ca088ed576cea7a496de608c7fdc8adf94e22690d642584b9d121a80980bff1d66f2dbc7abf03c7272b4bd1f74df56756a806d0e76f293912b968b023f95efc0779c20497e818842577470c33cf1f1412cea0944a4fa2cd2a145d2a4dc588712f11729cb1233d6eabd234e0556425985afe3cf2518e4f70bbf31c038d5c335f500e0125cd3429ce768886381d9bf7fa0236a3449fd423c501be99daf36e54f58f09e63462c975afb417a015bd5f4a918f66f022aa79981cb82c29087351b1afe7b5051ad3712c3150e62f9d01f429d0b1050f348592d09d22cd5dc3409e3d11e7664dc114d8c37160b9d39f7d594813fd90cd23ac43c86cce7f22a0ecc46e9c77c1a1097fab3af5c9e0bbd893630d1db32066c3aeb8544e5a3b1e9f4905a3685a041e7921c29f7eb36041f276e3de9da457c90c0a4e9b1ec38db531d7887628745c5f26194ad2c2bc892a0e62a63be8e7162540b04696ee38d1ffa3deef3f110517e9813d259eb2617581819a50a37da390650ba8a86f576db6036fe772c8f8d2b15633f5d1905f11d452d62d67121d9a7d30cf26419c7100f2f51a3f0f8597048cda90b68b1b86116671fed5953d70fa552b04bcd54001afaaa291346a9eef0cb871f350a08a2e2ad3ead37fbe7af6c5ea3fbb4e2af874efb0d4f33d149f83b525500d0d106ae12249119307c0242bcfff7425822d2f61aae575154c5499f03b06da9bdfabf4707602c20b2eb9173a7f01dd7ea77e0b44303670982c11b53a5603e22cc74ca166846ef28697572ae88504db22754792584f45a2a559813081ab34c8641550dc1259ba7cc55de0d8ea0ae7ab83afc533113272ad893f0106a087e6bd0eb90c464eca576a7a217ef654ea365834f37076cec52bb40f7c2ec76ca2fdfd93511f3132b68d5279d42422d4562ad20cba8e76ddf4570fdeb4a0b1e63f2b87edf688afd4f51ae842b14864a528c57686385e5e763d175bf04d26ffd612a90f5d5ed0d49d6dbd4e472a192665afa263e1d9c2dfafb17858b59b5957992af881daf5231757ae0a3733d0e032415f2e6147113228b4c342045de3f73e08d00f893f7c05ab15b64603ef42b1e300b879fe6a8703d130048a0ef4c43a0f5aae256cfbd422f76818720e45572b16b6aae06c7c9a8a2be60d6bc205e8a0bccfea6660196c6ccb73571d9fce6aec0dbf9a211c12769ce9f1d4d2dcaccffc5049e92fc42abc59c6b952abf55ce944bd619f23f17700a194a95daeae67c69a289b48ac154619c185012cae1d913657e9fcc2ea89ededbd49813fddef2a842336a0a62385844b872a5c648b7ab23e2015579b053780d4c2fc01e621dfdb0f169723e26e319948f6355a3d52c26774488a5f43a1d574e80c78730f8b825210e3a93d5b904cd14d74f09255b74f5e5185d35713038bfecaff6c4cbc9c3e6b3638c64ed1af85cd0746586e41377fa167c73f22a605639878844d9a73dc5c244e02e359c3ae6cb62540b36a4b5e2150898258f2f86d881fb21d0e5c1c4e3552eb48159529396d53cc96ff48320c1406acc328fe9c1cddb62363481ed658ec32273b5f6149e80d7f111cad43e8f989c6f9609f194d18319b7932ce1854265e28c93ad307ee5f638c795b49f625b6783187862743df526a3da373e9e814846ea92343d3d5979772a38dec79be44317f0c75efadac03409fc473af07b7c47adb8170959bb5d20d41362e96ff110bbecd6edb3a7fef4bab4470423113aa367d0e8a2425c87bd98550ac0e7db65c9c7d32db12cff2bcfa81cda4e41d0b308f9578b4b1e5d5794d5ce80ad0ef7eed3cf3039f85c28d6fc247f3e04e4da416c126c6a7453431952565dbd973ceb410451246d221b4c4c59bb45dc1e8f01d15456e4bc59b26feee41aa8ef0356eab5d03e4a9cced9df106708a16de62ca4bf2d9ca503747ed9f4b6b664916a7bf851b7392e1e71ded53d2576c775e15be1a4502a80dd2f5c34808e17f642d8a987ec273b5d0868a114466b331e563ac674abec48fd6783c8624a06a92dc359b3efbc0e9c28aa832f4a61417ff2859ddbda7ccc5617d1a9d17ce2843ea48c7b5bddf9e2d79aeae9d844002cae5545cceded9192bb31c3b49b7723b30da30318015acd6f16cabae11f2f2d197f0b0097fe222019bd1e82d6fb82b1b7a240b0be445cef0404adc7c55a1ff0bf296c88b6be1ce1b0083dd453c5a91cf01c0abe097a59f9f5771310187ee251f978945d21311f01ed29eb1ded81deda69d472642b543e0e8bf92781a96f9e576e3172770483f69c15fea7ec986b796d1a5c1f0a08e96b1090dd9119f840d9c016ac32b8cf483f3986934121380be1af639c7efc0ce4f4429aa99eabaf015c4f81a232aa9d030faa9c401c118532146e91ea4ccb77bbe21995fcdb4f16409a41715920a010d8adbca438d7c94852563dc36af172bd19e552fe44a45222fc43fe10e7ba6d4d857156399cd143de7caaeb001e14fcb3d03be87ea1717c748bce8c47ad170f8170c159e37f533dc7f0415eeb55dd07c7c28b7358f4cf62b257b6e3d972ee8d75e04c673e0cd267ac89badebc34fa445f6cac623c9ee9447556c5149db450291ba01c3dc62ebc7661da869d3c7f23b853f29af418a41890aab8c1093ba44d46019deb75043ee8b76f9fc9fbd149ad4b77ccbade7d360c94eba7766b1650414c48088892abb236903bac42fa1c32d90d972ef54da2a2d87b8e0f2ddbf5b006e6ff79660d4122fdb8332e5ec80a90bcd95db27fcf79376ed0baaea37dc99c00194e35cd48c3f93a78000fbbead43982ed3dacbea40785414ac60d9281353479cee2cae86b73a3769ebd29736f9dff2ca6be49d2908d7517f4f11d6145e23cab64929ca877bb055d9a547e4f13dfb1cc300487538fe065df2eb6cad120563d809978f54eb6337ddab9e509fd1ffb27217ccc59f8bdc582037569b46a1d88ca9641b721f5177a10abb2038b60945f5ddc42f0433c0062cf5410a8ca84a91930718f1ba1a0bb879da6130740911c5a7431c19985ea8a6f6a64ee53399cb40a1252e2dee4a36178fa2e25826e8787db25c33b3c11a1574a0bc8b5f58cb6f7bc7b31878ac035bce91319ed0f5bbef3e7b249ca8c7ecae0ed40e38f8881f73125aa4058883ed2e3241d9706bc3c185c9fe9f0c9a64318a0e848ad08864b747a38a166cfa55dbaf417deaf2781a8223d6b3856a69a48e53f3bea85f02eaab5a61d8185e7856ff545e2e666b839bac6ca08a34a9ed391eb859330148e35f0a9221f8000f1ba42a55a545688868027c4a34cf2d05dc12f3e512500e853e853fc713465766e55741d58b28a9b994fd03cb213d1475e84189329170f0160ed9f5cf75260be695c74fa812375c6f0ad329adc909e5f76cb3f12a98b4128d5b17677cbc9322360667ad6f2268f49e6c70f905adae18ef1a10b8ebcc6c5df15fbcaee97e5bf039a683af766b7ee350eeb564f7df1159c0cfc7b863ed7844ab0f55c147028bbc125822720807d0da21387520376d1f581235ae9887f952ee49b5d746989ce8d9378aa6bee5faf12d9ac3b2f79e3a684361dba69b657884b8cab25daec678f004f793a845fbe5bdec336aa74d05948fbafca14c7ec43a6569883b0ad31a801c38d78173453b632b65ccb08ac379aa6f0dcf7a11035415c58b39557dff5a4246860f5ce80cc862218a43986e3b9f27ceebcdd62f7fb645f5c77b7450995789545edb0a5c11119e87691691478b9d939ac95c43e2245d4c448e806b01c0918ed18805edd519d2a927adb92fbfd2c9dfc5d564d82f5b092b5203547ed28d731726e47fe054cecfa6b4137024e8ca9b943d46aac7b792bfdb857831de16281dc4b15ccf73a6774799cada60cd4e964b3ec56b057df054ac12f14c886dc99ffbe46426607d8b754058f944304ffa6dd7a19e96ff9fb9630948e0526ab72cad0633b507a48ed58f7d34cfb0dc68c6fd9523246b3b63d4db3ee7a6563787fc9f7cbd88966881671abf8c037f15d362a7ae43e3174ccd05716e3e595a36b45b42d16059f1ffe3f85acb416942c0d82de9db439b96e08aacf890b61a936c285397eef3e83ad4a47f00059c0e0e9675e6dd257f5db2cd06bdb0506cb696f9a698c85a95cd95aee8c354456a8fcc055818e2b4da0b44376810cd607b3809f03d7af96ea963adaf4a8abaae66ec2b993cff102c57380bb41030f6192163a8076dbd2e7b037553d1f3928804847b1f359563a0e752c3b9b80dad8102cf77d3f7100a6e881e52db01c42d9694c3cd6afc86a77fda767232b2e66a393b2011ac6af6f9d00d9be3d31e1065b61a118319daa5422a78bf06ba773bb2a5f9343b948483ad66b781222d9bcb211e13d4c851d5bbf7328025b38ca63c4907945cedf110a838aba27cad851f73ddc5c5ee6538ebecb22454cde54cefd0d808263364a9d3fab55df73b11e0ac7f426f22d3050163fecf163512def63d06ede8f842fc5a41bd7b65915eb55bf776e7460d8675ce525a3bd8ce12fb42134dbd97321fea31444376355c9163a30d28d09c43be25fc49d7c9286e4b13c4dde2ec4f425d2f8a50c5f9229d2d6714e05d41eac3f8c2df13b25af2d912472a5ad9b600ff739bec4386b96fbf28767a19cd7696cf194bb1822b0bba1d55ecb053024fbfaf595ffb2b62114e56608cb119c3d6b26f3800998e20c7697e33087f223d6cef191cdc11a61009321aeac4c757fccb57ad6880f05302b00c7c12309e882126ee82c2d65f236d6aba8297a9fa113ddeecfaec3bf578f964449f208f86a55e7c7fc680104ccacc8b51731eac235142f937d68d117766c6b97a0890c2f0c5906269d463b70a27fcf042d702d6a84816c0b04c615e4641b37b352a5bdef59f27ceb05fe42f15f85ee9d3a3cb109fc07f4ea42d8577921315a1d57995acda377a83a95277869401d204d0154e45231dfa418ba19565adeb6f947f85ba84ead98fd9f72ddf24173d8bb6c675d60eb4c0bd019e2c2e04904ec56b0570662f7686ee4cd789bb9bf9a7cdc6cd155be5bc6dcbc548914afaa55553e6c8f9f7eac4ae6a9b43d0f42e810250d9812b6726d59c7a2adcf70a051bd6b970a701e7385972939f42c34c08676b778787a96fceb316a48b9e94efb3cece703aef605279442697282a777b97a5aa22ca2cfbd694d2e7e786878bd5b67cccff6e6763c52b8b0a4e5485fdee23ad79007c7201371e010c8a24d80b18e7d35d4d7d9335f4990dc027a096d5cf811f8fa3e21fe8146307e98fe97bcca6bcc11a0a67d7e65288ef112033b9f13248cdf8634ea67d6051e92933aacad2e4bac99ba8ae764a3c63cfc1069d1922f47f3e48f46c7d818682b51c92e31caf6977926dd3df0e6e9dc65d9858133186907b94939e288f46cee43adb7ff69d369c5828e043d10f3f132d5098c687633080f027dd73f34b4f070299a2ed3579eb2f7068d66a7485f3e20c2e9bb963d760467cfba67fd1cc253e97c8c0cb054fd06b2ed7d612388a50e59b2268f7094783f19103c8ed86d86ada4fd4d6b63eee59240d19cc566d83b3d499f86f0da374362dd17b24eeef5f8ff2536f431a0ba9c5fe7955508bf5824b9829e38687448f2e83c726931838c4d038ff25d171486f5ba4fbb2499edb41fa89c2113701003cfd6703d040acdcf83c87324d33778e217d37da1d2b072c39067b23f9e980d59f1b73757168124746a5c3b15eb75b41c0ba004ffa77b12ba35b1e9b5d141348c39d499d0621b12e1aa022bd569cb2bb30e15e82b458f336e2f3285f10e0a7859f824af87fe5d65159e0ec969ecc2161bb0e33dc9125fbac004c2705a85be85bdba10b86ce22b7b06cf08757792e8592bf397398fc9627094221440b4ecdab198583376f3393bd5ddf19c9f6ec3ac94aa6c9a44aa6509508f9c1a242158084e475c6819ce401816f785a6bcb3e553fb0917355e92c2cabf25b2bcd4d4f1443a3fa3330a3a8f46534b8dd466ec18fc4bafe757f0980c35cd260cf7cc46518f4813bf5614c82709a99ed68cd32a17aa97b99a1ba9f468fa44ffc29202d4baf93b9240d6c34d7d2349feedbcb34e6f28d6d6cff003d28b319ae4c153bb5b82e286feb73638187bd02e9b6b21a3ef2281ae8d589c921d426330cf693eb80eb45e3dd83df3f7e5f92268351885c3aff655d09df11c9e4aa4e011bb1ddcbc715673f4308b76e281aed3335c8447f82667fcd64089ca564d199b96b826a8425c15d033b37a437595111808f946326a4a7547e1afc1f60bf5d6881d5682048fd3fda3cc034b8962e8e3ab397e167e4e7a67fb5f6405170cb7b8a93a151963957a0c7e5a10f5c831de7608f2dc4742e10a0bff962ba5509b2c987e644e866f968538ada9b9dc173f7d06c13d7fd976a9556c0b92399da6389a79920bd7a6449c10bc99c4d8621f8d82237e635025391224151ae2808e73c2955a60e60c501d0e9fa96b55ce0677e57fdbf149aecd83033c72896390072961db8da0c5f683ba2308d0815acd5b23311c530e15a5ec406435cbabf12617615ddde9db78f91be2c139a96e354f7e1276393d6b0e1f0f5c98b2ea4c5f13e925201dd683080379e5c1e52c244a7b61937b3acda4e40ceb5c1b879fa0fa3f556f2b8cd0b978169299c61fa2bd70bd8d4699dcbe70818945a8e36b234e554d92705390e9639b926e87bb1fcf22a60833cf2fd5e97c245a383e05c0a1b13f75135b3a742f652cd2e7da3e73e8da53493ee51fb001e7f12618f8cd52e05e4f653b88338bb3f50649e351b6fc9cefdcbcb40903acea8e572bfcae0b0571ce2e3d5363e578d13e6acb598d176f392a60638490f32c5e128fa2e7e444511e8281829cc11a39d59d789abd84b6002e84ce4ef485957b48b3210fa04f4552cad85f28be845f3812d72e86190af94b9c370c2a30d3b6eabcc3fdebd1b5f4e1258f054466cdfa2ba30aaf845046cc19db80c200ae27f90532be1526717f3a4152a78985c93e735f46edad5be9899b890368c7443bd8bf0ac52f33c0388d906d1ae2778dc9415f48fe5b4d0eb8dfbdf96400fc43247b8fc8603302649fd9938f5d8be1fd266a32d4bc33f07cadf49933d016ff6463617e1968bb04dcad750ff91fff3ddaa7eac57728aa4fda71b6562d5285138a90e7bfcd1c190684f8a4832c4bb77737b81cf021e01abe5a7371a0ebbe5617235503f804212feed8fcb82fc2eaee5dccff4c0423fd78e874c30ce500e1fe9c6722f768561c3c903cf1193342660764081c81cdf0a7cfa9e519becba3ab8fd7cb705ee5930d61f732151414f9ed04a548f1b6d7fdaa22ff84f94f787afd2bfcfbef75830dabadcd44d3db76f40e1e5f25bb08fb979499873f8e12d53976af844bf4b9d041a2784a23b4824b329a9cc7098605eb815c475fd8f7c525ec8879decce1c48dbb8250e58b9e3057bb355c954fd92034065744a2f2b9fc1970d4f61eec37d842e0ac703585960b13237e87d94764e9db6bc45918fde2a365ee5308c52f01576712f31ba9a8b0dcc27cae382</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Encrypted</summary>
    
    
    
    <category term="阶段性总结" scheme="https://xorex.space/categories/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="幸福" scheme="https://xorex.space/tags/%E5%B9%B8%E7%A6%8F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-算法入门</title>
    <link href="https://xorex.space/2021/08/09/e904f9b136c8/"/>
    <id>https://xorex.space/2021/08/09/e904f9b136c8/</id>
    <published>2021-08-09T04:15:47.000Z</published>
    <updated>2021-08-11T08:20:03.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><blockquote><p>关于老年退役 OIer 竟然忘光光所有的算法和数据结构，然后从所有 OIer 和 ACMer 都看不起的 LeetCode 开始学习算法和数据结构的故事。</p></blockquote><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><p>为什么不是具体分析而是二分模板呢，因为具体分析太乱了，left right 的范围，while 循环结束的条件，每一次 mid 判断之后，left 和 right 变化的过程。每一道题目都不一样，所以二分还是要这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(left+<span class="number">1</span>&lt;right) &#123; <span class="comment">//推出循环条件就是 left+1==right</span></span><br><span class="line">    mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]&gt;target) right=mid;</span><br><span class="line">    <span class="keyword">else</span> left=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出循环之后，需要的答案就在 left 或者 right 里面，只需要对他们两个进行判断就好了</span></span><br><span class="line"><span class="keyword">if</span>(XXX) XXX; <span class="comment">// 单独判断 left</span></span><br><span class="line"><span class="keyword">if</span>(XXX) XXX; <span class="comment">// 单独判断 right</span></span><br></pre></td></tr></table></figure><h3 id="算法题目"><a href="#算法题目" class="headerlink" title="算法题目"></a>算法题目</h3><p>都很简单就不搞了。</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="算法模板-1"><a href="#算法模板-1" class="headerlink" title="算法模板"></a>算法模板</h3><p>没有模板。</p><h3 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p></blockquote><ul><li>输入: nums = [1,2,3,4,5,6,7], k = 3</li><li>输出: [5,6,7,1,2,3,4]</li></ul><p>要求使用空间复杂度为 O(1) 的算法。</p><h4 id="题解一"><a href="#题解一" class="headerlink" title="题解一"></a>题解一</h4><p>我们观察 <code>[1,2,3,4,5,6,7]</code> 变为 <code>[5,6,7,1,2,3,4]</code> 的过程，是将原来的顺序的数组拆分成了两个部分 [5,6,7] 和 [1,2,3,4] 两个部分。我们将这个两个部分进行反转，变成 <code>[7,6,5]</code> 和 <code>[4,3,2,1]</code> 。结合在一起就变成了原数组的反转。</p><p>所以我们可以利用这个过程的逆过程来求数组右移的结果，也就是三次反转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P0189</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k=k%nums.length;</span><br><span class="line">        trunOver(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>); <span class="comment">//整体翻转</span></span><br><span class="line">        trunOver(nums, <span class="number">0</span>, k-<span class="number">1</span>); <span class="comment">//前一块翻转</span></span><br><span class="line">        trunOver(nums, k, nums.length-<span class="number">1</span>); <span class="comment">//后一块翻转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trunOver</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(end-start+<span class="number">1</span>)/<span class="number">2</span>;i++) &#123;</span><br><span class="line">            temp=nums[start+i];</span><br><span class="line">            nums[start+i]=nums[end-i];</span><br><span class="line">            nums[end-i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题解二"><a href="#题解二" class="headerlink" title="题解二"></a>题解二</h4><p>这里是一个一个元素置换实现的，至于为什么需要 GCD(n,k) 轮置换才能全部结束，我根本看不懂它是怎么证明的，所以我选择另外一种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Method2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times=GCD(nums.length, k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;times;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp,pre=nums[i],next=i;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                next=(next+k)%nums.length;</span><br><span class="line">                temp=nums[next];</span><br><span class="line">                nums[next]=pre;</span><br><span class="line">                pre=temp;</span><br><span class="line">            &#125;<span class="keyword">while</span>(next!=i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y&gt;<span class="number">0</span>?GCD(y, x%y):x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那就是不计算置换多少轮，而是如果换位置的元素数量小于，则继续置换直到换位置元素数量等于 n 就好了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Method3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;count&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp,pre=nums[i],next=i;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                count++; <span class="comment">//使用 count 计数</span></span><br><span class="line">                next=(next+k)%nums.length;</span><br><span class="line">                temp=nums[next];</span><br><span class="line">                nums[next]=pre;</span><br><span class="line">                pre=temp;</span><br><span class="line">            &#125; <span class="keyword">while</span>(next!=i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LeetCode&quot;&gt;&lt;a href=&quot;#LeetCode&quot; class=&quot;headerlink&quot; title=&quot;LeetCode&quot;&gt;&lt;/a&gt;LeetCode&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;关于老年退役 OIer 竟然忘光光所有的算法和数据结构，然后从所有</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://xorex.space/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://xorex.space/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-06-数据访问</title>
    <link href="https://xorex.space/2021/08/08/c76cee16e45c/"/>
    <id>https://xorex.space/2021/08/08/c76cee16e45c/</id>
    <published>2021-08-07T17:31:37.000Z</published>
    <updated>2021-08-13T12:55:57.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><h3 id="starter-data-jdbc"><a href="#starter-data-jdbc" class="headerlink" title="starter-data-jdbc"></a>starter-data-jdbc</h3><p>分析 SpringBoot 的流程，就是导入 starter，它可以帮我们所有可以默认配置的东西都配置了，除了数据库类型和数据库配置。</p><p><img src="https://xorex.space/image/327.jpg" alt="327.jpg"></p><p>可以看到为我们导入了 Spring 的 JDBC 数据库相关包 (beans,tx,core)，一个数据库连接池 HikariCP，然后就是 Spring-Data 的东西了。</p><p>我们现在导入数据库驱动，因为 starter-data-jdbc 已经仲裁版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mysql-connector-java.version</span>&gt;</span>8.0.23<span class="tag">&lt;/<span class="name">mysql-connector-java.version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以我们引入数据库驱动的时候，其实是可以不写版本号的，但是因为驱动版本过高，所以修改一下降低驱动版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>剩下的事情就是写数据库的配置了，通过 DataSourceAutoConfiguration 可以看到使用的 DataSourceProperties 的 @ConfigurationProperties 是为 spring.datasource 前缀，我们就可以再 yaml 中配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">XXXXXXX</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>项目已启动，就会运行默认的连接池 HikariCP 来连接数据库。</p><h3 id="使用-Druid"><a href="#使用-Druid" class="headerlink" title="使用 Druid"></a>使用 Druid</h3><p>阿里的 Druid 虽然性能比不过 HikariCP，但是提供了很多很方便使用的生态页面，我们来用用 Druid 试试。</p><p>使用方法很简单，加入 Druid 的 starter 之后，引入一堆 AutoConfiguration 和 Properties 自动配置，就可以直接使用了。至于更多功能的 Druid 定制化，则不在讨论范围内。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="整合-MyBatis"><a href="#整合-MyBatis" class="headerlink" title="整合 MyBatis"></a>整合 MyBatis</h3><p>同样是引入 MyBatis 的 starter 启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从使用的 MyBatisProperties 可以看出来，绑定的配置前缀是 mybatis。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mybatis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisProperties</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们就可以在 application.yaml/properties 中配置 MyBatis 了。</p><p>以前我们需要 Config.xml 和 Mapper.xml，但是现在有了自动配置之后，我们就可以利用 application.yaml/properties 的 mybatis 前缀配置将 Config.xml 配置文件给省略掉：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span> <span class="comment">#驼峰和下划线映射</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:MyBatis/Mapper/*.xml</span> <span class="comment">#mappers 位置定位</span></span><br></pre></td></tr></table></figure><p>指明了 mapper.xml 还需要将 Mapper 的接口也放入 IOC 容器中才可以，这里使用注解 <code>@Mapper</code> （标注在接口处） 或者 <code>MapperScanner</code> （建议标注在和数据库配置相关的 @Configuration 的配置类上） 来注册 Mapper 接口。</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>还是引入 starter：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是 SpringBoot 默认是集成了 JUnit5 的，不包含其他的 JUnit 版本，不同的是不需要引入 Spring 环境了，在测试类的开头用 <code>@SpringBootTest</code> 就可以直接使用 SpringBoot 环境了。</p><p>剩下的东西大部分和 JUnit4 差不多，以后做项目深入学一学，练一练。</p><h2 id="指标监控-Actuator"><a href="#指标监控-Actuator" class="headerlink" title="指标监控 Actuator"></a>指标监控 Actuator</h2><p>SpringBoot 已经内置集成了 Actuator 这个东西，我们只需要引入 spring-boot-starter-actuator 即可。</p><p>具体的内容有点复杂，不太想学了，以后再搞吧……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库连接&quot;&gt;&lt;a href=&quot;#数据库连接&quot; class=&quot;headerlink&quot; title=&quot;数据库连接&quot;&gt;&lt;/a&gt;数据库连接&lt;/h2&gt;&lt;h3 id=&quot;starter-data-jdbc&quot;&gt;&lt;a href=&quot;#starter-data-jdbc&quot; class</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringBoot" scheme="https://xorex.space/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-05-视图解析与模板引擎</title>
    <link href="https://xorex.space/2021/08/03/5036c7ea09d6/"/>
    <id>https://xorex.space/2021/08/03/5036c7ea09d6/</id>
    <published>2021-08-02T16:34:12.000Z</published>
    <updated>2021-08-11T10:12:00.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图解析流程"><a href="#视图解析流程" class="headerlink" title="视图解析流程"></a>视图解析流程</h2><p>视图解析的地方主要是从返回值开始的，上一篇已经分析了返回值的处理流程，其中用于处理视图的有下面几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String</span><br><span class="line">ModelAndView</span><br><span class="line">View</span><br></pre></td></tr></table></figure><h3 id="重定向-redirect"><a href="#重定向-redirect" class="headerlink" title="重定向 redirect"></a>重定向 redirect</h3><p>我们以常用的 ViewNameMethodReturnValueHandler 来说（就是处理返回值为 String 的）：</p><p>先将视图名放到 ModelAndViewContainer 中，然后判断是不是重定向视图（看有没有 forward: 开头），经过各种数据获取之后，将 ModelAndViewContainer 里面的东西抽取并返回一个 ModelAndView 对象。</p><p>有了 ModelAndView 对象之后，也就是有了数据和视图名了，就可以去处理派发结果了调用 processDispatchResult() -&gt; render() 来渲染我们要得到的页面：</p><p>遍历所有的视图解析器（ViewResolver），通过视图名来找到可以处理当前视图的 ViewResolver，找到之后，就通过 ViewResolver 解析视图名来得到视图 View：</p><p>（比如能处理的 <code>redirect:/XXXX</code> 的 ViewResolver 就是 ContentNegotiatingViewResolver 这个解析器。它通过内部的一系列解析之后，返回了一个 RedirectView 对象。</p><p>只需要调用 RedirectView 对象的 render() 方法，它就会获取目标的 URL 地址，然后调用 response.sendRedirect(encodeedURL); 来跳转页面。</p><h3 id="页面转发-forward"><a href="#页面转发-forward" class="headerlink" title="页面转发 forward"></a>页面转发 forward</h3><p>当然还有另外一个常用的，那就是转发到其他的页面的时候，它是使用 InternalResourceView 来完成的，而核心功能还是 Servlet 的提供的原生 <code>request.getRequestDispatcher(path).forward(request,response);</code> </p><h3 id="模板页面-字符串"><a href="#模板页面-字符串" class="headerlink" title="模板页面 字符串"></a>模板页面 字符串</h3><p>如果是 Thymeleaf 模板引擎的话，就会获得一个 ThymeleafView 来渲染视图，渲染过程和 JSP 差不多：</p><p>先拿到 Model 里面的所有数据，然后明确页面的所有设置，剩下的就是在 Writer 输出流中不断的填充数据，输出代码了。 </p><h2 id="拦截器系统"><a href="#拦截器系统" class="headerlink" title="拦截器系统"></a>拦截器系统</h2><p>拦截器系统只需要实现 HandlerInterceptor 接口，具体的原理和过程可以参考原 SpringMVC 的文章。至于将自己实现的 Interceptor 放入 IOC 容器中，还是要依靠重写 WebMvcConfigurer 的配置方法。可以说所有关于 SpringMVC 的配置，都是在这个 WebMvcConfigurer 中的方法完成的。</p><p>我们只需要对这个配置类设置 Interceptor 进行重写就好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123; <span class="comment">//返回一个修改了某些默认实现的 WebMvcConfigurer 到 IOC 容器中。</span></span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">//重写添加 Interceptor 的方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">                        .addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                        .excludePathPatterns(<span class="string">&quot;/index.html&quot;</span>);</span><br><span class="line">            &#125; <span class="comment">//注意要拦截的范围</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件上传功能"><a href="#文件上传功能" class="headerlink" title="文件上传功能"></a>文件上传功能</h2><p>具体的使用方法还是看 SpringMVC，毕竟用的还是 MVC 的那一套东西，这里就分析一下源码。</p><p>关于文件上传的使用，因为 MultipartAutoConfiguration 运行的时候，从 MultipartProperties 中读取并将 StandardServletMultipartResolver 放到了 IOC 中。</p><p>当请求过来的时候，会用 StandardServletMultipartResolver 来判断当前请求是否为文件上传请求，依据就是 multipart 这个关键词。</p><p>判断成功之后会对请求进行二次包装，变成一个 StandardServletMultipartRequest，之后就是和参数解析流程一样的了，</p><p>不同的就是对于 StandardServletMultipartRequest 类型的请求，能解析它的是 RequestPartMethodArgumentResolver 。它会将请求里面的内容封装为 MultipartFile，然后传给处理方法的参数。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="基本异常响应"><a href="#基本异常响应" class="headerlink" title="基本异常响应"></a>基本异常响应</h3><p>SpringBoot 有自动的异常处理机制，只要抛了异常，对于浏览器用户，就会返回错误白页：</p><p><img src="https://xorex.space/image/325.jpg" alt="325.jpg"></p><p>对于非浏览器用户，就会返回错误的 Json 数据，因为异常信息太多了，就改成 404 了：</p><p><img src="https://xorex.space/image/326.jpg" alt="326.jpg"></p><p>自定义错误页面的话，只需要在静态资源或者模板资源目录下面创造 <code>/error</code> 文件夹，然后将状态码作为响应文件的文件名（可以使用掩码，不确定的用 x 来代替，比如 5xx.html 表示所有 5 开头的状态码）</p><p>放了之后一旦出现不正常的响应码，就会去 <code>/error</code> 下面找对应文件名，然后返回页面。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>这个源码在前面 SpringMVC 就分析过了，不过唯一不同的是当出现所有的 ExceptionResolver 都无法处理的错误的时候，SpringBoot 并不会抛给容器 Tomcat，而是转发请求到 <code>/error</code> 页面，这个页面有一个默认的 BasicErrorController 来处理。</p><p>这个 Controller 从请求域拿到各种数据，然后去找 ViewResolver 来处理这些数据，经过遍历之后，获得了一个 DefaultErrorViewResolver 来处理，它唯一干的事情就是根据响应码从 <code>/error</code> 静态页面或者模板页面里面找对应响应码的错误页面。</p><p>找到页面之后将视图名（错误页面文件名）封装到 ModelAndView 中，然后返回，开始视图 解析流程。</p><h3 id="自定义处理规则"><a href="#自定义处理规则" class="headerlink" title="自定义处理规则"></a>自定义处理规则</h3><p>先说一下具体的流程，抛出异常之后就会遍历所有的 Resolver，找到能够解析此异常的解析器。找到解析器之后，会遍历解析器内部的所有 Handler 处理器，依靠这些处理器对异常进行具体的处理。</p><p>以解析器 ExceptionHandlerExceptionResolver 来说，自定义其内部处理器方式和规则，和 SpringMVC 是一模一样的。也就是使用注解：<code>@ExceptionHandler</code> 来定义处理的异常类型和处理方法。</p><p>而要自定义 Resolver 只需要实现接口 HandlerExceptionResolver 接口，然后加上 <code>@Component</code> 注册 IOC 容器就好了。</p><h2 id="原生-Servlet-API"><a href="#原生-Servlet-API" class="headerlink" title="原生 Servlet API"></a>原生 Servlet API</h2><p>对于注册原生的 Servlet Filter Listener 来说，我们有两种方法，一种是基于注解扫描添加，一种是在 IOC 中通过修改 RegistrationBean 的行为来注册 Serlvet。</p><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>原生 Serlvet 使用方法和以前一样，不同的是自定义 Serlvet 完之后，需要使用 <code>@WebServlet(&quot;/path&quot;)</code> 来注册 Servlet 和定义映射的路径。然后在 <code>@SpringBootApplication</code> 的启动类中加上注解 <code>@ServletComponentScan(&quot;space.xorex&quot;)</code> ，来在定义扫描的包路径。</p><hr><p>或者使用 ServletRegistrationBean 来注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">servlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> Servlet(),<span class="string">&quot;/servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="function">ServletRegistrationBean <span class="title">servlet01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> Servlet01(), <span class="string">&quot;/servlet01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter 同样也是，使用 <code>@WebFilter</code> 定义路径，<code>@ServletComponentScan(&quot;space.xorex&quot;)</code> 定义扫描路径。</p><hr><p>还是可以依靠 FilterRegistrationBean 来注册 Filter，格式是和上面的一样的。</p><h3 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h3><p>Listener 只需要用 <code>@WebListener</code> 来注册一下，然后 <code>@ServletComponentScan(&quot;space.xorex&quot;)</code> 来扫描路径。</p><hr><p>同样是可以通过 ListenerRegistrationBean 来注册 Listener，格式是和上面一样的。</p><h2 id="内嵌服务器"><a href="#内嵌服务器" class="headerlink" title="内嵌服务器"></a>内嵌服务器</h2><h3 id="内嵌原理"><a href="#内嵌原理" class="headerlink" title="内嵌原理"></a>内嵌原理</h3><p>Tomcat 是 SpringBoot 默认的内嵌服务器，在启动的时候会通过 TomcatServletWebServerFactory 来获取 TomcatWebServer 实例，并启动服务器。</p><p>而要修改内嵌的服务器，方式就是通过切换导入的 WebServer 的 Jar 包，来决定加载的服务器类型。如果要讲默认的 Tomcat 修改为 Jetty。应该将默认的 Tomcat 排除配置，然后加入 Jetty 的 starter：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后启动之后就是使用 Jetty 作为容器和服务器了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2021-08-08 00:26:08.499  INFO 13260 --- [  restartedMain] o.s.b.web.embedded.jetty.JettyWebServer  : Jetty started on port(s) 8080 (http&#x2F;1.1) with context path &#39;&#x2F;&#39;</span><br></pre></td></tr></table></figure><h3 id="定制-Serlvet-容器"><a href="#定制-Serlvet-容器" class="headerlink" title="定制 Serlvet 容器"></a>定制 Serlvet 容器</h3><p>这个主要就是修改 <code>server</code> 下面的配置了。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;视图解析流程&quot;&gt;&lt;a href=&quot;#视图解析流程&quot; class=&quot;headerlink&quot; title=&quot;视图解析流程&quot;&gt;&lt;/a&gt;视图解析流程&lt;/h2&gt;&lt;p&gt;视图解析的地方主要是从返回值开始的，上一篇已经分析了返回值的处理流程，其中用于处理视图的有下面几种：&lt;/p&gt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringBoot" scheme="https://xorex.space/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-04-动态资源处理</title>
    <link href="https://xorex.space/2021/08/01/d5fec45a0a25/"/>
    <id>https://xorex.space/2021/08/01/d5fec45a0a25/</id>
    <published>2021-08-01T03:54:43.000Z</published>
    <updated>2021-08-11T10:12:14.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h2><h3 id="装配原理"><a href="#装配原理" class="headerlink" title="装配原理"></a>装配原理</h3><p>装配 SpringMVC 的时候就已经装配了 HiddenHttpMethodFilter，我们只需要在配置文件中开启使用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;HiddenHttpMethodFilter.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;spring.mvc.hiddenmethod.filter&quot;,</span></span><br><span class="line"><span class="meta">    name = &#123;&quot;enabled&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderedHiddenHttpMethodFilter <span class="title">hiddenHttpMethodFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrderedHiddenHttpMethodFilter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就需要配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">hiddenmethod:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span>   <span class="comment">#开启页面表单的Rest功能</span></span><br></pre></td></tr></table></figure><h3 id="HidenHttpMethodFilter"><a href="#HidenHttpMethodFilter" class="headerlink" title="HidenHttpMethodFilter"></a>HidenHttpMethodFilter</h3><p>本质是是一个包装器模式，通过重写了 HttpRequest 的 getMethod() 方法，检测如果有 <code>_method=XXX</code> 参数并且 XXX 为允许的 PUT DELETE BATCH 三种请求，就将 getMethod() 的返回值替换成对应的请求。</p><p>这是为了解决 HTML 只能发起 GET 和 POST 请求的弊端，对于非静态页面（JavaScript），则可以发送全部请求，所以这个功能是选开的。</p><h3 id="注解更换"><a href="#注解更换" class="headerlink" title="注解更换"></a>注解更换</h3><p>SpringMVC 有多了新的注解，用来代替 <code>@RequestMapping</code>，分别是：</p><ol><li>@GetMapping</li><li>@PostMapping</li><li>@PutMapping</li><li>@DeleteMapping</li></ol><h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><p>详细的处理流程和 SpringMVC 是相同的，都是交给了 DispatcherServlet 来解决，所以我们可以完全按照 SpringMVC 的流程来进行请求处理：</p><h3 id="基本注解"><a href="#基本注解" class="headerlink" title="基本注解"></a>基本注解</h3><ol><li>@PathVariable 不指定名字的时候用 Map 接受所有的路径变量。</li><li>@RequestHeader 不指定名字的时候用 Map 接受所有的请求头。</li><li>@ModelAttribute 操作隐含模型，标注在属性获取数据，标注在方法上存入数据</li><li>@RequestParam 不指定名字的时候用 Map 接受所有的请求参数。</li><li>@RequestBody 获取请求体内所有数据。</li><li>@CookieValue 加名字接收 Cookie 的 String 值或 Cookie 对象，不加名字没法用。</li><li>@RequestAttribute 必须指定名字来获取指定的请求域对象的值，不支持 Map 全都拿走（为啥啊？）</li><li>@MatrixVariable 获取矩阵变量的值。</li></ol><h3 id="矩阵变量"><a href="#矩阵变量" class="headerlink" title="矩阵变量"></a>矩阵变量</h3><p>首先需要明确一个矩阵变量的概念，对于普通的变量来说只能 <code>?key1=value1&amp;key2=value2</code> 这样通过字符串传递参数，而这些参数是一维的，是只能一个 key 对应一个 value 的。</p><p>矩阵变量的意义是将字符串传递参数从一维变为二维，而多的一个维度就通过路径分隔实现的，也是通过 key=value 的形式表示一组参数，不同的是同一个维度（路径分割下）的参数通过前缀 <code>;</code> 隔开，一个 key 的多个 value 可以用 <code>,</code> 隔开。</p><p><code>http://localhost:8080/Matrix/Boy;name=Xorex;hobby=coding,eat,sleep/Girl;name=yukino;hobby=play,outgoing,love</code></p><p>需要注意的是，对于一个 <code>/&#123;&#125;/</code> 之间的内容来说，<code>;</code> 开头之后的一组 <code>key=value</code> 或 <code>key=value1,value2</code> 作为一个参数，可以有若干个以 <code>;</code> 开头的参数，他们组成了一个维度的矩阵变量。而 <code>;</code> 之前的字符串则是作为这个维度的路径变量，可以用 @PathVariable 来捕获。具体例子可以看下面的 Demo。</p><p>这就是矩阵变量，有两个维度一个是性别维度，一个是个人信息的维度。而 @MatrixVariable 的作用就是从矩阵变量中提取信息。</p><p>因为 SpringMVC 的 urlPathHelper 的属性 removeSemicolonContent 设置为了 true，也就是将 <code>;</code> 给移除掉了，导致无法使用矩阵变量，我们首先需要设置为 false 才可以，方式就是将生成 urlPathHelper 对象的 WebMvcConfigurer 配置类的生成 urlPathHelper 方法自己实现。</p><p>WebMvcConfigurer 是一个有默认实现的接口（Java 8 新特性），我们只需要实现 WebMvcConfigurer 并单独重写 configurePathMath() 方法即可，然后扔到 IOC 容器中，会由于 @Conditional 系类注解导致不加载原来的，然后被使用的配置就是我们自己放入的 IOC 容器的这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">//在 IOC 容器中配置自定义 WebMvcConfigurer </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="comment">//因为默认实现机制，我们只需要重写一个方法就能实现接口</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">            UrlPathHelper urlPathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line">            urlPathHelper.setRemoveSemicolonContent(<span class="keyword">false</span>);</span><br><span class="line">            configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以这样捕获上面的 URL（<code>http://localhost:8080/Matrix/Boy;name=Xorex;hobby=coding,eat,sleep/Girl;name=yukino;hobby=play,outgoing,love</code>） 了：</p><p>使用 pathVar 来区分维度，value 选定参数，两者确定了矩阵变量里面的一个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/Matrix/&#123;Boy&#125;/&#123;Girl&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getMatrix</span><span class="params">(<span class="meta">@MatrixVariable(pathVar = &quot;Boy&quot;,value = &quot;name&quot;)</span> String boyName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@MatrixVariable(pathVar = &quot;Boy&quot;,value = &quot;hobby&quot;)</span> List&lt;String&gt; boyHobbys,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@MatrixVariable(pathVar = &quot;Girl&quot;,value = &quot;name&quot;)</span> String girlName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@MatrixVariable(pathVar = &quot;Girl&quot;,value = &quot;hobby&quot;)</span> List&lt;String&gt; girlHobbys,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="meta">@PathVariable</span> Map&lt;String,String&gt; paths)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;boyName&quot;</span>, boyName);</span><br><span class="line">    map.put(<span class="string">&quot;boyHobbys&quot;</span>, boyHobbys);</span><br><span class="line">    map.put(<span class="string">&quot;girlName&quot;</span>, girlName);</span><br><span class="line">    map.put(<span class="string">&quot;girlHobbys&quot;</span>, girlHobbys);</span><br><span class="line">    map.put(<span class="string">&quot;pathMap&quot;</span>, paths);</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;girlName&quot;</span>: <span class="string">&quot;yukino&quot;</span>,</span><br><span class="line"><span class="attr">&quot;girlHobbys&quot;</span>: [<span class="string">&quot;play&quot;</span>, <span class="string">&quot;outgoing&quot;</span>, <span class="string">&quot;love&quot;</span>],</span><br><span class="line"><span class="attr">&quot;boyHobbys&quot;</span>: [<span class="string">&quot;coding&quot;</span>, <span class="string">&quot;eat&quot;</span>, <span class="string">&quot;sleep&quot;</span>],</span><br><span class="line"><span class="attr">&quot;pathMap&quot;</span>: &#123;</span><br><span class="line"><span class="attr">&quot;Boy&quot;</span>: <span class="string">&quot;Boy&quot;</span>,</span><br><span class="line"><span class="attr">&quot;Girl&quot;</span>: <span class="string">&quot;Girl&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">&quot;boyName&quot;</span>: <span class="string">&quot;Xorex&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法参数-返回参数"><a href="#方法参数-返回参数" class="headerlink" title="方法参数/返回参数"></a>方法参数/返回参数</h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>众所周知，SpringMVC 对于一个请求的处理通过 Adapter 来实现的，以 RequestMappingHandlerAdapter 来说，他就是请求和 @RequestMapping 标注方法之间的桥梁。</p><p>我们就以最常用的 RequestMappingHandlerAdapter 来分析一下，SpringMVC 是如何处理请求参数的：</p><p>首先调用 RequestMappingHandlerAdapter 的 handle() 来处理请求之后，会来到：</p><p>handleInternal() 执行完一些对于缓存和 Session 的判断之后，进入：</p><p>invokeHandlerMethod() 这里首先会获取用来处理方法参数的 HandlerMethodArgumentResolvers 和处理方法返回值的 HandlerMethodReturnValueHandlers。</p><p>我们来看看它们，都是用来处理每一个不同的参数的（看名字就知道了）：</p><p><img src="https://xorex.space/image/323.jpg" alt="323.jpg"></p><p>然后进入 invokeAndHandle() 方法，再进入 invokeForRequest() 方法，第一步是调用 getMethodArgumentValues() 来获取方法参数，这里就是对方法参数的处理：</p><p>具体过程还是那个样子，双重循环，遍历所有的参数，同时遍历所有的参数解析器，依次尝试，直到确定某个参数可以被某个解析器解析。</p><h3 id="Servlet-API"><a href="#Servlet-API" class="headerlink" title="Servlet API"></a>Servlet API</h3><p>对于 WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId 这些 Servlet 的原生 API，作为处理方法的参数的时候，会被 <code>ServletRequestMethodArgumentResolver</code> 解析器处理。</p><h3 id="复杂参数"><a href="#复杂参数" class="headerlink" title="复杂参数"></a>复杂参数</h3><h4 id="Map-Model-ModelAndView"><a href="#Map-Model-ModelAndView" class="headerlink" title="Map Model ModelAndView"></a>Map Model ModelAndView</h4><p>当 Map，Model，ModelAndView（本质上还是包含了 Model）作为参数，会分别被 MapMethodProcessor 和 ModelMethodProcessor 处理（没听错，参数用的不是 Resolver 而是 Processor，是因为这两个东西虽然在参数的位置，但实际上干的是返回值的事情）。</p><p>这两个处理器其实本质上都是一样的，他们里面保存的东西都会被放到同一个地方：ModelAndViewContainer 里面的 BingAwareModelMap 中。这个 ModelAndViewContainer 是保存模型和视图数据的对象。</p><p><strong>重重重重点来了</strong>，经过了一系列的后续处理之后，最终回到页面渲染的部分，在渲染之前，有一句话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">exposeModelAsReqeustAttributes(model,request);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法也非常简单，就是单纯的将 Model 放入了 Request 中：</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">exposeModelAsRequestAttributes</span><span class="params">(Map&lt;String, Object&gt; model, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    model.forEach((name, value) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            request.setAttribute(name, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.removeAttribute(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是我们在操作的 Model 和 Map 到底发生了什么了。</p><h4 id="POJO-封装"><a href="#POJO-封装" class="headerlink" title="POJO 封装"></a>POJO 封装</h4><p>这里指的是将大量的 key=value 封装到一个 POJO 中。</p><p>源码是首先判断枚举 Resolvers 来判断哪一个可以处理这个参数。其中 ServletModelAttributeMethodProcessor 可以处理。这个 Processor 判断可以处理的依据就是参数没有注解并且不是一个简单参数（也就是非基础类型+枚举类+数组+Date+URL+URI+Local等等）。</p><p>两者都满足之后就返回  ServletModelAttributeMethodProcessor 来处理封装 POJO，下面介绍一下封装流程。</p><p>首先创建一个空的 POJO 对象，然后调用 createBinder() 并传入 POJO 对象和请求数据，来获取一个 WebDataBindaer 这个数据绑定器的作用就是将请求的参数绑定到 POJO 里面的属性中。</p><p>剩下的过程也就很熟悉了，依次枚举 POJO 需要封装的属性，然后枚举 Converters 转换器，直到可以完成请求的 String 到对应的属性类型，然后调用 Converters 进行转化并赋值。</p><p>大概流程就是这些，因为里面内容过于复杂，所以就不自己粘贴源码之类的了。</p><p>对于 POJO 里面包含自定义类型的，就需要自己实现 <code>Converter&lt;S,T&gt;</code> 接口了，具体接口实现流程可以参考 SpringMVC 里面的相关章节，这里只介绍实现之后的配置：</p><p>因为 converters 可以通过 WebMvcConfigurer 类里面的 addFormatters() 方法里面使用 FormatterRegistry.addConverter() 方法将自定义的 <code>Converter&lt;S,T&gt;</code> 添加到配置中的 converters 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 这就等价于在 applicationContext.xml 中配置 IOC 容器内容了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">webMvcConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addConverter(<span class="keyword">new</span> MyConvertor&lt;String,Address&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在封装过程中，ModelAndView 也会保存一个被封装 POJO 的引用。</p><h3 id="返回内容"><a href="#返回内容" class="headerlink" title="返回内容"></a>返回内容</h3><p>理论上的方法返回处理都比较清楚了，也是枚举返回类型的 Processor，找到一个合适的去处理它，看名字就知道是处理哪种类型的返回值了：</p><p><img src="https://xorex.space/image/324.jpg" alt="324.jpg"></p><p>从这些 Processor 可以看到 SpringMVC 支持的范围值类型为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//认识的</span></span><br><span class="line">ModelAndView</span><br><span class="line">Model</span><br><span class="line">String</span><br><span class="line">Map</span><br><span class="line">View</span><br><span class="line">ResponseEntity</span><br><span class="line">HttpEntity</span><br><span class="line">HttpHeaders</span><br><span class="line"><span class="meta">@ModelAttribute</span> 标注的类</span><br><span class="line"></span><br><span class="line"><span class="comment">//不认识的</span></span><br><span class="line">ResponseBodyEmitter </span><br><span class="line">StreamingResponseBody</span><br><span class="line">Callable</span><br><span class="line">DeferredResult</span><br><span class="line">ListenableFuture</span><br><span class="line">CompletionStage</span><br><span class="line">WebAsyncTask</span><br></pre></td></tr></table></figure><p>这里我们主要讨论的是几个常用的 Processor 内部的一些细节，对于我们最常用的 Json 数据返回来说，通过 @RequestBody 来返回 POJO 转化为 Json 数据的 Processor 就是 RequestResponseBodyMethodProcessor 。</p><p>而这个处理类的核心就是在 handleReturnValue() 方法中的 writeWithMessageConverters() 。在这里干了什么事情呢，就是找 Converters，要将信息作为 ResponseBody 写出去，就要找到将返回值转化为 String 的 Converter。而除了找到能处理的 Converter，还要找到浏览器想要的 Converter。</p><p>这就要说说内容协商了：</p><p>首先浏览器会发请求的时候，会有一个请求头 Accept：</p><p><code>accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</code></p><p>这些定义了浏览器可以接受的内容以及不同内容接收的优先级（后面的 q=0.9），服务器接收到之后，会解析出来所有的内容，然后一个二重循环遍历所有的 MessageConverters，找到能转化处理并且转化内容优先级更高的 MassageConverter。</p><p>而我们在前后端分离开发的时候，一般都是 MappingJackson2HttpMessageConverter 这个转换器，将 POJO 转化为 JSON。</p><h3 id="基于请求参数的内容协商"><a href="#基于请求参数的内容协商" class="headerlink" title="基于请求参数的内容协商"></a>基于请求参数的内容协商</h3><p>不在 accept 找协商，而是请求参数 <code>format=XXX</code> 中确定数据想要的响应内容，只需要开启配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">contentnegotiation:</span></span><br><span class="line">      <span class="attr">favor-parameter:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后就会自动注册一个 strategie （协商策略），优先级高于原本的哪个（从 Accept 请求头解析协商内容）。这个 strategie 会从请求参数中找 <code>format=XXX</code> 然后就是返回要接受的请求类型了。经过 MessageConverters 遍历之后，找到合适的并处理。</p><p>其中 <code>format=XXX</code> 接收两个参数：json 或者 xml。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RestFul-风格&quot;&gt;&lt;a href=&quot;#RestFul-风格&quot; class=&quot;headerlink&quot; title=&quot;RestFul 风格&quot;&gt;&lt;/a&gt;RestFul 风格&lt;/h2&gt;&lt;h3 id=&quot;装配原理&quot;&gt;&lt;a href=&quot;#装配原理&quot; class=&quot;head</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringBoot" scheme="https://xorex.space/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-03-开发技巧 &amp; 静态资源处理</title>
    <link href="https://xorex.space/2021/07/31/dcedfd27f096/"/>
    <id>https://xorex.space/2021/07/31/dcedfd27f096/</id>
    <published>2021-07-30T17:09:04.000Z</published>
    <updated>2021-08-01T03:55:32.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些开发技巧"><a href="#一些开发技巧" class="headerlink" title="一些开发技巧"></a>一些开发技巧</h2><h3 id="Lombok-简化"><a href="#Lombok-简化" class="headerlink" title="Lombok 简化"></a>Lombok 简化</h3><p>引入 Lombok 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Lombok 主要解决 Bean 的臃肿问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span> <span class="comment">//生成 getter setter 方法</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">//生成全参数构造器</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span> <span class="comment">//生成无参构造器</span></span><br><span class="line"><span class="meta">@ToString</span> <span class="comment">//生成 toString 方法</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span> <span class="comment">//生成 eauqls 和 hashCode 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Uesr</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Uesr</span><span class="params">(String userName, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以注入日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span> <span class="comment">//引入日志</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line">        log.info(<span class="string">&quot;启动完成！&quot;</span>); <span class="comment">//直接调用 log 就可以使用日志系统。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dev-Tools"><a href="#Dev-Tools" class="headerlink" title="Dev-Tools"></a>Dev-Tools</h3><p>这个工具主要是解决热更新的问题（其实就是重启），引入依赖之后，按 ctrl+F9 来更新页面。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Spring-init"><a href="#Spring-init" class="headerlink" title="Spring init"></a>Spring init</h3><p>在创建项目的时候选择 Spring 项目，然后勾选所需要的组件，IDEA 会自动加载所有的依赖，并创造出完整的目录结构。</p><h2 id="application-yaml"><a href="#application-yaml" class="headerlink" title="application.yaml"></a>application.yaml</h2><p>application.yaml 是和 application.properties 作用都是完全一样的，不过 yaml 语法格式有点区别。</p><p>yml/yaml 是一种类似于 json 的数据保存格式，它的表示形式是 <code>key: value</code> 记得中间有个空格，它的包含关系是通过缩进来解决的，类似于 Python。</p><h3 id="基本值"><a href="#基本值" class="headerlink" title="基本值"></a>基本值</h3><p>基本值支持一下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整形 int</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点型 float</span></span><br><span class="line"><span class="attr">money:</span> <span class="number">23213.21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 布尔型 boolean</span></span><br><span class="line"><span class="attr">alive:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日期 data</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020-02-02</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 空 null</span></span><br><span class="line"><span class="attr">point:</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串 string</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Xorex</span> <span class="string">\n</span> <span class="string">is</span> <span class="string">Xorex</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&#x27;Xorex \n is Xorex&#x27;</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&quot;Xorex \n is Xorex&quot;</span></span><br><span class="line"><span class="comment"># 前两者相同，都会转义 \n，而后者不会转义 \n 表示为换行。</span></span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>当内容为对象的时候，比如 Bean，Map 的时候，可以新增一个层级写多行 <code>key: value</code> ，或者使用 json 的大括号格式写成一行 <code>&#123;key: value,key: value&#125;</code> 逗号隔开，需要空格。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">Tempest</span> <span class="string">Xorex</span></span><br><span class="line">  <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">  <span class="attr">gender:</span> <span class="string">M</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">ChengDu</span></span><br><span class="line"></span><br><span class="line"><span class="attr">user:</span> &#123;<span class="attr">user:</span> <span class="string">Tempest</span> <span class="string">Xorex</span>,<span class="attr">password:</span> <span class="number">123456</span>,<span class="attr">gender:</span> <span class="string">M</span>,<span class="attr">address:</span> <span class="string">ChengDu</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h3><p>同样是两种，多行格式开头没了 key，用 <code>-</code> 表示新的一行开头，或者用单行写法：[XXX,XXX,XXX]</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pet:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">monkey</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"></span><br><span class="line"><span class="attr">pet:</span> [<span class="string">dog</span>,<span class="string">monkey</span>,<span class="string">cat</span>]</span><br></pre></td></tr></table></figure><h3 id="小例子："><a href="#小例子：" class="headerlink" title="小例子："></a>小例子：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Boolean alive;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] interests;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; level;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; score;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">Xorex</span></span><br><span class="line">  <span class="attr">alive:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">address:</span></span><br><span class="line">    <span class="attr">userName:</span> <span class="string">Xorex</span></span><br><span class="line">    <span class="attr">address:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ChengDu</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SiChuan</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">China</span></span><br><span class="line">  <span class="attr">interests:</span> [<span class="string">Sing</span>,<span class="string">jump</span>,<span class="string">Rap</span>,<span class="string">Basketball</span>]</span><br><span class="line">  <span class="attr">level:</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">  <span class="attr">score:</span></span><br><span class="line">    <span class="attr">Chinese:</span> <span class="number">59</span></span><br><span class="line">    <span class="attr">Math:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">English:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">user:</span> &#123;<span class="attr">userName:</span> <span class="string">Xorex</span>,<span class="attr">password:</span> <span class="number">123456</span>&#125;</span><br></pre></td></tr></table></figure><p>成功完成 yaml 版本的自动配置：</p><p><code>Test(name=Xorex, alive=true, age=18, address=Address(userName=Xorex, address=[ChengDu, SiChuan, China]), interests=[Sing, jump, Rap, Basketball], level=[1, 2, 3, 4, 5, 6], score=&#123;Chinese=59, Math=100, English=100&#125;, user=User(userName=Xorex, password=123456))</code></p><h2 id="静态资源映射"><a href="#静态资源映射" class="headerlink" title="静态资源映射"></a>静态资源映射</h2><h3 id="静态资源文件夹"><a href="#静态资源文件夹" class="headerlink" title="静态资源文件夹"></a>静态资源文件夹</h3><p>SpringBoot 是使用 ResourceHttpRequestHandler 来处理请求的，对于一个请求来说，如果 Controller 可以处理，就会交给它，不能处理的则会会依次从 <code>META-INF/resources</code>、<code>/resources</code>、 <code>/static</code> 和 <code>/public</code> 按照请求的静态文件名从里面找同名的静态文件。</p><p>这四个文件夹都可以放静态文件，同名文件的优先级顺序为上面的排列顺序，从源码中也可以看出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>, <span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="修改静态资源文件夹映射路径"><a href="#修改静态资源文件夹映射路径" class="headerlink" title="修改静态资源文件夹映射路径"></a>修改静态资源文件夹映射路径</h3><p>是路径和文件夹的映射，以前四个文件夹是映射到根目录的，现在可以通过在配置中设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br></pre></td></tr></table></figure><p>这样访问静态资源需要在原本路径下前面提娜佳 <code>/res/</code> 的 pattern 才可以访问。</p><h3 id="修改静态资源文件夹"><a href="#修改静态资源文件夹" class="headerlink" title="修改静态资源文件夹"></a>修改静态资源文件夹</h3><p>当我们在配置中设置 static-locations 这一项之后，原本的四大静态资源文件夹只会保留一个 <code>META-INF/resources</code> 毕竟是 JavaWeb 原生的东西肯定会保留（剩下三个会被取消），但访问优先级会下降到最低。而新配置的文件夹优先级按照配置顺序来。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> [<span class="string">classpath:/Static-Resource/</span>,<span class="string">classpath:/Static-Resource2/</span>]</span><br><span class="line">      <span class="comment"># 这里记得写 classpath 哇</span></span><br></pre></td></tr></table></figure><h3 id="Webjar"><a href="#Webjar" class="headerlink" title="Webjar"></a>Webjar</h3><p>Webjar 是指 SpringBoot 将前端所需依赖会打包成一个 Webjar 来供你使用，而我们下载之后的 Webjar 包里面的内容的访问路径则是 <code>/webjars/**</code>，比如我们引入 jQuery 的 Webjar：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后可以看到已经下载过的 jQuery，可以看到是放在 <code>/META-INF/resources/webjars/</code> 下面的，这也是为什么修改 static-locations 之后，还保留 <code>/META-INF/resources</code>，并且 webjar 的内容访问路径为 <code>/webjars/**</code> 了：</p><p><img src="https://xorex.space/image/322.jpg" alt="322.jpg"></p><p>对应源码地方就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.addResourceHandler(registry, <span class="string">&quot;/webjars/**&quot;</span>, <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后访问 <code>http://localhost:8080/res/webjars/jquery/3.5.1/jquery.js</code> 成功！</p><h3 id="欢迎页"><a href="#欢迎页" class="headerlink" title="欢迎页"></a>欢迎页</h3><p>对于官方的欢迎页的设置来说，可以用 <code>index.html</code> 的文件名放到静态资源文件夹里面，这样直接访问主机名就可以看到 <code>index.html</code>，但是这个时候是不可以配置静态资源访问前缀的，也就是 <code>static-path-pattern</code> ，不然就会失效，理由如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,</span><br><span class="line">ApplicationContext applicationContext, Resource welcomePage, String staticPathPattern) &#123;</span><br><span class="line"><span class="keyword">if</span> (welcomePage != <span class="keyword">null</span> &amp;&amp; <span class="string">&quot;/**&quot;</span>.equals(staticPathPattern)) &#123; </span><br><span class="line">      <span class="comment">//这自己设置了 staticPathPattern 之后，判断就不成立了。</span></span><br><span class="line">logger.info(<span class="string">&quot;Adding welcome page: &quot;</span> + welcomePage);</span><br><span class="line">setRootViewName(<span class="string">&quot;forward:index.html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Adding welcome page template: index&quot;</span>);</span><br><span class="line">setRootViewName(<span class="string">&quot;index&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要实现就只能通过 Controller 映射 <code>/</code> 页面转发到 <code>index.html</code> 了。</p><h3 id="favicon-ico"><a href="#favicon-ico" class="headerlink" title="favicon.ico"></a>favicon.ico</h3><p>配置网页小图标只需要将文件命名为 <code>favicon.ico</code> 然后放到静态资源目录即可，这个生效也<strong>不能配置</strong> static-path-pattern。</p><p>这是因为浏览器获取小图标的方式就是访问 <code>网页根目录+favicon.ico</code> 更改了 static-path-pattern 之后也自然无法找到小图标了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一些开发技巧&quot;&gt;&lt;a href=&quot;#一些开发技巧&quot; class=&quot;headerlink&quot; title=&quot;一些开发技巧&quot;&gt;&lt;/a&gt;一些开发技巧&lt;/h2&gt;&lt;h3 id=&quot;Lombok-简化&quot;&gt;&lt;a href=&quot;#Lombok-简化&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringBoot" scheme="https://xorex.space/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-02-自动配置原理</title>
    <link href="https://xorex.space/2021/07/30/47898b4fe443/"/>
    <id>https://xorex.space/2021/07/30/47898b4fe443/</id>
    <published>2021-07-30T09:46:33.000Z</published>
    <updated>2021-07-31T02:39:44.852Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><h3 id="SpringBootApplication-解析"><a href="#SpringBootApplication-解析" class="headerlink" title="@SpringBootApplication 解析"></a>@SpringBootApplication 解析</h3><p>我们是在 <code>@SpringBootApplication</code> 中确定的 SpringBoot 的程序入口，也是 SpringBoot 的初始化开始的地方。那么 SpringBoot 是如何实现自动配置的呢，将 <code>@SpringBootApplication</code> 点开，可以看到是下面三个注解组成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br></pre></td></tr></table></figure><p><code>@SpringBootConfiguration</code> 本质就是个 <code>@Configuration</code> 表示这个类是一个配置类（也就是可以当作 applicationContext.xml 使用的类），比如在里面使用注解 <code>@Bean</code> 代替 <code>&lt;bean&gt;</code> 来配置 IOC 容器的 Bean。</p><p><code>@ComponentScan</code> 主要是用来扫描包组件的，它可以自定义扫描的 BasePackage，如果没有指定的话，就是 <code>@SpringBootApplication</code> 所在的地方为 BasePackage 。</p><p><code>@EnableAutoConfiguration</code> 这个是核心，又包含了下面的两种注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h4><p>这里又套娃导入了一个 <code>@Import(&#123;Registrar.class&#125;)</code> ，点开 Registrar.class 可以看到，代码里面主要干了下面的事情：</p><p>自动配置包类，注册了当前路径为下面的 PackageNames 作为配置的下属包（其实也对应 <code>@ComponentScan</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AutoConfigurationPackages.register(getPackageNames().toArray()); <span class="comment">// 有简略</span></span><br></pre></td></tr></table></figure><h4 id="Import-AutoConfigurationImportSelector-class"><a href="#Import-AutoConfigurationImportSelector-class" class="headerlink" title="@Import({AutoConfigurationImportSelector.class})"></a>@Import({AutoConfigurationImportSelector.class})</h4><p>这里主要导入了 AutoConfigurationImportSelector.class 这个类，主要干的事情就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getAutoConfigurationEntry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是获得 100 多个 web 的 starter 所需要配置的类的全类名（其实是在一个文件中写死的类名），然后返回。</p><hr><p>SpringBoot 更厉害的是，它不是全部都真的将所有的预设类实例化并添加到 IOC 容器中的，而是根据 <code>@Conditional</code> 注解，根据里面的条件判断是否加载这个类。</p><p>比如虽然导入了 web-starter 的开发环境，可能需要 AOP 相关，但是 SpringBoot 是根据 <code>@ConditionalOnClass(Advice.class)</code> 来判断是否加载的，只有导入了 AspectJ 这个包（Advice.class 存在），SpringBoot 才会给你将 AOP 所需要的类都给加入到 IOC 容器中。</p><p>这就是传说中的按需加载。</p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><h3 id="具体实现细节"><a href="#具体实现细节" class="headerlink" title="具体实现细节"></a>具体实现细节</h3><p>上面大概说了说实利用 <code>@Conditional</code> 系列注解进行按需加载的，我们来结合一个熟悉的案例分析一下，DispatcherServlet:</p><p>上面说到了返回的 100 多个配置类的全类名统一格式都是 XXXXAutoConfiguration，通过运行这些类，来对相关内容进行自动配置。</p><p>我们点开 DispathcerServletAutoConfiguration，这个就是对 DispathcerServlet 进行自动配置的类，先看看程序头：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(&#123;DispatcherServlet.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;ServletWebServerFactoryAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServletAutoConfiguration</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@ConditionalOnClass</code>表示导入了 DispathcerSevlet（也就是 SpringMVC） 后才会运行下面的自动装配类。<code>@AutoConfigureAfter</code> 表示先自动加载完服务器的 AutoConfiguration 之后再加载自己。这两个都是启动装配的起始条件。</p><p>再进一步就是子类 RegistrationConfiguration 了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Import(&#123;DispatcherServletAutoConfiguration.DispatcherServletConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServletRegistrationConfiguration</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@EnableConfigurationProperties</code> 表示使用 WebMvcProperties.class 内容作为配置文件，而这个类是使用 <code>spring.mvc</code> 作为配置的 prefix 的。</p><p>前面都是讲了按需加载的一些东西，那么具体的 DispatcherServlet 的配置细节在那里呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title">dispatcherServletRegistration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DispatcherServletRegistrationBean registration = <span class="keyword">new</span> DispatcherServletRegistrationBean(dispatcherServlet, webMvcProperties.getServlet().getPath());</span><br><span class="line">    registration.setName(<span class="string">&quot;dispatcherServlet&quot;</span>);</span><br><span class="line">    registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">    multipartConfig.ifAvailable(registration::setMultipartConfig);</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到是将一系列的配置信息都设置到了 registration 中，最后返回，这里就是将获取的所有配置信息设置的地方。</p><h3 id="更改设置信息"><a href="#更改设置信息" class="headerlink" title="更改设置信息"></a>更改设置信息</h3><p>如何修改默认的设置信息呢，当然是在 application.properties 里面修改了，那么这些修改又是如何影响到 SpringBoot 的自动装配呢，我们以 CharacterEncodingFilter 的自动装配为例展示一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;ServerProperties.class&#125;)</span> <span class="comment">//调用外部的 服务器设置</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)</span> <span class="comment">//有这个类才会进行自动初始化</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(</span></span><br><span class="line"><span class="meta">    prefix = &quot;server.servlet.encoding&quot;,  //在调用的外部 ServerProperties 中 server.servlet.encoding 选项是否为enabled，如果是成立，如果不是失败，如果没有配置则默认为是。</span></span><br><span class="line"><span class="meta">    value = &#123;&quot;enabled&quot;&#125;,</span></span><br><span class="line"><span class="meta">    matchIfMissing = true</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Encoding properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从外部的 ServerProerties 中获取关于编码的设置，并放入本地变量 properties 中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(ServerProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties.getServlet().getEncoding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//在 IOC 中创建 Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span> <span class="comment">//IOC 中必须没有手动创建此实例才会自动创建</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123; <span class="comment">//根据读取的 properties 配置信息创建 Bean 并放入 IOC 中。</span></span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.web.servlet.server.Encoding.Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的代码，我们能看到配置信息的最重要来源就是上一级的 ServerProperties.class 里面获取的，那么 ServerProperties 又是如何生成的呢？</p><p>上一篇文章前面提到了 <code>@ConfigurationProperties(prefix=&quot;XXX&quot;)</code> 标注了之后会从 application.properties 找到前缀为 XXX 的配置然后调用 set 方法进行配置注入。 ServerProperties.class 在创建之后会属性都是默认值，然后再经过 <code>@ConfigurationProperties(prefix=&quot;XXX&quot;)</code> 从配置文件中注入外部设置来覆盖默认设置。</p><hr><p>具体从读取到 @ConfigurationProperties 再到读取 application.properties 注入设置的详细源码，一定会再详细介绍的。</p><p>现在对于 SpringBoot 的了解还是太浅了…… </p><p>QAQ</p><h2 id="自动装配总结"><a href="#自动装配总结" class="headerlink" title="自动装配总结"></a>自动装配总结</h2><ol><li>SpringBoot 会首先获取所有自动装配运行类的名字，然后依次运行 XXXAutoConfiguration 的自动装配运行类，负责装配 XXX。</li><li>自动装配运行类通过 <code>@Conditional</code> 系列注解，判断满足要求之后开始从 XXXProperties.class 中拿到具体的配置信息。XXXProperties 和 application.properties 绑定。</li><li>自动装配运行类运行后会向 IOC 容器中添加很多配置好的组件，IOC 有了这些配置好的组件之后就拥有了对应的功能。</li><li>可以通过自己使用 <code>@Bean</code> 向 IOC 中添加配件来实现自定义配置，或者在 application.properties 中设置自定义配置。</li></ol><h2 id="自动装配开发技巧"><a href="#自动装配开发技巧" class="headerlink" title="自动装配开发技巧"></a>自动装配开发技巧</h2><ol><li><p>开发的时候将对应的场景依赖引入即可，xxx-starter</p></li><li><p>查看场景依赖的哪些元素装配了，可以在设置中设置 debug=true，会打印日志，Positive 生效部分，Negative 不生效部分</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自动配置原理&quot;&gt;&lt;a href=&quot;#自动配置原理&quot; class=&quot;headerlink&quot; title=&quot;自动配置原理&quot;&gt;&lt;/a&gt;自动配置原理&lt;/h2&gt;&lt;h3 id=&quot;SpringBootApplication-解析&quot;&gt;&lt;a href=&quot;#SpringBootApp</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringBoot" scheme="https://xorex.space/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-01-快速开始和自动配置</title>
    <link href="https://xorex.space/2021/07/29/cdaa75e9175f/"/>
    <id>https://xorex.space/2021/07/29/cdaa75e9175f/</id>
    <published>2021-07-29T06:34:46.000Z</published>
    <updated>2021-07-31T08:56:03.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringBoot-快速开始"><a href="#SpringBoot-快速开始" class="headerlink" title="SpringBoot 快速开始"></a>SpringBoot 快速开始</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>SpringBoot 项目只需要一个普通的 Maven 项目就可以了。我们是通过运行 SpringBoot 的 SpringApplication.run() 方法，来让 SpringBoot 控制整个项目的。</p><p>首先我们需要将在 Maven 中引入包含了大量依赖信息的 SpringBoot parent（继承信息），和我们要进行 Web 开发的 starter （真正的引入依赖下载 jar 包）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也就是 parent 引入保存的各种开发场景对应的依赖需求集合，我们在 dependencies 真正的引入这些依赖的时候，就不需要一个个写了，直接调用依赖集合名就好了。</p><p>然后我们就能看到所有关于 web 开发的 jar 包就都被导入了，包括 tomcat。这些 jar 包的集合被 SpringBoot 叫作一个 starter，开始集合。</p><h3 id="让-SpringBoot-接管项目"><a href="#让-SpringBoot-接管项目" class="headerlink" title="让 SpringBoot 接管项目"></a>让 SpringBoot 接管项目</h3><p>就像配置 DispatcherServlet 让 SpringMVC 接管业务流程一样，这里是让 SpringBoot 直接从根本接管所有东西，不仅仅是业务流程，包括了 Tomcat 的创建。</p><p>只需要创建一个方法，在 main 方法中运行 SpringBoot 的启动程序，SpringApplication.run()，参数就是这个类本身的 class 和输入的参数，当然这个类也需要用注解标记为 SpringBoot 启动类。要运行整个项目的时候，就直接运行 main 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开始写业务逻辑"><a href="#开始写业务逻辑" class="headerlink" title="开始写业务逻辑"></a>开始写业务逻辑</h3><p>剩下的部分就是按照 SpringMVC 的形式写了，不用管配置啥的，直接各种注解随便用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Controller 和 RequestBody 的结合，意思为用来实现 rest 风格的 Controller</span></span><br><span class="line"><span class="meta">@RestController</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello SpringBoot!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h3><p>SpringBoot 因为一个人就接管了整个项目，所以可以将整个项目的所有配置都简化到一个文件中： <code>application.properties</code> ，这个文件可以改所有的配置。</p><p>比如将端口号改为 8888，只需要在 <code>application.properties</code> 中写下即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">servet.port</span>=<span class="string">8888</span></span><br></pre></td></tr></table></figure><p>而在 application.properties 里面的各种配置信息提示需要将配置处理器 Springboot-configurationg-processor 引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 maven 插件配置的地方设置打包去除到这个 processor ，因为只是支持配置提示，也不需要打包成运行环境。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h3><p>以前部署是打包成 war 包，放到服务器的 Tomcat 环境上面的，现在因为所有的东西都被 SpringBoot 管理，所以只需要让 SpringBoot 跑起来就可以了。</p><p>那么我们就可以将项目打包成一个可以运行 main 方法的 jar 包即可。（main 方法负责启动 SpringBoot）</p><p>我们是用 Maven 进行打包的，先引入 SpringBoot 关于 Maven 的打包插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后运行（注意 IDEA 需要停止运行当前的 SpringBoot 防止端口占用）</p><p><code>java -jar SpringBoot-1.0-SNAPSHOT.jar</code></p><h2 id="SpringBoot-依赖管理"><a href="#SpringBoot-依赖管理" class="headerlink" title="SpringBoot 依赖管理"></a>SpringBoot 依赖管理</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>SpringBoot 一个让我们省心的就是它的 starter 直接配齐了所有的生产环境。starter 的实现就是依靠 SpringBoot 的依赖管理，什么样的生产环境需要什么依赖，以及依赖的版本号，都被记录在 <code>spring-boot-starter-parent</code> 中。</p><h3 id="版本更改"><a href="#版本更改" class="headerlink" title="版本更改"></a>版本更改</h3><p>依赖的具体版本是通过在 SpringBoot 的依赖管理中的 <code>&lt;properties&gt;&lt;/properties&gt;</code> 标签中定义好的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--截取一部分--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jstl.version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">jstl.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jtds.version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">jtds.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">junit-jupiter.version</span>&gt;</span>5.7.2<span class="tag">&lt;/<span class="name">junit-jupiter.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kafka.version</span>&gt;</span>2.7.1<span class="tag">&lt;/<span class="name">kafka.version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们要更改它的版本只需要在 Maven 中配置 <code>&lt;properties&gt;&lt;/properties&gt;</code> 中设置具体的版本即可，比如想要文艺复兴，使用 8.0.1 的 tomcat，改就完事了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tomcat.version</span>&gt;</span>8.0.1<span class="tag">&lt;/<span class="name">tomcat.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SpringBoot-自动配置"><a href="#SpringBoot-自动配置" class="headerlink" title="SpringBoot 自动配置"></a>SpringBoot 自动配置</h2><h3 id="组件配置"><a href="#组件配置" class="headerlink" title="组件配置"></a>组件配置</h3><p>以前我们要引入很多的组件，比如 DispatcherServlet，CharacterEncoding 等等，现在使用了 SpringBoot 之后就不需要写了，这是因为 SpringBoot 会自动将一整套的开发环境预设到 IOC 容器中，<code>SpringApplication.run(MainApplication.class, args)</code> 的返回结果就是这个 IOC 容器。</p><h3 id="包扫描"><a href="#包扫描" class="headerlink" title="包扫描"></a>包扫描</h3><p>SpringBoot 会扫描标注了 <code>@SpringBootApplication</code> 的启动类以下的所有子包：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line"> +- example</span><br><span class="line">     +- myapplication</span><br><span class="line">         +- Application.java //下面的 customer 和 order 两个包都会被扫描注解</span><br><span class="line">         |</span><br><span class="line">         +- customer</span><br><span class="line">         |   +- Customer.java</span><br><span class="line">         |   +- CustomerController.java</span><br><span class="line">         |   +- CustomerService.java</span><br><span class="line">         |   +- CustomerRepository.java</span><br><span class="line">         |</span><br><span class="line">         +- order</span><br><span class="line">             +- Order.java</span><br><span class="line">             +- OrderController.java</span><br><span class="line">             +- OrderService.java</span><br><span class="line">             +- OrderRepository.java</span><br></pre></td></tr></table></figure><p>所以我们才不需要配置扫描的包。但如果真的想要配置，在 <code>@SpringBootApplication</code> 添加属性：<code>scanBasePackages = &quot;space.xorex&quot;</code> 。</p><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>SpringBoot 所有场景的默认配置信息都在 spring-boot-autoconfigure 里面：</p><p><img src="https://xorex.space/image/321.jpg" alt="321.jpg"></p><h2 id="容器功能"><a href="#容器功能" class="headerlink" title="容器功能"></a>容器功能</h2><h3 id="添加容器"><a href="#添加容器" class="headerlink" title="添加容器"></a>添加容器</h3><p>Spring 一个重要功能就是 IOC ，那么到了 SpringBoot，如何使用 IOC 容器呢？</p><p><code>@Configuration</code> 用来标注表示这是一个配置类，然后对方法 <code>@Bean</code> 表示这是一个 Bean 配置，方法名就是 id，返回的结果就是配置 Bean 获取的结果。</p><p>这样成功将 id=userXorex 的 User 实例添加到了 IOC 容器中，默认为 <strong>单实例对象</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uesr <span class="title">userXorex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Uesr(<span class="string">&quot;Xorex&quot;</span>,<span class="string">&quot;Tempest&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Address <span class="title">xorexAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Address(<span class="string">&quot;ChengDu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例获取"><a href="#实例获取" class="headerlink" title="实例获取"></a>实例获取</h3><p>因为上面写过之后两个 bean 都被加入了单例的 IOC 中，所以自然可以用 @Autowired 来获取单例 bean 的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">static</span> Uesr user1;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">static</span> Uesr user2;</span><br><span class="line">System.out.println(user1==user2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>但是还有另外一种获取方法，就是调用 MyConfig 里面的方法返回 bean 实例。当我们的 @Configuration 配置的为默认： proxyBeanMethods=true 的时候，也就是使用代理获取对象的时候，在外部获取的都是容器中的单例 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyConfig config=run.getBean(MyConfig.class); </span><br><span class="line"><span class="comment">//从 IOC 中拿到 Config，此时的 proxyBeanmethods=true ，也就是 Config IOC 代理了，返回的实例是从 IOC 容器中拿出来的。</span></span><br><span class="line">Uesr user1=config.userXorex(); <span class="comment">// 从 Config 中返回 bean</span></span><br><span class="line">Uesr user2=config.userXorex();</span><br><span class="line">System.out.println(user1==user2); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>当我们将 proxyBeanMethods=false 的时候，上面从 IOC 中取出来的 MyConfig 就是普通类了（等同于 new 出来一个普通的 MyConfig），调用方法返回的 bean 也是方法里面 new 出来的，就不是 IOC 控制的单例对象了。</p><h3 id="快速添加"><a href="#快速添加" class="headerlink" title="快速添加"></a>快速添加</h3><p>可以使用 <code>@Import(&#123;XXX1.class,XXX2.class&#125;)</code> 快速将两个类 XXX1 和 XXX2 的无参构造器的实例放入 IOC 容器中，id 就是这个类的全类名。</p><h3 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h3><p>这里的配置绑定指的是将 application.properties 中的配置信息和 IOC 容器中的 Bean 的属性相绑定。</p><p>比如我们将配置文件中的 info.xxx 配置于 Info 类中的属性 xxx 相绑定，只需要在 <code>@ConfigurationProperties</code></p><h4 id="1-Component-ConfigurationProperties"><a href="#1-Component-ConfigurationProperties" class="headerlink" title="1. @Component + @ConfigurationProperties"></a>1. @Component + @ConfigurationProperties</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-ConfigurationProperties-Bean"><a href="#2-ConfigurationProperties-Bean" class="headerlink" title="2. @ConfigurationProperties + @Bean"></a>2. @ConfigurationProperties + @Bean</h4><p>第二种主要适用于对第三方包里面的类进行属性设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="comment">//加入到 IOC 容器中</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;info&quot;)</span> <span class="comment">//添加配置映射信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Info <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SpringBoot-快速开始&quot;&gt;&lt;a href=&quot;#SpringBoot-快速开始&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 快速开始&quot;&gt;&lt;/a&gt;SpringBoot 快速开始&lt;/h2&gt;&lt;h3 id=&quot;导包&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringBoot" scheme="https://xorex.space/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>IDEA-大揭秘</title>
    <link href="https://xorex.space/2021/07/28/473525f83e0b/"/>
    <id>https://xorex.space/2021/07/28/473525f83e0b/</id>
    <published>2021-07-27T16:38:55.000Z</published>
    <updated>2021-07-29T09:44:47.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我要好好学习-IDEA！"><a href="#我要好好学习-IDEA！" class="headerlink" title="我要好好学习 IDEA！"></a>我要好好学习 IDEA！</h2><p>IDEA 是什么，IDEA 是世界上最棒的 Java 开发工具。但是因为我对它的不熟悉，基本上看着各种英文选项都看不懂，所以不可以这样子下去了！我要更好的了解我手上的开发工具，来减少 Debug 的时间！</p><h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><p>对于 IDEA 来说，Project 是一个项目的总称，而 Module 是项目不同部分实现的模块。比如一个电商系统中，需要使用到分布式系统开发多个服务器后台，那么 Project 就是这个电商系统，Module 就是服务器1、服务器2、的开发模块。</p><p>当然也可以一个 Project 只包含一个 Module，那么这个时候两者就是同一个东西了，都指的是当前项目。</p><p>如果想要一个 Project 包含多个 Module，那么就新建一个<strong>空的 Project</strong>，然后在空 Project 中新建各种模块。这个空的 Project 就是起一个约束的作用：</p><p><img src="https://xorex.space/image/312.jpg" alt="312.jpg"></p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>然后就是关于项目下面的模块的单独管理了：</p><p>1 表示选择的相应模块进行设置。</p><p>2 表示模块的目录结构的标识，比如将某些目录标识为源码目录，资源目录等等，作用是让 IDEA 对不同目录的内容做不同的处理，比如源码目录就涉及到代码之间的导入和编译（只有 IDEA 知道此目录是源码目录才会去找 java 编译成 class），比如 Test 目录就是测试的时候和源码目录合并，但是编译到 target 文件夹的时候忽略，等等。</p><p>3 表示不同类型的表示都有哪些文件夹，相当于一个汇总。</p><p><img src="https://xorex.space/image/313.jpg" alt="313.jpg"></p><hr><p>然后在后面就是路径管理，主要就是编译后的输出位置，一般都是 target 文件夹。</p><p><img src="https://xorex.space/image/314.jpg" alt="314.jpg"></p><hr><p>这里主要是管理模块所依赖的外部库的（Libraries），IDEA 整个项目下面有一个 External Libraries 概念的项目外部库，里面有所有模块导入的各种外部库，可以从这里面添加其他模块以来的外部库到自己的模块中。</p><p>而 Export 选项是当我们将模块导出来成 Jar 包的时候，是否将依赖的外部库也打包进去。</p><p><img src="https://xorex.space/image/315.jpg" alt="315.jpg"></p><h3 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h3><p>Libraries 这个主要是本项目（Project）下面的所有外部依赖进行一个管理，所有模块被 <code>add as Libraries</code> 的 Jar 包都会出现在这里（Maven 添加进来的自动导入 Libraries 中）。</p><p>1 表示当前项目中所有模块添加的 Project 级别的依赖仓库，2 表示对这些仓库进行修改和查看下载信息（编译文件，源码，文档）</p><p><img src="https://xorex.space/image/316.jpg" alt="316.jpg"></p><h3 id="Facets"><a href="#Facets" class="headerlink" title="Facets"></a>Facets</h3><p>Facets 的中文是刻面，表示事物的方面特征，在这里表示记录整个项目的一些特征，比如用了哪些框架（Spring），项目是哪一类的（Web 项目），等等：</p><p><img src="https://xorex.space/image/318.jpg" alt="318.jpg"></p><h3 id="Artifacts"><a href="#Artifacts" class="headerlink" title="Artifacts"></a>Artifacts</h3><p>Aritfacts 的意思是制品，表示我们项目最后的输出状态：jar （代码包）或者 war （Web 程序包）。</p><p>比如下面就是 Module1 的 Artifacts 页面，其中 1 表示两种形式，一中是经过压缩的（第一个），一种是不经过压缩的，可以看到目录结构的（第二个，exploded 的）。我们一般选择后者来调整输出内容。</p><p>2 则表示的是项目打包输出的时候的输出内容，也就是我们本机编写的 Module1 的代码，和引入的外部依赖 lib 文件夹。这里的外部依赖是根据 Maven 的配置文件 pom.xml 中读取的，回将默认的 scope compile 类型的仓库添加到 lib 文件夹里面。</p><p>如果我们有一些库是从本地 Jar 包形式或者 Global、Project 范围的 Libraries 中导入的话，因为在 pom.xml 中没有他们的身影，所以在打包的时候也没有他们，这就需要我们用区域 3，从模块已有的依赖库中选择要添加到打包的库文件。</p><p><img src="https://xorex.space/image/319.jpg" alt="319.jpg"></p><h3 id="Platfrom-Settings"><a href="#Platfrom-Settings" class="headerlink" title="Platfrom Settings"></a>Platfrom Settings</h3><p>这个就是关于 IDEA 这个平台的整体的设置了，包括 SDK 的包的选择，还有 Global 级别的 Libraries 的管理。</p><p><img src="https://xorex.space/image/320.jpg" alt="320.jpg"></p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="iml-文件"><a href="#iml-文件" class="headerlink" title="iml 文件"></a>iml 文件</h3><p>Java 中的一个单模块项目或者多模块项目中的每一个模块，都会有一个模块名的 iml 文件，这个文件就是保存本模块的依赖信息的文件，IDEA 也就是根据这个文件将项目依赖的 Jar 包添加到当前项目的 ClassPath 之中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引用 Global 级别的库，所有的项目所有模块都可以引用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;library&quot;</span> <span class="attr">name</span>=<span class="string">&quot;commons-beanutils-1.8.0&quot;</span> <span class="attr">level</span>=<span class="string">&quot;application&quot;</span> /&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--引用 Project 级别的库，只有当前项目下面的所有模块才可以引用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;library&quot;</span> <span class="attr">name</span>=<span class="string">&quot;druid-1.1.9&quot;</span> <span class="attr">level</span>=<span class="string">&quot;project&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">&quot;module-library&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">library</span>&gt;</span> <span class="comment">&lt;!--引用 Module 级别的库，只有本模块才可以引用--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">root</span> <span class="attr">url</span>=<span class="string">&quot;jar://$MODULE_DIR$/src/test/java/c3p0-0.9.1.2.jar!/&quot;</span> /&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">library</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">orderEntry</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Maven-管理"><a href="#Maven-管理" class="headerlink" title="Maven 管理"></a>Maven 管理</h3><p>当我们在 Maven 中添加了一个 Jar 包的下载信息之后，Maven 会自动下载 Jar 包到一个<strong>固定的文件夹</strong>（user/.m2/repostory/），下载完成之后，会自动更新 iml 文件，将 Jar 包以 Project 级别引入当前模块。</p><p>因为 Maven 下载的 Jar 包都在固定的文件夹，所以 Maven 也会根据 pom.xml 里面的记录将 Jar 包信息添加到 <code>External Libraries</code> 中，表示 Jar 包来自于外部的文件夹，并不是本项目目录结构里面的。有时候在 pom.xml 添加了下载信息之后，并没有更新 iml 文件，但是更新了 <code>External Libraries</code> 列表，这时候就需要手动将下载好的 Jar 包从 <code>External Libraries</code> 列表中用 <code>add as Library</code> （其实就是写到 iml 文件中）添加到当前模块的依赖中。</p><p>根据当前项目下所有模块的 pom.xml 文件显示的外部库列表：</p><p><img src="https://xorex.space/image/317.jpg" alt="317.jpg"></p><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="Library-和-jar-的区别"><a href="#Library-和-jar-的区别" class="headerlink" title="Library 和 jar 的区别"></a>Library 和 jar 的区别</h3><p>jar 包通常用来表示一个小功能的所有 .class 文件，而 Library 更像是 jar 包的文件夹，将若干个 jar 包打包在一起，作为一个 Library （当然单个 jar 包也可以作为 Library）。</p><h3 id="Project-和-Module-的关系"><a href="#Project-和-Module-的关系" class="headerlink" title="Project 和 Module 的关系"></a>Project 和 Module 的关系</h3><p>Project 用来作为一个文件夹约束包含的模块 Module，模块 Module 是实现一个完整功能的最小单位。</p><h3 id="External-Libraries-和-Maven-的关系"><a href="#External-Libraries-和-Maven-的关系" class="headerlink" title="External Libraries 和 Maven 的关系"></a>External Libraries 和 Maven 的关系</h3><p>External Libraries 是从 Maven 文件 pom.xml 中读出来并展示的，表示从外部引入的库（外部指 Maven 下载目录，项目目录为内部引用）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;我要好好学习-IDEA！&quot;&gt;&lt;a href=&quot;#我要好好学习-IDEA！&quot; class=&quot;headerlink&quot; title=&quot;我要好好学习 IDEA！&quot;&gt;&lt;/a&gt;我要好好学习 IDEA！&lt;/h2&gt;&lt;p&gt;IDEA 是什么，IDEA 是世界上最棒的 Java 开发工</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="IDEA" scheme="https://xorex.space/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记</title>
    <link href="https://xorex.space/2021/07/20/6a60c37480ef/"/>
    <id>https://xorex.space/2021/07/20/6a60c37480ef/</id>
    <published>2021-07-20T04:42:34.000Z</published>
    <updated>2021-07-27T16:40:54.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-概念"><a href="#Git-概念" class="headerlink" title="Git 概念"></a>Git 概念</h2><h3 id="分布式与集中式"><a href="#分布式与集中式" class="headerlink" title="分布式与集中式"></a>分布式与集中式</h3><p>其实这两个在版本控制系统里面区别就是历史版本存放位置。</p><p>集中式版本控制系统单的历史版本是存放在一个固定的服务器上面的，每次写代码只是拿到其中的一个版本，写完之后提交。这样一旦服务器挂掉，就无法工作了。</p><p>而分布式版本控制系统的历史版本是所有人都在本地有一份的，服务器的作用是用来方便大家同步本地的版本（合并别人的修改），这样即使服务器挂掉，可以一对一的同步代码，甚至不同步也可以，手里有整个历史版本，可以回退，不影响工作。</p><p>所以这就是 Git 分布式版本控制系统的强大之处！</p><h3 id="Git-历史"><a href="#Git-历史" class="headerlink" title="Git 历史"></a>Git 历史</h3><p>Git 的来源是 Linus 不满意其他人写的版本控制系统，自己花了两个星期写的。牛的牛的！</p><h3 id="Git-工作原理"><a href="#Git-工作原理" class="headerlink" title="Git 工作原理"></a>Git 工作原理</h3><p>Git 将文件分为三个区域：</p><p>工作区的文件 -&gt; git add -&gt; 暂存区的文件 -&gt; git commit -&gt; 本地库的文件 -&gt; git push —&gt; 远程库</p><p>工作区其实就是我们写代码的地方，写好一个代码文件之后添加到暂存区，等到整个版本的很多代码文件都写好并加入暂存区之后，就可以将暂存区里面的所有内容作为一个版本更新提交到本地库里面了。本地有了一个版本的记录，就可以推送到远程库里面，让所有人都看到这次版本更新了。不过具体的实际原理还是看后面的分析吧。</p><h2 id="Git-基础命令"><a href="#Git-基础命令" class="headerlink" title="Git 基础命令"></a>Git 基础命令</h2><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>用来查看当前工作状态，告诉你当前分支 <code>On branch master</code> ，哪些暂存区文件被修改了还没有提交 <code>Changes not staged for commit</code>，哪些文件没有被记录到暂存区 <code>Untracked files</code>。</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p><code>git add FILENAME</code> 将 FILENAME 文件加入暂存区中，实测加入到暂存区之后的文件，修改之后可以不经过 add 直接 commit 该文件。</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p><code>git commit -m &quot;INFO&quot;</code> 将暂存区的所有文件的都提交到本地库中并附上说明 INFO。</p><p><code>git commit -m &quot;INFO&quot; FILENAME</code> 将工作区的 FILENAME 文件提交到本地库并附上说明 INFO。</p><p>所以如果指定文件，是从工作区找的，如果不指定文件，则只会 <strong>将修改后使用 add 命令提交到暂存区的文件们</strong> 提交到本地库！</p><p>当然如果不想指定文件，也想将所有被追踪的工作区文件提交到本地库，而不经过暂存区，就直接用命令： <code>git commit -m &quot;INFO&quot; -a</code></p><h3 id="git-commit-–amend"><a href="#git-commit-–amend" class="headerlink" title="git commit –amend"></a>git commit –amend</h3><p>amend <code>[ə&#39;mɛnd]</code> 修正改善，故名思意，这个命令是用来修复上一次提交的。</p><p>说是修复提交，其实就是合并提交，当你发现上一次提交不足以作为一个版本记录之后，就可以先将代码修改到一个版本记录级别，然后使用命令 <code>git commit --amend -m &quot;AMEND_INFO&quot;</code> 这样回将这次新修改的和上次提交的修改合并为一个新的修改并提交，提交信息为新设置的 AMEND_INFO。</p><h3 id="git-log-relog"><a href="#git-log-relog" class="headerlink" title="git log/relog"></a>git log/relog</h3><p>relog 是用来查看简单的版本记录（只包括版本号，版本名，当前版本和当前指向分支）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">c939839 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: The second commit!</span><br><span class="line">69663c7 HEAD@&#123;1&#125;: commit (initial): Just test commit!</span><br></pre></td></tr></table></figure><p>log 会现实更加详细的内容，包括日期和提交者签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit c939839a1549e2dfd718c3d6bf9ad4b7cc61214b (HEAD -&gt; master)</span><br><span class="line">Author: Xorex &lt;cloudloverain@Foxmail.com&gt;</span><br><span class="line">Date:   Tue Jul 20 13:37:31 2021 +0800</span><br><span class="line"></span><br><span class="line">    The second commit!</span><br><span class="line"></span><br><span class="line">commit 69663c76cc270f8a7e0914730d6d184a66632012</span><br><span class="line">Author: Xorex &lt;cloudloverain@Foxmail.com&gt;</span><br><span class="line">Date:   Tue Jul 20 13:19:49 2021 +0800</span><br><span class="line"></span><br><span class="line">    Just test commit!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>git reset 主要用于当前工作分支的版本回退，格式为：<code>git reset --MODE VERSION_ID</code>。</p><p>用 MODE 级别的模式，回退到 VERSION_ID 的版本（将本分支指针指向对应的版本号）。下面是 MODE 的对应的几种模式：</p><p><a href="https://segmentfault.com/a/1190000012071372">我是看着这篇文章学会的！！！</a></p><ol><li>–soft 等同于将状态恢复到执行 <code>commit</code> 之前（也就是撤销 commit，工作区代码修改完成，全部放到了暂存区，就差 commit 的状态。）</li><li>–mixed 等同于将状态恢复到写好了代码，但是没有 add 和 commit 的状态。（工作区内容不变，暂存区变为指定的版本）</li><li>–keep 比较特殊，工作区的内容根据版本重置（恢复到对应版本状态），但是暂存区还是原来的，和 mixed 相反。</li><li>–hard 将所有状态都同步到当时版本的状态，工作区，暂存区，都是目标版本执行完 commit 之前的状态。</li></ol><h2 id="Git-分支系统"><a href="#Git-分支系统" class="headerlink" title="Git 分支系统"></a>Git 分支系统</h2><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p><code>git branch -v</code> 查看所有的分支。</p><p><code>git branch BRANCH_NAME</code> 创建一个新的分支，BRANCH_NAME 。</p><p><code>git checkout BRANCH_NAME</code> 查看另外一个分支（将指针移动到 BRANCH_NAME 分支上面）</p><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p><code>git merge BRANCH_NAME</code> 会将分支 BRANCH_NAME 合并到当前的分支上面。</p><p>当两个分支的同一个文件的相同行都有修改的时候（不同行被两个分支分别修改没关系，两个修改都会被保留），自动合并就会出问题了，需要我们手动处理冲突。</p><p>出现合并冲突之后，打开冲突的文件，会自动标注冲突的地方，也就是 … 的地方就是冲突的文本。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt; HEAD            //开始分隔符</span><br><span class="line">...</span><br><span class="line">======                 //中间分隔符</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt; MERGED_BRANCE   //结束分隔符</span><br></pre></td></tr></table></figure><p>只需要将分隔符删掉，两个冲突文本选择要保留的，就可以保存了。保存完之后只能添加到暂存区，然后统一提交。（提交 + 文件名的方法不可以，会报错找不到哪个文件）</p><h3 id="Git-游离-Head"><a href="#Git-游离-Head" class="headerlink" title="Git 游离 Head"></a>Git 游离 Head</h3><p>checkout 就是很简单的查看的意思，就是为了查看某个版本的状态。当然我们一般都是查看某个分支所处的状态，然后用 reset 不断切换分支所属的版本。那能不能不切换分支所属版本，也能查看某个版本的状态呢，答案是可以的，让 HEAD 指针不指向分支，而是指向版本（某次提交的版本号）</p><p>比如 <code>git checkout 7ea3922</code> 就直接到了 7ea3922 提交过后的版本状态了，但是这个时候 HEAD 不在任何一个分支上面，是游离的，也就是 Detached HEAD。</p><p>我们到了游离分支也可以发展自己，不断的 commit，或者当作一个分支使用，不过由于都是版本名，不太好进行版本控制，还是直接在游离分支上建立一个真正的 Branch 并取一个名字，方便对这个分支进行版本控制。</p><h2 id="文件忽略"><a href="#文件忽略" class="headerlink" title="文件忽略"></a>文件忽略</h2><p>对于一些不需要版本控制的文件，比如数据库配置文件，IDEA 配置文件，.class 编译的文件，则可以都配置成 <code>git.ignore</code>，然后声明到 .gitconfig 文件里面，让 Git 放弃对这些文件的版本控制。</p><p>而我们设置的 git.ignore 和 .gitconfig 都是在 C 盘的 Users/Xorex 目录下面的，做的是一个全局的配置。</p><p><code>.ignore</code> 使用 # 做注释，支持正则表达式，一行为一句表达式。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for java</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target/</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure><p>然后将这个文件路径在 .gitconfig 中添加配置：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">    excludesfile = C:/Users/Xorex/git.ignore</span><br></pre></td></tr></table></figure><p>一定要多次比对配置信息啊，千万别写错，写错了就执行不了！！！</p><h2 id="代码托管平台"><a href="#代码托管平台" class="headerlink" title="代码托管平台"></a>代码托管平台</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>在 Github 上面创建完一个仓库之后，有两种连接方式：</p><ol><li>HTTP 连接: <code>https://github.com/Administrator-Xorex/Git.git</code></li><li>SSH 连接：<code>git@github.com:Administrator-Xorex/Git.git</code></li></ol><p>因为连接太长，所以可以建立一个别名：<code>git remote add ALIAS https://xxx.xxx</code> ALIAS 就是我们给后面连接设置的别名。</p><p>推送本地库某个分支到仓库里面：<code>git push ALIAS BRANCH_NAME</code> 需要指定推送的分支名。</p><p>拉取仓库代码：<code>git pull ALIAS BRANCH_NAMEs</code> 需要指定拉去的分支名。</p><p>克隆仓库代码：<code>git clone https://xxx.xxx/xx.git</code> 然后就会在当前目录下面将仓库所有代码用仓库名作为文件夹保存下来，克隆之后会创建项目地址的别名 origin。</p><p>对于多人协作的时候，自己编写完代码需要先将远程库里面的代码 pull 下来，解决完冲突之后，才可以将自己的代码 push 上去。</p><hr><p>HTTPS 连接每次都需要输入 Github 的密码，解决方案一个是使用 Windows 自带的 Credential Manager 添加验证，另外一个是在 Git 里面保存一定时常的密码，只需要输入命令：<code>git config --global credential.helper store</code> 即可，下次输入完密码就被保存了。</p><p>或者配置好 SSH 的公钥到 Github 中，走 SSH 连接。</p><h3 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h3><p>第一种团队协作方式就是将另外一个人加入到自己的团队中开发，这就需要 Github 里面的团队邀请机制了，把别人邀请到自己的团队里面，然后给予他 pull 和 push 的权限，一起开发。</p><p>这个只需要在 Manage access 里面添加用户就可以了。</p><hr><p>另外一种就是让另外一个团队复制一份仓库，然后他们开发完之后，请求让仓库主人将开发完的复制仓库拉去到自己的主仓库中。解决完冲突之后，另外团队的开发内容就合并到主仓库里面了。</p><p>复制使用 fork 来将仓库拉过来一份，开发完点击 pull request 发起请求。仓库主人审核完代码自会后，统一请求，向被 forked 出来的仓库发起 pull，从而合并代码。</p><p><img src="https://xorex.space/image/311.jpg" alt="311.jpg"></p><p>比如上面的图片就是对项目 UpStream 进行的一个多团队开发过程。</p><p>先 fork 出来一个 origin 的仓库，然后在 clone 到本地，经过开发之后，向项目 UpStream 发起 Pull Request 请求，项目管理员同意之后，会 pull origin 仓库，完成代码合并。</p><h2 id="和-IDEA-整合"><a href="#和-IDEA-整合" class="headerlink" title="和 IDEA 整合"></a>和 IDEA 整合</h2><h3 id="分支合并-1"><a href="#分支合并-1" class="headerlink" title="分支合并"></a>分支合并</h3><p>原理和命令都是相同的，都是选择分支，然后让其合并到当前的分支上面。</p><h2 id="Git-实现原理"><a href="#Git-实现原理" class="headerlink" title="Git 实现原理"></a>Git 实现原理</h2><p>Git 的实现原理就是通过 HEAD 指针和分支指针所指向内容的变化，来描述当前分支的变化和当前分支所在历史版本的变化。然后每一次 commit 都记录下来此次提交每一行的变化记录，然后根据这个变化记录来计算不同版本的文本内容。</p><p>先看看 Git 的目录：</p><p><img src="https://xorex.space/image/307.jpg" alt="307.jpg"></p><h3 id="hooks-目录"><a href="#hooks-目录" class="headerlink" title="hooks 目录"></a>hooks 目录</h3><p>这个文件夹里面保存了下面这些东西：</p><p><img src="https://xorex.space/image/308.jpg" alt="308.jpg"></p><p>这些都是一些脚本，在执行 git 一些命令的前后执行，所以被称为钩子，来钩在命令的前后，做一些检查之类的工作。</p><h3 id="info-目录"><a href="#info-目录" class="headerlink" title="info 目录"></a>info 目录</h3><p>里面只有 exclude 一个文件，用来配置不纳入 git 管理文件信息。</p><h3 id="logs-目录"><a href="#logs-目录" class="headerlink" title="logs 目录"></a>logs 目录</h3><p>记录提交的提交记录，下属有一个 HEAD 文件和 refs 文件夹，HEAD 文件记录所有的提交记录，而 refs 文件夹分别保存着不同分支的提交记录文件。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| -- refs</span><br><span class="line">|   -- heads</span><br><span class="line">|       -- master //主分支提交记录文件</span><br><span class="line">|       -- feature //featrure 分支提交记录文件</span><br><span class="line">| -- HEAD //所有提交记录文件</span><br></pre></td></tr></table></figure><p>在我们调用 <code>git reflog</code> 和 <code>git log</code> 命令来获取提交记录的时候，就是从这些文件里面读取的。</p><h3 id="objects-目录"><a href="#objects-目录" class="headerlink" title="objects 目录"></a>objects 目录</h3><p>执行完 git add 之后，文件的更改信息（每一行的变化）就会被存储到 objects 目录了，会根据版本名的前两位做一个类似于 HashTable 的分组优化。</p><p><img src="https://xorex.space/image/309.jpg" alt="309.jpg"></p><p>然后里面的文件名为历史版本名（其实就是内容计算 SHA1 作为文件名），文件内容就是此版本文件的每一行变化记录，根据记录来计算不同版本下文件的内容，</p><p>当我们执行了 git gc 或者将代码 push 到远程仓库之后，git 就会将这些零散的文件更改信息打包，放入 pack 文件夹里面，并在 info 文件夹里面的文件留下记录。</p><h3 id="refs-目录"><a href="#refs-目录" class="headerlink" title="refs 目录"></a>refs 目录</h3><p>里面有存储着分支和标签的引用，用来记录当前 HEAD 指针指向的分支和标签内容。实际上根据 HEAD 指针找到当前分支以及当前分支所处的记录节点（历史版本节点）就是在这个目录里面的文件里保存的。</p><h3 id="config-文件"><a href="#config-文件" class="headerlink" title="config 文件"></a>config 文件</h3><p>主要是 Git 的一些配置保存的地方：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = false</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">    symlinks = false</span><br><span class="line">    ignorecase = true</span><br><span class="line">[user]</span><br><span class="line">    username = Tempest</span><br><span class="line">    email = Xorex@Tempest.com</span><br></pre></td></tr></table></figure><h3 id="HEAD-文件"><a href="#HEAD-文件" class="headerlink" title="HEAD 文件"></a>HEAD 文件</h3><p>存储着当前位置的指针，表示当前所在的分支名称，内容为一个 ref 的地址，从 refs 目录里面找分支引用。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><p>目录文件的结果是当前分支 master 的记录节点名（其实就是根据内容计算 SHA1 作为文件名）：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">96e8d208240398683deb39dd4de2aeb576136ca6</span><br></pre></td></tr></table></figure><h3 id="index-文件"><a href="#index-文件" class="headerlink" title="index 文件"></a>index 文件</h3><p>index 在 Git 里面是暂存区记录，并不是真正的暂存区。当我们使用 add 之后，会直接将更改记录添加到 objects 文件夹里面，然后在 index 文件里面留下来记录。commit 的时候是从 index 里面找到缓存区内容的索引信息。</p><h2 id="add-和-commmit-命令分别做了什么"><a href="#add-和-commmit-命令分别做了什么" class="headerlink" title="add 和 commmit 命令分别做了什么"></a>add 和 commmit 命令分别做了什么</h2><p>对于 objects 文件夹里面的东西，虽然名字都是 SHA1 生成的，但是还是有区别的，分为四类：</p><ol><li>Commit 包含提交人、日期、消息还有目录树，作为一个版本的快照。</li><li>Tree 引用其他的 Tree 或者 Blob</li><li>Blob 存储一个文件的修改数据</li><li>Tag 存储某个提交的引用。</li></ol><p>关系如下：</p><p><img src="https://xorex.space/image/310.jpg" alt="310.jpg"></p><p>当我们执行了 add 命令之后，就会在 objects 生成 Blob 文件，文件的数量取决于 add 加入暂存区并修改内容的文件的数量。使用 commit 提交之后，会生成一个快照 Tree 文件，来记录本次提交所有文件修改记录的索引（SHA1 文件名）。生成完快照之后，会生成一个提交记录，里面包括快照的索引（SHA1 文件名），上一次提交记录的索引（SHA1 文件名），本次提交的作者签名（name 和 email），以及提交描述。</p><p>观察上面的图片，有一点点细节，那就是 Blob 文件并不会存储文件名，文件名是交给 Tree 文件保存的，所以一旦移动文件或者改名字，是认不出来的，只会被当作一个新的文件。其次是这个文件需要手动删除，也就是使用命令 <code>git rm test.txt</code> 将其从暂存区删除，不然从另外一个版本跳过来的时候，会根据快照重新生成这个文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Git-概念&quot;&gt;&lt;a href=&quot;#Git-概念&quot; class=&quot;headerlink&quot; title=&quot;Git 概念&quot;&gt;&lt;/a&gt;Git 概念&lt;/h2&gt;&lt;h3 id=&quot;分布式与集中式&quot;&gt;&lt;a href=&quot;#分布式与集中式&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Git" scheme="https://xorex.space/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-04-动态SQL和缓存系统</title>
    <link href="https://xorex.space/2021/07/19/6df2c6bea164/"/>
    <id>https://xorex.space/2021/07/19/6df2c6bea164/</id>
    <published>2021-07-19T07:15:47.000Z</published>
    <updated>2021-07-23T06:03:07.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="if-标签"><a href="#if-标签" class="headerlink" title="if 标签"></a>if 标签</h2><p><code>&lt;if test=&quot;Expression&quot;&gt;&lt;/if&gt;</code></p><p>其中 Expression 为加强版本的 if 表达式，就是 Java 里面的 if 表达式（指可以调用其他方法），并且可以使用 and or 代替 &amp;&amp; || 符号。</p><h2 id="choose、when、otherwise-标签"><a href="#choose、when、otherwise-标签" class="headerlink" title="choose、when、otherwise 标签"></a>choose、when、otherwise 标签</h2><p>故名思意就是很常规的标签罢了。</p><h2 id="trim、where、set-标签"><a href="#trim、where、set-标签" class="headerlink" title="trim、where、set 标签"></a>trim、where、set 标签</h2><p>这三个标签主要是为了拓展 if 标签存在的。</p><p>主要是比如 and , 这些符号在拼接的时候不是很可控，所以多了这些标签。</p><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>where 标签有两个作用：</p><ol><li>在内部有 if 判断成立的时候添加 where 符号</li><li>去掉句子开头的 and or 符号</li></ol><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 标签也有两个作用：</p><ol><li>在内部有 if 判断成立的时候添加 set 符号</li><li>去掉句子结尾的逗号</li></ol><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>trim 其实就是自定义版本的前两者，拥有属性 prefix 和 suffix 来设置内部 if 成立之后添加的关键词，suffixOverrides preffixOverrides 用来去除 if 里面可能会多出来的前后缀 <code>and</code> 或者 <code>,</code> 这些。</p><p>代替 where 的 trim：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代替 set 的 trim：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>forEach 标签主要用来对 Collection 和 Map 进行遍历：</p><ol><li>collection 用来指明遍历的集合或者 Map</li><li>item 单个元素的变量名</li><li>open 遍历内容之前的东西，如 (</li><li>close 遍历内容之后的东西，如 )</li><li>separator 遍历内容之间的分隔符</li><li>index 遍历内容的索引（Map 中是键）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;users&quot;</span> <span class="attr">item</span>=<span class="string">&quot;user&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">index</span>=<span class="string">&quot;i&quot;</span>&gt;</span></span><br><span class="line">    #&#123;user&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><p>大概就这样啦！</p><h2 id="sql-include-标签"><a href="#sql-include-标签" class="headerlink" title="sql include 标签"></a>sql include 标签</h2><p>这两个标签是放在一起使用的，sql 标签用来抽取 SQL 语句， inlcude 标签用来引用被抽取的 SQL 语句。</p><h2 id="OGNL-表达式"><a href="#OGNL-表达式" class="headerlink" title="OGNL 表达式"></a>OGNL 表达式</h2><p>OGNL Object Graph Navigation Language 对象导航图语言，也就是 test 判断里面使用的语言。</p><p>内容有亿点点复杂，先不研究了！</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>在 MyBatis 里面缓存其实就是一个 Map，一个用 SQL 语句作为 Key，查询结果作为 Value 的一个 Map，缓存能减少数据库的压力，大大加快系统的运行速度。</p><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>MyBatis 的一级缓存就是 SqlSession 级别的缓存，是线程级别的缓存，是默认生效的。每个 SqlSession 的连接都有自己单独的一级缓存区域，不同连接的一级缓存不共享。</p><p>对于同一个 Session 连接来说，只要缓存不刷新，缓存就能一直用。当这个 Session 调用了 update delete create 方法之后，一级缓存就会被刷新（Map 清空）。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>二级缓存是一个作用与所有 SqlSession 的共享缓存，二级缓存默认不使用。如果想要打开的话，需要开启全局配置 cacheEnabled 为 true，然后在 mapper.xml 文件里面加入 <code>&lt;cache&gt;&lt;/cache&gt;</code> 标签。</p><p>当一个 SqlSession 被 commit() 或者 close() 之后，它的一级缓存就会被放入二级缓存中。</p><p>二级缓存的刷新是需要设置的，SQL 标签里面有一个选项 flushCache，设置为 true 之后，执行语句会连着二级缓存一起刷新。</p><p>在 <code>&lt;cache&gt;&lt;/cache&gt;</code> 标签里面有一些属性，可以设置缓存回收策略（当缓存空间满了之后处理），返回的缓存是复制出来的还是直接给引用等等。</p><p>MyBatis 使用缓存的原则是先从二级缓存找数据，没有再去一级缓存。</p><p>不过以后我们都是使用第三方的缓存系统的比如 Redis，MyBatis 本身做的有点菜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;if-标签&quot;&gt;&lt;a href=&quot;#if-标签&quot; class=&quot;headerlink&quot; title=&quot;if 标签&quot;&gt;&lt;/a&gt;if 标签&lt;/h2&gt;&lt;p&gt;&lt;code&gt;&amp;lt;if test=&amp;quot;Expression&amp;quot;&amp;gt;&amp;lt;/if&amp;gt;&lt;/c</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-03-XML映射文件</title>
    <link href="https://xorex.space/2021/07/18/bd50545aca34/"/>
    <id>https://xorex.space/2021/07/18/bd50545aca34/</id>
    <published>2021-07-18T08:04:33.000Z</published>
    <updated>2021-07-19T15:48:36.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h2><h3 id="insert-update-delete"><a href="#insert-update-delete" class="headerlink" title="insert update delete"></a>insert update delete</h3><p>这个三个标签分别负责实现：插入更新和删除，三者的属性非常接近。</p><h4 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>此语句绑定接口的方法</td></tr><tr><td>parameterType</td><td>用来说明方法输入的参数类型，但这个类型通过反射可以拿到，所以不需要写</td></tr><tr><td>flushCache</td><td><code>true/false:true</code>此语句被调用之后刷新本地缓存和二级缓存。</td></tr><tr><td>timeout</td><td>整形等待数据库的最长秒数，这个不用填，交给 Spring 控制</td></tr><tr><td>statementType</td><td>执行 SQL 使用的语句类型，可选 STATEMENT，PREPARED 或 CALLABLE，表示 Statement，PreparedStatement 和 CallableStatement，默认PREPARED</td></tr><tr><td>useGeneratedKeys（适用于 insert 和 update）</td><td><code>true/false:false</code> 开启之后，执行完 SQL 会在传入的对象中自动填写数据库生成的主键值（需要设置keyProperty）</td></tr><tr><td>keyProperty（适用于 insert 和 update）</td><td>搭配上面的 useGeneratedKeys 使用，指明传入参数的哪个属性对应数据库主键。</td></tr><tr><td>keyColumn（适用于 insert 和 update）</td><td>对于某些主键列不在第一个的数据库，需要设置这个，指明哪一列是主键的列，才能配合使用上面两项设置。</td></tr><tr><td>databaseId</td><td>用来指明这条 SQL 语句执行的数据库类型。</td></tr></tbody></table><h4 id="获取自增主键"><a href="#获取自增主键" class="headerlink" title="获取自增主键"></a>获取自增主键</h4><p>在 SQL 语句里面设置 useGeneratedKeys 和 keyProperty：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    SQL statement...</span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后用于新插入的对象 user 执行完 SQL 语句之后，就会被自动赋值 id 属性为生成的主键值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">    User user=<span class="keyword">new</span> User(<span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;Tempest&quot;</span>, <span class="keyword">new</span> UserAddress(<span class="string">&quot;Xorex&quot;</span>,<span class="string">&quot;China&quot;</span>));</span><br><span class="line">    mapper.insertUser(user);</span><br><span class="line">    System.out.println(user.getId());</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><h4 id="属性设置-1"><a href="#属性设置-1" class="headerlink" title="属性设置"></a>属性设置</h4><p>这里只说说和上面三条不太一样的：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>resultType</td><td>设置返回值类型，非常用类型必须填写。</td></tr><tr><td>resultMap</td><td>设置结果映射，和 resultType 二选一</td></tr><tr><td>useCache</td><td><code>true/false:true</code> 查询结果会放在二级缓存中</td></tr><tr><td>resultSetType</td><td>用于设置 JDBC 获取的结果集的类型 FORWARD_ONLY 指的是只能用 next() 向下读取，SCROLL_SENSITIVE 可以实现结果前后滚动读取和相对坐标跳跃读取，而选项 SCROLL_INSENSITIVE 的结果集不仅可以前后滚动读取，还可以实时感知数据库的更新（不包括插入和删除），也就是获取的结果集在不同时间调用的时候，拿到的都是最新的数据。一般这个选项不需要我们设置，使用默认的 unset 即可。</td></tr><tr><td>resultOrdered</td><td>和 MyBatis 缓存有关，设置为 true 之后表示数据是根据 key 相同分好组的，MyBatis 就可以进行解析优化。具体用法后面再讨论。</td></tr><tr><td>resultSet</td><td>由于一些特殊语句（比如两条 selete 查询）会返回多个结果集，为了操作不同结果集，就需要区分。这里是按照顺序设置结果集的名称 <code>resultSet=&quot;User,Address&quot;</code> 这样为两条 SQL 返回的不同结果集命名。</td></tr></tbody></table><h2 id="参数映射"><a href="#参数映射" class="headerlink" title="参数映射"></a>参数映射</h2><h3 id="单参数映射"><a href="#单参数映射" class="headerlink" title="单参数映射"></a>单参数映射</h3><p>当我们的方法参数为一个单个参的时候，又分为很多种情况。</p><ol><li><p>为 MyBatis 内置的较为基本的类型的时候，MyBatis 会直接将其返回调用 toString() 填充到 SQL 语句中。</p></li><li><p>为 POJO 类型的时候，会根据 <code>#&#123;VarName&#125;</code> 构造 getVarName() 方法获取 POJO 值，填充 SQL 语句。</p></li><li><p>为 Map 类型的时候，会根据 <code>#&#123;Varname&#125;</code> 名字作为 Key 从 Map 中取出 value，填充到 SQL 语句中。</p></li><li><p>为 List 类型的时候：</p></li><li><p>为 数组类型的时候：</p></li></ol><h3 id="多参数映射"><a href="#多参数映射" class="headerlink" title="多参数映射"></a>多参数映射</h3><h4 id="多参数入参解决方案"><a href="#多参数入参解决方案" class="headerlink" title="多参数入参解决方案"></a>多参数入参解决方案</h4><p>这里主要是 SQL 语句中 parameterType 属性和 @Param 注解的解释。</p><p>其中因为 Java 基本上所有的版本都是支持反射获取方法参数类型 （Method 类 getParameterTypes()），所以对于 parameterType 这个属性完全可以不写，Mybatis 完全可以通过反射拿到。</p><p>但是 Mybatis 拿到的仅仅只是方法参数的类型，是拿不到参数名的，编译之后就成了 var1 var2 这样的，所以对于多个参数进行的映射如 <code>public void insertUser(String userName,String password);</code> 这样，只能用一些特殊的技巧填入 SQL 语句中的 #{} 里面：</p><ol><li>使用数字表示参数顺序</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user (username,password) values (#&#123;0&#125;,#&#123;1&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过数字来表示方法中的第 0 个参数，第 1 个参数等等。</p><ol start="2"><li>使用 @Param(“Name”) 来定义参数名</li></ol><p>使用 Mybatis 提供的注解 @Param 来对方法中的参数起一个别名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(<span class="meta">@Param(&quot;userNameVar&quot;)</span> String userName,<span class="meta">@Param(&quot;passwordVar&quot;)</span> String password)</span></span>;</span><br></pre></td></tr></table></figure><p>然后就可以在 SQL 语句中使用我们在 @Param 中定义的别名了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user (username,password) values (#&#123;userNameVar&#125;,#&#123;passwordVar&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>将多个参数封装为 Map 之后传入</li></ol><p>自己构造一个参数的 参数名-&gt;参数值 的 Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;Tempest&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;userAddress&quot;</span>,<span class="string">&quot;China&quot;</span>);</span><br><span class="line">    mapper.insertUser(map);</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 SQL 里面直接写 Map 的 key 就能获取自己传入的 value。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user (user_name,password)</span><br><span class="line">    values(#&#123;userName&#125;,#&#123;password&#125;);</span><br><span class="line">    insert into address (user_name,user_address)</span><br><span class="line">    values(#&#123;userName&#125;,#&#123;userAddress&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>封装成 POJO 入参</li></ol><p>将所有需要入参的参数封装为一个 POJO，然后就能像使用 Map 一样，用属性名取出参数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">    mapper.insertUser(<span class="keyword">new</span> User(<span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;Tempest&quot;</span>, <span class="keyword">new</span> UserAddress(<span class="string">&quot;Xorex&quot;</span>,<span class="string">&quot;China&quot;</span>)));</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user (user_name,password)</span><br><span class="line">    values(#&#123;userName&#125;,#&#123;password&#125;);</span><br><span class="line">    insert into address (user_name,user_address)</span><br><span class="line">    values(#&#123;userAddress.userName&#125;,#&#123;userAddress.userAddress&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="多参数入参原理"><a href="#多参数入参原理" class="headerlink" title="多参数入参原理"></a>多参数入参原理</h4><p>其实只要你的方法参数数量大于 1 ，那么就会被 MyBatis 封装为 Map 类型，通过 Key-&gt;Value 来在 SQL 中填充值。</p><p>如果在方法参数的地方标注了 @Param(“Alias”)，那么封装 Map 的时候这里的 Key 就是自己设置的 Alias，如果没标注，那么就是 arg1 arg2 这些。</p><p>而从 Map 中取出来的值也是原原本本的传入的参数类型，不会改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="meta">@Param(&quot;user&quot;)</span> User user,<span class="meta">@Param(&quot;address&quot;)</span> String address)</span></span>;</span><br></pre></td></tr></table></figure><p>这里面需要取值的时候，user 取出来一个 User 对象，address 取出来一个 String 对象。</p><h2 id="结果映射"><a href="#结果映射" class="headerlink" title="结果映射"></a>结果映射</h2><p>Java 是可以通过反射拿到方法的返回值类型，但是对于 List Map 这样用到了泛型的，是无法拿到泛型的具体类型，也自然无法进行封装，所以才会引入 resultType 和 resultMap 来解决这个问题，两者将作为反射的一个补充。</p><h3 id="列名和属性一一对应"><a href="#列名和属性一一对应" class="headerlink" title="列名和属性一一对应"></a>列名和属性一一对应</h3><p>当数据库的列名和属性名一一对应的时候，就不需要自定义映射规则了，只需要指定映射结果类型即可。</p><ol><li><p>当设置为 POJO 类型的时候，会根据列名和属性名进行一一映射，如果名字相同，则可以映射成功，如果不相同，则需要引入 resultMap 来自定义映射规则。</p></li><li><p>当设置为 List 类型的时候，resultType 应该填写 <code>List&lt;Type&gt;</code> 里面的数据类型 Type，多条结果会自动封装为 List。</p></li><li><p>当想要将一条数据的列名作为 Key，值作为 Value，返回值类型为 Map&lt;String,Object&gt;，resultType 应该填写 map。</p></li><li><p>当想要将主键作为 Key，剩下其余的值封装为 POJO 作为 Value 的时候，返回值类型为 Map&lt;KeyType,POJOType&gt;，resultType 应该填写 POJO 的类型。并在接口方法出添加注解 <code>@MapKey(&quot;KeyColumn&quot;)</code> 来指明拿哪一列的值作为 Map 中 POJO 的 Key。</p></li></ol><h3 id="列名和属性不对应"><a href="#列名和属性不对应" class="headerlink" title="列名和属性不对应"></a>列名和属性不对应</h3><p>这个时候就无法自动映射了，需要我们指定映射规则，也就是填写 resultMap。</p><p>需要注意的是，当我们设置了驼峰下划线自动映射之后，也就是 mapUnderScoreToCamelCase 之后。这玩意只能在 <strong>自动匹配</strong> 的时候生效，也就是使用 resultType 或者 resultMap 设置属性 autoMapping=ture 的时候，会在自动映射的属性-列中自动进行下划线驼峰转化。</p><p>当你进行手动映射的时候，只能老老实实写 SQL 语句里面的真实列名进行手动映射，mapUnderScoreToCamelCase 不会生效的！！！</p><h4 id="resultMap-标签属性"><a href="#resultMap-标签属性" class="headerlink" title="resultMap 标签属性"></a>resultMap 标签属性</h4><ol><li>id 定义此 resultMap 的 id。</li><li>type 定义此 resultMap 结果映射的类。</li><li>autoMapping <code>true/false:false</code>，在 resultMap 中开启自动映射。</li><li>extends 外部继承一个 resultMap，并在它后面补充（概念上是和 Java 的继承是一样的）</li></ol><h4 id="resultMap-内部标签"><a href="#resultMap-内部标签" class="headerlink" title="resultMap 内部标签"></a>resultMap 内部标签</h4><ol><li>&lt;id&gt; 定义 ID 映射，有特殊优化。</li><li>&lt;result&gt; 定义一个普通的映射</li><li>&lt;association&gt; 关联，定义一个内联的 resultMap，给是属性的 POJO 赋值。</li><li>&lt;constructor&gt; 构造器，利用构造器给结果赋值。</li><li>&lt;collection&gt; 集合，将一对多的查询结果的多的部分封装为集合类型。</li><li>&lt;discriminator&gt; 鉴别器，</li></ol><p>下面主要介绍后三个的用法:</p><h5 id="constructor-构造器"><a href="#constructor-构造器" class="headerlink" title="constructor 构造器"></a>constructor 构造器</h5><p>指的是使用 POJO 里面的构造器进行封装参数，参数传入顺序是按照标签顺序进行的，只需要写 javaType 和 column 两个属性即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;userAddress&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;useraddress&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_address&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想要按照参数名来进行传参而不是顺序，则需要在 POJO 的构造方法的参数里面添加 <code>@Param(&quot;paramName&quot;)</code> 注解，然后在 arg 标签里面指定属性 <code>name=paramName</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserAddress</span><span class="params">(<span class="meta">@Param(&quot;userName&quot;)</span> String userName, <span class="meta">@Param(&quot;userAddress&quot;)</span> String userAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    <span class="keyword">this</span>.userAddress = userAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;userAddress&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;false&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;useraddress&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor</span>&gt;</span> <span class="comment">&lt;!--更换位置之后也不需要担心顺序哦--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_address&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userAddress&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="collection-集合"><a href="#collection-集合" class="headerlink" title="collection 集合"></a>collection 集合</h5><p>collection 主要是用来封装一对多的情况，也就是 POJO 属性有集合类型的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> List&lt;UserAddress&gt; userAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是一对多，所以查出来的条数是多的数量，因此在<strong>对一使用自动映射</strong>的时候，会因为有多条数据无法对应上一而报错。 <code>Expected one result (or null) to be returned by selectOne(), but found: 3</code></p><p>正确的解决方案就是：先手动映射上一列，到后面映射集合元素的时候，就会对应上多条数据，从而避免多条数据无法对应上，手动映射随便一列就行，我这里选的是主键。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;userAddress&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;arraylist&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;useraddress&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>collection 和其他标签<strong>唯一不同</strong>的地方是，标注集合内元素类型使用的是 <code>ofType</code> 属性，而我们在其他标签（比如 association）指明映射类型使用的 javaType 在这里面则是值生成的集合的类型，比如 ArrayList，LinkedList 等等。</p><h5 id="discriminator-鉴别器"><a href="#discriminator-鉴别器" class="headerlink" title="discriminator 鉴别器"></a>discriminator 鉴别器</h5><p>这个东西用的不多，就先不学了。</p><h5 id="分级查询"><a href="#分级查询" class="headerlink" title="分级查询"></a>分级查询</h5><p>记得在配置中有 lazyLoadingEnabled aggressiveLazyLoading 两条关于懒加载，按需加载，延迟加载的配置，这些配置就是作用于分级查询的语句的。</p><p>分级查询针对对象是内联属性，也就是 collection 和 association 标签，实现方式就是将联合查询的 SQL 语句拆分成两句简单的查询，然后分两次调用。不同的是第二次调用是通过配置来完成的：</p><p>还是这样一个 POJO：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> List&lt;UserAddress&gt; userAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将内联查询拆分成两条单独的 SQL 语句，第一条 SQL 只处理非内联属性的值获取，第二条 SQL 负责处理内联属性的值获取。然后在 resultMap 对内联属性进行映射处理的时候，添加数据获取源 <code>select=&quot;&quot;</code> 表明通过另外一条 SQL 查询获取数据，对于此 SQL 的输入参数，则通过上一条 SQL 查询结果获取，设置为属性 column 将上一条结果的某一列的值传给下一条 SQL。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;userAddress&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;useraddress&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getUserAddressByUserName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUserName&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from user where user_name=#&#123;userName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserAddressByUserName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;useraddress&quot;</span>&gt;</span></span><br><span class="line">    select * from address where user_name=#&#123;userName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，指定的数据传递 column 属性之后，回<strong>对这一列数据的自动封装有一定影响</strong>，需要重新手动映射一下，也就是因为 <code>column=&quot;user_name&quot;</code> 多出来的 <code>&lt;result column=&quot;user_name&quot; property=&quot;userName&quot;/&gt;</code>。</p><p>这样分级查询就构建好了！！！</p><p>对于第二级 SQL 的输入为多个参数的情况，使用 <code>column=&#123;key1=column1,key2=column2&#125;</code> 这样来解决，key 为我们在 <code>@Param()</code> 定义的别名，column 为上一条查询结果的列名。</p><hr><p>构建完分级查询之后，最大的意义就是使用延迟加载来提高数据库性能！！！</p><p>只需要将 lazyLoadingEnabled 设置为 true 表明系统可以使用延迟加载，然后将 aggressiveLazyLoading 设置为 false ，关闭延迟加载侵入。这样分级查询的第二级就只会在需要（被调用的时候）进行了！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;标签属性&quot;&gt;&lt;a href=&quot;#标签属性&quot; class=&quot;headerlink&quot; title=&quot;标签属性&quot;&gt;&lt;/a&gt;标签属性&lt;/h2&gt;&lt;h3 id=&quot;insert-update-delete&quot;&gt;&lt;a href=&quot;#insert-update-delete&quot; cla</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-02-全局配置文件</title>
    <link href="https://xorex.space/2021/07/17/10f39f81a384/"/>
    <id>https://xorex.space/2021/07/17/10f39f81a384/</id>
    <published>2021-07-17T07:33:02.000Z</published>
    <updated>2021-07-19T12:55:16.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="properties-属性"><a href="#properties-属性" class="headerlink" title="properties 属性"></a>properties 属性</h2><p>这里的 properties 有三种配置方式：</p><ol><li>在 properties 内部标签定义：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Xorex&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;https://xorex.space/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;space.xorex.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>引入外部的配置文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;JDBC.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在创建 SqlSessionFactory 的时候，给 Builder 传入一份配置文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, Properties properties)</span></span>;</span><br></pre></td></tr></table></figure><p>这三种方式传入的配置信息的优先级是依次递增的，后面的会覆盖前面的配置条目的信息，只需要注意第一种和第二种的优先级关系，有点反常 QAQ。</p><h2 id="settings-设置"><a href="#settings-设置" class="headerlink" title="settings 设置"></a>settings 设置</h2><h3 id="cacheEnabled"><a href="#cacheEnabled" class="headerlink" title="cacheEnabled"></a>cacheEnabled</h3><p><code>true/false:true</code></p><p>允许缓存：全局性的打开或者关闭缓存设置。</p><h3 id="lazyLoadingEnable"><a href="#lazyLoadingEnable" class="headerlink" title="lazyLoadingEnable"></a>lazyLoadingEnable</h3><p><code>true/false:false</code></p><p>允许延迟加载：全局性的打开或者关闭数据库延迟加载，可被 fetchType 覆盖。</p><h3 id="aggressiveLazyLoading"><a href="#aggressiveLazyLoading" class="headerlink" title="aggressiveLazyLoading"></a>aggressiveLazyLoading</h3><p><code>true/false:false</code></p><p>侵入式延迟加载：开启时，任一方法的调用都会加载该对象的所有延迟加载属性（被侵入了就不懒加载了）。 否则，每个延迟加载属性会按需加载（所以要懒加载这条必须是 false）</p><h3 id="multipleResultSetsEnable"><a href="#multipleResultSetsEnable" class="headerlink" title="multipleResultSetsEnable"></a>multipleResultSetsEnable</h3><p><code>true/false:true</code></p><p>是否允许单语句查询返回多结果集（需要数据库支持），比如一条 &lt;select&gt; 标签里面有两条 select 语句，查询到了两个结果集。</p><h3 id="useColumnLabel"><a href="#useColumnLabel" class="headerlink" title="useColumnLabel"></a>useColumnLabel</h3><p><code>true/false:true</code></p><p>使用列标签代替列名，是解决查询结果映射集的一种方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> userName <span class="keyword">as</span> <span class="keyword">user</span> <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure><p>这样就给 userName 起了一个别名（列标签）user，在进行结果映射的时候，如果开启了 useColumnLabel，那么就用别名 user 去找结果映射填充而不是原名的 userName。<strong>建议一直开着</strong>。</p><h3 id="useGeneratedKeys"><a href="#useGeneratedKeys" class="headerlink" title="useGeneratedKeys"></a>useGeneratedKeys</h3><p><code>true/false:false</code></p><p>在调用 insert 和 update 语句更新数据库的时候，允许 JDBC 自动生成主键，并将主键内容返回给传入参数的 keyProperty 一项。</p><p>也就是传入一个 User 实例后，利用 userName 和 password 插入数据库，数据库生成的主键回赋值给传入参数 id 属性。</p><p>这个在 settings 设置之后，只对接口映射器有效（也就是在 Mapper 接口处使用注解开发），而对 XML 映射器无效。因此如果想要 XML 处实现，则需要到具体的 insert 和 update 语句里面设置：<code>useGeneratedKyes=&quot;true&quot; keyProperty=&quot;id&quot;</code> 打开开关并指定赋值主键的属性。</p><h3 id="autoMappingBehavior"><a href="#autoMappingBehavior" class="headerlink" title="autoMappingBehavior"></a>autoMappingBehavior</h3><p><code>NONE/PARTIAL/FULL:PARTIAL</code></p><p>表示自动结果映射行为的等级，none 表示不自动映射，partial [pɑːrʃl] 局部的，表示只会自动映射没有定义嵌套结果映射的字段，FULL 自动映射任何复杂的结果集，无论是否有嵌套。</p><p>不过一般默认的 PARTIAL 级别就够用了，FULL 就有点不太可控了，对于嵌套映射，还是自己写一个 ResultMap 爽。</p><h3 id="autoMappingUnknowColumnBehavior"><a href="#autoMappingUnknowColumnBehavior" class="headerlink" title="autoMappingUnknowColumnBehavior"></a>autoMappingUnknowColumnBehavior</h3><p><code>NONE/WARNING/FAILING:NONE</code></p><p>表示开启自动映射的时候，遇到未知列或者未知属性的时候，应该怎么做。</p><p>NONE 表示什么都不做，WARNING 表示日志输出 WARN 级别，FAILING 表示抛出 SqlSessionException。</p><h3 id="defaultExecutorType"><a href="#defaultExecutorType" class="headerlink" title="defaultExecutorType"></a>defaultExecutorType</h3><p><code>SIMPLE/REUSE/BATCH:SIMPLE</code></p><p>配置默认的执行器，SIMPLE 为简单执行器，没执行一句 SQL 就创建一个新的 Statement 实例。REUSE 为重复使用执行器，将执行过的 Statement 实例放入 Map 中缓存，方便下次相同 SQL 语句使用。BATCH 为批量执行器，会将多个 SQL 一次性执行。</p><h3 id="defaultStatementTimeout"><a href="#defaultStatementTimeout" class="headerlink" title="defaultStatementTimeout"></a>defaultStatementTimeout</h3><p><code>正整数:null</code></p><p>设置 Mybatis 等待数据库响应的最长时间，默认没有设置，单位秒。</p><h3 id="defaultFetchSize"><a href="#defaultFetchSize" class="headerlink" title="defaultFetchSize"></a>defaultFetchSize</h3><p><code>正整数:null</code></p><p>设置 Mybatis 获取 SQL 结果集的缓冲区大小的建议值，避免因为结果集数据过大，单位为条。</p><h3 id="mapUnderScoreToCamelCase"><a href="#mapUnderScoreToCamelCase" class="headerlink" title="mapUnderScoreToCamelCase"></a>mapUnderScoreToCamelCase</h3><p><code>true/false:false</code></p><p>设置将数据库列里面的下划线命名法和 Java 中的驼峰命名法进行映射匹配。</p><p>……</p><p>其实还有很多很多设置，但是时间和精力关系，就先这样了，等学到后面回把这些补上的。</p><h2 id="typeAliases-别名"><a href="#typeAliases-别名" class="headerlink" title="typeAliases 别名"></a>typeAliases 别名</h2><p>TypeAliases 主要作用就是为我们自己写的 POJO 起别名，这样只要遇到需要写全类名的地方，都可以用别名来代替。需要注意的是，所有的别名都是<strong>不区分大小写</strong>的！！！</p><h3 id="单独指定"><a href="#单独指定" class="headerlink" title="单独指定"></a>单独指定</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;space.xorex.mybatis.POJO.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>单独给某一个类指定<strong>任意</strong>一个名字作为他的别名。</p><hr><p>或者使用注解 <code>@Alias(&quot;name&quot;)</code> 标注在需要别名的 POJO 的申明类上面，也可以起别名。</p><h3 id="整个包执行"><a href="#整个包执行" class="headerlink" title="整个包执行"></a>整个包执行</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;space.xorex.mybatis.POJO&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>会将 <code>space.xorex.mybatis.POJO</code> 下面所有的 POJO 都起一个和<strong>类名相同</strong>不区分大小写的别名。</p><h3 id="MyBatis-内部设置的别名"><a href="#MyBatis-内部设置的别名" class="headerlink" title="MyBatis 内部设置的别名"></a>MyBatis 内部设置的别名</h3><p>MyBatis 给 Java 常见的一些类设置了别名，包含几乎所有的数据类型，不过对于基本类型和包装器类型，因为本来差距就是首字母大小写，所以两者的别名有所不同。基本类型的数据别名<strong>前面多了下划线</strong>。</p><table><thead><tr><th>别名</th><th>映射的类型</th></tr></thead><tbody><tr><td>_byte</td><td>byte</td></tr><tr><td>_long</td><td>long</td></tr><tr><td>_short</td><td>short</td></tr><tr><td>_int</td><td>int</td></tr><tr><td>_integer</td><td>int</td></tr><tr><td>_double</td><td>double</td></tr><tr><td>_float</td><td>float</td></tr><tr><td>_boolean</td><td>boolean</td></tr><tr><td>string</td><td>String</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>integer</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>date</td><td>Date</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr><tr><td>bigdecimal</td><td>BigDecimal</td></tr><tr><td>object</td><td>Object</td></tr><tr><td>map</td><td>Map</td></tr><tr><td>hashmap</td><td>HashMap</td></tr><tr><td>list</td><td>List</td></tr><tr><td>arraylist</td><td>ArrayList</td></tr><tr><td>collection</td><td>Collection</td></tr><tr><td>iterator</td><td>Iterator</td></tr></tbody></table><h2 id="typeHandlers-类型处理器"><a href="#typeHandlers-类型处理器" class="headerlink" title="typeHandlers 类型处理器"></a>typeHandlers 类型处理器</h2><p>类型处理器主要的工作内容就是将 SQL 数据库中的数据类型和 Java 的数据类型做一个转化，MyBatis 本身已经内置了很多类型处理器了，基本足够我们使用，但是如果想要实现自己的 typeHandler 的话，也不是不可以，只需要实现 TypeHandler 接口或者继承 BaseTypeHandler 即可。</p><p>实现完自己 typeHandler 后，需要将其加入 MyBatis 全局配置文件的 <code>&lt;typeHandlers&gt;</code> 里面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;space.xorex.handlers.MyHandler&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="objectFactory-对象工厂"><a href="#objectFactory-对象工厂" class="headerlink" title="objectFactory 对象工厂"></a>objectFactory 对象工厂</h2><p>这个没啥可说的，就是单纯的用来创造一个填充数据库查询来的数据的对象实例。这个选项的意义就是当自己实现了 objectFactory 之后，将自己的实现的工厂替换 MyBatis 自带的工厂。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;space.xorex.mybatis.objectFactorys.MyObjectFactory&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins 插件"></a>plugins 插件</h2><p>插件的作用其实就是一个拦截器，它可以拦截 MyBatis 里面的四大组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executor(update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) <span class="comment">//负责 SQL 语句的执行</span></span><br><span class="line">ParameterHandler(getParameterObject, setParameters) <span class="comment">//负责参数的填充</span></span><br><span class="line">ResultSetHandler(handleResultSets, handleOutputParameters) <span class="comment">//负责查询结果集的映射</span></span><br><span class="line">StatementHandler(prepare, parameterize, batch, update, query) <span class="comment">//负责 SQL 语句的构造</span></span><br></pre></td></tr></table></figure><p>我们只要实现了 Interceptor 接口，就可以在这个拦截器里面对上面类里面的任意执行方法进行拦截，比如执行器 Executor 的更新方法 update()，然后加入一些自定义的东西。最后加入到配置中就生效了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;space.xorex.mybatis.interceptors.MyInterceptors&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="environment-环境"><a href="#environment-环境" class="headerlink" title="environment 环境"></a>environment 环境</h2><p>MyBatis 里面的环境就是数据库相关的配置，在 <code>&lt;environments&gt;</code> 标签里面可以添加多个数据库环境配置，然后在 default 选项里面指明要使用的环境 id 即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;Dep-Env&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;Test-Env&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;Dep-Env&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 transactionManager 标签主要是设置事务管理的级别，其属性 type 有两个选项 <code>JDBC/MANAGED</code> ，JDBC 指的是使用 JDBC 自带的 commit rollback 进心事务管理，而 MANAGED 表示啥都不做。</p><p>当我们单独使用 MyBatis 的时候，可以用 JDBC 来控制事务。而和 Spring 整合之后，所以这条可以不配置（Spring 的事务控制的配置会直接覆盖 MyBatis 的！）</p><p>其次的 dataSource 用来配置数据源，其属性 type 有 <code>UNPOOLED/POOLED/JNDI</code>，UNPOOLED 表示一次访问新建一个连接，POOLED 表示使用连接池来优化连接，JNDI 是在 EJB 服务器上使用的，这个可以先不管。</p><p>然后 dataSource 里面就是设置各种数据源的信息了。</p><hr><p>当我们使用 Spring 进行整合的时候，上面的配置其实都没啥用（也不需要配置），我们将数据源和事务管理都交给 Spring 来完成，MyBatis 做好自己的 CRUD 即可。</p><h2 id="databaseIdProvider-数据库厂商标识"><a href="#databaseIdProvider-数据库厂商标识" class="headerlink" title="databaseIdProvider 数据库厂商标识"></a>databaseIdProvider 数据库厂商标识</h2><p>这个主要是用来设置多数据库连接的时候，一个数据库厂商标识别名的问题，其中属性 type 的值 DB_VENDOR 是固定的，表示通过方法 <code>DatabaseMetaData#getDatabaseProductName()</code> 自动获取当前数据库连接的数据库厂商标识。</p><p>获取标识之后，会在下面 property 标签里面的 name 属性匹配相同的数据库厂商标识，然后给它设置一个别名，为 value 里面的值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;MySQL&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;SQL Server&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlserver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置别名是为了方便，但是要在那里需要这个数据库厂商标识别名呢，答案就是在 Mapper.xml 的 SQL 语句映射文件里面，每一句 SQL 标签都有一个属性 databaseId 里面可以填写数据库厂商标识别名，标识这句 SQL 是在对应数据库上执行的。这样面对不停切换的数据库源，可以轻松的用不同 SQL 语句来应对。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">    select * from users;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;sqlserver&quot;</span>&gt;</span></span><br><span class="line">    select * from users;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="mappers-映射器"><a href="#mappers-映射器" class="headerlink" title="mappers 映射器"></a>mappers 映射器</h2><p>用来找 SQL 的 mapper.xml 映射文件的，分为单个配置和批量配置：</p><h3 id="单个配置"><a href="#单个配置" class="headerlink" title="单个配置"></a>单个配置</h3><p>使用 mapper 标签，resource 是从类路径下面开始找的指定配置文件，class 根据接口全类名在同级目录下找同名配置文件的，url 是从磁盘（格式为本地文件传输协议 <code>file:///</code> ）或者网络上根据路径找的映射文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;space/xorex/mybatis/Mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.mybatis.Mapper.UserMapper&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///D:/MyBatis/src/main/java/space/xorex/mybatis/Mapper/UserMapper.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="批量配置"><a href="#批量配置" class="headerlink" title="批量配置"></a>批量配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;space.xorex.mybatis.Mapper&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 package 标签，设置一个包名，然后会自动在包的同级目录下面找到所有的 xml 映射文件，根据类和 xml 文件名称相同进行匹配。</p><h3 id="优先级问题"><a href="#优先级问题" class="headerlink" title="优先级问题"></a>优先级问题</h3><p>需要注意的是，四者完全冲突，建议一个 mapper 只使用一种方法进行映射。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;properties-属性&quot;&gt;&lt;a href=&quot;#properties-属性&quot; class=&quot;headerlink&quot; title=&quot;properties 属性&quot;&gt;&lt;/a&gt;properties 属性&lt;/h2&gt;&lt;p&gt;这里的 properties 有三种配置方式：&lt;/p</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-01-基础与配置</title>
    <link href="https://xorex.space/2021/07/16/3074f743feb9/"/>
    <id>https://xorex.space/2021/07/16/3074f743feb9/</id>
    <published>2021-07-16T02:56:51.000Z</published>
    <updated>2021-07-18T03:49:58.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MyBatis-概述"><a href="#MyBatis-概述" class="headerlink" title="MyBatis 概述"></a>MyBatis 概述</h2><p>Mybatis 是一种持久层的框架，通过建立接口的方法和 XML 注册的 SQL 语句的映射关系来实现对数据库的操作。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="获取数据库连接之前"><a href="#获取数据库连接之前" class="headerlink" title="获取数据库连接之前"></a>获取数据库连接之前</h3><p>首先获取数据库的连接实例 SqlSession 的连接池 SqlSessionFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory factory; <span class="comment">//连接池</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String resource=<span class="string">&quot;MyBatis-config.xml&quot;</span>; <span class="comment">//连接池的配置文件</span></span><br><span class="line">        InputStream inputstream = Resources.getResourceAsStream(resource); <span class="comment">//将配置文件读入流中</span></span><br><span class="line">        factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputstream); <span class="comment">//按照配置文件建造 SqlSession 连接池</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSession</span><span class="params">()</span> </span>&#123; <span class="comment">//从连接池获取连接</span></span><br><span class="line">        <span class="keyword">return</span> factory.openSession();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取连接池需要在服务器启动的时候进行，所以放到静态代码块里面执行。上面的 <code>SqlSessionFactoryBuilder</code> 作用就是按照配置文件建造连接池，此实例用完就扔，所以不给外部引用，让 GC 把它回收了。留着 <code>SqlSessionFactory</code> 作为单独一个连接池管理 SQL 连接。</p><h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><p>在 <code>MyBatis-config.xml</code> 连接池配置中加入数据库连接环境，其中 <code>&lt;property&gt;</code> 标签中的 value 中依次填入所有的信息即可。</p><p>或者外部引入一个 properties 文件，里面写上数据库连接数据，然后用 <code>$&#123;PropertyName&#125;</code> 的方式引用。</p><p>外部文件 <code>DataBase.properties</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>然后配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;DataBase.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span> <span class="comment">&lt;!--引入外部的文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="建立-DAO-层方法和-SQL-语句的映射"><a href="#建立-DAO-层方法和-SQL-语句的映射" class="headerlink" title="建立 DAO 层方法和 SQL 语句的映射"></a>建立 DAO 层方法和 SQL 语句的映射</h3><p>DAO 层的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUserByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">queryUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">queryUserByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建数据库操作接口映射的 XML 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;space.xorex.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;space.xorex.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意上面的 <code>namespace</code> 是下方的 SQL 语句映射的<strong>执行方法</strong>名称所在的定义空间（就是定义这些方法的接口），接口只能写完整的类名，不可以用别名。然后每一条就是执行方法映射的 SQL 语句。</p><p>对于这些映射标签，比如下面的，就一定要注意对应的接口方法名称的 参数 和 返回值，写对应的信息，而对于常见的数据类型，MyBatis 进行了别名映射，可以<strong>不区分大小写</strong>的使用这些别名。然后就是占位符的填充，使用 <code>#&#123;&#125;</code> 里面写数据名，是从 parameterType 中寻找的（但其实这个属性完全可以不写）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByUserName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;space.xorex.pojo.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--这里 string 就是一个规定好的 java.lang.String 的别名--&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from user</span><br><span class="line">    where userName=#&#123;userName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="获取-Mapper-实例"><a href="#获取-Mapper-实例" class="headerlink" title="获取 Mapper 实例"></a>获取 Mapper 实例</h3><p>直接用 MybatisUtils 里面的 getSession() 获取连接，然后调用 SqlSession 的 getMapper() 获取对应 Mapper 接口的实现对象。都用完之后，SqlSession 需要提交 commit() 和关闭 close()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;</span><br><span class="line">    SqlSession session=MybatisUtils.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserMapper mapper=session.getMapper(UserMapper.class);</span><br><span class="line">        mapper.insertUser(<span class="string">&quot;This&quot;</span>, <span class="string">&quot;That&quot;</span>);</span><br><span class="line">        session.commit(); <span class="comment">//修改完数据库需要提交</span></span><br><span class="line">        session.close(); <span class="comment">//使用完连接记得关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>需要说一下的是，这里获取的 Mapper 接口实现类，其实是一个动态代理类，叫作 MapperProxy，这个动态代理类是 Mybatis 根据配置文件自动生成的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MyBatis-概述&quot;&gt;&lt;a href=&quot;#MyBatis-概述&quot; class=&quot;headerlink&quot; title=&quot;MyBatis 概述&quot;&gt;&lt;/a&gt;MyBatis 概述&lt;/h2&gt;&lt;p&gt;Mybatis 是一种持久层的框架，通过建立接口的方法和 XML 注册的 S</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-架构解析</title>
    <link href="https://xorex.space/2021/07/15/39ec926b82d1/"/>
    <id>https://xorex.space/2021/07/15/39ec926b82d1/</id>
    <published>2021-07-15T13:09:31.000Z</published>
    <updated>2021-07-16T07:34:06.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringMVC-工作流程"><a href="#SpringMVC-工作流程" class="headerlink" title="SpringMVC 工作流程"></a>SpringMVC 工作流程</h2><iframe src="https://www.xmind.net/embed/969fGv" width="800px" height="540px" frameborder="0" scrolling="no"></iframe><h2 id="流程图补充说明"><a href="#流程图补充说明" class="headerlink" title="流程图补充说明"></a>流程图补充说明</h2><p>待更新…</p><h2 id="DispatcherServlet-九大组件"><a href="#DispatcherServlet-九大组件" class="headerlink" title="DispatcherServlet 九大组件"></a>DispatcherServlet 九大组件</h2><h3 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h3><p>多媒体解析器，一般用来实现上传下载的功能</p><h3 id="LocaleResolver"><a href="#LocaleResolver" class="headerlink" title="LocaleResolver"></a>LocaleResolver</h3><p>国际化解析器，自动从请求头中的地区和语言信息解析并获取 Locale 对象，并设置到响应内容中，来实现国际化。</p><h3 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h3><p>主题解析器，主题是样式、图片及它们所形成的显示效果的集合。一套主题对应一个 properties文件，里面存放着与当前主题相关的所有资源。</p><h3 id="List-lt-HandlerMapping-gt"><a href="#List-lt-HandlerMapping-gt" class="headerlink" title="List&lt;HandlerMapping&gt;"></a>List&lt;HandlerMapping&gt;</h3><p>请求映射处理的集合，作用是判断请求和对应的处理器之间的映射关系，确保请求能找到对应的处理器。</p><h3 id="List-lt-HandlerAdapter-gt"><a href="#List-lt-HandlerAdapter-gt" class="headerlink" title="List&lt;HandlerAdapter&gt;"></a>List&lt;HandlerAdapter&gt;</h3><p>处理器适配器集合，因为在 SpringMVC 中 Handler 可以是任意形式的，比如 @RequestMapping 的方法，实现 Controller 接口的类，为了将这些 Handler 统一规格给 SpringMVC 使用，就需要能转化这些 Handler 的 Adapter。</p><h3 id="List-lt-HandlerExceptionResolver-gt"><a href="#List-lt-HandlerExceptionResolver-gt" class="headerlink" title="List&lt;HandlerExceptionResolver&gt;"></a>List&lt;HandlerExceptionResolver&gt;</h3><p>异常处理解析器集合，判断是否能处理所抛出来的异常，转化为目标的 ModelAndView，如果不能处理，则会将异常抛给 Tomcat。</p><h3 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h3><p>请求名到视图名翻译器，当我们自己写的 Handler 没有定义 viewName 的时候，就会调用它，将请求的目标截取，作为 viewName，供 ViewResolver 进行解析。</p><h3 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h3><p>重定向参数传递，当我们将 Post 请求进行重定向为 Get 请求的时候（防止重复提交），为了将 Post 数据体现在 Get 请求页面中，用 FlashMapManager 实现重定向参数传递。  </p><h3 id="List-lt-ViewResolver-gt"><a href="#List-lt-ViewResolver-gt" class="headerlink" title="List&lt;ViewResolver&gt;"></a>List&lt;ViewResolver&gt;</h3><p>视图解析器集合，用来通过视图名解析成视图 View 的解析器，从而进行渲染页面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SpringMVC-工作流程&quot;&gt;&lt;a href=&quot;#SpringMVC-工作流程&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC 工作流程&quot;&gt;&lt;/a&gt;SpringMVC 工作流程&lt;/h2&gt;&lt;iframe src=&quot;https://www.</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常阅读</title>
    <link href="https://xorex.space/2021/07/06/cb7f2bf06a64/"/>
    <id>https://xorex.space/2021/07/06/cb7f2bf06a64/</id>
    <published>2021-07-06T03:22:24.000Z</published>
    <updated>2021-07-06T05:51:44.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常信息解读"><a href="#异常信息解读" class="headerlink" title="异常信息解读"></a>异常信息解读</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;level 1 exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fun1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;level 2 exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Test().fun2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: level 2 exception</span><br><span class="line">    at space.xorex.SSM_CRUD.DAO.Test.fun2(Test.java:15)</span><br><span class="line">    at space.xorex.SSM_CRUD.DAO.Test.main(Test.java:21)</span><br><span class="line">Caused by: java.io.IOException: level 1 exception</span><br><span class="line">    at space.xorex.SSM_CRUD.DAO.Test.fun1(Test.java:8)</span><br><span class="line">    at space.xorex.SSM_CRUD.DAO.Test.fun2(Test.java:13)</span><br><span class="line">    ... 1 more</span><br></pre></td></tr></table></figure><p>对于整个异常栈来说，最下面的 Caused by 就是异常最初被抛出来的类型和原因。然后依次向上的 Caused by 就是上一个异常被捕获之后，catch 语句里面抛出来的其他的异常。每一个 Caused by 都是捕获下一层抛出的异常，经过分析后被抛出的新异常。而没有 Caused by 修饰的最顶层异常，就是没有被任何程序捕捉处理的异常。</p><p>异常栈里每一层都有这些信息组成：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Caused by] 异常名 自定义异常出现原因 </span><br><span class="line">异常在被捕获之前经过的第一个方法</span><br><span class="line">异常在被捕获之前经过的第二个方法</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>需要注意的是，异常中会有 <code>XXX more</code> 的语句，这是指没有被打印出来的方法对异常的抛接过程，是不重要的信息，可以不用管。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;异常信息解读&quot;&gt;&lt;a href=&quot;#异常信息解读&quot; class=&quot;headerlink&quot; title=&quot;异常信息解读&quot;&gt;&lt;/a&gt;异常信息解读&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="异常" scheme="https://xorex.space/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>SSM_CRUD 搭建架构</title>
    <link href="https://xorex.space/2021/07/03/76ad6f7344ef/"/>
    <id>https://xorex.space/2021/07/03/76ad6f7344ef/</id>
    <published>2021-07-03T02:26:45.000Z</published>
    <updated>2021-07-29T06:33:33.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><iframe src="https://www.xmind.net/embed/wKvQSz" width="800px" height="540px" frameborder="0" scrolling="no"></iframe><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>一个基于 SSM 整合的 CRUD，并使用 Mybatis-Generator 自动生成数据库代码。bootstrap 和 jQuery 作为前端框架。</p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><ol><li><p>三大框架的核心包 Spring-Core Spring-WebMVC Mybatis</p></li><li><p>用于自动分页的 Pagehelper ，生成代码的 Mybatis-Generator-Core</p></li><li><p>数据库原生的 Mysql-Connector-Java 数据库连接池 c3p0</p></li><li><p>实现 jsp 中 JSTL 标签语言的 JSTL 库</p></li></ol><h2 id="Spring-和-SpringMVC-配置"><a href="#Spring-和-SpringMVC-配置" class="headerlink" title="Spring 和 SpringMVC 配置"></a>Spring 和 SpringMVC 配置</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>在 Web.xml 中配置一启动服务器就创建 Spring 容器的 Listener 和指定 Spring 配置文件位置的 context-param 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>contextLoaderListener 监听启动后执行内容：</p><blockquote><p>Initialize Spring’s web application context for the given servlet context, using the application context provided at construction time, or creating a new one according to the “contextClass” and “contextConfigLocation” context-params.</p></blockquote><h3 id="配置杂七杂八"><a href="#配置杂七杂八" class="headerlink" title="配置杂七杂八"></a>配置杂七杂八</h3><ol><li>Filter 字符编码 CharacterEncodingFilter 设置初始参数，encoding=utf-8，forceRequestEncoding 和 forceResponseEncoding 都设置为 true 。拦截路径为全路径 <code>/*</code> 。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--字符编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Filter REST 风格，HiddenHttpMethodFilter，拦截路径为全路径 <code>/*</code> 。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--REST风格实现过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="关于两个容器分工问题"><a href="#关于两个容器分工问题" class="headerlink" title="关于两个容器分工问题"></a>关于两个容器分工问题</h3><p>Spring 的容器是一个父容器，SpringMVC 的容器是子容器。<strong>子容器可以访问父容器</strong>，<strong>而父容器不能访问子容器</strong>。</p><p>所以这就决定了用于自动注入的对象必须放入 Spring 容器中（放入到 SpringMVC 容器 Spring 访问不到），而又因为 Spring 并没有区分四大组件： @Controller @Service @Component @Repository 的功能，所以虽然 SpringMVC 可以访问到 Spring 的容器，但是却无法找到 Controller 的实例。</p><p>总之就是 Controller 必须放到 SpringMVC 的容器中，其他的组件可以随意放置两个容器中。</p><p>但是一般来说我们会把其他的组件都放到 Spring 的容器中，因为 Spring 可以轻易和其他框架进行整合。</p><h2 id="整合-Mybatis"><a href="#整合-Mybatis" class="headerlink" title="整合 Mybatis"></a>整合 Mybatis</h2><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>整合 Mybatis 的核心就是将 SqlSessionFactory 以及 Mybatis 自动生成的 DAO 接口实现实例交给 IOC 容器进行管理。Mybatis 有和 Spring 的整合包： Mybatis-Spring.jar。</p><p>Spring 中配置实现了 BeanFactory 接口的 SqlSessionFactoryBean 实例加入 IOC 容器中，负责获取 SqlSessionFactory。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--实现了BeanFactory，调用getBean() 返回 sqlSessionFactory 用于获取连接--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:Mybatis-config.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;pooledDataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:space.xorex.SSM_CRUD.DAO*&quot;</span> /&gt;</span> <span class="comment">&lt;!--将Mapper和映射文件放到同级目录下面--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DAO-接口实现"><a href="#DAO-接口实现" class="headerlink" title="DAO 接口实现"></a>DAO 接口实现</h3><p>MapperScannerConfigurer 扫描 DAO 中规定的接口，并加入 IOC 容器中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将Mybatis生成的DAO接口实现类加入 IOC 容器中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperScannerConfigurer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描所有 DAO 接口的实现--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;space.xorex.SSM_CRUD.DAO&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h3><h4 id="基于命名空间"><a href="#基于命名空间" class="headerlink" title="基于命名空间"></a>基于命名空间</h4><p>这里使用 Spring 的 tx 包和 aop 功能实现事务的控制，</p><p>首先使用 tx 注解进行配置确定对于被标注使用 AOP 功能的方法中，哪些是需要进行事务管理的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 选择控制事务的方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 搞个 get 优化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后就是配置 AOP 的切入点表达式，声明哪些包下面的哪些类的哪些方法需要进行 AOP 管理，其实就是 DAO 包下面所有接口的所有方法，同时将事务管理配置的 AOP 配置进行一个整合。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPoint&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(public * space.xorex.SSM_CRUD..*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务增强，也就是将 AOP 和 TX 所选择的方法进行一个整合--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPoint&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h4><p>直接无脑标注 @Trancational 即可。</p><p>然后在 Spring 中进行扫描，真的是方便极了！！！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h2><p>决定自己写 SQL，来锻炼对 MyBatis 和 SQL 语句的熟练程度！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本流程&quot;&gt;&lt;a href=&quot;#基本流程&quot; class=&quot;headerlink&quot; title=&quot;基本流程&quot;&gt;&lt;/a&gt;基本流程&lt;/h2&gt;&lt;iframe src=&quot;https://www.xmind.net/embed/wKvQSz&quot; width=&quot;800px&quot; he</summary>
      
    
    
    
    <category term="项目记录" scheme="https://xorex.space/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="SSM" scheme="https://xorex.space/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-07-拦截器/异常处理</title>
    <link href="https://xorex.space/2021/06/16/0372728335e9/"/>
    <id>https://xorex.space/2021/06/16/0372728335e9/</id>
    <published>2021-06-16T13:14:45.000Z</published>
    <updated>2021-07-15T15:45:01.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>加强版本的 Filter，MVC 中的接口为 HandlerInterceptor 处理拦截器，一共有三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">()</span></span>; <span class="comment">//执行请求处理方法之前执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">()</span></span>; <span class="comment">//执行请求处理方法之后执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">()</span></span>; <span class="comment">//视图渲染完成之后执行</span></span><br></pre></td></tr></table></figure><p>自己实现 HandlerInterceptor 之后，需要在 SpringMVC 中配置拦截器的信息才可以使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/Interceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.SpringMVC_01.Interceptor.MyInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多重拦截器"><a href="#多重拦截器" class="headerlink" title="多重拦截器"></a>多重拦截器</h3><p>当有多个拦截器匹配到某个方法的时候，整体拦截器的工作顺序是按照在 SpringMVC 配置的顺序执行的。</p><p>而对于 preHandle() 和 postHandle() 则是按照一层一层套娃执行的，拦截器执行顺序靠前的在最外层，拦截器配置 01 在 02 前面：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">01 preHandle() is invoked!</span><br><span class="line">02 preHandle() is invoked!</span><br><span class="line">testInterceptor() is invoked!</span><br><span class="line">02 postHandle() is invoked!</span><br><span class="line">01 postHandle() is invoked!</span><br><span class="line">02 afterCompletion() is invoked!</span><br><span class="line">01 afterCompletion() is invoked!</span><br></pre></td></tr></table></figure><p>而 afterCompletion() 作为最后执行的擦屁股方法，和 try-catch-finally 里面的 finally 代码块类似，等待前面的套娃执行完毕，再单独按照顺序套娃从内到外执行最后的处理。可以记忆为，prehandle 顺序执行，postHandle() 和 afterCompletion() 逆序执行。</p><h3 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h3><p>对于配置了一个拦截器的执行方法被 preHandler() return 了 false，那么后面的请求处理方法、postHandle() 和 afterCompletion() 都停止执行。</p><p>如果多个拦截器的执行方法被某一个 preHandler() return 了 false，那么这个 preHandler() 所在的截断了的拦截器的<strong>后面拦截器的</strong>所有方法（preHandler()、postHandle() 和 afterCompletion()）都不会再执行。而<strong>前面所有放行了的拦截器</strong>的 afterCompletion() 方法作为拦截器的结尾处理还是会被执行的！</p><p>举个例子，01、02 和 03 三个拦截器，02 的 preHandler() return false，进行截断，那么方法的执行结果为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01 preHandle() is invoked!</span><br><span class="line">02 preHandle() is invoked!</span><br><span class="line">01 afterCompletion() is invoked! //因为 01 的 preHandle() 放行了，所以需要执行收尾方法、</span><br></pre></td></tr></table></figure><p>所以如果一旦被拦截，整个请求就不会被处理了，也不会有有效的响应。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p>SpringMVC 的异常处理是通过 <code>List&lt;HandlerExceptionResolver&gt;</code> 来解决的，如果在调用请求处理方法的时候抛出了异常，那么会依次枚举实现了 HandlerExceptionResolver 接口的类，如果抛出来的这些异常能被这些异常处理解析器解决，那么就交给他们，如果不能解决，那么会直接抛出异常到 Tomcat，最终在页面上显示一个丑丑的 500 服务器内部错误的页面。</p><p>在 SpringMVC 中，有三个默认加载的 HandlerExceptionResolver 实现：ExceptionHandlerExceptionResolver、ResponseStatusExceptionResolver 和 DefaultHandlerExceptionResolver。</p><ol><li>ExceptionHandlerExceptionResolver</li></ol><p>第一个处理类可以处理的异常为所有使用了注解 <code>@ExcpetionHandler(Class)</code> 中参数输入的异常。也是我们用来自定义异常处理的方式，详情看下面介绍。</p><ol start="2"><li>ResponseStatusExceptionResolver</li></ol><p>用于设置当我们出现了自定义异常的时候，应该返回什么状态码和错误信息，而使用核心就是注解 <code>@ResponseStatus</code>：</p><p>我们首先自定义一个异常，并使用注解 <code>@ResponseStatus</code> 来定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus(value = HttpStatus.NOT_ACCEPTABLE,reason = &quot;拒绝访问！&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanNotAccsessException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/exception&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CanNotAccsessException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后当我们抛出我们自定义的异常 CanNotAccessException 无法被 ExceptionHandlerExceptionResolver 里面的异常处理方法处理之后，就会交给 ResponseStatusExceptionResolver ，发现异常拥有注解 <code>@ResponseStatus</code> 之后，会读取注解信息，然后返回一个自定义的错误页面， 406 拒绝访问。</p><p><img src="https://xorex.space/image/306.jpg" alt="306.jpg"></p><ol start="3"><li>DefaulthandlerExceptionResolver</li></ol><p>是用来处理和 SpringMVC 相关的异常，我们可以忽略它，比如这些异常：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">handleNoSuchRequestHandlingMethod</span><br><span class="line">handleHttpRequestMethodNotSupported</span><br><span class="line">handleHttpMediaTypeNotSupported</span><br><span class="line">handleMissingServletRequestParameter</span><br><span class="line">handleServletRequestBindingException</span><br><span class="line">handleTypeMismatch</span><br><span class="line">handleHttpMessageNotReadable</span><br><span class="line">handleHttpMessageNotWritable</span><br><span class="line">handleMethodArgumentNotValidException</span><br><span class="line">handleMissingServletRequestParameter</span><br><span class="line">handleMissingServletRequestPartException</span><br><span class="line">handleBindException</span><br></pre></td></tr></table></figure><h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><p>只需要在某个方法前面加上 <code>@ExceptionHandler</code> 这个注解，就可以让这个方法变为异常处理器。处理的异常取决于注解里面的参数填写的异常种类。可以自己在异常处理器中返回 ModelAndView 来自定义视图，不写也没关系。获取异常实例通过异常处理器的参数处获取，参数类型一定要匹配被 catch 异常的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/exception&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CanNotAccsessException(); <span class="comment">//抛出异常供下面处理器处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler(CanNotAccsessException.class)</span> <span class="comment">//指明这个方法是处理 CanNotAccessException 异常的处理器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">mathException</span><span class="params">(Exception exception)</span> </span>&#123; <span class="comment">//获取被抛出来的实例</span></span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;Hello/error&quot;</span>);</span><br><span class="line">    mv.addObject(<span class="string">&quot;error&quot;</span>, exception);</span><br><span class="line">    <span class="keyword">return</span> mv; <span class="comment">//当然如果不想跳转页面的话也可以不返回 ModelAndView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h3><p>可以将多个 ExceptionHandler 异常处理器方法集中到一个类中去，然后使用注解 <code>@ControllerAdvice</code> 告诉 SpringMVC 这个类里面的东西都是控制层的建议方法。这个属于全局的异常处理器，而上面在 <code>@Controller</code> 里面定义的处理器则是局部处理器，只能处理本类里面抛出的异常。</p><p>当 <code>@Controller</code> 和 <code>@ControllerAdvice</code> 都拥有能处理异常的方法的时候，本类处理器优先级高于全局处理器。而对于两个在同一个地方的异常处理器，则是优先选择匹配精度最高的那一个。</p><h3 id="SimpleMappingExceptionHandlerResovler"><a href="#SimpleMappingExceptionHandlerResovler" class="headerlink" title="SimpleMappingExceptionHandlerResovler"></a>SimpleMappingExceptionHandlerResovler</h3><p>这个异常处理解析器是通过配置的方式来对某些异常进行指定页面处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span> <span class="comment">&lt;!--设置捕捉异常之后前往的页面--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.NullPointerException&quot;</span>&gt;</span>Hello/error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> <span class="comment">&lt;!-- 设置将异常实例放入请求域的 Key --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;exception&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;拦截器&quot;&gt;&lt;a href=&quot;#拦截器&quot; class=&quot;headerlink&quot; title=&quot;拦截器&quot;&gt;&lt;/a&gt;拦截器&lt;/h2&gt;&lt;h3 id=&quot;基础使用&quot;&gt;&lt;a href=&quot;#基础使用&quot; class=&quot;headerlink&quot; title=&quot;基础使用&quot;&gt;&lt;/a&gt;基础使</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-06-AJAX支持/文件上传</title>
    <link href="https://xorex.space/2021/06/15/de23fc4f3bd1/"/>
    <id>https://xorex.space/2021/06/15/de23fc4f3bd1/</id>
    <published>2021-06-15T14:46:38.000Z</published>
    <updated>2021-06-18T05:36:50.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="响应-AJAX-的-Json-类型"><a href="#响应-AJAX-的-Json-类型" class="headerlink" title="响应 AJAX 的 Json 类型"></a>响应 AJAX 的 Json 类型</h2><h3 id="设置响应内容"><a href="#设置响应内容" class="headerlink" title="设置响应内容"></a>设置响应内容</h3><p>只需要在请求处理方法前面加上 <code>@ResponseBody</code> 表示将方法返回值添加到响应体中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ajax&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAjax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;AJAX!&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会在响应体里面看到一串 JS 代码了。</p><h3 id="Json-处理"><a href="#Json-处理" class="headerlink" title="Json 处理"></a>Json 处理</h3><p>SpringMVC 支持自动将对象转化为 Json 格式的字符串，需要导入三个包：<code>jackson-core</code>，<code>jackson-annotations</code>，<code>jackson-databind</code>。然后对于将自定义对象返回的方法，会自动转化为 Json 字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ajax/get&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title">returnAjax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> employeeDao.getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法返回的值是一个 <code>Collection&lt;Employee&gt;</code> 对象，但是标注了 <code>@ResponseBody</code> 之后，这个对象会经过转换器转化为 Json 格式（因为我们引入的 <code>jackson-core</code> 里面的 Json 转化器被添加到了转化器列表里面）</p><p>还可以使用一些其他关于 Json 的注解来控制转化的过程，如 <code>@JsonIgnore</code> 用于标注被省略转化的字段，使用 <code>JsonFormat(pattern=&quot;XXXX&quot;)</code> 来规定向 Date Time 这样的字段的转化格式等等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"><span class="meta">@JsonIgnore</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure><p>然后响应体里面返回的转化 Json 就是按照我们的要求的了，没有 password，时间按照 yyyy-MM-dd 格式： <code>&#123;&quot;userName&quot;:&quot;Tempest&quot;,&quot;email&quot;:&quot;cloudloverain@Foxmail.com&quot;,&quot;date&quot;:&quot;2021-06-16&quot;&#125;</code></p><h3 id="获取请求内容"><a href="#获取请求内容" class="headerlink" title="获取请求内容"></a>获取请求内容</h3><p>只需要在请求处理方法的参数前面加上 <code>@RequestBody</code> 表示将请求中的请求体放入参数中，比如我们设置一个 userName 的 Post 提交，按照 SpringMVC 参数填充规则，是无法填充到 <code>String body</code> 上面的，没有设置注解，参数名也不匹配，但是我们标注 <code>@RequestBody</code> 之后，整个 Post 的请求体会作为一个 String 字符串填充到 body 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;ajax/post&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAjax</span><span class="params">(<span class="meta">@RequestBody</span> String body)</span> </span>&#123;</span><br><span class="line">    System.out.println(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果，为 Post 所有内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tempest=Xorex&amp;Submit=Submit</span><br></pre></td></tr></table></figure><hr><p>而 <code>@RequestBody</code> 也支持自动转化格式的功能，比如将请求体中的 Json 数据转化为对象：</p><p>请求体：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;userName&quot;</span>:<span class="string">&quot;Tempest&quot;</span>,<span class="attr">&quot;password&quot;</span>:<span class="string">&quot;Xorex&quot;</span>,<span class="attr">&quot;email&quot;</span>:<span class="string">&quot;cloudloverain@Foxmail.com&quot;</span>,<span class="attr">&quot;date&quot;</span>:<span class="string">&quot;2021-06-16&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>接收请求的处理方法，将 Json 自动转化为 User 对象并传入参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;ajax/post&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAjax</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Body-数据转化原理"><a href="#Body-数据转化原理" class="headerlink" title="Body 数据转化原理"></a>Body 数据转化原理</h2><h3 id="HttpMessageConverter-lt-T-gt"><a href="#HttpMessageConverter-lt-T-gt" class="headerlink" title="HttpMessageConverter&lt;T&gt;"></a>HttpMessageConverter&lt;T&gt;</h3><p>对于请求 Body 和响应 Body 和 Java 对象的数据转化流程如下：</p><p><img src="https://xorex.space/image/302.jpg" alt="302.jpg"></p><p>对于任意一个涉及到 Body 数据转换的请求或者响应，SpringMVC 会遍历自己拥有的所有 <code>HttpMessageConverter&lt;T&gt;</code>，去一一确认是否能处理此转换，默认实现了的转换器如下：</p><p><img src="https://xorex.space/image/303.jpg" alt="303.jpg"></p><h3 id="使用-HttpEntity-lt-T-gt-代替-RequestBody"><a href="#使用-HttpEntity-lt-T-gt-代替-RequestBody" class="headerlink" title="使用 HttpEntity&lt;T&gt; 代替 @RequestBody"></a>使用 HttpEntity&lt;T&gt; 代替 @RequestBody</h3><p>将这个类作为请求参数，泛型 T 写为 RequestBody 需要被转化的类型（会依次寻找能处理 T 的Converter）。然后调用 <code>getBody()</code> 、<code>getHeaders()</code> 等来获取更加完整的请求信息（请求头）;</p><h3 id="使用-ResponseEntity-lt-T-gt-代替-ResponseBody"><a href="#使用-ResponseEntity-lt-T-gt-代替-ResponseBody" class="headerlink" title="使用 ResponseEntity&lt;T&gt; 代替 @ResponseBody"></a>使用 ResponseEntity&lt;T&gt; 代替 @ResponseBody</h3><p>只需要将这个这个类作为请求处理方法的返回类型，泛型 T 为向响应体写入的数据类型，也就是 Object-&gt;String 转化的 Object 类型。</p><p>比如下面设置请求头（setcookie），设置请求体（User 用 Json 格式转 String），设置响应码（200 OK）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/Entity&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">getEntity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;cloudloverain@foxmail.com&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    MultiValueMap&lt;String,String&gt; headers=<span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    headers.set(HttpHeaders.SET_COOKIE, <span class="string">&quot;Temespt=Xorex&quot;</span>);</span><br><span class="line">    HttpStatus status=HttpStatus.OK;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(user, headers, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>对于多媒体文件的处理在 SpringMVC 中使用的是 MultipartResolver 这个组件来解决的，当我们需要处理文件上传的时候，就需要给这个组件设置一个实现类去处理。</p><p>从 MultipartResolver 的创建过程可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.multipartResolver = (MultipartResolver)context.getBean(<span class="string">&quot;multipartResolver&quot;</span>, MultipartResolver.class);</span><br></pre></td></tr></table></figure><p>我们只需要在 ioc 容器中注册一个 id 为 multipartResolver 的 Bean 即可，这里使用的是：<code>CommonsMultipartResolver</code> 这个实现类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;1024*1024*100&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置最大上传文件大小为100MB--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="单文件接收"><a href="#单文件接收" class="headerlink" title="单文件接收"></a>单文件接收</h3><p>然后使用 <code>MultipartFile</code> 类作为参数来接受请求发过来的文件，需要注意的是 <code>getName()</code> 指的是文件上传的 key 值 file，而 <code>getOriginalFileName()</code> 指的是文件本身的名字 <code>XXX.jpg</code>，使用它自带的 <code>transferTo(File)</code> 方法将上传来的文件转移到指定的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEntity</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    file.transferTo(<span class="keyword">new</span> File(<span class="string">&quot;D:\\Pictures\\Saved Pictures\\Tempest.jpg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>注意需要将文件上传的表单里面添加一项 <code>enctype=&quot;multipart/form-data&quot;</code>，其不对字符编码。当使用有文件上传控件的表单时，该值是必需的。</p><p>如果不加编码规则，那么上传的就是 <code>file=fileName</code>，并不包含多媒体数据（上传文件本身），惨痛结果：</p><p><img src="https://xorex.space/image/304.jpg" alt="304.jpg"></p><p>加了之后（没找到请求体 QAQ）：</p><p><img src="https://xorex.space/image/305.jpg" alt="305.jpg"></p><h3 id="多文件接收"><a href="#多文件接收" class="headerlink" title="多文件接收"></a>多文件接收</h3><p>这里的多文件指的是一个 name 对应多个文件的情景，这个时候只需要使用 <code>MultipartFile[]</code> 来接收文件即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEntity</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file,<span class="meta">@RequestParam(&quot;files&quot;)</span> MultipartFile[] files)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(file.getOriginalFilename());</span><br><span class="line">    <span class="keyword">for</span> (MultipartFile multipartFile : files) &#123;</span><br><span class="line">        System.out.println(multipartFile.getOriginalFilename());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;响应-AJAX-的-Json-类型&quot;&gt;&lt;a href=&quot;#响应-AJAX-的-Json-类型&quot; class=&quot;headerlink&quot; title=&quot;响应 AJAX 的 Json 类型&quot;&gt;&lt;/a&gt;响应 AJAX 的 Json 类型&lt;/h2&gt;&lt;h3 id=&quot;设置响应内</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-05-数据绑定/转化/校验</title>
    <link href="https://xorex.space/2021/06/11/4130a9517564/"/>
    <id>https://xorex.space/2021/06/11/4130a9517564/</id>
    <published>2021-06-11T06:16:40.000Z</published>
    <updated>2021-07-27T13:04:23.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="静动态资源处理管理"><a href="#静动态资源处理管理" class="headerlink" title="静动态资源处理管理"></a>静动态资源处理管理</h2><p>我们最初在配置 <code>DispatcherServlet</code> 来作为处理方法映射的时候，因为静态资源无法找到对应的处理方法，所以无法访问，针对这个问题，使用 <code>&lt;mvc:default-servlet-handler/&gt;</code> 之后，SpringMVC 将在容器中中定义一个 SimpleUrlhandlerMapping，它的作用就是将请求交给 WEB 应用服务器默认的 Tomcat 处理，这样静态资源的访问就得到了解决。</p><p>但是我们标注了 <code>&lt;mvc:default-servlet-handler/&gt;</code> 之后，新加入的 SimpleUrlHandlerMapping 会覆盖我们原本用来处理方法映射的 DefaultAnnotationHandlerMapping。这样处理动态资源访问的映射关系就没有了，因此动态资源无法访问。</p><p>解决方法就是：使用 <code>&lt;mvc:annotation-driven/&gt;</code>，添加这个设置之后，就会多出来一个优先级最高的 RequestMappingHandlerMapping，专门处理动态资源访问和处理方法之间的映射关系。只有这个 Mapping 无法处理的资源（静态资源），才会交给后面的 SimpleUrlHandlerMapping 处理（交给 Tomcat）。</p><h2 id="lt-mcv-anntation-driven-gt"><a href="#lt-mcv-anntation-driven-gt" class="headerlink" title="&lt;mcv:anntation-driven&gt;"></a>&lt;mcv:anntation-driven&gt;</h2><p>这个配置的字面意思就是 MVC 注解驱动。那么这个配置有什么用呢？</p><ul><li><p><code>&lt;mvc:annotation-driven/&gt;</code> 会自动注册： RequestMappingHandlerMapping 、 RequestMappingHandlerAdapter 与 ExceptionHandlerExceptionResolver 三个 bean。</p></li><li><p>还将提供以下支持：</p></li></ul><ol><li>支持使用 ConversionService 实例对表单参数进行类型转换</li><li>支持使用 @NumberFormat、@DateTimeFormat 注解完成数据类型的格式化</li><li>支持使用 @Valid 注解对 JavaBean 实例进行 JSR 303 验证</li><li>支持使用 @RequestBody 和 @ResponseBody 注解实现 AJAX</li></ol><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>数据绑定指的是从请求的数据到处理方法中的参数这个过程，在 SpringMVC 中，数据绑定的流程大概如下：</p><ol><li>SpringMVC 主框架将 ServletRequest 对象及目标方法的入参实例传递给 WebDataBinderFactory 实例，以创建 DataBinder 实例对象</li><li>DataBinder 调用装配在 SpringMVC 上下文中的 ConversionService 组件进行数据类型转换、数据格式化工作。将 Servlet 中的请求信息填充到入参对象中</li><li>调用 Validator 组件对已经绑定了请求消息的入参对象进行数据合法性校验，并最终生成数据绑定结果 BindingData 对象</li><li>SpringMVC 抽取 BindingResult 中的入参对象和校验错误对象，将它们赋给处理方法的参数。</li></ol><p>也就是过程如下：</p><p><img src="https://xorex.space/image/301.jpg" alt="301.jpg"></p><p>在 SpringMVC 的 ConversionService 数据转化服务中，有大量的转化器 Converter 可以作为用于将 String 类型的数据转化为 Java 常间的类型，但是对于我们自己设置的类型，如果需要转化则需要我们手动实现 Converter 接口。</p><p>比如我们想要将 String 类型转化为 User 类型；<code>&quot;Xorex-Tempest-Xorex@Tempest.com&quot;</code> -&gt; <code>User&#123;username=Xorex,password=Tempest,email=Xorex@Tempest.com&#125;</code> 需要这样实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToUserConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] datas=s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(datas[<span class="number">0</span>],datas[<span class="number">1</span>],datas[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了 Converter 之后，需要将我们自己实现的 Converter 放入执行转化服务的 ConversionService 中。而麻烦之处在于 ConversionService 是由 ConversionServiceFactoryBean 生成的，那么我们最终其实是将 Converter 交给 FormattingConversionServiceFactoryBean，由这个工厂来生成含有自定义 Converter 的 ConversionService。</p><p>所以我们需要 SpringMVC 配置文件中，声明：将自定义 Converter 交给 FormattingConversionServiceFactoryBean 并告诉 SpringMVC 用这个含有我们自定义 Converter 的 FactoryBean 来生成 ConversionService:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.SpringMVC_01.Conversion.StringToUserConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数据格式化"><a href="#数据格式化" class="headerlink" title="数据格式化"></a>数据格式化</h2><p>前面介绍了通过实现 Converter 来实现自定义数据和请求数据的绑定。下面来介绍一下请求数据的格式化，也就是将请求发过来的数据转化为格式化的数据，比如将 <code>2021-06-01</code> 转化为 Date 对象。将 <code>$12,123,234.3242</code> 转化为 Double 对象等等。</p><p>这里使用的 Format 注解：<code>@DateTimeFormat</code> 和 <code>@NumberFormat</code> 等，只需要标注到需要接收格式化的参数或者字段前面，被 SpringMVC 自动填充的时候，就会根据 ConversionService 里面定义的 Format 规则进行格式化了。</p><p>而我们上面配置的 FormattingConversionServiceFactoryBean 这个工厂生成的 ConversionService 就包含一系列 Format 类型的 Class 用于数据格式化，而不同的注解也有不同的格式化方法，需要在注解参数 <code>pattern</code> 中填写。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/date&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDate</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date)</span> </span>&#123;</span><br><span class="line">    System.out.println(date);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/number&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNumber</span><span class="params">(<span class="meta">@NumberFormat(pattern = &quot;$#,###.##&quot;)</span> Double money)</span> </span>&#123;</span><br><span class="line">    System.out.println(money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间用 <code>yyyy-MM-dd</code> 规定传入的时间字符串格式，浮点数用 <code>$#,###.##</code> 规定传入的金钱的格式，对于 JavaBean 里面的数据使用格式化，则直接在 Bean 里面的字段加上注解即可，SpringMVC 进行参数填充的时候会读取上面的注解的。</p><h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><h3 id="JSR-303"><a href="#JSR-303" class="headerlink" title="JSR-303"></a>JSR-303</h3><p>对于数据在服务端进行的数据校验工作，我们自己写真的是太麻烦了，于是在 JAVA6 里面推出了一种规范：JSR-303，JSR 是 Java Specification Requests 的缩写，意思是 Java 规范提案，又叫做 Bean Validation。JSR 303 是 Java 为 bean 数据合法性校验提供的标准框架。</p><h3 id="使用-hibernate-实现的-JSR-303"><a href="#使用-hibernate-实现的-JSR-303" class="headerlink" title="使用 hibernate 实现的 JSR-303"></a>使用 hibernate 实现的 JSR-303</h3><p>需要导入一下包：一个是 hibernate.validator 的 hibernate-validator 和 fasterxml 的 classmate 共两个包。其中前者提供 JSR-303 接口的实现，后者为前者的依赖包（会自动加入另外一个依赖 jboss-logging）。</p><p>然后就可以使用很多 hibernate 自己实现的接口了，挺多挺好用的。</p><h3 id="JavaBean-校验"><a href="#JavaBean-校验" class="headerlink" title="JavaBean 校验"></a>JavaBean 校验</h3><p>然后我们就可以利用 JSR-303 定义的注解，去去进行数据校验了，这里的所有注解可以查看文档。对于自定义 Bean ，在 Bean 的声明处向内部标校验注解，然后参数处标注 <code>@Valid</code> 表示需要要校验这个 Bean,并<strong>紧接着</strong>被校验的 Bean 声明一个参数：<code>BindingResult result</code> 或者 <code>Errors errors</code>，这个  两个类可以记录校验的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@Past</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/valid&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testValid</span><span class="params">(<span class="meta">@Valid</span> User user,BindingResult result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.hasErrors()) &#123; <span class="comment">//从校验结果中查看是否校验成功</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义错误消息"><a href="#自定义错误消息" class="headerlink" title="自定义错误消息"></a>自定义错误消息</h3><p>最简单的方法就是在任何一个校验的注解里面添加 message 属性，里面填写需要自定错误的消息。这样我们取出来的 Message 就是我们自己设置的错误了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull(message = &quot;老哥不能空啊！&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="meta">@NotNull(message = &quot;老哥不能空啊！&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@Email(message = &quot;老哥你邮箱不对啊！&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure><p>但是如果需要实现国际化的话，具体的流程和 JstlView 实现国际化的流程都是一样的，唯一的不同是对国际化文件的 Key 进行一定的规则限制。</p><p>因为我们在回显错误信息的时候，比如使用 <code>&lt;form:errors path=&quot;email&quot;&gt;</code> 来现实隐含模型中属性为 email 的校验错误的时候，他会根据一定的规则从国际化文档中寻找对应的 Key：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Email.user.email=XXXX //在隐含模型的 user 对象的 email 字段使用 @Email 校验时，匹配此国际化错误信息</span><br><span class="line">Email.email=XXXX //在隐含模型任意对象中的 email 字段使用 @Email 校验时，匹配此国际化错误信息</span><br><span class="line">Email.java.lang.String=XXXX //字段为 String 的值使用 @Email 校验时，匹配此国际化错误信息</span><br><span class="line">Email=XXXX //任意字段使用 @Email 校验时，匹配此国际化错误信息</span><br></pre></td></tr></table></figure><p>当有多个国际化 Key 得到匹配的时候，同样按照精确度决定匹配优先级。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;静动态资源处理管理&quot;&gt;&lt;a href=&quot;#静动态资源处理管理&quot; class=&quot;headerlink&quot; title=&quot;静动态资源处理管理&quot;&gt;&lt;/a&gt;静动态资源处理管理&lt;/h2&gt;&lt;p&gt;我们最初在配置 &lt;code&gt;DispatcherServlet&lt;/code&gt; 来作为</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
</feed>
