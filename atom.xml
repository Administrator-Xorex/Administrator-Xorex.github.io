<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xorex</title>
  
  <subtitle>要成为世界上最幸福的人啊！</subtitle>
  <link href="https://xorex.space/atom.xml" rel="self"/>
  
  <link href="https://xorex.space/"/>
  <updated>2022-10-19T13:50:03.348Z</updated>
  <id>https://xorex.space/</id>
  
  <author>
    <name>Xorex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL-13-高阶知识概览</title>
    <link href="https://xorex.space/2022/10/15/8d0abca8d502/"/>
    <id>https://xorex.space/2022/10/15/8d0abca8d502/</id>
    <published>2022-10-15T14:31:43.000Z</published>
    <updated>2022-10-19T13:50:03.348Z</updated>
    
    <content type="html"><![CDATA[<p>就是简单的概括一下，有一个基本的概念！</p><h2 id="数据库程序逻辑架构"><a href="#数据库程序逻辑架构" class="headerlink" title="数据库程序逻辑架构"></a>数据库程序逻辑架构</h2><p><img src="https://xorex.space/image/369.jpg" alt="369.jpg"></p><p>三层结构：最上面的 Connectors 是客户端，比如 JDBC 之类的，不是 DBMS 的范围。最下面的是存在硬盘中的数据，也不是 DBMS 的范围。</p><h3 id="第一层：连接层"><a href="#第一层：连接层" class="headerlink" title="第一层：连接层"></a>第一层：连接层</h3><p>系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</p><p>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p><p>所以连接管理的职责是负责认证、管理连接、获取权限信息。</p><h3 id="第二层：服务层"><a href="#第二层：服务层" class="headerlink" title="第二层：服务层"></a>第二层：服务层</h3><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p><ul><li><p>SQL Interface: SQL接口。接收用户的SQL命令，并且返回用户需要查询的结果。</p></li><li><p>Parser: 解析器。在解析器中对 SQL 语句进行语法分析、语义分析。对SQl查询进行语法上的优化，进行查询重写。</p></li><li><p>Optimizer: 查询优化器。确定 SQL 语句的执行路径，生成一个执行计划。这个执行计划表明应该 使用哪些索引 进行查询（全表检索还是使用索引检索），表之间的连 接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将 查询结果返回给用户。使用“ 选取（WHERE 留下的数据）-投影（被 SELECT 的列）-连接（前两者结合） ”策略。</p></li><li><p>Caches &amp; Buffers： 查询缓存组件。缓存一条SELECT语句的执行结果，MySQL 8.0 已经删除。</p></li></ul><h3 id="第三层：引擎层"><a href="#第三层：引擎层" class="headerlink" title="第三层：引擎层"></a>第三层：引擎层</h3><p>负责了 MySQL 中数据在硬盘中的存储和提取，对物理服务器级别维护的底层数据执行操作。支持很多引擎实现，默认的是 InnoDB。</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h2 id="数据库设计规范"><a href="#数据库设计规范" class="headerlink" title="数据库设计规范"></a>数据库设计规范</h2><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h2 id="多版本并发"><a href="#多版本并发" class="headerlink" title="多版本并发"></a>多版本并发</h2><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h2 id="备份恢复"><a href="#备份恢复" class="headerlink" title="备份恢复"></a>备份恢复</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;就是简单的概括一下，有一个基本的概念！&lt;/p&gt;
&lt;h2 id=&quot;数据库程序逻辑架构&quot;&gt;&lt;a href=&quot;#数据库程序逻辑架构&quot; class=&quot;headerlink&quot; title=&quot;数据库程序逻辑架构&quot;&gt;&lt;/a&gt;数据库程序逻辑架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-12-索引和性能</title>
    <link href="https://xorex.space/2022/10/11/a380b847aa86/"/>
    <id>https://xorex.space/2022/10/11/a380b847aa86/</id>
    <published>2022-10-11T13:55:22.000Z</published>
    <updated>2022-10-19T10:20:28.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>索引要解决的问题就是在使用 <code>WHERE</code> 语句定位数据的时候，可以通过数据结构进行优化。因此我们在定位数据的时候，尽量使用主键（或者其他有索引的列）进行查询。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h3><p>索引要解决的问题就是在使用 <code>WHERE</code> 语句定位数据的时候，可以通过二叉搜索树来优化。但是由于计算机硬件的特点，（Cache 内存 硬盘）需要尽量多命中 Cache，少硬盘 IO，和需要查询稳定性的需求。所以并没有使用传统的平衡二叉树，红黑树等，而是使用了 B+ 树。</p><p><img src="https://xorex.space/370.jpg" alt="370.jpg"></p><p>B+ 树的特点就是层级比较少（在树分支处较次数比较少，一般不超过 4 层，二叉搜索树是 logN 层），在查询的时候大大减少了对硬盘 IO 的次数。定位到目标数据所在的硬盘块的时候，就可以一起读入内存中处理，邻近性原理等也大大方便了 Cache 的命中。</p><p>而目标数据的那一块在读入内存之后，由于维护了单调的顺序，所以可以采用二分法进行具体定位，所以复杂度是和二叉搜索树一样的，但是大大减少了硬盘 IO 的次数。</p><h3 id="物理实现分类"><a href="#物理实现分类" class="headerlink" title="物理实现分类"></a>物理实现分类</h3><p>按照物理实现，索引可以分为：聚簇索引（一级索引） 和 非聚簇索引（辅助索引、二级索引）。</p><p>聚簇索引：这个索引在 InnoDB 里面默认就是主键，在建立 B+ 树索引的时候，时会将所有的数据放在聚簇索引中的（也只会在聚簇索引中），这样一旦索引找到，就可以直接获取数据。一个数据库只有一个聚簇索引。<strong>建议使用自增的 ID 列为主键，并不可改变，性能更好</strong>。</p><p>非聚簇索引：索引里面没有数据，只有一个连接。数据库中可以有多个非聚簇索引，也就是可以根据非主键搜索比较多的列，给他们建一个索引，提高性能。</p><p>使用聚簇索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。</p><h2 id="索引设置"><a href="#索引设置" class="headerlink" title="索引设置"></a>索引设置</h2><h3 id="隐式-显式创建"><a href="#隐式-显式创建" class="headerlink" title="隐式/显式创建"></a>隐式/显式创建</h3><p>隐式创建：定义主键约束、外键约束或者唯一性约束的时候，会自动添加索引在列上，这个是隐式索引。三者都是 <strong>唯一性索引</strong>。</p><p>显式索引：在定义表的时候在表级约束地方设置。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name(</span><br><span class="line">    XXXX,</span><br><span class="line">    XXXX,</span><br><span class="line">    [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY] [index_name] (col_name [(length)]) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>UNIQUE 、 FULLTEXT 和 SPATIAL 为可选参数，分别表示唯一索引、全文索引和空间索引；</li><li>INDEX 与 KEY 为同义词，两者的作用相同，用来指定创建索引；</li><li>index_name 指定索引的名称，为可选参数，如果不指定，那么 MySQL 默认 col_name 为索引名；</li><li>col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；</li><li>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</li><li>ASC 或 DESC 指定升序或者降序的索引值存储，默认升序。</li></ul><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    pwd <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX,</span><br><span class="line">    INDEX(username) <span class="keyword">DESC</span>, <span class="comment">-- 创建普通索引降序存储</span></span><br><span class="line">    INDEX username_index(username), <span class="comment">-- 创建普通索引，并给索引名</span></span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX(username(<span class="number">10</span>)) <span class="comment">-- 创建唯一性索引，并限制只有前10个字符参与索引</span></span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX username_pwd_index(username,pwd) <span class="comment">-- 创建复合唯一索引，并给索引名   </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="新增索引"><a href="#新增索引" class="headerlink" title="新增索引"></a>新增索引</h3><p>对于 唯一 主键 外键 绑定的索引，是按照约束的方式新增。</p><p>而普通的索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL] [INDEX <span class="operator">|</span> KEY]</span><br><span class="line">[index_name] (col_name[length],...) [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p>就是一个 ALTER TABLE，语法和上面是一样的。</p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名称; <span class="comment">-- 先看看所有的索引名称</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name; <span class="comment">-- 然后删除索引</span></span><br></pre></td></tr></table></figure><h2 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h2><h3 id="建立索引技巧"><a href="#建立索引技巧" class="headerlink" title="建立索引技巧"></a>建立索引技巧</h3><ol><li><p><strong>字段的数值有唯一性的限制适合建立索引</strong>：业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。INSERT 的成本增加忽略不计，但是搜索速度大大增加！</p></li><li><p><strong>频繁作为 WHERE 查询条件的字段适合建立索引</strong>：或者说，尽量以有索引的列作为 WHERE 的查询条件。无论是查询还是修改删除，都会快很多。</p></li><li><p><strong>经常 GROUP BY 和 ORDER BY 的列适合建立索引</strong>：建立索引之后，速度非常快。</p></li><li><p><strong>DISTINCT 字段需要创建索引</strong>：有索引带来的数据有序性之后，去重快很多。</p></li><li><p><strong>JOIN ON 的连接字段创建索引</strong>：建立连接的过程，本质也是一个 WHERE 的过程。</p></li><li><p><strong>列类型占用空间小的可以建立索引</strong>：因为建立索引成本小。</p></li><li><p><strong>字符串比较长的适合截取前缀建立索引</strong>：减少建立索引的空间成本和查找的时间成本，可以使用 <code>count(distinct left(列名, 索引长度))/count(*)</code> 越接近与 1 ，那个索引长度就越合适。</p></li><li><p><strong>数据散列程度高的适合建立索引</strong>：散列程度越高，建立索引之后的优化效果就越好 <code>count(distinct 索引列名) / count(*)</code> 的结果大于 30% 就算比较高效的了，可以考虑添加索引了。</p></li><li><p><strong>在多个字段都要创建索引的情况下，联合索引优于单值索引</strong>：联合索引成本低，散列性好。</p></li></ol><h3 id="不建立索引技巧"><a href="#不建立索引技巧" class="headerlink" title="不建立索引技巧"></a>不建立索引技巧</h3><ol><li><p><strong>不要建立太多的索引</strong>：因为有空间成本和修改数据删除数据的时间成本。最好一张表少于 6 个。</p></li><li><p><strong>数据量小的表最好不要使用索引</strong>：顺序查询花费的时间可能比通过索引的时间还要短，比如小于 1000 行。</p></li><li><p><strong>有大量重复数据的列上不要建立索引</strong>：重复数据简历 B+ 树查找效率很低。</p></li><li><p><strong>避免对经常更新的表创建过多的索引</strong>：索引对更新是有性能影响的。</p></li><li><p><strong>不建议用无序的值作为索引</strong>：例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字 符串等。</p></li><li><p><strong>不要定义夯余或重复的索引</strong>：浪费性能。</p></li></ol><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>希望以后可以把它补充完！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;索引要解决的问题就是在使用 &lt;code&gt;WHERE&lt;/code&gt; 语句定位数据的时候，可以通过数据结构进行优化。因此我们在定位数据的时候，尽</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-11-字符目录权限</title>
    <link href="https://xorex.space/2022/10/10/a188aa520d06/"/>
    <id>https://xorex.space/2022/10/10/a188aa520d06/</id>
    <published>2022-10-10T03:09:03.000Z</published>
    <updated>2022-10-13T14:44:26.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符集的相关"><a href="#字符集的相关" class="headerlink" title="字符集的相关"></a>字符集的相关</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character%&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><code>character_set_server</code>：服务器级别的字符集</li><li><code>character_set_database</code>：当前数据库的字符集</li><li><code>character_set_client</code>：服务器解码请求时使用的字符集</li><li><code>character_set_connection</code>：服务器处理请求时会把请求字符串从 character_set_client 转为 character_set_connection </li><li><code>character_set_results</code>：服务器向客户端返回数据时使用的字符集</li></ul><h3 id="默认编码"><a href="#默认编码" class="headerlink" title="默认编码"></a>默认编码</h3><ul><li>如果<code>创建或修改列</code>时没有显式的指定字符集和比较规则，则该列<code>默认用表的</code>字符集和比较规则</li><li>如果<code>创建表时</code>没有显式的指定字符集和比较规则，则该表<code>默认用数据库的</code>字符集和比较规则</li><li>如果<code>创建数据库时</code>没有显式的指定字符集和比较规则，则该数据库<code>默认用服务器的</code>字符集和比较规则</li></ul><h3 id="字符编码处理过程"><a href="#字符编码处理过程" class="headerlink" title="字符编码处理过程"></a>字符编码处理过程</h3><p><img src="https://xorex.space/image/368.jpg" alt="368.jpg"></p><h2 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>1、数据库名、表名、表的别名、变量名是严格区分大小写的；<br>2、关键字、函数名称在 SQL 中不区分大小写；<br>3、列名（或字段名）与列的别名（或字段别名）在所有的情况下均是忽略大小写的；</p><h3 id="编写规范"><a href="#编写规范" class="headerlink" title="编写规范"></a>编写规范</h3><ol><li>关键字和函数名称全部大写；</li><li>数据库名、表名、表别名、字段名、字段别名等全部小写；</li><li>SQL 语句必须以分号结尾。</li></ol><h2 id="数据库文件"><a href="#数据库文件" class="headerlink" title="数据库文件"></a>数据库文件</h2><p>MySQL数据库文件的存放路径：<code>/var/lib/mysql/</code>，可以用下面的命令查看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;datadir&#x27;</span>;</span><br></pre></td></tr></table></figure><p>里面存放着所有数据库的定义和数据，下面的举例都是用 MySQL 默认的引擎 InnoDB。</p><h3 id="MySQL-5-7"><a href="#MySQL-5-7" class="headerlink" title="MySQL 5.7"></a>MySQL 5.7</h3><p>每一个数据库在 <code>/var/lib/mysql/</code> 下面都有一个自己的文件夹，里面包含：</p><ul><li>数据库的属性文件：<code>db.opt</code> 包含字符集，比较规则。</li><li>数据库表定义：<code>tableName.frm</code> Frame</li><li>数据库表数据：<code>tableName.ibd</code> InnoDB Data</li></ul><h3 id="MySQL-8-0"><a href="#MySQL-8-0" class="headerlink" title="MySQL 8.0"></a>MySQL 8.0</h3><p>不在提供 <code>db.opt</code> 和 <code>tableName.frm</code>，而是集成在 <code>tableName.idb</code> 中。</p><h2 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h2><p>MySQL 自带了四个默认的系统数据库：</p><p>mysql infromation_schema performance_schema sys</p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><blockquote><p>MySQL 系统自带的核心数据库，它存储了 MySQL 的用户账户和权限信息，一些存储过程、事件的定<br>义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</p></blockquote><p>比如 mysql.user 表里面就存着数据库的用户信息，如果修改了这张表，那么就也会该表数据库的用户设置。</p><h3 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h3><p>库保存着MySQL服务器 维护的所有其他数据库的信息 ，比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为 元数据。在系统数据库 information_schema 中提供了一些以 innodb_sys 开头的表，用于表示内部系统表。</p><p>可以从这张表里面看到所有的数据库的架构。</p><h3 id="performance-schema"><a href="#performance-schema" class="headerlink" title="performance_schema"></a>performance_schema</h3><p>这个数据库里主要保存 MySQL 服务器运行过程中的一些状态信息，可以用来 监控 MySQL 服务的各类性能指标 。包括统计最近执行了哪些语句，在执行过程的每个阶段都<br>花费了多长时间，内存的使用情况等信息。</p><h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>MySQL 系统自带的数据库，这个数据库主要是通过 视图 的形式把 information_schema 和 performance_schema 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。目标是把performance_schema 的把复杂度降低，让使用者能更好的阅读这个库里的内容。更快的了解 DB 的运行情况。</p><h2 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h2><h3 id="账号规则"><a href="#账号规则" class="headerlink" title="账号规则"></a>账号规则</h3><ol><li>帐号名称的格式为: ​​‘user_name’@’host_name’​​ 表示用户名和用户登陆来源。</li><li>如果只指定了 user_name, 则等价于 ​​‘user_name’@’％’​​​; 例如, ​​’me’​​​ 等价于 ​​‘me’@’%’​​。</li><li>如果用户名和主机名是合法的标识符, 则可以省略引号。 否则必须用引号引起来。</li></ol><ul><li><p>用户名：如果用户名是非空白值(nonblank value), 客户端连接时使用的用户名必须在字符上与这个值完全一致,如果用户名是一个空白值(空字符串), 则可以和任意用户名匹配。 帐号中用户名为空, 也就是匿名用户。 要在SQL中指定匿名用户, 请使用引号把空串作为用户名引起来, 例如 ​​‘’@’localhost’​​。</p></li><li><p>主机名： 可以是域名(host name) 或者是 IP 地址(支持IPv4/IPv6)。 ​​’localhost’​​ 表示本机。 ​​’127.0.0.1’​​ 表示本机的IPv4回环地址。 ​​’::1’​​ 则表示本机的IPv6回环地址。%​​ 和 ​​_​​ 通配符可以模糊匹配主机名和IP地址。 匹配规则和SQL标准中的 ​ ​​LIKE​​​ 语句一致。 例如, 百分号 ​​’%’​​ 与所有主机名匹配, 而 ​​’%.mysql.com’​​ 则与 ​​mysql.com​​ 域中的所有主机匹配。 而 ​​’198.51.100.%’​​ 则与 198.51.100 网段下的所有C类地址匹配。</p></li></ul><hr><p>账号存储在 mysql.user 表下面，表的主键就是 User 和 Host 组成的复合主键，一起标识唯一的账号。登陆的时候就在这个表里面去匹配 User 和 Host 来确定账号密码和赋予的权限。</p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> 用户名 [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>][,用户名 [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>]];</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>“[ ]”表示可选，也就是说，可以指定用户登录时需要密码验证，也可以不指定密码验证，这样用户可以直接登录。不过，不指定密码的方式不安全，不推荐使用。如果指定密码值，这里需要使用 IDENTIFIED BY 指定明文密码值。</li></ul><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;test_user&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="修改用户名和密码"><a href="#修改用户名和密码" class="headerlink" title="修改用户名和密码"></a>修改用户名和密码</h3><p>修改用户名（mysql.user 权限拥有者去做）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE mysql.user <span class="keyword">SET</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;xorex002&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;xorex001&#x27;</span>; <span class="comment">-- 直接修改 mysql.user 即可</span></span><br><span class="line">FLUSH PRIVILEGES; <span class="comment">-- 修改完表数据之后，要告诉数据库系统，让它更新数据</span></span><br></pre></td></tr></table></figure><hr><p>修改密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">USER</span>() IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br><span class="line"><span class="comment">--- USER() 直接获取当前连接用户名 然后修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;USER&#x27;</span>@<span class="string">&#x27;HOST&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br><span class="line"><span class="comment">-- 修改别人的密码</span></span><br></pre></td></tr></table></figure><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="keyword">user</span>[,<span class="keyword">user</span>]…;</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;xorex001&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>要注意权限更迭之后，需要重新登陆之后才可以哦。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PRIVILEGES; <span class="comment">-- 查看有什么权限</span></span><br></pre></td></tr></table></figure><ol><li>CREATE 和 DROP 权限 ，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将 MySQL 数据库中的 DROP 权限授予某用户，用户就可以删除 MySQL 访问权限保存的数据库。 </li><li>SELECT、INSERT、UPDATE 和 DELETE 权限 允许在一个数据库现有的表上实施操作。 </li><li>SELECT 权限只有在它们真正从一个表中检索行时才被用到。 </li><li>INDEX 权限 允许创建或删除索引，INDEX 适用于已有的表。如果具有某个表的 CREATE 权限，就可以在 CREATE TABLE 语句中包括索引定义。 </li><li>ALTER 权限 可以使用 ALTER TABLE 来更改表的结构和重新命名表。 </li><li>CREATE ROUTINE 权限 用来创建保存的程序（函数和程序），ALTER ROUTINE 权限用来更改和删除保存的程序， EXECUTE 权限 用来执行保存的程序。 </li><li>GRANT 权限 允许授权给其他用户，可用于数据库、表和保存的程序。 </li><li>FILE 权限 使用户可以使用 LOAD DATA INFILE 和 SELECT … INTO OUTFILE 语句读或写服务器上的文件，任何被授予 FILE 权限的用户都能读或写 MySQL 服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）。</li></ol><h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;user&#x27;</span>@<span class="string">&#x27;主机地址&#x27;</span> ;</span><br></pre></td></tr></table></figure><h3 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h3><p>授权的时候如果发现没有该用户，则会直接新建一个用户。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n <span class="keyword">ON</span> 数据库名称.表名称 <span class="keyword">TO</span> 用户名@用户地址;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给 xorex 用户在 test 数据库下所有表的四个权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">DELETE</span>,UPDATE <span class="keyword">ON</span> test.<span class="operator">*</span> <span class="keyword">TO</span> xorex<span class="variable">@localhost</span> ; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 给 xorex 授权所有数据库的所有权限（除了 GRANT 权限，需要单独授予一遍）</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> xorex@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="回收权限"><a href="#回收权限" class="headerlink" title="回收权限"></a>回收权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n <span class="keyword">ON</span> 数据库名称.表名称 <span class="keyword">FROM</span> 用户名@用户地址;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 收回全库全表的所有权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> joe@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 收回mysql库下的所有表的插删改查权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,UPDATE,<span class="keyword">DELETE</span> <span class="keyword">ON</span> mysql.<span class="operator">*</span> <span class="keyword">FROM</span> joe<span class="variable">@localhost</span>;</span><br></pre></td></tr></table></figure><h2 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h2><p>这个类似于 Linux 中的 Group，用于归纳相同的权限</p><h3 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ROLE <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>] [,<span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>]]...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 比如</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE <span class="string">&#x27;manager&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="删除角色"><a href="#删除角色" class="headerlink" title="删除角色"></a>删除角色</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> ROLE <span class="string">&#x27;角色名&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限<span class="number">1</span>,权限<span class="number">2</span> <span class="keyword">ON</span> 数据库.表 <span class="keyword">TO</span> <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">--- 比如</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> demo.settlement <span class="keyword">TO</span> <span class="string">&#x27;manager&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="查看权限-1"><a href="#查看权限-1" class="headerlink" title="查看权限"></a>查看权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;角色名&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="回收权限-1"><a href="#回收权限-1" class="headerlink" title="回收权限"></a>回收权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限<span class="number">1</span>,权限<span class="number">2</span> <span class="keyword">ON</span> 数据库.表 <span class="keyword">FROM</span> <span class="string">&#x27;角色名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 比如</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">INSERT</span>, UPDATE, <span class="keyword">DELETE</span> <span class="keyword">ON</span> school.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;school_write&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="用户和角色"><a href="#用户和角色" class="headerlink" title="用户和角色"></a>用户和角色</h2><h3 id="给用户赋予角色"><a href="#给用户赋予角色" class="headerlink" title="给用户赋予角色"></a>给用户赋予角色</h3><p>角色创建并授权后，要赋给用户并处于 <code>激活状态</code> 才能发挥作用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 角色名 <span class="keyword">TO</span> 用户名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 比如</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="string">&#x27;school_read&#x27;</span> <span class="keyword">TO</span> <span class="string">&#x27;xorex&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后激活角色：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">DEFAULT</span> ROLE <span class="keyword">ALL</span> <span class="keyword">TO</span> <span class="string">&#x27;xorex&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="撤销用户角色"><a href="#撤销用户角色" class="headerlink" title="撤销用户角色"></a>撤销用户角色</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 角色名 <span class="keyword">FROM</span> 用户名;</span><br></pre></td></tr></table></figure><h3 id="设置强制默认角色"><a href="#设置强制默认角色" class="headerlink" title="设置强制默认角色"></a>设置强制默认角色</h3><p>比如给所有账号 role1 角色，所有只能在 localhost 登陆的账号 role2 角色，所有只能在 server.xorex.space 下登陆的账号 role3 角色。</p><p>启动前：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]mandatory_roles<span class="operator">=</span><span class="string">&#x27;role1,role2@localhost,role3@%.server.xorex.space&#x27;</span></span><br></pre></td></tr></table></figure><p>启动后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 系统重启后仍然有效</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST mandatory_roles <span class="operator">=</span> <span class="string">&#x27;role1,role2@localhost,role3@%.server.xorex.space&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 系统重启后失效</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> mandatory_roles <span class="operator">=</span> <span class="string">&#x27;role1,role2@localhost,role3@%.server.xorex.space&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符集的相关&quot;&gt;&lt;a href=&quot;#字符集的相关&quot; class=&quot;headerlink&quot; title=&quot;字符集的相关&quot;&gt;&lt;/a&gt;字符集的相关&lt;/h2&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-10-环境变量-配置文件-触发器</title>
    <link href="https://xorex.space/2022/10/07/6833e237c661/"/>
    <id>https://xorex.space/2022/10/07/6833e237c661/</id>
    <published>2022-10-07T01:29:18.000Z</published>
    <updated>2022-10-11T08:34:49.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>是 MySQL 服务器有的变量，用于支持服务的运转。</p><h3 id="变量级别"><a href="#变量级别" class="headerlink" title="变量级别"></a>变量级别</h3><p>全局系统变量：MySQL 应用级别，所有的会话均可访问。</p><p>会话系统变量：单次的会话级别，不同会话之间隔离。</p><p>在 MySQL 中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集（可以作为全局变量设置为默认值，也可以变成会话变量只设置当前会话的字符集）；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。</p><h3 id="查看变量"><a href="#查看变量" class="headerlink" title="查看变量"></a>查看变量</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查看满足条件的部分系统变量。</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#查看满足条件的部分会话变量</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>作为 MySQL 编码规范，MySQL 中的系统变量以<code>两个“@”</code>开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查看指定的系统变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.变量名;</span><br><span class="line"></span><br><span class="line">#查看指定的会话变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@session</span>.变量名;</span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">SELECT</span> @@变量名;</span><br></pre></td></tr></table></figure><h3 id="修改变量"><a href="#修改变量" class="headerlink" title="修改变量"></a>修改变量</h3><p>有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者 MySQL 服务实例的属性、特征。具体方法：</p><p>方式1：修改 MySQL <code>配置文件</code>，继而修改 MySQL 系统变量的值（该方法需要重启 MySQL 服务）</p><p>方式2：在 MySQL 服务运行期间，使用“set”命令重新设置系统变量的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#为某个系统变量赋值</span><br><span class="line">#方式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@global</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line">#方式<span class="number">2</span>：</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> 变量名<span class="operator">=</span>变量值;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#为某个会话变量赋值</span><br><span class="line">#方式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line">#方式<span class="number">2</span>：</span><br><span class="line"><span class="keyword">SET</span> SESSION 变量名<span class="operator">=</span>变量值;</span><br></pre></td></tr></table></figure><h2 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h2><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以 <code>一个“@”</code> 开头。根据作用范围不同，又分为 <code>会话用户变量</code> 和 <code>局部变量</code>。</p><ul><li><p>会话用户变量：作用域和会话变量一样，只对 <code>当前连接</code> 会话有效。</p></li><li><p>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在 <code>存储过程和函数</code> 中使用。</p></li></ul><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>会话变量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @用户变量 <span class="operator">=</span> 值;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> 表达式 <span class="keyword">INTO</span> @用户变量  [<span class="keyword">FROM</span> 等子句];</span><br></pre></td></tr></table></figure><p>局部变量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 变量名<span class="number">1</span> 变量数据类型 [<span class="keyword">DEFAULT</span> 变量默认值];</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> 字段名或表达式 <span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表;</span><br></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                    作用域定义位置                    语法</span><br><span class="line">会话用户变量        当前会话                会话的任何地方          加@符号，不用指定类型</span><br><span class="line">局部变量        定义它的 <span class="keyword">BEGIN</span> <span class="keyword">END</span> 中     <span class="keyword">BEGIN</span> <span class="keyword">END</span> 的第一句话     一般不用加@,需要指定类型</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>win 下面的配置文件是 ini，而 Linux/MacOS 是 cnf。启动 MySQL 的时候，会读取对应的配置信息。</p><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><p>与在命令行中指定启动选项不同的是，配置文件中的启动选项被划分为若干个组，每个组有一个组名，用中括号 [] 扩起来，像这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">(具体的启动选项...)</span><br><span class="line"></span><br><span class="line">[mysqladmin]</span><br><span class="line">(具体的启动选项...)</span><br></pre></td></tr></table></figure><p>像这个配置文件里就定义了许多个组，组名分别是server 、mysqld、mysqld_safe、 client、mysql、mysqladmin。每个组下边可以定义若干个启动选项，使用 <code>key=value</code> 的形式。</p><ul><li>如果两个一模一样的配置冲突，则按照最后的那个生效。</li></ul><h3 id="选项组"><a href="#选项组" class="headerlink" title="选项组"></a>选项组</h3><p>配置文件中不同的选项组是给不同的启动命令使用的。不过有两个选项组比较特别:</p><ul><li>[server] 组下边的启动选项将作用于所有的服务器程序。</li><li>[client] 组下边的启动选项将作用于所有的客户端程序。</li></ul><p>下面是启动命令能读取的选项组都有哪些:</p><table><thead><tr><th>启动命令</th><th>类别</th><th>能读取的组</th></tr></thead><tbody><tr><td>mysqld</td><td>启动服务器</td><td>[mysqld]、[server]</td></tr><tr><td>mysqld_safe</td><td>启动服务器</td><td>[mysqld]、 [server] 、[mysqld_safe]</td></tr><tr><td>mysql.server</td><td>启动服务器</td><td>[mysqld]、[server]、[mysql.server]</td></tr><tr><td>mysql</td><td>启动客户端</td><td>[mysql]、[client]</td></tr><tr><td>mysqladmin</td><td>启动客户端</td><td>[mysqladmin]、[client]</td></tr><tr><td>mysqldump</td><td>启动客户端</td><td>[mysqldump] 、[client]</td></tr></tbody></table><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是由 <code>事件来触发</code> 某个操作，这些事件包括 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code> 事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会 <code>自动</code> 激发触发器执行相应的操作。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名称</span><br><span class="line">&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="comment">-- 这句话是固定的，要判断行数据处理的话在执行语句块里进行</span></span><br><span class="line">触发器执行的语句块;</span><br></pre></td></tr></table></figure><ul><li><p><code>表名</code>：表示触发器监控的对象。</p></li><li><p><code>BEFORE|AFTER</code>：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</p></li><li><p><code>INSERT|UPDATE|DELETE</code>：表示触发的事件。</p><ul><li>INSERT 表示插入记录时触发；</li><li>UPDATE 表示更新记录时触发；</li><li>DELETE 表示删除记录时触发。</li></ul></li><li><p><code>触发器执行的语句块</code>：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。</p></li></ul><hr><p>比如，用触发器更新日志:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> after_insert</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> test_trigger</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_trigger_log (t_log)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;after_insert&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。</p><p>方式1：查看当前数据库的所有触发器的定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TRIGGERS\G</span><br></pre></td></tr></table></figure><p>方式2：查看当前数据库中某个触发器的定义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名</span><br></pre></td></tr></table></figure><p>方式3：从系统库 information_schema 的 TRIGGERS 表中查询 “salary_check_trigger” 触发器的信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>触发器也是数据库对象，删除触发器也用 DROP 语句，语法格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> 触发器名称;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;系统变量&quot;&gt;&lt;a href=&quot;#系统变量&quot; class=&quot;headerlink&quot; title=&quot;系统变量&quot;&gt;&lt;/a&gt;系统变量&lt;/h2&gt;&lt;p&gt;是 MySQL 服务器有的变量，用于支持服务的运转。&lt;/p&gt;
&lt;h3 id=&quot;变量级别&quot;&gt;&lt;a href=&quot;#变量级别&quot; c</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-09-视图-存储过程-函数</title>
    <link href="https://xorex.space/2022/10/06/6bb0987688db/"/>
    <id>https://xorex.space/2022/10/06/6bb0987688db/</id>
    <published>2022-10-06T02:21:30.000Z</published>
    <updated>2022-10-09T14:41:49.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>可以将视图理解为<strong>存储起来的</strong> <strong>SELECT</strong> <strong>语句</strong>。可以很好的控制数据的访问权限，方便调用。</p><p>使用视图就像使用表一样，视图会保存在当前数据库下。直接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 视图名;</span><br></pre></td></tr></table></figure><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>完全版：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] </span><br><span class="line">[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] </span><br><span class="line"><span class="keyword">VIEW</span> 视图名称 [(字段列表)]</span><br><span class="line"><span class="keyword">AS</span> 查询语句</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span><span class="operator">|</span><span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure><p>精简版：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span> 查询语句;</span><br></pre></td></tr></table></figure><hr><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> salvu50</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span>  employee_id <span class="keyword">as</span> ID_NUMBER, last_name <span class="keyword">as</span> `NAME`,salary<span class="operator">*</span><span class="number">12</span> <span class="keyword">as</span> ANN_SALARY <span class="comment">-- 别名会作为视图表里面的列名</span></span><br><span class="line"><span class="keyword">FROM</span>    employees</span><br><span class="line"><span class="keyword">WHERE</span>   department_id <span class="operator">=</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> emp_year_salary (ename,year_salary) <span class="comment">-- 也可以在视图名后面重命名视图表里面的列名</span></span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> ename,salary<span class="operator">*</span><span class="number">12</span><span class="operator">*</span>(<span class="number">1</span><span class="operator">+</span>IFNULL(commission_pct,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">FROM</span> t_employee;</span><br></pre></td></tr></table></figure><h3 id="查看视图属性"><a href="#查看视图属性" class="headerlink" title="查看视图属性"></a>查看视图属性</h3><p>语法1：查看数据库的表对象、视图对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><p>语法2：查看视图的结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> <span class="operator">/</span> <span class="keyword">DESCRIBE</span> 视图名称;</span><br></pre></td></tr></table></figure><p>语法3：查看视图的属性信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;视图名称&#x27;</span>\G</span><br></pre></td></tr></table></figure><p>执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。</p><p>语法4：查看视图的详细定义信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称;</span><br></pre></td></tr></table></figure><h3 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> 被修改视图名</span><br><span class="line"><span class="keyword">AS</span> 查询语句;</span><br></pre></td></tr></table></figure><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>就是把保存的 SELECT 语句给删掉了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IF <span class="keyword">EXISTS</span> 视图名称;</span><br></pre></td></tr></table></figure><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>一段没有返回的应用程序，调用就执行。</p><h3 id="创建语法"><a href="#创建语法" class="headerlink" title="创建语法"></a>创建语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">存储过程体</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h4 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h4><p>1、关于 IN OUT INOUT。</p><ul><li><code>IN</code>：当前参数为输入参数，也就是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类，<code>默认就是 IN</code>，表示输入参数。</li><li><code>OUT</code>：当前参数为输出参数，也就是表示出参；执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</li><li><code>INOUT</code>：当前参数既可以为输入参数，也可以为输出参数。</li></ul><p>2、形参类型可以是 MySQL数据库中的任意类型。</p><p>3、<code>characteristics</code> 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span></span><br><span class="line"><span class="operator">|</span> [<span class="keyword">NOT</span>] <span class="keyword">DETERMINISTIC</span></span><br><span class="line">| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">| SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br><span class="line"><span class="operator">|</span> COMMENT <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>LANGUAGE SQL</code>：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</li><li><code>[NOT] DETERMINISTIC</code>：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</li><li><code>&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</code>：指明子程序使用SQL语句的限制。<ul><li>CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；</li><li>NO SQL表示当前存储过程的子程序中不包含任何SQL语句；</li><li>READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；</li><li>MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。</li><li>默认情况下，系统会指定为CONTAINS SQL。</li></ul></li><li><code>SQL SECURITY &#123; DEFINER | INVOKER &#125;</code>：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。<ul><li><code>DEFINER</code>表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；</li><li><code>INVOKER</code>表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。</li><li>如果没有设置相关的值，则MySQL默认指定值为DEFINER。</li></ul></li><li><code>COMMENT &#39;string&#39;</code>：注释信息，可以用来描述存储过程。</li></ul><p>4、存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END</p><h4 id="过程体"><a href="#过程体" class="headerlink" title="过程体"></a>过程体</h4><ul><li>会用到下面的语句：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">BEGIN</span>…<span class="keyword">END</span> 中间包含了多个语句，每个语句都以（;）号为结束符。</span><br><span class="line"><span class="number">2.</span> <span class="keyword">DECLARE</span>：<span class="keyword">DECLARE</span> 用来声明变量，使用的位置在于 <span class="keyword">BEGIN</span>…<span class="keyword">END</span> 语句中间，而且需要在其他语句使用之前进行变量的声明。</span><br><span class="line"><span class="number">3.</span> <span class="keyword">SET</span>：赋值语句，用于对变量进行赋值。</span><br><span class="line"><span class="number">4.</span> <span class="keyword">SELECT</span> A,B <span class="keyword">INTO</span> C,D：把从数据表中查询的结果存放到变量中，也就是为变量赋值（C<span class="operator">=</span>A D<span class="operator">=</span>B）。</span><br></pre></td></tr></table></figure><ul><li>需要设置新的结束标记：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER 新的结束标记</span><br></pre></td></tr></table></figure><p>因为 MySQL 默认的语句结束符号为分号 <code>;</code>。为了避免与存储过程中 SQL 语句结束符相冲突，需要使用 DELIMITER 改变存储过程的结束符，比如改为 <code>$</code>。</p><hr><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> select_all_data()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><p>使用 <code>CALL</code> 调用，存储过程和数据库绑定，如果执行其他数据库中的存储过程，要加上数据库名前缀 <code>databaseName.procedureName</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> 存储过程名(参数);</span><br></pre></td></tr></table></figure><p>格式：</p><p>1、调用in模式的参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> sp1(<span class="string">&#x27;值&#x27;</span>);</span><br></pre></td></tr></table></figure><p>2、调用out模式的参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span> sp1(<span class="variable">@name</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@name</span>;</span><br></pre></td></tr></table></figure><p>3、调用inout模式的参数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="variable">@name</span><span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">CALL</span> sp1(<span class="variable">@name</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@name</span>;</span><br></pre></td></tr></table></figure><hr><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建存储过程 get_phone(),实现传入女神编号，返回女神姓名和女神电话。</span></span><br><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_phone(<span class="keyword">IN</span> girl_id <span class="type">INT</span>, <span class="keyword">OUT</span> girl_name <span class="type">VARCHAR</span>(<span class="number">15</span>),<span class="keyword">OUT</span> girl_phone <span class="type">VARCHAR</span>(<span class="number">15</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span> `NAME`, phone <span class="keyword">INTO</span> girl_name,girl_phone <span class="keyword">FROM</span> beauty <span class="keyword">WHERE</span> id <span class="operator">=</span> girl_id;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程并查看返回值。</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@girl</span>_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">CALL</span> get_phone(<span class="variable">@girl</span>_id,<span class="variable">@girl</span>_name,<span class="variable">@girl</span>_phone);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@girl</span>_name,<span class="variable">@girl</span>_phone;</span><br></pre></td></tr></table></figure><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><p>可以在 SELECT 语句中使用，会有固定的一个返回值。</p><h3 id="创建语法-1"><a href="#创建语法-1" class="headerlink" title="创建语法"></a>创建语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名(参数名 参数类型,...) </span><br><span class="line"><span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">函数体   #函数体中肯定有 <span class="keyword">RETURN</span> 语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用</span></span><br><span class="line"><span class="keyword">SELECT</span> 函数名(参数...)</span><br></pre></td></tr></table></figure><p>说明：</p><p>1、参数列表：FUNCTION 中总是默认为 IN 参数。</p><p>2、RETURNS type 语句表示函数返回数据的类型。RETURNS 子句只能对 FUNCTION 做指定，对函数而言这是<code>强制</code>的。它用来指定函数的返回类型，而且函数体必须包含一个<code>RETURN value</code>语句。</p><p>3、characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。</p><p>4、函数体也可以用 BEGIN…END 来表示 SQL 代码的开始和结束。如果函数体只有一条语句，也可以省略 BEGIN…END。</p><p>注意：</p><p>若在创建存储函数中报错“<code>you might want to use the less safe log_bin_trust_function_creators variable</code>”，有两种处理方法：</p><ul><li><p>方式1：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}”</p></li><li><p>方式2：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><hr><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> `add_num`(n <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line">    <span class="comment">-- 不加就会报错</span></span><br><span class="line"><span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">CONTAINS</span> <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">       <span class="keyword">DECLARE</span> i <span class="type">INT</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> SUM <span class="type">INT</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">SET</span> i <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">SET</span> SUM <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       WHILE i <span class="operator">&lt;=</span> n DO</span><br><span class="line">              <span class="keyword">SET</span> SUM <span class="operator">=</span> SUM <span class="operator">+</span> i;</span><br><span class="line">              <span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span><span class="number">1</span>;</span><br><span class="line">       <span class="keyword">END</span> WHILE;</span><br><span class="line">       <span class="keyword">RETURN</span> SUM;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--调用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> add_num();</span><br></pre></td></tr></table></figure><h2 id="关于存储-过程和函数"><a href="#关于存储-过程和函数" class="headerlink" title="关于存储 过程和函数"></a>关于存储 过程和函数</h2><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th></th><th>关键字</th><th>调用语法</th><th>返回值</th><th>应用场景</th></tr></thead><tbody><tr><td>存储过程</td><td>PROCEDURE</td><td>CALL 存储过程()</td><td>理解为有0个或多个</td><td>一般用于更新，可以执行强大功能</td></tr><tr><td>存储函数</td><td>FUNCTION</td><td>SELECT 函数()</td><td>只能是一个</td><td>一般用于查询结果为一个值并返回时</td></tr></tbody></table><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE &#123;PROCEDURE | FUNCTION&#125; 存储过程名或函数名</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW &#123;PROCEDURE | FUNCTION&#125; STATUS LIKE &#x27;pattern&#x27;</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER &#123;PROCEDURE | FUNCTION&#125; 存储过程或函数的名 [characteristic ...]</span><br></pre></td></tr></table></figure><p>其中，characteristic 指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">| SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br><span class="line"><span class="operator">|</span> COMMENT <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><code>CONTAINS SQL</code>，表示子程序包含SQL语句，但不包含读或写数据的语句。</li><li><code>NO SQL</code>，表示子程序中不包含SQL语句。</li><li><code>READS SQL DATA</code>，表示子程序中包含读数据的语句。</li><li><code>MODIFIES SQL DATA</code>，表示子程序中包含写数据的语句。</li><li><code>SQL SECURITY &#123; DEFINER | INVOKER &#125;</code>，指明谁有权限来执行。<ul><li><code>DEFINER</code>，表示只有定义者自己才能够执行。</li><li><code>INVOKER</code>，表示调用者可以执行。</li></ul></li><li><code>COMMENT &#39;string&#39;</code>，表示注释信息。</li></ul><blockquote><p>修改存储过程使用 ALTER PROCEDURE 语句，修改存储函数使用 ALTER FUNCTION 语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的。</p></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除存储过程和函数，可以使用 DROP 语句，其语法结构如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP &#123;PROCEDURE | FUNCTION&#125; [IF EXISTS] 存储过程或函数的名。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;视图&quot;&gt;&lt;a href=&quot;#视图&quot; class=&quot;headerlink&quot; title=&quot;视图&quot;&gt;&lt;/a&gt;视图&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;可以将</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-08-约束</title>
    <link href="https://xorex.space/2022/09/29/7eb0e56b7fa7/"/>
    <id>https://xorex.space/2022/09/29/7eb0e56b7fa7/</id>
    <published>2022-09-29T06:56:34.000Z</published>
    <updated>2022-10-20T11:16:31.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>一些可能会比较模糊的概念：</p><h3 id="索引概念"><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h3><p>index INDEX</p><ol><li><p>只有是独一无二的列才可以作为索引，当列为 UNIQUE 时，默认添加此列为 INDEX。</p></li><li><p>索引是与表相关的一个可选结构：一个表中可以存在索引，也可以不存在索引，不做硬性要求。</p></li><li><p>用以提高 SQL 语句执行的性能：快速定位我们需要查找的表的内容（物理位置），提高 sql 语句的执行性能。</p></li><li><p>减少磁盘 I/O 取数据从磁盘上取到数据缓冲区中，再交给用户。磁盘 IO 非常不利于表的查找速度（效率的提高）。</p></li></ol><h3 id="约束概念"><a href="#约束概念" class="headerlink" title="约束概念"></a>约束概念</h3><p>constraint CONSTRAINT</p><p>对数据的一种限制，用于实现数据库的数据完整性。</p><ul><li><code>独一无二</code>：例如，同一个表中，不能存在两条完全相同无法区分的记录</li><li><code>符合范围</code>：例如：年龄范围0-120，性别范围“男/女”</li><li><code>引用存在</code>：例如：员工所在部门，在部门表中要能找到这个部门</li><li><code>自定义完整性</code>：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。</li></ul><p>可以在<strong>创建表时规定约束（通过 CREATE TABLE 语句）</strong>，或者在<strong>表创建之后通过 ALTER TABLE 语句规定约束</strong>。</p><h3 id="键概念"><a href="#键概念" class="headerlink" title="键概念"></a>键概念</h3><p>key KEY</p><p><strong>键</strong>（Key）就是用来识别实体（一行数据描述的物体，比如一个人的信息，一个岗位的信息）的。换句话说，键可以用来确定表中具体的一行记录。</p><p><strong>主键</strong> 表示可以用它自己这一列来识别实体的 列。比如 UID 列，身份证列等等。主键同时拥有 索引 和 约束 的性质。primary key 既是索引（会作为优化的 index），也是约束（unique 和 not null）。换言之，被设置为 index，添加了 unique，not null 约束的列，就等同于 primary key。</p><h2 id="约束概览"><a href="#约束概览" class="headerlink" title="约束概览"></a>约束概览</h2><p>一共有下面的七种约束：</p><ul><li><strong>NOT NULL</strong>：非空约束，规定某个字段不能为空。</li><li><strong>UNIQUE</strong>：唯一约束，规定某个字段在整个表中是唯一的。</li><li><strong>PRIMARY KEY</strong>：主键(非空且唯一)约束。</li><li><strong>AUTO_INCREMENT</strong>：自增约束。</li><li><strong>FOREIGN KEY</strong>：外键约束。</li><li><strong>CHECK</strong>：自定义检查约束。</li><li><strong>DEFAULT</strong>：默认值约束。</li></ul><h3 id="约束分类"><a href="#约束分类" class="headerlink" title="约束分类"></a>约束分类</h3><ul><li><p><strong>根据约束数据列的限制，</strong>约束可分为：</p><ul><li><strong>单列约束</strong>：每个约束只约束一列。</li><li><strong>多列约束</strong>：每个约束可约束多列数据。</li></ul></li><li><p><strong>根据约束的作用范围</strong>，约束可分为：</p><ul><li><strong>列级约束</strong>：只能作用在一个列上，跟在列的定义后面。</li><li><strong>表级约束</strong>：可以作用在多个列上，不与列一起，而是单独定义。</li></ul></li></ul><hr><ol><li><p>不支持多列约束有：NOT NULL（很好理解），AUTO_INCREMENT（只允许一列支持自增），DEFAULT（只能给一列设置默认）</p></li><li><p>支持多列约束有：UNIQUE（多列组合的独一无二），PRIMARY KEY（多列组合结果的主键），FOREIGN KEY（连接的外键是复合的话，约束的本表列也是多列），CHECK（自定义约束的判断表达式可以包含多个列的值）</p></li><li><p>所有约束都可以作为单列约束，只作用于一列。除了 <code>FOREIGN KEY</code> 以外（因为语法比较特殊，要指定外部表和列），都可以写在单列约束处，作用于此列。</p></li><li><p>所有支持多列约束的，都可以写在表级约束的地方。此时既可以作用多列，也可以作用一列。</p></li></ol><h3 id="约束操作命令"><a href="#约束操作命令" class="headerlink" title="约束操作命令"></a>约束操作命令</h3><p>设置约束关键词为 XXXX（NOT NULL、UNIQUE、PRIMARY KEY、CHECK 等等）</p><h4 id="创建时添加约束"><a href="#创建时添加约束" class="headerlink" title="创建时添加约束"></a>创建时添加约束</h4><p>定义表，建议作用单列的写在列约束处，作用多列的写在表约束处：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 除了 FOREIGN KEY 收到语法影响，其他都可以</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称(</span><br><span class="line">    字段名  数据类型,</span><br><span class="line">    字段名  数据类型 XXXX <span class="comment">-- 列级约束</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 支持多列约束的可以：UNIQUE PRIMARY FOREIGN CHECK</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名称(</span><br><span class="line">    字段名  数据类型,</span><br><span class="line">    字段名  数据类型,</span><br><span class="line">    [<span class="keyword">CONSTRAINT</span> 约束名] XXXX(列名<span class="number">1</span>, 列名<span class="number">2</span>)</span><br><span class="line">    <span class="comment">-- 在表级约束可以选择给约束起名字。</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="后期新增约束"><a href="#后期新增约束" class="headerlink" title="后期新增约束"></a>后期新增约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 等价于列级约束，除了 FOREIGN 以外都可以</span></span><br><span class="line"><span class="comment">-- NOT NULL UNIQUE PRIMARY AUTO CHECK DEFAULT</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 MODIFY 字段名 数据类型 XXXX;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价于表级约束</span></span><br><span class="line"><span class="comment">-- 所有的多列约束都可以：UNIQUE PRIMARY FROEIGN CHECK</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> 约束名] XXXX(列名<span class="number">1</span>, 列名<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h4 id="后期删除约束"><a href="#后期删除约束" class="headerlink" title="后期删除约束"></a>后期删除约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只有三个只支持单列约束的可以通过去掉列后面的 约束 来删除约束。</span></span><br><span class="line"><span class="comment">-- 如果有多个下面的单列约束，那么记得写上要保留的约束</span></span><br><span class="line"><span class="comment">-- NOT NULL DEFAULT AUTO_INCREMENT</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 MODIFY 字段名 数据类型; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只能用于 UNIQUE</span></span><br><span class="line"><span class="comment">-- UNIQUE 作用的列会自动变为表的索引，所以删掉索引就等于去掉 UNIQUE</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 <span class="keyword">DROP</span> INDEX 约束名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 作用于 PRIMARY（主键约束只有一个，不需要写约束名） CHECK FOREIGN</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 <span class="keyword">DROP</span> XXXX 约束名;</span><br></pre></td></tr></table></figure><p>对于删除需要约束名的，可以先查一查约束，再删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="非空约束-NOT-NULL"><a href="#非空约束-NOT-NULL" class="headerlink" title="非空约束 NOT NULL"></a>非空约束 NOT NULL</h2><ul><li>默认，所有的类型的值都可以是 NULL，包括 INT、FLOAT 等数据类型</li><li>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空</li><li>一个表可以有很多列都分别限定了非空</li><li>空字符串 ‘’ 不等于 NULL，0 也不等于 NULL</li><li>单列约束，写在列定义的后面。</li></ul><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>新增：因为是只支持单列约束，所以只有一种。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test01 MODIFY username <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><hr><p>删除：只支持单列约束，去掉即删除。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test01 MODIFY username <span class="type">VARCHAR</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="唯一性约束-UNIQUE"><a href="#唯一性约束-UNIQUE" class="headerlink" title="唯一性约束 UNIQUE"></a>唯一性约束 UNIQUE</h2><ul><li>同一个表可以有多个唯一约束。</li><li>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</li><li>唯一性约束允许列值为空。</li><li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li><li><strong>MySQL 会给唯一约束的列上默认创建一个唯一索引。</strong></li><li>约束多个列的复合唯一约束，作用为多个列拼起来的唯一。</li></ul><h3 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h3><p>增加：同时支持单列和多列约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test01 MODIFY id <span class="type">INT</span> <span class="keyword">UNIQUE</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test01 <span class="keyword">ADD</span> [CONSTRIANT 约束名] <span class="keyword">UNIQUE</span>(id,username...); </span><br></pre></td></tr></table></figure><hr><p>删除：</p><ul><li>添加唯一性约束的列上也会自动创建唯一索引。</li><li>删除唯一约束只能通过删除唯一索引的方式删除。</li><li>删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。</li><li>如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。</li></ul><p>删之前可以先看看有哪些约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名&#x27;</span>;</span><br></pre></td></tr></table></figure><p>然后再删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 <span class="keyword">DROP</span> INDEX 约束名称;</span><br></pre></td></tr></table></figure><h2 id="主键约束-PRIMARY-KEY"><a href="#主键约束-PRIMARY-KEY" class="headerlink" title="主键约束 PRIMARY KEY"></a>主键约束 PRIMARY KEY</h2><ul><li>主键约束相当于<strong>唯一约束 + 非空约束的组合</strong>，主键约束列不允许重复，也不允许出现空值。</li><li>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</li><li>主键约束对应着表中的一列或者多列（复合主键）</li><li>如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</li><li><strong>MySQL 的主键名总是 PRIMARY</strong>，就算自己命名了主键约束名也没用。</li><li>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的<strong>主键索引</strong>（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。</li><li>需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</li></ul><h3 id="设置-2"><a href="#设置-2" class="headerlink" title="设置"></a>设置</h3><p>增加：同时支持单列和多列约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test01 MODIFY id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test01 <span class="keyword">ADD</span> [CONSTRIANT 约束名] <span class="keyword">PRIMARY</span> KEY(id,username...); </span><br></pre></td></tr></table></figure><hr><p>删除：不需要指定主键名，因为一个表只有一个主键，删除主键约束后，UNIQUE 和 INDEX 被去掉，<strong>非空约束还存在</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY; <span class="comment">-- 删除主键</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 MODIFY 列名 类型; <span class="comment">-- 删除非空约束</span></span><br></pre></td></tr></table></figure><h2 id="自增列-AUTO-INCREMENT"><a href="#自增列-AUTO-INCREMENT" class="headerlink" title="自增列 AUTO_INCREMENT"></a>自增列 AUTO_INCREMENT</h2><ul><li>一个表最多只能有一个自增长列</li><li>当需要产生唯一标识符或顺序值时，可设置自增长</li><li>自增长列约束的列必须是键列（主键列 primary key，唯一键列 unique）</li><li>自增约束的列的数据类型必须是整数类型</li><li>如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</li></ul><h3 id="设置-3"><a href="#设置-3" class="headerlink" title="设置"></a>设置</h3><p>增加：同时支持单列约束（只有一个增长列！）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test01 MODIFY id <span class="type">INT</span> AUTO_INCREMENT;</span><br></pre></td></tr></table></figure><p>删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test91 MODIFY id <span class="type">int</span>; </span><br><span class="line"><span class="comment">--去掉 auto_increment 相当于删除</span></span><br></pre></td></tr></table></figure><h2 id="外键约束-FOREIGN-KEY"><a href="#外键约束-FOREIGN-KEY" class="headerlink" title="外键约束 FOREIGN KEY"></a>外键约束 FOREIGN KEY</h2><p>用来限定某个表的某个字段的引用完整性。</p><p>比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分</p><hr><p>主表（父表）：被引用的表，被参考的表</p><p>从表（子表）：引用别人的表，参考别人的表</p><p>例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。</p><p>例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。</p><hr><p>（1）从表的外键列，必须引用/参考主表的主键或唯一约束的列。因为被依赖/被参考的值必须是唯一的</p><p>（2）在创建外键约束时，如果不给外键约束命名，<strong>默认名不是列名，而是自动产生一个外键名</strong>（例如 student_ibfk_1;），也可以指定外键约束名。</p><p>（3）创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表</p><p>（4）删表时，先删从表（或先删除外键约束），再删除主表</p><p>（5）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据</p><p>（6）在“从表”中指定外键约束，并且一个表可以建立多个外键约束</p><p>（7）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t create table’database.tablename’(errno: 150)”。例如：都是表示部门编号，都是int类型。</p><p>（8）<strong>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引</strong>。但是索引名是外键的约束名。（所以除了通过主键定位数据，外键定位数据效率也很高）</p><p>（9）删除外键约束后，必须<code>手动</code>删除对应的索引</p><h3 id="设置-4"><a href="#设置-4" class="headerlink" title="设置"></a>设置</h3><p>新建表时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 主表名称(</span><br><span class="line">    字段<span class="number">1</span>  数据类型  <span class="keyword">primary</span> key,</span><br><span class="line">    字段<span class="number">2</span>  数据类型</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 从表名称(</span><br><span class="line">    字段<span class="number">1</span>  数据类型  <span class="keyword">primary</span> key,</span><br><span class="line">    字段<span class="number">2</span>  数据类型,</span><br><span class="line">    [<span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>外键约束名称<span class="operator">&gt;</span>] <span class="keyword">FOREIGN</span> KEY（从表的某个字段) <span class="keyword">references</span> 主表名(被参考字段)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- (从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样</span></span><br><span class="line"><span class="comment">-- (从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- FOREIGN KEY: 在表级指定子表中的列</span></span><br><span class="line"><span class="comment">-- REFERENCES: 标示在父表中的列</span></span><br></pre></td></tr></table></figure><hr><p>新增：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> 约束名] <span class="keyword">FOREIGN</span> KEY (从表的字段) <span class="keyword">REFERENCES</span> 主表名(被引用字段) [<span class="keyword">on</span> update xx][<span class="keyword">on</span> <span class="keyword">delete</span> xx];</span><br></pre></td></tr></table></figure><hr><p>删除：因为外键约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- (1) 第一步先查看约束名和删除外键约束</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名称&#x27;</span>;#查看某个表的约束名</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键约束名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- （2）第二步查看索引名和删除索引。（注意，只能手动删除）</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名称; </span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> INDEX 索引名;</span><br></pre></td></tr></table></figure><h3 id="约束等级"><a href="#约束等级" class="headerlink" title="约束等级"></a>约束等级</h3><ul><li><p><code>Cascade方式</code>：在父表上 update/delete 记录时，同步 update/delete 掉子表的匹配记录 </p></li><li><p><code>Set null方式</code>：在父表上 update/delete 记录时，将子表上匹配记录的列设为 null，但是要注意子表的外键列不能为 not null  </p></li><li><p><code>No action方式</code>：如果子表中有匹配的记录，则不允许对父表对应候选键进行 update/delete 操作  </p></li><li><p><code>Restrict方式</code>：同 no action， 都是立即检查外键约束</p></li><li><p><code>Set default方式</code>（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别</p></li></ul><p>默认是 <code>Restrict</code> 方式，报错就完了。</p><p>可以添加外键的时候，在最后加上 <code>on update 等级名称</code> 和 <code>on delete 等级名称</code> 来自定义约束等级。</p><hr><p>举个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept(</span><br><span class="line">    did <span class="type">int</span> <span class="keyword">primary</span> key,<span class="comment">-- 部门编号</span></span><br><span class="line">    dname <span class="type">varchar</span>(<span class="number">50</span>)<span class="comment">-- 部门名称</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">    eid <span class="type">int</span> <span class="keyword">primary</span> key,    <span class="comment">-- 员工编号</span></span><br><span class="line">    ename <span class="type">varchar</span>(<span class="number">5</span>),       <span class="comment">-- 员工姓名</span></span><br><span class="line">    deptid <span class="type">int</span>,<span class="comment">-- 员工所在的部门</span></span><br><span class="line">    <span class="keyword">foreign</span> key (deptid) <span class="keyword">references</span> dept(did)  <span class="keyword">on</span> update cascade <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="keyword">null</span></span><br><span class="line">    <span class="comment">-- 把修改操作设置为级联修改等级，把删除操作设置为set null等级</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="阿里开发规范"><a href="#阿里开发规范" class="headerlink" title="阿里开发规范"></a>阿里开发规范</h3><p>【<code>强制</code>】不得使用外键与级联，一切外键概念必须在应用层解决。 </p><p>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于<code>单机低并发</code>，不适合<code>分布式</code>、<code>高并发集群</code>；级联更新是强阻塞，存在数据库<code>更新风暴</code>的风险；外键影响数据库的<code>插入速度</code>。</p><h2 id="检查约束-CHECK"><a href="#检查约束-CHECK" class="headerlink" title="检查约束 CHECK"></a>检查约束 CHECK</h2><p>这个是 MySQL8 才支持的新功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 主表名称(</span><br><span class="line">    字段<span class="number">1</span>  数据类型  <span class="keyword">check</span>(EXPRESSION), <span class="comment">-- 列约束，表达式里只能出现此列的字段</span></span><br><span class="line">    字段<span class="number">2</span>  数据类型,</span><br><span class="line">    <span class="keyword">check</span>(EXPRESSION) <span class="comment">-- 表约束，可以有很多列的综合表达式</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>比如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> temp(</span><br><span class="line">id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="type">INT</span> <span class="keyword">CHECK</span>(age <span class="operator">&gt;</span> <span class="number">18</span>), <span class="comment">-- 必须成年</span></span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line"><span class="keyword">CHECK</span>(age <span class="operator">&lt;=</span> <span class="number">30</span>) <span class="comment">-- 不能大于三十岁</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="设置-5"><a href="#设置-5" class="headerlink" title="设置"></a>设置</h3><p>新增：支持两种</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 列名 类型 <span class="keyword">CHECK</span>(表达式);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> 约束名] <span class="keyword">CHECK</span>(表达式);</span><br></pre></td></tr></table></figure><hr><p>删除（删之前查一查约束名）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">CHECK</span> 约束名;</span><br></pre></td></tr></table></figure><h2 id="默认约束-DEFAULT"><a href="#默认约束-DEFAULT" class="headerlink" title="默认约束 DEFAULT"></a>默认约束 DEFAULT</h2><p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">    字段名  数据类型 <span class="keyword">default</span> 默认值 ,</span><br><span class="line">    字段名  数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,  </span><br><span class="line">    字段名  数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">    <span class="keyword">primary</span> key(字段名),</span><br><span class="line">    <span class="keyword">unique</span> key(字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="设置-6"><a href="#设置-6" class="headerlink" title="设置"></a>设置</h3><p>新增：只支持列约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 列名 类型 <span class="keyword">DEFAULT</span> 默认值;</span><br></pre></td></tr></table></figure><hr><p>删除：去掉即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 MODIFY 列名 类型; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;一些可能会比较模糊的概念：&lt;/p&gt;
&lt;h3 id=&quot;索引概念&quot;&gt;&lt;a href=&quot;#索引概念&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-07-数据类型</title>
    <link href="https://xorex.space/2022/09/28/7cad80d6d851/"/>
    <id>https://xorex.space/2022/09/28/7cad80d6d851/</id>
    <published>2022-09-28T13:51:59.000Z</published>
    <updated>2022-09-29T06:31:12.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL中的数据类型"><a href="#MySQL中的数据类型" class="headerlink" title="MySQL中的数据类型"></a>MySQL中的数据类型</h2><table><thead><tr><th>类型</th><th>类型举例</th></tr></thead><tbody><tr><td>整数类型</td><td>TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT</td></tr><tr><td>浮点类型</td><td>FLOAT、DOUBLE</td></tr><tr><td>定点数类型</td><td>DECIMAL</td></tr><tr><td>位类型</td><td>BIT</td></tr><tr><td>日期时间类型</td><td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td></tr><tr><td>文本字符串类型</td><td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td></tr><tr><td>枚举类型</td><td>ENUM</td></tr><tr><td>集合类型</td><td>SET</td></tr><tr><td>二进制字符串类型</td><td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td></tr><tr><td>JSON类型</td><td>JSON对象、JSON数组</td></tr><tr><td>空间数据类型</td><td>单值类型：GEOMETRY、POINT、LINESTRING、POLYGON；<br/>集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td></tr></tbody></table><h2 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h2><p>在定义数据类型时，如果确定是<code>整数</code>，就用<code> INT</code>； 如果是<code>小数</code>，一定用定点数类型 <code>DECIMAL(M,D)</code>； 如果是日期与时间，就用 <code>DATETIME</code>。 </p><p>这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。</p><p>关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：</p><p><strong>阿里巴巴《Java开发手册》之MySQL数据库：</strong></p><ul><li>任何字段如果为非负数，必须是 UNSIGNED</li><li>【<code>强制</code>】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。 <ul><li>说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。</li></ul></li><li>【<code>强制</code>】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。 </li><li>【<code>强制</code>】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</li></ul><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><h3 id="类型介绍"><a href="#类型介绍" class="headerlink" title="类型介绍"></a>类型介绍</h3><p>整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。</p><p>它们的区别如下表所示：</p><table><thead><tr><th><strong>整数类型</strong></th><th><strong>字节</strong></th><th>有符号数取值范围</th><th>无符号数取值范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128~127</td><td>0~255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768~32767</td><td>0~65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608~8388607</td><td>0~16777215</td></tr><tr><td>INT、INTEGER</td><td>4</td><td>-2147483648~2147483647</td><td>0~4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808~9223372036854775807</td><td>0~18446744073709551615</td></tr></tbody></table><h3 id="无符号-unsigned"><a href="#无符号-unsigned" class="headerlink" title="无符号 unsigned"></a>无符号 unsigned</h3><p><code>UNSIGNED</code>: 无符号类型（非负），所有的整数类型都有一个可选的属性 UNSIGNED（无符号属性），无符号整数类型的最小取值为 0。所以，如果需要在 MySQL 数据库中保存非负整数值时，可以将整数类型设置为无符号类型。</p><p>int 类型默认显示宽度为 int(11)，无符号 int 类型默认显示宽度为 int(10)。</p><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>浮点数和定点数类型的特点是可以 <code>处理小数</code>，你可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，比整数大多了。 MySQL 支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。</p><ul><li><p>FLOAT 表示单精度浮点数；</p></li><li><p>DOUBLE 表示双精度浮点数；</p></li><li><p>REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用 “<code>REAL_AS_FLOAT</code>”，那么，MySQL 就认为 REAL 是 FLOAT。如果要启用 “REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> sql_mode <span class="operator">=</span> “REAL_AS_FLOAT”;</span><br></pre></td></tr></table></figure></li></ul><p>不推荐在浮点类型中使用 unsigned。</p><h2 id="定点类型-DECIMAL"><a href="#定点类型-DECIMAL" class="headerlink" title="定点类型 DECIMAL"></a>定点类型 DECIMAL</h2><p>DECIMAL 列的声明语法是 DECIMAL(M,D)。NUMERIC 与 DECIMAL 同义，如果字段类型定义为 NUMERIC，则将自动转成 DECIMAL。</p><p>对于声明语法 DECIMAL(M,D)，自变量的值范围如下：</p><p>M 是最大位数（精度），范围是 1 到 65。可不指定，默认值是 10。</p><p>D 是小数点右边的位数（小数位）。范围是 0 到 30，并且不能大于 M，可不指定，默认值是 0。</p><p>例如字段 salary DECIMAL(5,2)，能够存储具有五位数字和两位小数的任何值，因此可以存储在 salary 列中的值的范围是从 -999.99 到 999.99。</p><p><strong>浮点数 vs 定点数</strong></p><ul><li><p>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）</p></li><li><p>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景）</p></li></ul><h2 id="位类型：BIT"><a href="#位类型：BIT" class="headerlink" title="位类型：BIT"></a>位类型：BIT</h2><p>BIT类型中存储的是二进制值，类似 010110。</p><table><thead><tr><th>二进制字符串类型</th><th>长度</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>BIT(M)</td><td>M</td><td>1 &lt;= M &lt;= 64</td><td>约为(M + 7)/8个字节</td></tr></tbody></table><p>BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64。</p><p>注意：在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内。</p><h2 id="日期与时间类型"><a href="#日期与时间类型" class="headerlink" title="日期与时间类型"></a>日期与时间类型</h2><p>日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的时间标签，从而进行数据查询、统计和处理。 </p><p>MySQL 有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0 版本支持的日期和时间类型主要有：YEAR 类型、TIME 类型、DATE 类型、DATETIME 类型和 TIMESTAMP 类型。</p><ul><li><code>YEAR</code> 类型通常用来表示年</li><li><code>DATE</code> 类型通常用来表示年、月、日</li><li><code>TIME</code> 类型通常用来表示时、分、秒</li><li><code>DATETIME</code> 类型通常用来表示年、月、日、时、分、秒</li><li><code>TIMESTAMP</code> 类型通常用来表示带时区的年、月、日、时、分、秒</li></ul><table><thead><tr><th>类型</th><th>名称</th><th>字节</th><th>日期格式</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>YEAR</td><td>年</td><td>1</td><td>YYYY</td><td>1901</td><td>2155</td></tr><tr><td>TIME</td><td>时间</td><td>3</td><td>HH:MM:SS</td><td>-838:59:59</td><td>838:59:59</td></tr><tr><td>DATE</td><td>日期</td><td>3</td><td>YYYY-MM-DD</td><td>1000-01-01</td><td>9999-12-03</td></tr><tr><td>DATETIME</td><td>日期时间</td><td>8</td><td>YYYY-MM-DD HH:MM:SS</td><td>1000-01-01 00:00:00</td><td>9999-12-31 23:59:59</td></tr><tr><td>TIMESTAMP</td><td>日期时间</td><td>4</td><td>YYYY-MM-DD HH:MM:SS</td><td>1970-01-01 00:00:00 UTC</td><td>2038-01-19 03:14:07UTC</td></tr></tbody></table><p>可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据实际需要灵活选取。</p><p>为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？原因是 MySQL 设计的 TIME 类型，不光表示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。</p><h3 id="TIME-类型"><a href="#TIME-类型" class="headerlink" title="TIME 类型"></a>TIME 类型</h3><p>TIME 类型用来表示时间，不包含日期部分。在 MySQL 中，需要 <code>3个字节</code> 的存储空间来存储 TIME 类型的数据，可以使用 “HH:MM:SS” 格式来表示 TIME 类型，其中，HH 表示小时，MM 表示分钟，SS 表示秒。</p><p>在 MySQL 中，向 TIME 类型的字段插入数据时，也可以使用几种不同的格式。<br>（1）可以使用带有冒号的字符串，比如’<code>D HH:MM:SS&#39;</code>、’<code>HH:MM:SS</code>‘、’<code>HH:MM</code>‘、’<code>D HH:MM</code>‘、’<code>D HH</code>‘或’<code>SS</code>‘格式，都能被正确地插入 TIME 类型的字段中。其中 D 表示天，其最小值为 0，最大值为 34。如果使用带有 D 格式的字符串插入 TIME 类型的字段时，D 会被转化为小时，计算格式为 D*24+HH。当使用带有冒号并且不带 D 的字符串表示时间时，表示当天的时间，比如 12:10 表示 12:10:00，而不是 00:12:10。<br>（2）可以使用不带有冒号的字符串或者数字，格式为’<code>HHMMSS</code>‘或者<code>HHMMSS</code>。如果插入一个不合法的字符串或者数字，MySQL 在存储数据时，会将其自动转化为 00:00:00 进行存储。比如 1210，MySQL 会将最右边的两位解析成秒，表示 00:12:10，而不是 12:10:00。<br>（3）使用 <code>CURRENT_TIME()</code> 或者 <code>NOW()</code>，会插入当前系统的时间。</p><h3 id="DATE-类型"><a href="#DATE-类型" class="headerlink" title="DATE 类型"></a>DATE 类型</h3><p>DATE 类型表示日期，没有时间部分，格式为 <code>YYYY-MM-DD</code> ，其中，YYYY 表示年份，MM 表示月份，DD 表示日期。需要 <code>3个字节</code> 的存储空间。在向 DATE 类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以 <code>YYYY-MM-DD</code> 格式或者 <code>YYYYMMDD</code> 格式表示的字符串日期，其最小取值为 1000-01-01，最大取值为 9999-12-03。YYYYMMDD 格式会被转化为 YYYY-MM-DD 格式。</li><li>以 <code>YY-MM-DD</code> 格式或者 <code>YYMMDD</code> 格式表示的字符串日期，此格式中，年份为两位数值或字符串满足 YEAR 类型的格式条件为：当年份取值为 00 到 69 时，会被转化为 2000 到 2069；当年份取值为 70 到 99 时，会被转化为 1970 到 1999。</li><li>使用 <code>CURRENT_DATE()</code> 或者 <code>NOW()</code> 函数，会插入当前系统的日期。</li></ul><h3 id="DATETIME-类型"><a href="#DATETIME-类型" class="headerlink" title="DATETIME 类型"></a>DATETIME 类型</h3><p>DATETIME 类型在所有的日期时间类型中占用的存储空间最大，总共需要 <code>8</code> 个字节的存储空间。在格式上为 DATE 类型和 TIME 类型的组合，可以表示为<code>YYYY-MM-DD HH:MM:SS</code>，其中 YYYY 表示年份，MM 表示月份，DD 表示日期，HH 表示小时，MM 表示分钟，SS 表示秒。</p><p>在向 DATETIME 类型的字段插入数据时，同样需要满足一定的格式条件。</p><ul><li>以 <code>YYYY-MM-DD HH:MM:SS</code> 格式或者 <code>YYYYMMDDHHMMSS</code> 格式的字符串插入 DATETIME 类型的字段时，最小值为 1000-01-01 00:00:00，最大值为 9999-12-03 23:59:59。</li><li>以 YYYYMMDDHHMMSS 格式的数字插入 DATETIME 类型的字段时，会被转化为 YYYY-MM-DD HH:MM:SS 格式。</li><li>以 <code>YY-MM-DD HH:MM:SS</code> 格式或者 <code>YYMMDDHHMMSS</code> 格式的字符串插入 DATETIME 类型的字段时，两位数的年份规则符合 YEAR 类型的规则，00 到 69 表示 2000 到 2069；70 到 99 表示 1970 到 1999。</li><li>使用函数 <code>CURRENT_TIMESTAMP()</code> 和 <code>NOW()</code>，可以向DATETIME类型的字段插入系统的当前日期和时间。</li></ul><h3 id="TIMESTAMP-类型"><a href="#TIMESTAMP-类型" class="headerlink" title="TIMESTAMP 类型"></a>TIMESTAMP 类型</h3><p>TIMESTAMP 类型也可以表示日期时间，其显示格式与 DATETIME 类型相同，都是 <code>YYYY-MM-DD HH:MM:SS</code> ，需要 4 个字节的存储空间。但是 TIMESTAMP 存储的时间范围比 DATETIME 要小很多，只能存储 “1970-01-01 00:00:01 UTC” 到 “2038-01-19 03:14:07 UTC” 之间的时间。其中，UTC 表示世界统一时间，也叫作世界标准时间。</p><ul><li><strong>存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用 TIMESTAMP 存储的同一个时间值，在不同的时区查询时会显示不同的时间。</strong></li></ul><p>向 TIMESTAMP 类型的字段插入数据时，当插入的数据格式满足 YY-MM-DD HH:MM:SS 和 YYMMDDHHMMSS 时，两位数值的年份同样符合 YEAR 类型的规则条件，只不过表示的时间范围要小很多。</p><p>如果向 TIMESTAMP 类型的字段插入的时间超出了 TIMESTAMP 类型的范围，则 MySQL 会抛出错误信息。</p><p><strong>TIMESTAMP 和 DATETIME 的区别：</strong></p><ul><li><p>TIMESTAMP 存储空间比较小，表示的日期时间范围也比较小</p></li><li><p>底层存储方式不同，TIMESTAMP 底层存储的是毫秒值，距离 1970-1-1 0:0:0 0毫秒的毫秒值。</p></li><li><p>两个日期比较大小或日期计算时，TIMESTAMP 更方便、更快。</p></li><li><p>TIMESTAMP 和时区有关。TIMESTAMP 会根据用户的时区不同，显示不同的结果。而 DATETIME 则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。</p></li></ul><h3 id="开发中经验"><a href="#开发中经验" class="headerlink" title="开发中经验"></a>开发中经验</h3><p>用得最多的日期时间类型，就是 <code>DATETIME</code>。虽然 MySQL 也支持 YEAR（年）、 TIME（时间）、DATE（日期），以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。 </p><p>此外，一般存注册时间、商品发布时间等，不建议使用 DATETIME 存储，而是使用 <code>时间戳</code>，因为 DATETIME 虽然直观，但不便于计算。</p><h2 id="字符文本"><a href="#字符文本" class="headerlink" title="字符文本"></a>字符文本</h2><p><img src="https://xorex.space/image/367.jpg" alt="367.jpg"></p><h3 id="char-varchar"><a href="#char-varchar" class="headerlink" title="char varchar"></a>char varchar</h3><p>CHAR 和 VARCHAR 类型都可以存储比较短的字符串。</p><table><thead><tr><th>字符串(文本)类型</th><th>特点</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>M</td><td>0 &lt;= M &lt;= 255</td><td>M个字节</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>M</td><td>0 &lt;= M &lt;= 65535</td><td>(实际长度 + 1) 个字节</td></tr></tbody></table><p><strong>哪些情况使用 CHAR 或 VARCHAR 更好</strong></p><table><thead><tr><th>类型</th><th>特点</th><th>空间上</th><th>时间上</th><th>适用场景</th></tr></thead><tbody><tr><td>CHAR(M)</td><td>固定长度</td><td>浪费存储空间</td><td>效率高</td><td>存储不大，速度要求高</td></tr><tr><td>VARCHAR(M)</td><td>可变长度</td><td>节省存储空间</td><td>效率低</td><td>非CHAR的情况</td></tr></tbody></table><hr><p><strong>CHAR类型：</strong></p><ul><li>CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。</li><li>如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在<code>右侧填充</code>空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。</li><li>定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。</li></ul><hr><p><strong>VARCHAR类型：</strong></p><ul><li>VARCHAR(M) 定义时，<code>必须指定</code>长度M，否则报错。</li><li>MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放 UTF8 汉字时，只能存6个（每个汉字3字节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。</li><li>检索 VARCHAR 类型的字段数据时，会保留数据尾部的空格。VARCHAR 类型的字段所占用的存储空间为字符串实际长度加1个字节。</li></ul><hr><p>情况1：存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。</p><p>情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。</p><p>情况3：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。</p><h3 id="TEXT-类型"><a href="#TEXT-类型" class="headerlink" title="TEXT 类型"></a>TEXT 类型</h3><p>在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。</p><p>在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和 VARCHAR类型相同。</p><p>每种TEXT类型保存的数据长度和所占用的存储空间不同，如下：</p><table><thead><tr><th>文本字符串类型</th><th>特点</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>TINYTEXT</td><td>小文本、可变长度</td><td>L</td><td>0 &lt;= L &lt;= 255</td><td>L + 2 个字节</td></tr><tr><td>TEXT</td><td>文本、可变长度</td><td>L</td><td>0 &lt;= L &lt;= 65535</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMTEXT</td><td>中等文本、可变长度</td><td>L</td><td>0 &lt;= L &lt;= 16777215</td><td>L + 3 个字节</td></tr><tr><td>LONGTEXT</td><td>大文本、可变长度</td><td>L</td><td>0 &lt;= L&lt;= 4294967295（相当于4GB）</td><td>L + 4 个字节</td></tr></tbody></table><p><strong>由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键</strong>。遇到这种情况，你只能采用 CHAR(M)，或者 VARCHAR(M)。</p><hr><p><strong>开发中经验：</strong></p><p>TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。</p><h2 id="ENUM类型"><a href="#ENUM类型" class="headerlink" title="ENUM类型"></a>ENUM类型</h2><p>ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。</p><p>其所需要的存储空间由定义ENUM类型时指定的成员个数决定。</p><table><thead><tr><th>文本字符串类型</th><th>长度</th><th>长度范围</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>ENUM</td><td>L</td><td>1 &lt;= L &lt;= 65535</td><td>1或2个字节</td></tr></tbody></table><ul><li><p>当ENUM类型包含1～255个成员时，需要1个字节的存储空间；</p></li><li><p>当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。</p></li><li><p>ENUM类型的成员个数的上限为65535个。</p></li></ul><p>举例：</p><p>创建表如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_enum(</span><br><span class="line">season ENUM(<span class="string">&#x27;春&#x27;</span>,<span class="string">&#x27;夏&#x27;</span>,<span class="string">&#x27;秋&#x27;</span>,<span class="string">&#x27;冬&#x27;</span>,<span class="string">&#x27;unknow&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>添加数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;春&#x27;</span>),(<span class="string">&#x27;秋&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 忽略大小写</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;UNKNOW&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 允许按照角标的方式获取指定索引位置的枚举值</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;1&#x27;</span>),(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"># Data truncated <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;season&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;ab&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 当ENUM类型的字段没有声明为<span class="keyword">NOT</span> <span class="keyword">NULL</span>时，插入<span class="keyword">NULL</span>也是有效的</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure><h2 id="9-SET类型"><a href="#9-SET类型" class="headerlink" title="9. SET类型"></a>9. SET类型</h2><p>SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为<code>64</code>。设置字段值时，可以取取值范围内的 0 个或多个值。</p><p>当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：</p><table><thead><tr><th>成员个数范围（L表示实际成员个数）</th><th>占用的存储空间</th></tr></thead><tbody><tr><td>1 &lt;= L &lt;= 8</td><td>1个字节</td></tr><tr><td>9 &lt;= L &lt;= 16</td><td>2个字节</td></tr><tr><td>17 &lt;= L &lt;= 24</td><td>3个字节</td></tr><tr><td>25 &lt;= L &lt;= 32</td><td>4个字节</td></tr><tr><td>33 &lt;= L &lt;= 64</td><td>8个字节</td></tr></tbody></table><p>SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</p><p>举例：</p><p>创建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_set(</span><br><span class="line">s <span class="keyword">SET</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>向表中插入数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_set (s) <span class="keyword">VALUES</span> (<span class="string">&#x27;A&#x27;</span>), (<span class="string">&#x27;A,B&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#插入重复的<span class="keyword">SET</span>类型成员时，MySQL会自动删除重复的成员</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_set (s) <span class="keyword">VALUES</span> (<span class="string">&#x27;A,B,C,A&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#向<span class="keyword">SET</span>类型的字段插入<span class="keyword">SET</span>成员中不存在的值时，MySQL会抛出错误。</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_set (s) <span class="keyword">VALUES</span> (<span class="string">&#x27;A,B,C,D&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> test_set;</span><br></pre></td></tr></table></figure><h2 id="二进制字符串类型"><a href="#二进制字符串类型" class="headerlink" title="二进制字符串类型"></a>二进制字符串类型</h2><p>MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。</p><p>MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB类型。</p><h3 id="BINARY-与-VARBINARY-类型"><a href="#BINARY-与-VARBINARY-类型" class="headerlink" title="BINARY 与 VARBINARY 类型"></a>BINARY 与 VARBINARY 类型</h3><p>BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。</p><p>BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储<code>1个字节</code>。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字节，将在右边填充’\0’以补齐指定长度。</p><p>VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。VARBINARY类型<code>必须指定(M)</code>，否则报错。</p><table><thead><tr><th>二进制字符串类型</th><th>特点</th><th>值的长度</th><th>占用空间</th></tr></thead><tbody><tr><td>BINARY(M)</td><td>固定长度</td><td>M （0 &lt;= M &lt;= 255）</td><td>M个字节</td></tr><tr><td>VARBINARY(M)</td><td>可变长度</td><td>M（0 &lt;= M &lt;= 65535）</td><td>M+1个字节</td></tr></tbody></table><p>举例：</p><p>创建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_binary1(</span><br><span class="line">f1 <span class="type">BINARY</span>,</span><br><span class="line">f2 <span class="type">BINARY</span>(<span class="number">3</span>),</span><br><span class="line"># f3 <span class="type">VARBINARY</span>,</span><br><span class="line">f4 <span class="type">VARBINARY</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>添加数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_binary1(f1,f2)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_binary1(f1,f2)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;尚&#x27;</span>,<span class="string">&#x27;尚&#x27;</span>);#失败</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_binary1(f2,f4)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;ab&#x27;</span>,<span class="string">&#x27;ab&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> LENGTH(f2),LENGTH(f4)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> test_binary1;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+------------+</span></span><br><span class="line"><span class="operator">|</span> LENGTH(f2) <span class="operator">|</span> LENGTH(f4) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+------------+</span></span><br><span class="line"><span class="operator">|</span>          <span class="number">3</span> <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>          <span class="number">3</span> <span class="operator">|</span>          <span class="number">2</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="BLOB类型"><a href="#BLOB类型" class="headerlink" title="BLOB类型"></a>BLOB类型</h3><p>BLOB是一个<code>二进制大对象</code>，可以容纳可变数量的数据。</p><p>MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如<code>图片</code>、<code>音频</code>和<code>视频</code>等。</p><p>需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到<code>服务器的磁盘上</code>，并将图片、音频和视频的访问路径存储到MySQL中。</p><table><thead><tr><th>二进制字符串类型</th><th>值的长度</th><th>长度范围</th><th>占用空间</th></tr></thead><tbody><tr><td>TINYBLOB</td><td>L</td><td>0 &lt;= L &lt;= 255</td><td>L + 1 个字节</td></tr><tr><td>BLOB</td><td>L</td><td>0 &lt;= L &lt;= 65535（相当于64KB）</td><td>L + 2 个字节</td></tr><tr><td>MEDIUMBLOB</td><td>L</td><td>0 &lt;= L &lt;= 16777215 （相当于16MB）</td><td>L + 3 个字节</td></tr><tr><td>LONGBLOB</td><td>L</td><td>0 &lt;= L &lt;= 4294967295（相当于4GB）</td><td>L + 4 个字节</td></tr></tbody></table><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_blob1(</span><br><span class="line">id <span class="type">INT</span>,</span><br><span class="line">img MEDIUMBLOB</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>TEXT和BLOB的使用注意事项：</strong></p><p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p><p>① BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的”<code>空洞</code>“，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行<code>碎片整理</code>。</p><p>② 如果需要对大文本字段进行模糊查询，MySQL 提供了<code>前缀索引</code>。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</p><p>③ 把BLOB或TEXT列<code>分离到单独的表</code>中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会<code>减少主表中的碎片</code>，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL中的数据类型&quot;&gt;&lt;a href=&quot;#MySQL中的数据类型&quot; class=&quot;headerlink&quot; title=&quot;MySQL中的数据类型&quot;&gt;&lt;/a&gt;MySQL中的数据类型&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-06-表管理-增删改</title>
    <link href="https://xorex.space/2022/09/23/b61f9d102a69/"/>
    <id>https://xorex.space/2022/09/23/b61f9d102a69/</id>
    <published>2022-09-23T10:47:10.000Z</published>
    <updated>2022-10-07T08:56:32.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="管理数据库"><a href="#管理数据库" class="headerlink" title="管理数据库"></a>管理数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名 [<span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集];</span><br></pre></td></tr></table></figure><p>因为 MySQL5 默认字符集是拉丁，所以对于 5 版本的一定要指定字符集为 <code>&quot;utf8&quot;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test01_office <span class="type">CHARACTER</span> <span class="keyword">SET</span> &quot;utf8&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的。</p></blockquote><h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><ul><li>查看当前所有的数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES; <span class="comment">-- 有一个S，代表多个数据库</span></span><br></pre></td></tr></table></figure><ul><li>查看当前正在使用的数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();  <span class="comment">-- 使用的一个 mysql 中的全局函数</span></span><br></pre></td></tr></table></figure><ul><li>查看指定库下所有的表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES <span class="keyword">FROM</span> 数据库名;</span><br></pre></td></tr></table></figure><ul><li>查看数据库的创建信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE 数据库名;</span><br></pre></td></tr></table></figure><ul><li>使用/切换数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure><blockquote><p>注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名.”。</p></blockquote><h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><ul><li>更改数据库字符集</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集;  <span class="comment">-- 比如：gbk、utf8等</span></span><br></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><ul><li>删除指定的数据库</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE 数据库名;</span><br></pre></td></tr></table></figure><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><h3 id="自定义创建表"><a href="#自定义创建表" class="headerlink" title="自定义创建表"></a>自定义创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 表名(</span><br><span class="line">字段<span class="number">1</span> 数据类型 [约束条件] [默认值],</span><br><span class="line">字段<span class="number">2</span> 数据类型 [约束条件] [默认值],</span><br><span class="line">字段<span class="number">3</span> 数据类型 [约束条件] [默认值],</span><br><span class="line">……</span><br><span class="line">[表约束条件]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>加上了 IF NOT EXISTS 关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</p></blockquote><ul><li>创建表举例：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">  <span class="comment">-- int类型 4 byte，（最小显示长度 3 位，不推荐使用以后可能会被取消）</span></span><br><span class="line">  emp_id <span class="type">INT</span>(<span class="number">3</span>),</span><br><span class="line">  <span class="comment">-- 最多保存20个中英文字符</span></span><br><span class="line">  emp_name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">  <span class="comment">-- 总位数不超过15位</span></span><br><span class="line">  salary <span class="keyword">DOUBLE</span>,</span><br><span class="line">  <span class="comment">-- 日期类型</span></span><br><span class="line">  birthday <span class="type">DATE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="通过其他表数据创建"><a href="#通过其他表数据创建" class="headerlink" title="通过其他表数据创建"></a>通过其他表数据创建</h3><p><code>CREATE TABLE table_name as 子查询</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp1 <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees; <span class="comment">-- 复制 employees 表的定义和数据为 emp1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp2 <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>; <span class="comment">-- 只复制表的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept80 <span class="comment">-- 例子</span></span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span>  employee_id, last_name, salary<span class="operator">*</span><span class="number">12</span> ANNSAL, hire_date</span><br><span class="line"><span class="keyword">FROM</span>    employees</span><br><span class="line"><span class="keyword">WHERE</span>   department_id <span class="operator">=</span> <span class="number">80</span>;</span><br></pre></td></tr></table></figure><h3 id="查看表的结构"><a href="#查看表的结构" class="headerlink" title="查看表的结构"></a>查看表的结构</h3><p><code>DESC table_name</code> 看表的数据结构</p><p><code>SHOW CREATE TABLE table_name</code> 看表的创建信息</p><h2 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h2><p>表结构的修改！ </p><iframe src="https://xmind.app/embed/FiYwCR/" width="800px" height="540px" frameborder="0" scrolling="no"></iframe><p>修改表名称推荐：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 RENAME 新名称;</span><br></pre></td></tr></table></figure><h2 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><h4 id="插入单行数据"><a href="#插入单行数据" class="headerlink" title="插入单行数据"></a>插入单行数据</h4><p>按照自定义列顺序插入数据，这个时候，只需要我们包括必须要更新的列的数据即可:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 (column1 [, column2, …, columnn]) </span><br><span class="line"><span class="keyword">VALUES</span> (value1 [,value2, …, valuen]);</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">User</span>` (user_name,country,`password`) </span><br><span class="line"><span class="keyword">VALUES</span> (&quot;GoGo&quot;,&quot;CN&quot;,&quot;No&quot;);</span><br></pre></td></tr></table></figure><hr><p>按照列顺序依次插入数据，这个就不需要指定列名了，依次来，对于那些不需要我们给出值得列，<strong>就给一个 NULL 即可</strong>，比如自增，MySQL8 新特性那些。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,....);</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">User</span>` <span class="keyword">VALUES</span> (<span class="keyword">NULL</span>,&quot;ToTo&quot;,&quot;CN&quot;,&quot;No&quot;); <span class="comment">-- id 这里自增，设为 NULL 占位即可。</span></span><br></pre></td></tr></table></figure><h4 id="插入多行数据"><a href="#插入多行数据" class="headerlink" title="插入多行数据"></a>插入多行数据</h4><p>同样，对应是否按照自定义顺序插入，也有两套多行插入方式：</p><p>自定义列顺序多行插入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1 [, column2, …, columnn]) </span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">……</span><br><span class="line">(value1 [,value2, …, valuen]);</span><br></pre></td></tr></table></figure><hr><p>表列顺序多行插入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name </span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">……</span><br><span class="line">(value1 [,value2, …, valuen]);</span><br></pre></td></tr></table></figure><h4 id="将子查询结果插入"><a href="#将子查询结果插入" class="headerlink" title="将子查询结果插入"></a>将子查询结果插入</h4><p>语法格式（不需要子查询的括号，也不需要 Values 关键字，单查询出来的表要和被插入的表列对应）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 目标表名</span><br><span class="line">(tar_column1 [, tar_column2, …, tar_columnn])</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">(src_column1 [, src_column2, …, src_columnn])</span><br><span class="line"><span class="keyword">FROM</span> 源表名</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp2</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><h4 id="普通修改数据"><a href="#普通修改数据" class="headerlink" title="普通修改数据"></a>普通修改数据</h4><p>修改数据语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line"><span class="keyword">SET</span> column1<span class="operator">=</span>value1, column2<span class="operator">=</span>value2, … , <span class="keyword">column</span><span class="operator">=</span>valuen</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure><p>如果想要修改多行数据的话，只能执行多次 <code>UPDATE</code> 语句。</p><h4 id="子查询修改数据"><a href="#子查询修改数据" class="headerlink" title="子查询修改数据"></a>子查询修改数据</h4><p>关联子查询，每次修改一个列的时候，就会进行一次子查询得到修改数据，和普通的关联子查询的用法是一模一样的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE employees e</span><br><span class="line"><span class="keyword">SET</span> department_name <span class="operator">=</span>  (<span class="keyword">SELECT</span> department_name </span><br><span class="line">                       <span class="keyword">FROM</span>   departments d</span><br><span class="line">                       <span class="keyword">WHERE</span>  e.department_id <span class="operator">=</span> d.department_id);</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>非常简单，根据 WHERE 条件直接删掉对应的行即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><p>eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">WHERE</span>  department_name <span class="operator">=</span> <span class="string">&#x27;Finance&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="子查询删除"><a href="#子查询删除" class="headerlink" title="子查询删除"></a>子查询删除</h4><p>和修改子查询一样，都是普通的关联子查询而已：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table1 t1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> operator (<span class="keyword">SELECT</span> expression</span><br><span class="line">                       <span class="keyword">FROM</span>   table2 t2</span><br><span class="line">                       <span class="keyword">WHERE</span>  t1.column <span class="operator">=</span> t2.column);</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th>数据</th><th>介绍</th></tr></thead><tbody><tr><td>INT</td><td>4字节整形</td></tr><tr><td>BIGINT</td><td>8字节整形</td></tr><tr><td>REAL</td><td>4字节浮点数</td></tr><tr><td>DECIMAL(M,N)</td><td>M 有效位数，其中小数位数 N</td></tr><tr><td>DOUBLE</td><td>8字节浮点数</td></tr><tr><td>VARCHAR(N)</td><td>0-n 长度的边长字符串</td></tr><tr><td>BOOLEAN</td><td>布尔类型 True of False</td></tr><tr><td>DATE</td><td>日期类型 2021-02-24</td></tr><tr><td>TIME</td><td>时间类型 15:31:10</td></tr><tr><td>DATETIME</td><td>日期时间类 2021-02-24 15:31:10</td></tr><tr><td>TINYINT</td><td>单字节正整数</td></tr></tbody></table><p>只要在 数值类 的数据后面加上 unsigned，比如 <code>int unsigned</code> 就会变成无符号数据。 </p><h2 id="关于表管理的拓展内容"><a href="#关于表管理的拓展内容" class="headerlink" title="关于表管理的拓展内容"></a>关于表管理的拓展内容</h2><h3 id="阿里巴巴《Java-开发手册》之-MySQL-字段命名"><a href="#阿里巴巴《Java-开发手册》之-MySQL-字段命名" class="headerlink" title="阿里巴巴《Java 开发手册》之 MySQL 字段命名"></a>阿里巴巴《Java 开发手册》之 MySQL 字段命名</h3><ul><li><p>【<code>强制</code>】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p><ul><li>正例：aliyun_admin，rdc_config，level3_name </li><li>反例：AliyunAdmin，rdcConfig，level_3_name</li></ul></li><li><p>【<code>强制</code>】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p></li><li><p>【<code>强制</code>】表必备三字段：id, gmt_create, gmt_modified。 </p><ul><li>说明：其中 id 必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新</li></ul></li><li><p>【<code>推荐</code>】表的命名最好是遵循 “业务名称_表的作用”。 </p><ul><li>正例：alipay_task 、 force_project、 trade_config</li></ul></li><li><p>【<code>推荐</code>】库名与应用名称尽量一致。</p></li><li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 </p><ul><li>正例：无符号值可以避免误存负数，且扩大了表示范围。</li></ul></li></ul><h3 id="如何理解清空表、删除表等操作需谨慎？！"><a href="#如何理解清空表、删除表等操作需谨慎？！" class="headerlink" title="如何理解清空表、删除表等操作需谨慎？！"></a>如何理解清空表、删除表等操作需谨慎？！</h3><p><code>表删除</code>操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行<code>备份</code>，这样当操作失误时可以对数据进行恢复，以免造成无法挽回的后果。</p><p>同样的，在使用 <code>ALTER TABLE</code> 进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进行完整的<code>备份</code>，因为数据库的改变是<code>无法撤销</code>的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</p><h3 id="MySQL8新特性—DDL的原子化"><a href="#MySQL8新特性—DDL的原子化" class="headerlink" title="MySQL8新特性—DDL的原子化"></a>MySQL8新特性—DDL的原子化</h3><p>在 MySQL 8.0版本中，InnoDB 表的 DDL 支持事务完整性，即<code>DDL操作要么成功要么回滚</code>。DDL操作回滚日志写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p><p>分别在MySQL 5.7版本和MySQL 8.0版本中创建数据库和数据表，结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE mytest;</span><br><span class="line"></span><br><span class="line">USE mytest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book1(</span><br><span class="line">book_id <span class="type">INT</span> ,</span><br><span class="line">book_name <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><p>（1）在MySQL 5.7版本中，测试步骤如下：<br>删除数据表book1和数据表book2，结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">TABLE</span> book1,book2;</span><br><span class="line">ERROR <span class="number">1051</span> (<span class="number">42</span>S02): <span class="literal">Unknown</span> <span class="keyword">table</span> <span class="string">&#x27;mytest.book2&#x27;</span></span><br></pre></td></tr></table></figure><p>再次查询数据库中的数据表名称，结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>从结果可以看出，虽然删除操作时报错了，但是仍然删除了数据表book1。</p><p>（2）在MySQL 8.0版本中，测试步骤如下：<br>删除数据表book1和数据表book2，结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">TABLE</span> book1,book2;</span><br><span class="line">ERROR <span class="number">1051</span> (<span class="number">42</span>S02): <span class="literal">Unknown</span> <span class="keyword">table</span> <span class="string">&#x27;mytest.book2&#x27;</span></span><br></pre></td></tr></table></figure><p>再次查询数据库中的数据表名称，结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_mytest <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> book1            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>从结果可以看出，数据表book1并没有被删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;管理数据库&quot;&gt;&lt;a href=&quot;#管理数据库&quot; class=&quot;headerlink&quot; title=&quot;管理数据库&quot;&gt;&lt;/a&gt;管理数据库&lt;/h2&gt;&lt;h3 id=&quot;创建数据库&quot;&gt;&lt;a href=&quot;#创建数据库&quot; class=&quot;headerlink&quot; title=&quot;创建数</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-05-子查询</title>
    <link href="https://xorex.space/2022/09/20/5d9a0289c382/"/>
    <id>https://xorex.space/2022/09/20/5d9a0289c382/</id>
    <published>2022-09-20T03:56:39.000Z</published>
    <updated>2022-09-28T13:51:04.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询也叫 嵌套查询，就是在 SQL 语句中，部分值是从查询语句中返回的。子查询的语句需要在 <code>()</code> 中写出来，然后会替换查询返回的结果：</p><p>比如：查询工资大于 Abel 的人：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, salary </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name <span class="operator">=</span> &quot;Abel&quot; );</span><br></pre></td></tr></table></figure><h2 id="子查询位置"><a href="#子查询位置" class="headerlink" title="子查询位置"></a>子查询位置</h2><p>子查询 除了 在 GROUP BY（接收参数是当前表的列名，用来提取数据分组）和 LIMIT（只接收数字）无法使用子查询以外，其他地方都可以用子查询返回的内容作为参数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 每一行的子查询返回的单行内容可以作为新的一列的数据</span><br><span class="line"><span class="keyword">FROM</span><span class="operator">/</span><span class="keyword">JOIN</span> 子查询返回内容可以作为一个表（需要起别名）</span><br><span class="line"><span class="keyword">WHERE</span> 可以</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 不可以</span><br><span class="line"><span class="keyword">HAVING</span> 可以</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 接收的是每一行的排序依据，可以从子查询中获取</span><br><span class="line">LIMIT 不可以</span><br></pre></td></tr></table></figure><h3 id="SELECT-子查询"><a href="#SELECT-子查询" class="headerlink" title="SELECT 子查询"></a>SELECT 子查询</h3><p>SELECT 中，每一行的子查询返回的单行内容可以作为新列的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.employee_id, (</span><br><span class="line"><span class="keyword">SELECT</span> e2.last_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> e2 </span><br><span class="line"><span class="keyword">WHERE</span> e2.employee_id <span class="operator">=</span> e1.employee_id) <span class="keyword">AS</span> e2_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> e1;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">employee_ide2_name <span class="comment">-- 新的一列数据是从子查询中获取的。</span></span><br><span class="line"><span class="number">206</span>Gietz</span><br><span class="line"><span class="number">205</span>Higgins</span><br><span class="line"><span class="number">204</span>Baer</span><br><span class="line"><span class="number">203</span>Mavris</span><br></pre></td></tr></table></figure><h3 id="FROM-JOIN-子查询"><a href="#FROM-JOIN-子查询" class="headerlink" title="FROM / JOIN 子查询"></a>FROM / JOIN 子查询</h3><p>除了多行操作符，还有一个关键词也是操作多行数据的，就是 <code>FROM</code> <code>JOIN</code>，也就是说，多行子查询的结果可以被当做一张新的表来使用（必须要给这个新的表一个别名）：</p><p>比如：查询部门最低的平均工资：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只需要在一个平均工资的表里进行 MIN() 查询即可</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(avg_salary) </span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line">      <span class="keyword">FROM</span> employees</span><br><span class="line">      <span class="keyword">WHERE</span> department_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id) <span class="keyword">AS</span> avg_table; <span class="comment">-- 必须给一个别名</span></span><br></pre></td></tr></table></figure><h3 id="WHERE-HAVING-子查询"><a href="#WHERE-HAVING-子查询" class="headerlink" title="WHERE/HAVING 子查询"></a>WHERE/HAVING 子查询</h3><ul><li>两者一模一样。</li></ul><p>题目：查询最低工资大于 50 号部门最低工资的部门 id 和其最低工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>   department_id, <span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span>     employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span>   <span class="built_in">MIN</span>(salary) <span class="operator">&gt;</span></span><br><span class="line">                       (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line">                        <span class="keyword">FROM</span>   employees</span><br><span class="line">                        <span class="keyword">WHERE</span>  department_id <span class="operator">=</span> <span class="number">50</span>);</span><br></pre></td></tr></table></figure><h3 id="ORDER-BY-子查询"><a href="#ORDER-BY-子查询" class="headerlink" title="ORDER BY 子查询"></a>ORDER BY 子查询</h3><p>ORDER BY 需要的参数是行数据的排序依据，可以是当前表某一列数据，也可以是子查询获得的数据（因为排序依据是和行数据有一定关系的，所以 ORDER BY 的都是相关子查询）：</p><p>比如：查询员工的 id，salary，按照 department_name 排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, salary</span><br><span class="line"><span class="keyword">FROM</span> employees emp</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ( <span class="comment">-- 每一行数据都会子查询出自己部门的名字，作为 ORDER BY 排序这些行的依据</span></span><br><span class="line">  <span class="keyword">SELECT</span> department_name </span><br><span class="line">  <span class="keyword">FROM</span> departments dep </span><br><span class="line">  <span class="keyword">WHERE</span> emp.department_id <span class="operator">=</span> dep.department_id);</span><br></pre></td></tr></table></figure><h3 id="CASE-子查询"><a href="#CASE-子查询" class="headerlink" title="CASE 子查询"></a>CASE 子查询</h3><ul><li>WHEN 中使用子查询，比较操作和 WHERE 一模一样。也可以判断是否有查询结果，有就是 TRUE。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> (<span class="keyword">SELECT</span> job_id</span><br><span class="line">                 <span class="keyword">FROM</span>   employees</span><br><span class="line">                 <span class="keyword">WHERE</span>  last_name <span class="operator">=</span> <span class="string">&#x27;Haas&#x27;</span>) <span class="keyword">THEN</span> &quot;有 Haas&quot;</span><br><span class="line">                 <span class="keyword">ELSE</span> &quot;没有 Hass&quot; <span class="keyword">END</span></span><br><span class="line"><span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure><p>子查询没有返回数据，则被 WHEN 判定为 FASLE。</p><h2 id="子查询分类"><a href="#子查询分类" class="headerlink" title="子查询分类"></a>子查询分类</h2><p>依据返回结果行数和子查询和主查询是否有关系进行分类：</p><h3 id="返回结果行数"><a href="#返回结果行数" class="headerlink" title="返回结果行数"></a>返回结果行数</h3><ul><li>按内查询的结果返回一行还是多行记录，将子查询分为<code>单行子查询</code>、<code>多行子查询</code>。</li></ul><p>单行子查询：查询返回一行数据。<br>多行子查询：查询返回多行数据。</p><h3 id="主子查询关系"><a href="#主子查询关系" class="headerlink" title="主子查询关系"></a>主子查询关系</h3><ul><li>按内查询是否被执行多次，将子查询划分为<code>相关(或关联)子查询</code>和<code>不相关(或非关联)子查询</code>。</li></ul><p>相关子查询：子查询和主查询的行数据相关，会随着主查询行数据的变化，子查询的结果也不一样，会进行多次子查询。eg：查询工资大于部门平均工资的，每个人的部门可能不一样。对于子查询来说，部门名就是和主查询的相关点，每一个员工都会执行一次子查询。这就是多次执行的相关子查询。</p><p>不相关子查询：子查询和主查询的行数据无关，返回的内容是固定值，只会执行一次。eg：查询工资大于公司平均工资的员工。公司平均工资是固定的，和员工变量无关，只用执行一次即可。</p><h2 id="行数子查询"><a href="#行数子查询" class="headerlink" title="行数子查询"></a>行数子查询</h2><h3 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h3><p>因为单行子查询结果返回一行，所以对结果的操作也应该是 单行操作符：</p><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>=</td><td>equal to</td></tr><tr><td>&gt;</td><td>greater than</td></tr><tr><td>&gt;=</td><td>greater than or equal to</td></tr><tr><td>&lt;</td><td>less than</td></tr><tr><td>&lt;=</td><td>less than or equal to</td></tr><tr><td>&lt;&gt;</td><td>not equal to</td></tr></tbody></table><h4 id="单行单列数据"><a href="#单行单列数据" class="headerlink" title="单行单列数据"></a>单行单列数据</h4><p>指的是返回数据只有一个，可以直接进行比较：</p><p>比如：查询工资大于 Abel 的人：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, salary </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name <span class="operator">=</span> &quot;Abel&quot; );</span><br></pre></td></tr></table></figure><h4 id="单行多列数据"><a href="#单行多列数据" class="headerlink" title="单行多列数据"></a>单行多列数据</h4><p>指的是返回了一行多列数据，需要借用 <code>()</code> 将列名代表的数据组成数据对，的和返回的一行多列数据比较。</p><p>比如 查询 141 号员工的 manager_id 和 department_id 相同的员工的信息，这两个数据组成的数据对可用 <code>()</code> 为一个整体和返回的单行多列数据进行比较，进行比较：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, employee_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> (manager_id, department_id) <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> manager_id, department_id </span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">141</span>);</span><br></pre></td></tr></table></figure><h3 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h3><p><strong>重要提醒</strong>：</p><ol><li>多行子查询的结果是多行数据，一定要思考里面掺杂有 NULL 数据之后的运算逻辑，如果不确定就过滤掉 NULL 数据之后再处理。</li><li>多行子查询返回的数据可以看做一个新的表，给个别名就可以当做表名来使用。</li></ol><hr><p>因为要操作子查询返回的多行数据（可以看做一张表），所以需要出现多行操作符：</p><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>IN</td><td>等于列表中的<strong>任意一个</strong></td></tr><tr><td>ANY</td><td>需要和单行比较操作符一起使用，和子查询返回的<strong>某一个</strong>值比较</td></tr><tr><td>ALL</td><td>需要和单行比较操作符一起使用，和子查询返回的<strong>所有</strong>值比较</td></tr></tbody></table><p>比如：<strong>查询平均工资最低的部门 id</strong>，如果是其他数据库，可以用 <code>MIN(AVG(salary))</code> 进行嵌套聚合函数，进行双重分组查询即可，但是 MySQL 不支持，需要进行子查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(salary) <span class="operator">&lt;=</span> <span class="keyword">ALL</span>( <span class="comment">-- 只有部门平均工资比所有其他部门都低，就是最低的。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) </span><br><span class="line"><span class="keyword">FROM</span> employees </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id);</span><br></pre></td></tr></table></figure><h3 id="有无子查询-EXISTS"><a href="#有无子查询-EXISTS" class="headerlink" title="有无子查询 EXISTS"></a>有无子查询 EXISTS</h3><p>如果子查询能否查到数据也可以作为判断条件，那就要有对应的关键词来转化为 TRUE 和 FASLE，它就是 <code>EXISTS</code> 和 <code>NOT EXISTS</code>。</p><p>如果 <code>EXISTS</code> 后面的子查询返回了结果，那么表示为 TRUE。</p><p>比如，使用 EXISTS 查询公司管理者的 ID 信息。（用子查询看表里面有没有把自己的 ID 作为上司 ID 的）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.employee_id </span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">      <span class="keyword">FROM</span> employees e2</span><br><span class="line">      <span class="keyword">WHERE</span> e1.employee_id <span class="operator">=</span> e2.manager_id );</span><br></pre></td></tr></table></figure><h2 id="关系查询"><a href="#关系查询" class="headerlink" title="关系查询"></a>关系查询</h2><h3 id="非相关子查询"><a href="#非相关子查询" class="headerlink" title="非相关子查询"></a>非相关子查询</h3><p>不相关子查询：子查询和主查询的行数据无关，返回的内容是固定值，只会执行一次。eg：查询工资大于公司平均工资的员工。公司平均工资是固定的，和员工变量无关，只用执行一次即可。</p><p>其他例子：查询工资大于 Abel 的人（Abel 工资是固定值，不会变化，和主查询的行数据没有任何关联）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, salary </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> last_name <span class="operator">=</span> &quot;Abel&quot; );</span><br></pre></td></tr></table></figure><h3 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h3><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为<code>关联子查询</code>。</p><p>相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。</p><p>比如，查找工资大于自己部门平均工资的人：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, department_id </span><br><span class="line"><span class="keyword">FROM</span> employees e1 <span class="comment">-- 每换一个人都要</span></span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees e2</span><br><span class="line"><span class="keyword">WHERE</span> e1.department_id <span class="operator">=</span> e2.department_id); </span><br><span class="line">        <span class="comment">-- 用到了外部表 e1，通过 department_id 关联</span></span><br></pre></td></tr></table></figure><h2 id="和增删改结合"><a href="#和增删改结合" class="headerlink" title="和增删改结合"></a>和增删改结合</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><code>CREATE TABLE table_name as 子查询</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp1 <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees; <span class="comment">-- 复制 employees 表的定义和数据为 emp1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp2 <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>; <span class="comment">-- 只复制表的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept80 <span class="comment">-- 例子</span></span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span>  employee_id, last_name, salary<span class="operator">*</span><span class="number">12</span> ANNSAL, hire_date</span><br><span class="line"><span class="keyword">FROM</span>    employees</span><br><span class="line"><span class="keyword">WHERE</span>   department_id <span class="operator">=</span> <span class="number">80</span>;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>语法格式（不需要子查询的括号，也不需要 Values 关键字，单查询出来的表要和被插入的表列对应）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 目标表名</span><br><span class="line">(tar_column1 [, tar_column2, …, tar_columnn])</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">(src_column1 [, src_column2, …, src_columnn])</span><br><span class="line"><span class="keyword">FROM</span> 源表名</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="keyword">condition</span>]</span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp2</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>关联子查询，每次修改一个列的时候，就会进行一次子查询得到修改数据，和普通的关联子查询的用法是一模一样的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE employees e</span><br><span class="line"><span class="keyword">SET</span> department_name <span class="operator">=</span>  (<span class="keyword">SELECT</span> department_name </span><br><span class="line">                       <span class="keyword">FROM</span>   departments d</span><br><span class="line">                       <span class="keyword">WHERE</span>  e.department_id <span class="operator">=</span> d.department_id);</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>和修改子查询一样，都是普通的关联子查询而已：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table1 t1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> operator (<span class="keyword">SELECT</span> expression</span><br><span class="line">                       <span class="keyword">FROM</span>   table2 t2</span><br><span class="line">                       <span class="keyword">WHERE</span>  t1.column <span class="operator">=</span> t2.column);</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul><li>查询平均工资最低的部门信息和该部门的平均工资</li></ul><p>子查询获取平均工资最低的的 部门 id 和 平均工资，再作为一个表进行多表查询，绑定上部门信息一起展示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dep.<span class="operator">*</span>, min_sal_dep.avg_salary</span><br><span class="line"><span class="keyword">FROM</span> departments <span class="keyword">AS</span> dep </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary</span><br><span class="line">        <span class="keyword">FROM</span> employees</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> avg_salary <span class="keyword">ASC</span></span><br><span class="line">        LIMIT <span class="number">0</span>,<span class="number">1</span>) <span class="keyword">AS</span> min_sal_dep </span><br><span class="line"><span class="keyword">ON</span> dep.department_id <span class="operator">=</span> min_sal_dep.department_id;</span><br></pre></td></tr></table></figure><hr><ul><li>查询平均工资最高的部门的 manager 的详细信息: last_name, department_id, email, salary</li></ul><p>子查询套子查询，因为需要将平均工资最高的部门 和 个人具体信息 借助着 departments 表连接起来，不得不这样嵌套。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, department_id, email, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> (<span class="keyword">SELECT</span> manager_id </span><br><span class="line">             <span class="keyword">FROM</span> departments</span><br><span class="line">             <span class="keyword">WHERE</span> department_id <span class="operator">=</span> (<span class="keyword">SELECT</span> department_id</span><br><span class="line">                                            <span class="keyword">FROM</span> employees</span><br><span class="line">                                            <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line">                                            <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(salary) <span class="keyword">DESC</span></span><br><span class="line">                                            LIMIT <span class="number">0</span>,<span class="number">1</span>) );</span><br></pre></td></tr></table></figure><hr><ul><li>查询每个国家下的部门个数大于 2 的国家编号（相关子查询）</li></ul><p>locations 和 departments 两个表，因为 country_id 可以对应多个 location_id，所以要查到一个国家下面的所有部门 location，然后在去找这个 location 里有几个部门，累加即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> country_id</span><br><span class="line"><span class="keyword">FROM</span> locations loc </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> location_id, <span class="built_in">COUNT</span>(<span class="operator">*</span>) dep_num</span><br><span class="line">        <span class="keyword">FROM</span> departments</span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> location_id) loc_dep_num <span class="comment">-- 获取每个 location 里有多少个 departments</span></span><br><span class="line"><span class="keyword">ON</span> loc.location_id <span class="operator">=</span> loc_dep_num.location_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> country_id <span class="comment">-- 分组聚合 一个 country 下所有 location 的 departments 数量</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(dep_num) <span class="operator">&gt;</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;子查询&quot;&gt;&lt;a href=&quot;#子查询&quot; class=&quot;headerlink&quot; title=&quot;子查询&quot;&gt;&lt;/a&gt;子查询&lt;/h2&gt;&lt;p&gt;子查询也叫 嵌套查询，就是在 SQL 语句中，部分值是从查询语句中返回的。子查询的语句需要在 &lt;code&gt;()&lt;/code&gt; 中写出</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-04-函数-分组查询</title>
    <link href="https://xorex.space/2022/09/13/d37ac7557219/"/>
    <id>https://xorex.space/2022/09/13/d37ac7557219/</id>
    <published>2022-09-13T13:30:44.000Z</published>
    <updated>2022-09-21T12:46:03.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>MySQL 支持简单的流程控制，通过指定的条件判断来执行不同的指令：</p><h3 id="if-A-B-C"><a href="#if-A-B-C" class="headerlink" title="if(A,B,C)"></a>if(A,B,C)</h3><p>语法：等价于 A?B:C，如果 A 为真，则返回 B，为假则返回 C。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, salary, IF(salary<span class="operator">&gt;</span><span class="number">6000</span>,&quot;有钱&quot;,&quot;没钱&quot;) <span class="keyword">FROM</span> employees; </span><br></pre></td></tr></table></figure><h3 id="case-when"><a href="#case-when" class="headerlink" title="case when"></a>case when</h3><p>语法：CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 …. [ELSE resultn] END。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- case 后面的 when 是逐个对比，符合就返回 then 的后面。</span></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary, <span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;=</span><span class="number">15000</span> <span class="keyword">THEN</span> <span class="string">&#x27;富豪&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;=</span><span class="number">10000</span> <span class="keyword">THEN</span> <span class="string">&#x27;有钱人&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> salary<span class="operator">&gt;=</span><span class="number">8000</span> <span class="keyword">THEN</span> <span class="string">&#x27;打工人&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;穷人&#x27;</span> <span class="keyword">END</span> <span class="comment">-- END 为结束。</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><h2 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h2><p>指的是输入的值是 输入 单个数据，返回 单个数据 的函数。</p><h3 id="数值相关"><a href="#数值相关" class="headerlink" title="数值相关"></a>数值相关</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>ABS(x)</td><td>返回x的绝对值</td></tr><tr><td>SIGN(X)</td><td>返回X的符号。正数返回1，负数返回-1，0返回0</td></tr><tr><td>CEIL(x)</td><td>返回大于或等于某个值的最小整数（取整）</td></tr><tr><td>FLOOR(x)</td><td>返回小于或等于某个值的最大整数（取整）</td></tr><tr><td>LEAST(e1,e2,e3…)</td><td>返回列表中的最小值</td></tr><tr><td>GREATEST(e1,e2,e3…)</td><td>返回列表中的最大值</td></tr><tr><td>MOD(x,y)</td><td>返回X除以Y后的余数</td></tr><tr><td>RAND()</td><td>返回0~1的随机值</td></tr><tr><td>RAND(x)</td><td>返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数</td></tr><tr><td>ROUND(x)</td><td>返回一个对x的值进行四舍五入后，最接近于X的整数</td></tr><tr><td>ROUND(x,y)</td><td>返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位</td></tr><tr><td>TRUNCATE(x,y)</td><td>返回数字x截断为y位小数的结果</td></tr><tr><td>SQRT(x)</td><td>返回x的平方根。当X的值为负数时，返回NULL</td></tr></tbody></table><h3 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>BIN(x)</td><td>返回x的二进制编码</td></tr><tr><td>HEX(x)</td><td>返回x的十六进制编码</td></tr><tr><td>OCT(x)</td><td>返回x的八进制编码</td></tr><tr><td>CONV(x,f1,f2)</td><td>返回f1进制数变成f2进制数</td></tr></tbody></table><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p><strong>注意</strong>：MySQL 中，字符串下标是从 1 开始的。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>ASCII(S)</td><td>返回字符串S中的第一个字符的ASCII码值</td></tr><tr><td>CHAR_LENGTH(s)</td><td>返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同</td></tr><tr><td>LENGTH(s)</td><td>返回字符串s的字节数，和字符集有关</td></tr><tr><td>CONCAT(s1,s2,……,sn)</td><td>连接s1,s2,……,sn为一个字符串</td></tr><tr><td>CONCAT_WS(x, s1,s2,……,sn)</td><td>同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x</td></tr><tr><td>UPPER(s) 或 UCASE(s)</td><td>将字符串s的所有字母转成大写字母</td></tr><tr><td>LOWER(s)  或LCASE(s)</td><td>将字符串s的所有字母转成小写字母</td></tr><tr><td>LEFT(str,n)</td><td>返回字符串str最左边的n个字符</td></tr><tr><td>RIGHT(str,n)</td><td>返回字符串str最右边的n个字符</td></tr><tr><td>LPAD(str, len, pad)</td><td>用字符串pad对str最左边进行填充，直到str的长度为len个字符</td></tr><tr><td>RPAD(str ,len, pad)</td><td>用字符串pad对str最右边进行填充，直到str的长度为len个字符</td></tr><tr><td>NULLIF(value1,value2)</td><td>比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1</td></tr></tbody></table><h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>CURRENT_DATE()</td><td>返回当前日期，只包含年、月、日</td></tr><tr><td>CURRENT_TIME()</td><td>返回当前时间，只包含时、分、秒</td></tr><tr><td>NOW()</td><td>返回当前系统日期和时间</td></tr><tr><td>UTC_DATE()</td><td>返回UTC（世界标准时间）日期</td></tr><tr><td>UTC_TIME()</td><td>返回UTC（世界标准时间）时间</td></tr></tbody></table><p>下面的是解析日期和时间的，需要配合上面的函数嵌套使用。</p><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>YEAR(date) / MONTH(date) / DAY(date)</td><td>返回具体的日期值</td></tr><tr><td>HOUR(time) / MINUTE(time) / SECOND(time)</td><td>返回具体的时间值</td></tr><tr><td>MONTHNAME(date)</td><td>返回月份：January，…</td></tr><tr><td>DAYNAME(date)</td><td>返回星期几：MONDAY，TUESDAY…..SUNDAY</td></tr><tr><td>WEEKDAY(date)</td><td>返回周几，注意，周1是0，周2是1，。。。周日是6</td></tr><tr><td>QUARTER(date)</td><td>返回日期对应的季度，范围为1～4</td></tr></tbody></table><h3 id="MySQL-信息函数"><a href="#MySQL-信息函数" class="headerlink" title="MySQL 信息函数"></a>MySQL 信息函数</h3><table><thead><tr><th>函数</th><th>用法</th></tr></thead><tbody><tr><td>VERSION()</td><td>返回当前MySQL的版本号</td></tr><tr><td>CONNECTION_ID()</td><td>返回当前MySQL服务器的连接数</td></tr><tr><td>DATABASE()，SCHEMA()</td><td>返回MySQL命令行当前所在的数据库</td></tr><tr><td>USER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER()</td><td>返回当前连接MySQL的用户名，返回结果格式为“主机名@用户名”</td></tr><tr><td>CHARSET(value)</td><td>返回字符串value自变量的字符集</td></tr><tr><td>COLLATION(value)</td><td>返回字符串value的比较规则</td></tr></tbody></table><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>输入多行数据，数据一个数据的聚合函数，一般是配合着 <code>group by</code> 进行分组使用。</p><h3 id="分组查询-group-by-having"><a href="#分组查询-group-by-having" class="headerlink" title="分组查询 group by/having"></a>分组查询 group by/having</h3><p>group by 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。我们需要选择一个column列作为分组的依据，然后这个column中数值相同的数据将会被整合到一行数据中，被整合在一起的数据需要进行合并处理，不然就会报错。</p><p>也就是说，在 SELECT 语句中出现的元素要么为一个聚合函数的输入值，要么为 GROUP BY 语句的参数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column1, aggregate_function(column2) <span class="keyword">as</span> new_column</span><br><span class="line"><span class="keyword">from</span> &quot;table&quot;</span><br><span class="line"><span class="keyword">where</span> column1<span class="operator">=</span>XXX</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> column1</span><br><span class="line"><span class="keyword">having</span> new_column<span class="operator">=</span>XXX;</span><br></pre></td></tr></table></figure><p>这样，会返回一个列出所有不同column1的值为一行数据的表格，其中column1值相同的数据所拥有的column2的值会根据aggregate_function()的功能进行计算，然后出现在那行数据里。</p><hr><p>也可以根据多个列进进行分组查询，分组的组则是依据多个列数据的 distinct。</p><p>列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id dept_id, job_id, <span class="built_in">SUM</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id, job_id;</span><br></pre></td></tr></table></figure><p>分组数量为：<code>distinct department_id, job_id</code>，也就有多少行数据。可以得到不同部门和工作的平均薪水。</p><hr><p><strong>HAVING</strong> 语句！</p><p>如果想要将 聚合函数 返回的新的 column 进行筛选，则在 group by 后面使用 having 语句，使用方法和 where 一样，它会在分组之后，进行一次过滤。</p><p>虽然 having 可以起到 where 的作用，但是两者的效率差距很大，能 where 就不 having，建议参考 MySQL 语句执行顺序，来理解 having。</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>WHERE</td><td>先筛选数据再关联，执行效率高</td><td>不能使用分组中的计算函数进行筛选</td></tr><tr><td>HAVING</td><td>可以使用分组中的计算函数</td><td>在最后的结果集中进行筛选，执行效率较低</td></tr></tbody></table><h3 id="聚合函数-1"><a href="#聚合函数-1" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>注意，只要 SQL 语句中，出现了聚合函数（尤其是 COUNT()），就是分组查询，就需要考虑分组。如果没有设置 group by 分组条件，那么整张表就是一个分组。</p><table><thead><tr><th>函数</th><th>作用数据类型</th><th>用法</th></tr></thead><tbody><tr><td><strong>AVG()</strong></td><td>数值型数据</td><td>求平均数</td></tr><tr><td><strong>SUM()</strong></td><td>数值型数据</td><td>求累加和</td></tr><tr><td><strong>MAX()</strong></td><td>任意数据类型</td><td>求最大值</td></tr><tr><td><strong>MIN()</strong></td><td>任意数据类型</td><td>求最小值</td></tr><tr><td><strong>COUNT()</strong></td><td>任意数据类型</td><td>求数据个数</td></tr></tbody></table><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, <span class="built_in">AVG</span>(salary), <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id; </span><br></pre></td></tr></table></figure><p>是分组查询，不过是 employees 因为没有 group by 的分组条件，所以所有数据都是一组，可以直接得到表的总行数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><hr><p><strong>COUNT()</strong></p><ul><li><p><code>count(*)</code> 返回分组中的数据行数。</p></li><li><p><code>count(column)</code> 返回分组中 column 列不为 NULL 的总数。</p></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul><li>查询各个管理者手下员工的最低工资，其中最低工资不能低于 6000，没有管理者的员工不计算在内 </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> manager_id, <span class="built_in">MIN</span>(salary) <span class="keyword">AS</span> min_salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> manager_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>; <span class="comment">-- where 对非聚合列进行提前过滤</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> manager_id</span><br><span class="line"><span class="keyword">HAVING</span> min_salary <span class="operator">&gt;=</span> <span class="number">6000</span>; <span class="comment">-- having 对聚合列过滤</span></span><br></pre></td></tr></table></figure><hr><ul><li>查询所有部门的名字，location_id，员工数量和平均工资，并按平均工资降序 </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dep.department_name, dep.location_id, <span class="built_in">COUNT</span>(emp.employee_id) <span class="keyword">AS</span> emp_num, <span class="built_in">AVG</span>(emp.salary) <span class="keyword">AS</span> salary_avg</span><br><span class="line"><span class="keyword">FROM</span> departments dep </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees emp</span><br><span class="line"><span class="keyword">ON</span> dep.department_id <span class="operator">=</span> emp.department_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> dep.department_name, dep.location_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> salary_avg <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><hr><ul><li>查询每个工种、每个部门的部门名、工种名和最低工资</li></ul><p>每个工种，每个部门，他们之间需要用 <code>FULL OUT JOIN</code>（MySQL 用 Union 实现），工种 jobs 和 部门 departments 借助 employees 建立连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> dep.department_name, jobs.job_title, <span class="built_in">MIN</span>(emp.salary)</span><br><span class="line"><span class="keyword">FROM</span> departments <span class="keyword">AS</span> dep</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees <span class="keyword">AS</span> emp </span><br><span class="line"><span class="keyword">ON</span> dep.department_id <span class="operator">=</span> emp.department_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> jobs</span><br><span class="line"><span class="keyword">ON</span> jobs.job_id <span class="operator">=</span> emp.job_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> jobs.job_title, dep.department_name</span><br><span class="line"><span class="keyword">UNION</span> </span><br><span class="line"><span class="keyword">SELECT</span> dep.department_name, jobs.job_title, <span class="built_in">MIN</span>(emp.salary)</span><br><span class="line"><span class="keyword">FROM</span> departments <span class="keyword">AS</span> dep</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees <span class="keyword">AS</span> emp </span><br><span class="line"><span class="keyword">ON</span> dep.department_id <span class="operator">=</span> emp.department_id</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> jobs</span><br><span class="line"><span class="keyword">ON</span> jobs.job_id <span class="operator">=</span> emp.job_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> jobs.job_title, dep.department_name;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;流程控制&quot;&gt;&lt;a href=&quot;#流程控制&quot; class=&quot;headerlink&quot; title=&quot;流程控制&quot;&gt;&lt;/a&gt;流程控制&lt;/h2&gt;&lt;p&gt;MySQL 支持简单的流程控制，通过指定的条件判断来执行不同的指令：&lt;/p&gt;
&lt;h3 id=&quot;if-A-B-C&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-00-基本概念</title>
    <link href="https://xorex.space/2022/09/12/8cbfa7ed4017/"/>
    <id>https://xorex.space/2022/09/12/8cbfa7ed4017/</id>
    <published>2022-09-12T09:44:15.000Z</published>
    <updated>2022-10-22T07:57:22.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系型数据库-RDBMS"><a href="#关系型数据库-RDBMS" class="headerlink" title="关系型数据库 RDBMS"></a>关系型数据库 RDBMS</h2><p>RDBMS Related DataBase Management System，关系型数据库。</p><p>MySQL 的关系型，体现的就是不同的表之间，是有数据关系的，一个表将学号和姓名绑定，其他表将班级和姓名绑定，通过这样的方式，表和表之间就建立了关系，可以进行复杂的查询。</p><p>对应的非关系型数据库，就是数据之间彼此独立的，比如 Redis。</p><h2 id="表与表的关系"><a href="#表与表的关系" class="headerlink" title="表与表的关系"></a>表与表的关系</h2><ul><li>有四种：一对一关联、一对多关联、多对多关联、自我引用</li></ul><h3 id="一对一关联"><a href="#一对一关联" class="headerlink" title="一对一关联"></a>一对一关联</h3><ul><li><p>在实际的开发中应用不多，因为一对一可以创建成一张表。</p></li><li><p>举例：设计<code>学生表</code>：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、…</p><ul><li>拆为两个表：两个表的记录是一一对应关系。</li><li><code>基础信息表</code>（常用信息）：学号、姓名、手机号码、班级、系别</li><li><code>档案信息表</code>（不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、…</li></ul></li><li><p>两种建表原则： </p><ul><li>外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。 </li><li>外键是主键：主表的主键和从表的主键，形成主外键关系。</li></ul></li></ul><h3 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h3><ul><li>常见实例场景：<code>客户表和订单表</code>，<code>分类表和商品表</code>，<code>部门表和员工表</code>。</li><li>举例：<ul><li>员工表：编号、姓名、…、所属部门（多）</li><li>部门表：编号、名称、简介（一）</li><li>部门表的一条记录，对应员工表的多条记录。</li></ul></li></ul><ul><li>一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键</li></ul><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>要表示多对多关系，必须创建第三个表，该表通常称为<code>联接表</code>，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。</p><p><img src="https://xorex.space/image/353.jpg" alt="353.jpg"></p><ul><li><strong>举例：学生-课程</strong></li></ul><ol><li><p><code>学生信息表</code>：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别…）和 3 是一对多关系。</p></li><li><p><code>课程信息表</code>：一行代表一个课程的信息（课程编号、授课老师、简介…）和 3 是一对多关系。</p></li><li><p><code>选课信息表</code>：一个学生可以选多门课，一门课可以被多个学生选择。（在这个表中，体现了 1 和 2 的多对多关系）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">学号     课程编号  </span><br><span class="line">1        1001</span><br><span class="line">2        1001</span><br><span class="line">1        1002</span><br></pre></td></tr></table></figure></li></ol><h3 id="自我引用"><a href="#自我引用" class="headerlink" title="自我引用"></a>自我引用</h3><p>一个表的某一列数据，成为这个表的另外一列数据的引用。比如下面的员工的主管编号就是引用本表的员工编号，是表内的自我引用。</p><p><img src="https://xorex.space/image/354.jpg" alt="354.jpg"></p><h2 id="MySQL-目录结构"><a href="#MySQL-目录结构" class="headerlink" title="MySQL 目录结构"></a>MySQL 目录结构</h2><p>重点目录结构有三个：</p><ol><li><code>/etc/mysql/conf.d</code> 存放配置文件。</li><li><code>/logs</code> 存放 MySQL 的执行日志文件。</li><li><code>/var/lib/mysql</code> 存储数据库的数据。</li></ol><h2 id="语言分类"><a href="#语言分类" class="headerlink" title="语言分类"></a>语言分类</h2><p>SQL语言在功能上主要分为如下3大类，定义、操作和控制：</p><ul><li><p><strong>DDL（Data Definition Languages、数据定义语言）</strong>，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。</p><ul><li>主要的语句关键字包括<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code>等。</li></ul></li><li><p><strong>DML（Data Manipulation Language、数据操作语言）</strong>，用于添加、删除、更新和查询数据库记录，并检查数据完整性。</p><ul><li>主要的语句关键字包括<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>、<code>SELECT</code>等。</li><li><strong>SELECT是SQL语言的基础，最为重要。</strong></li></ul></li><li><p><strong>DCL（Data Control Language、数据控制语言）</strong>，用于定义数据库、表、字段、用户的访问权限和安全级别。</p></li></ul><h2 id="关键词执行顺序："><a href="#关键词执行顺序：" class="headerlink" title="关键词执行顺序："></a>关键词执行顺序：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from</span><br><span class="line">on&#x2F;using</span><br><span class="line">join</span><br><span class="line">where</span><br><span class="line">group by</span><br><span class="line">having</span><br><span class="line">select</span><br><span class="line">distinct</span><br><span class="line">union</span><br><span class="line">order by</span><br><span class="line">limit</span><br></pre></td></tr></table></figure><p>比如，对于我们手写的 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">&lt;</span>select_list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>join_type<span class="operator">&gt;</span> <span class="keyword">join</span> <span class="operator">&lt;</span>join_table<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">where</span> <span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">having</span> <span class="operator">&lt;</span>having_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>order_by_condition<span class="operator">&gt;</span></span><br><span class="line">limit <span class="operator">&lt;</span>limt_number<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>会这样处理：</p><ol><li>第一步：加载 from 子句的前两个表计算笛卡尔积，生成虚拟表 vt1；</li><li>第二步：筛选关联表符合 on 表达式的数据，保留主表，生成虚拟表 vt2；</li><li>第三步：如果使用的是外连接，执行 on 的时候，会将主表中不符合 on 条件的数据也加载进来，做为外部行</li><li>第四步：如果 from 子句中的表数量大于 2，则重复第一步到第三步，直至所有的表都加载完毕，更新 vt3；</li><li>第五步：执行 where 表达式，筛选掉不符合条件的数据生成 vt4；</li><li>第六步：执行 group by 子句。group by 子句执行过后，会对子句组合成唯一值并且对每个唯一值只包含一行，生成 vt5,。一旦执行 group by，后面的所有步骤只得到 vt5 中的列（group by 的子句包含的列）和聚合函数。</li><li>第七步：执行聚合函数，生成 vt6；</li><li>第八步：执行 having 表达式，筛选 vt6 中的数据。having 是唯一一个在分组后的条件筛选，生成 vt7;</li><li>第九步：从 vt7 中筛选列，生成 vt8；</li><li>第十步：执行 distinct，对 vt8 去重，生成 vt9。其实执行过 group by 后就没必要再去执行 distinct，因为分组后，每组只会有一条数据，并且每条数据都不相同。</li><li>第十一步：对 vt9 进行排序，此处返回的不是一个虚拟表，而是一个游标，记录了数据的排序顺序，此处可以使用别名；</li><li>第十二步：执行 limit 语句，将结果返回给客户端</li></ol><h2 id="MySQL-对象"><a href="#MySQL-对象" class="headerlink" title="MySQL 对象"></a>MySQL 对象</h2><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>表(TABLE)</td><td>表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</td></tr><tr><td>数据字典(INFORMATION_SCHEMA)</td><td>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看</td></tr><tr><td>约束(CONSTRAINT)</td><td>执行数据校验的规则，用于保证数据完整性的规则</td></tr><tr><td>视图(VIEW)</td><td>一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</td></tr><tr><td>索引(INDEX)</td><td>用于提高查询性能，相当于书的目录</td></tr><tr><td>存储过程(PROCEDURE)</td><td>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</td></tr><tr><td>存储函数(FUNCTION)</td><td>用于完成一次特定的计算，具有一个返回值</td></tr><tr><td>触发器(TRIGGER)</td><td>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关系型数据库-RDBMS&quot;&gt;&lt;a href=&quot;#关系型数据库-RDBMS&quot; class=&quot;headerlink&quot; title=&quot;关系型数据库 RDBMS&quot;&gt;&lt;/a&gt;关系型数据库 RDBMS&lt;/h2&gt;&lt;p&gt;RDBMS Related DataBase Managem</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL-03-多表查询</title>
    <link href="https://xorex.space/2022/09/12/c541195ff16d/"/>
    <id>https://xorex.space/2022/09/12/c541195ff16d/</id>
    <published>2022-09-12T01:42:57.000Z</published>
    <updated>2022-09-24T07:24:43.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序-ORDER-BY"><a href="#排序-ORDER-BY" class="headerlink" title="排序 ORDER BY"></a>排序 ORDER BY</h2><p>排序语句，将要显示的数据按照自己要求的规则进行排序。</p><p>将 SELECT 出来的数据，按照指定的列值进行排序，ASC 为从小到大，DESC 为从大到小，如果不写排序方式，则默认为 ASC，从小到大。</p><p>ASC全称<strong>ascend</strong> ，为升序的意思，即从小到大。</p><p>DESC全程<strong>descend</strong>，为降序的意思，即从大到小。</p><hr><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;table&quot;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> column1 <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span>, column2 <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>如果 <code>ORDER BY</code> 后面有多个列，则满足 column1 的排序规则后，对于 column1 相等的列则进行 column2 的排序。</p><h3 id="排序依据"><a href="#排序依据" class="headerlink" title="排序依据"></a>排序依据</h3><p>对于 ORDER BY 后面跟着 FROM 表里面的 column 的，就可以直接找到对应的数据，作为排序依据。</p><p>如果利用关系子查询返回的内容作为排序依据，那么则会执行子查询，返回结果作为本行的排序依据。</p><h2 id="分页-LIMIT"><a href="#分页-LIMIT" class="headerlink" title="分页 LIMIT"></a>分页 LIMIT</h2><p>用来只显示一段指定的查询出来的结果，只能放在语句末尾。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>LIMIT [位置偏移量,] 行数</code></p><ul><li>第一个 “位置偏移量” 参数指示 MySQL 从哪一行开始显示，是一个可选参数，如果不指定 “位置偏移量” ，将会从表中的第一条记录开始（第一条记录的位置偏移量是 0，第二条记录的位置偏移量是 1，以此类推）；第二个参数 “行数” 指示返回的记录条数。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--前10条记录：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--第21至30条记录： </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名 LIMIT <span class="number">20</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>约束返回结果的数量可以 <code>减少数据表的网络传输量</code>，也可以 <code>提升查询效率</code> 。如果我们知道返回结果只有 1 条，就可以使用 <code>LIMIT 1</code> ，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。</p><h2 id="多表查询概念"><a href="#多表查询概念" class="headerlink" title="多表查询概念"></a>多表查询概念</h2><p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p><p>前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段。</p><p>通过多表查询可以从多个表得到对应的完整数据，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.a table2.b <span class="keyword">FROM</span> table1, table2。</span><br></pre></td></tr></table></figure><hr><p>举个栗子：</p><p>我们有员工表和部门表，我们想要知道所有员工的部门信息（员工对部门为 多对一 关系），就需要多表查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.last_name, departments.department_name <span class="comment">-- 要查询的信息为两个表的列</span></span><br><span class="line"><span class="keyword">FROM</span> employees, departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id; <span class="comment">-- 两个表的连接条件</span></span><br></pre></td></tr></table></figure><h3 id="多表查询-表名前缀"><a href="#多表查询-表名前缀" class="headerlink" title="多表查询-表名前缀"></a>多表查询-表名前缀</h3><p>因为是多表查询，所以可能会涉及到两个表有字段名字相同，所以可以在表中有相同列时，在列名之前加上表名前缀来区分。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.a table2.b <span class="keyword">FROM</span> table1, table2。</span><br></pre></td></tr></table></figure><h3 id="多表查询-分类"><a href="#多表查询-分类" class="headerlink" title="多表查询-分类"></a>多表查询-分类</h3><h4 id="等值连接-和-非等值连接"><a href="#等值连接-和-非等值连接" class="headerlink" title="等值连接 和 非等值连接"></a>等值连接 和 非等值连接</h4><p>是看两个表的连接条件是否为 相等。</p><ul><li><p>等值连接：连接条件为字段的值相等。</p></li><li><p>非等值连接：连接条件为非相等符号，一般来说是一个区间范围。</p></li></ul><p>比如，工资等级表 和 员工工资 进行连接，那就是 员工工资 满足 工资等级表 的两个值之间的范围就可以连接起来：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name, e.salary, j.grade_level</span><br><span class="line"><span class="keyword">FROM</span>   employees e, job_grades j</span><br><span class="line"><span class="keyword">WHERE</span>  e.salary <span class="keyword">BETWEEN</span> j.lowest_salary <span class="keyword">AND</span> j.highest_salary; </span><br><span class="line"><span class="comment">-- 连接条件为一个区间，而不是等号。</span></span><br></pre></td></tr></table></figure><h4 id="自连接-和-非自连接"><a href="#自连接-和-非自连接" class="headerlink" title="自连接 和 非自连接"></a>自连接 和 非自连接</h4><ul><li><p>非自连接：就是这里的多表查询，利用了表之间的 N 对 N 关系（除了自我引用以外的所有关系）。</p></li><li><p>自连接：单表查询，但是连接的对象是一张表里面的两个字段。利用了这张表的自我引用的关系。</p></li></ul><p>比如，一张表里面有所有的人信息，我们想要通过每个人的 manager_id 和 其他人的 employee_id 进行连接，从而获取每个人的上司的名字，整个过程是一个表的自连接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> concat(worker.last_name ,<span class="string">&#x27; works for &#x27;</span> </span><br><span class="line">       , manager.last_name)</span><br><span class="line"><span class="keyword">FROM</span>   employees worker, employees manager</span><br><span class="line"><span class="keyword">WHERE</span>  worker.manager_id <span class="operator">=</span> manager.employee_id ;</span><br></pre></td></tr></table></figure><h4 id="内连接-和-外连接"><a href="#内连接-和-外连接" class="headerlink" title="内连接 和 外连接"></a>内连接 和 外连接</h4><ul><li><p>内连接: 合并具有同一列的两个以上的表的行, <strong>结果集中不包含一个表与另一个表不匹配的行</strong>，也就是不满足 WHERE 条件的<strong>其他所有行数据</strong>，都不会出现在结果中。</p></li><li><p>外连接: 两个表在连接过程中除了返回满足连接条件的行以外<strong>还返回左（或右）表中不满足条件的行</strong> <strong>，这种连接称为左（或右） 外连接</strong>。没有匹配的行时, 结果表中相应的列为空(NULL)。</p></li><li><p>如果是左外连接，则连接条件中左边的表也称为<code>主表</code>，右边的表称为<code>从表</code>。</p></li><li><p>如果是右外连接，则连接条件中右边的表也称为<code>主表</code>，左边的表称为<code>从表</code>。</p></li></ul><p>内连接可用 WHERE 直接连接，或者 Inner Join ON 连接。</p><p>外连接用 Left/Right Join On 进行。</p><h3 id="多表查询-笛卡尔积错误"><a href="#多表查询-笛卡尔积错误" class="headerlink" title="多表查询-笛卡尔积错误"></a>多表查询-笛卡尔积错误</h3><p>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。</p><p>如果在多表查询中，出现了部分行或者全部行的数据进行了笛卡尔积组合，那么就说明这个多表查询出现了连接错误。可能原因：</p><ul><li>省略多个表的连接条件（或关联条件）</li><li>连接条件（或关联条件）无效</li><li>所有表中的所有行互相连接</li></ul><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.last_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees, departments</span><br></pre></td></tr></table></figure><p>查询结果为两个表所有行数据组合，数量为两个表的行数乘积。</p><p>如果加上连接条件，结果就是 多对一 中多的那个行数了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.last_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees, departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id; </span><br></pre></td></tr></table></figure><p>连接条件是用来消除不符合要求的笛卡尔积组合的，如果连接条件没有设好，那么就会出现不符合要求的笛卡尔积组合。</p><h3 id="多表查询实现（99-标准）"><a href="#多表查询实现（99-标准）" class="headerlink" title="多表查询实现（99 标准）"></a>多表查询实现（99 标准）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;</span><br></pre></td></tr></table></figure><p>多个表之间的连接查询，只需要 table 1 join table2 之后，再将结果 join table3 就实现了三个表的连接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> table1.column, table2.column,table3.column</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line">    <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1 和 table2 的连接条件</span><br><span class="line">        <span class="keyword">JOIN</span> table3 <span class="keyword">ON</span> table2 和 table3 的连接条件</span><br></pre></td></tr></table></figure><h3 id="内查询"><a href="#内查询" class="headerlink" title="内查询"></a>内查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.last_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees, departments</span><br><span class="line"><span class="keyword">WHERE</span> employees.department_id <span class="operator">=</span> departments.department_id; </span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employees.last_name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">INNER</span> <span class="keyword">JOIN</span>  departments </span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id; </span><br></pre></td></tr></table></figure><h3 id="外查询"><a href="#外查询" class="headerlink" title="外查询"></a>外查询</h3><p><img src="https://xorex.space/image/116.png"></p><p>假设我们要查询 employees A departments B 两个表的 employee_id last_name department_name 数据。</p><p>下面是对上图的一个实现：</p><ol><li>中图：内连接 A∩B</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.employee_id, A.last_name, B.department_name </span><br><span class="line"><span class="keyword">FROM</span> employees A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments B</span><br><span class="line"><span class="keyword">ON</span> A.department_id <span class="operator">=</span> B.department_id; </span><br></pre></td></tr></table></figure><ol start="2"><li>左上图：左外连接</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.employee_id, A.last_name, B.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments B </span><br><span class="line"><span class="keyword">ON</span> A.department_id <span class="operator">=</span> B.department_id;</span><br></pre></td></tr></table></figure><ol start="3"><li>右上图：右外连接</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.employee_id, A.last_name, B.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments B </span><br><span class="line"><span class="keyword">ON</span> A.department_id <span class="operator">=</span> B.department_id;</span><br></pre></td></tr></table></figure><ol start="4"><li>左中图：A - A∩B</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.employee_id, A.last_name, B.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments B </span><br><span class="line"><span class="keyword">ON</span> A.department_id <span class="operator">=</span> B.department_id</span><br><span class="line"><span class="keyword">WHERE</span> B.department_name <span class="keyword">IS</span> <span class="keyword">NULL</span>; </span><br><span class="line"><span class="comment">-- A 中没有匹配到 B 中的那一部分，department_name 自然为 NULL</span></span><br></pre></td></tr></table></figure><ol start="5"><li>右中图：B-A∩B</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.employee_id, A.last_name, B.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments B </span><br><span class="line"><span class="keyword">ON</span> A.department_id <span class="operator">=</span> B.department_id</span><br><span class="line"><span class="keyword">WHERE</span> A.last_name <span class="keyword">IS</span> <span class="keyword">NULL</span>; </span><br><span class="line"><span class="comment">-- B 中没有匹配到 A 中的那一部分，last_name 自然为 NULL</span></span><br></pre></td></tr></table></figure><ol start="6"><li>左下图：满外连接</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 左上+右中</span></span><br><span class="line"><span class="keyword">SELECT</span> A.employee_id, A.last_name, B.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments B </span><br><span class="line"><span class="keyword">ON</span> A.department_id <span class="operator">=</span> B.department_id</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="comment">-- 不需要去重</span></span><br><span class="line"><span class="keyword">SELECT</span> A.employee_id, A.last_name, B.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments B </span><br><span class="line"><span class="keyword">ON</span> A.department_id <span class="operator">=</span> B.department_id</span><br><span class="line"><span class="keyword">WHERE</span> A.last_name <span class="keyword">IS</span> <span class="keyword">NULL</span>; </span><br></pre></td></tr></table></figure><ol start="7"><li>右下图</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 左中+右中</span></span><br><span class="line"><span class="keyword">SELECT</span> A.employee_id, A.last_name, B.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments B </span><br><span class="line"><span class="keyword">ON</span> A.department_id <span class="operator">=</span> B.department_id</span><br><span class="line"><span class="keyword">WHERE</span> B.department_name <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="comment">-- 不需要去重</span></span><br><span class="line"><span class="keyword">SELECT</span> A.employee_id, A.last_name, B.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments B </span><br><span class="line"><span class="keyword">ON</span> A.department_id <span class="operator">=</span> B.department_id</span><br><span class="line"><span class="keyword">WHERE</span> A.last_name <span class="keyword">IS</span> <span class="keyword">NULL</span>; </span><br></pre></td></tr></table></figure><h2 id="多表查询练习"><a href="#多表查询练习" class="headerlink" title="多表查询练习"></a>多表查询练习</h2><p>要首先判断目标为某个表 or 两个表的全体成员还是 两个表的有链接成员。（及判断是否需要一部分为 NULL 的数据），从而确定是 OUTER JOIN 还是 INNER JOIN。</p><hr><p>员工表：employees；<br>部门表：departments；<br>位置表：locations；</p><ul><li>显示 <strong>所有</strong> 员工的姓名，部门号和部门名称。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 因为是 所有 员工，所以要覆盖员工所有数据，即使没有连接在部门的那部分。</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.last_name, emp.department_id, dep.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> emp </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments <span class="keyword">AS</span> dep</span><br><span class="line"><span class="keyword">ON</span> emp.department_id <span class="operator">=</span> dep.department_id;</span><br></pre></td></tr></table></figure><hr><ul><li>选择所有有奖金的员工的 last_name , department_name , location_id , city </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 因为还是 所有 员工，所以两次 join 都要保留 emp 表 数据。</span></span><br><span class="line"><span class="keyword">SELECT</span> emp.last_name, dep.department_name, dep.location_id, loc.city</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> emp</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments <span class="keyword">AS</span> dep</span><br><span class="line"><span class="keyword">ON</span> emp.department_id <span class="operator">=</span> dep.department_id</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> locations <span class="keyword">AS</span> loc</span><br><span class="line"><span class="keyword">ON</span> dep.location_id <span class="operator">=</span> loc.location_id</span><br><span class="line"><span class="keyword">WHERE</span> emp.commission_pct <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><hr><ul><li>选择指定员工的姓名，员工号，以及他的管理者的姓名和员工号（都在 employees 里），结果类似于下面的格式</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">employees   Emp   manager   Mgr </span><br><span class="line"> kochhar    101    king     100 </span><br></pre></td></tr></table></figure><p>多表查询中的自连接查询，也就是建立连接的是一张表内的两个不同但有关系的字段（员工 id 和它的上司 id）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp.last_name <span class="keyword">AS</span> `employees`, emp.employee_id <span class="keyword">AS</span> Emp, man.last_name <span class="keyword">AS</span> `manager`, man.employee_id <span class="keyword">AS</span> Mgr</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> emp <span class="comment">-- 一张表叫两个名字，方便区分。</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees <span class="keyword">AS</span> man <span class="comment">-- 因为可能有员工没有上司，所以要 LEFT JOIN</span></span><br><span class="line"><span class="keyword">ON</span> emp.manager_id <span class="operator">=</span> man.employee_id;</span><br></pre></td></tr></table></figure><hr><ul><li>查询哪个城市没有部门 </li></ul><p>因为是看那个城市没有部门，所以关注的是 城市 中，无法和部门建立连接的数据，locations 放在 left join 的左边，显示所有城市数据（尤其是连接后 部门相关信息为 null 的）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> loc.city</span><br><span class="line"><span class="keyword">FROM</span> locations <span class="keyword">AS</span> loc</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments <span class="keyword">AS</span> dep</span><br><span class="line"><span class="keyword">ON</span> loc.location_id <span class="operator">=</span> dep.location_id</span><br><span class="line"><span class="keyword">WHERE</span> dep.department_id <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;排序-ORDER-BY&quot;&gt;&lt;a href=&quot;#排序-ORDER-BY&quot; class=&quot;headerlink&quot; title=&quot;排序 ORDER BY&quot;&gt;&lt;/a&gt;排序 ORDER BY&lt;/h2&gt;&lt;p&gt;排序语句，将要显示的数据按照自己要求的规则进行排序。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Car-01-</title>
    <link href="https://xorex.space/2022/09/03/d64b2d671eff/"/>
    <id>https://xorex.space/2022/09/03/d64b2d671eff/</id>
    <published>2022-09-03T11:36:33.000Z</published>
    <updated>2022-09-03T11:36:33.576Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL-02-运算符</title>
    <link href="https://xorex.space/2022/08/25/285f8ca0b985/"/>
    <id>https://xorex.space/2022/08/25/285f8ca0b985/</id>
    <published>2022-08-25T08:35:06.000Z</published>
    <updated>2022-09-23T12:16:04.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DUAL-表"><a href="#DUAL-表" class="headerlink" title="DUAL 表"></a>DUAL 表</h2><p>Dual 是一个为了满足 <code>SELECT xxx FROM xxx</code> 这样格式的一个虚拟的表，可以当做一个表名字来用，如：</p><p><code>SELECT 1+1 FROM DUAL</code>;</p><p>但其实 MySQL 中，不加 <code>FROM xxx</code> 也可以返回对应的运行结果。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>这些都是最基本的算术运算符，可以在 MySQL 中直接使用。其计算结果会作为一个新的列。</p><p><img src="https://xorex.space/image/355.jpg" alt="355.jpg"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> PASSWORD<span class="operator">+</span><span class="number">1</span> <span class="keyword">FROM</span> `<span class="keyword">User</span>`;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">password+1</span><br><span class="line">124</span><br><span class="line">1234</span><br><span class="line">1234</span><br><span class="line">1234</span><br><span class="line">1234</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回 1 ，比较的结果为假则返回 0 ，其他情况则返回 NULL。</p><p>比较运算符经常被用来作为 <strong>SELECT 查询语句的条件</strong> 来使用，返回符合条件的结果记录。</p><p><img src="https://xorex.space/image/365.jpg" alt="365.jpg"></p><p><img src="https://xorex.space/image/366.jpg" alt="366.jpg"></p><h3 id="比较判断规则"><a href="#比较判断规则" class="headerlink" title="= 比较判断规则"></a>= 比较判断规则</h3><p>1 表示 true，0 表示 false。</p><ul><li>在使用等号运算符时，遵循如下规则：<ul><li>如果等号两边的值、字符串或表达式都为字符串，则 MySQL 会按照字符串进行比较，其比较的是每个字符串中字符的 ANSI 编码是否相等。</li><li>如果等号两边的值都是整数，则 MySQL 会按照整数来比较两个值的大小。</li><li>如果等号两边的值一个是整数，另一个是字符串，则 MySQL 会将字符串转化为数字进行比较。</li><li>如果等号两边的值、字符串或表达式中有一个为 NULL，则比较结果为 NULL。</li></ul></li></ul><p>特殊情况：</p><ol><li>字符数字和数字比较：<code>SELECT &quot;20&quot; &gt; 10;</code> 返回的是 1，也就是将字符串转化为数字。</li><li>字符字母和数据比较：<code>SELECT &quot;abc&quot; = 0;</code> 返回的是 1，永远是 1.</li><li>比较一方为 NULL：<code>SELECT NULL = 0;</code> 返回 NULL。</li></ol><h3 id="lt-gt-安全等于运算符"><a href="#lt-gt-安全等于运算符" class="headerlink" title="&lt;=&gt; 安全等于运算符"></a>&lt;=&gt; 安全等于运算符</h3><p>和 = 基本一样，不同的是，对于含有 NULL 的比较，不在返回 NULL。这样相对来说更加安全一点。</p><ol><li>NULL 和 NULL 比较，返回 1：<code>SELECT NULL &lt;=&gt; NULL; 1</code></li><li>NULL 和非 NULL 比较，返回 0：<code>SELECT NULL &lt;=&gt; &quot;NULL&quot;; 0</code></li></ol><h3 id="lt-gt-不等于运算符"><a href="#lt-gt-不等于运算符" class="headerlink" title="&lt;&gt; != 不等于运算符"></a>&lt;&gt; != 不等于运算符</h3><p>不等为 1，相等为 0。如果运算一方含有 NULL，则结果为 NULL。</p><h2 id="其他非符号运算符"><a href="#其他非符号运算符" class="headerlink" title="其他非符号运算符"></a>其他非符号运算符</h2><h3 id="A-is-NULL"><a href="#A-is-NULL" class="headerlink" title="A is NULL"></a>A is NULL</h3><p>判断 A 是否为 NULL，等价于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> A <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">WHERE</span> A <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">WHERE</span> A <span class="operator">=</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">WHERE</span> ISNULL(A);</span><br></pre></td></tr></table></figure><h3 id="A-is-not-NULL"><a href="#A-is-not-NULL" class="headerlink" title="A is not NULL"></a>A is not NULL</h3><p>判断 A 是否不是 NULL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> A <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> A <span class="operator">&lt;=&gt;</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> ISNULL(A)</span><br></pre></td></tr></table></figure><h3 id="A-between-B-and-C"><a href="#A-between-B-and-C" class="headerlink" title="A between B and C"></a>A between B and C</h3><p>B 和 C 需要是相同种类的区间。</p><h3 id="in-A-B-C-not-in-A-B-C"><a href="#in-A-B-C-not-in-A-B-C" class="headerlink" title="in (A,B,C) | not in (A,B,C)"></a>in (A,B,C) | not in (A,B,C)</h3><p>在 A B C 范围内。</p><h3 id="A-like-“Exp”"><a href="#A-like-“Exp”" class="headerlink" title="A like “Exp”"></a>A like “Exp”</h3><p>like 用于进行模糊匹配，有两种符号可以使用:</p><ol><li>可以用 % 来模糊任意个字符</li><li>可以用 _ 下划线，来之模糊下划线部位单个字符。</li></ol><p>符合匹配返回 1，不符合返回 0。如果参与匹配的字符串为 NULL，则返回 NULL：</p><p><code>SELECT NULL LIKE &quot;%NULL%&quot;</code> 返回 NULL。</p><h3 id="A-regexp-“Exp”"><a href="#A-regexp-“Exp”" class="headerlink" title="A regexp “Exp”"></a>A regexp “Exp”</h3><p>加强版本的 like，支持完整的正则表达式！</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>有 AND OR XOR NOT 四种逻辑运算。可以和上面的逻辑比较结果进行逻辑运算。</p><h2 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h2><p>() 优先级最高，不知道怎么写就加括号就行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;DUAL-表&quot;&gt;&lt;a href=&quot;#DUAL-表&quot; class=&quot;headerlink&quot; title=&quot;DUAL 表&quot;&gt;&lt;/a&gt;DUAL 表&lt;/h2&gt;&lt;p&gt;Dual 是一个为了满足 &lt;code&gt;SELECT xxx FROM xxx&lt;/code&gt; 这样格式的一个虚</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-01-SELECT</title>
    <link href="https://xorex.space/2022/08/25/2eb5de0e2c65/"/>
    <id>https://xorex.space/2022/08/25/2eb5de0e2c65/</id>
    <published>2022-08-25T08:18:32.000Z</published>
    <updated>2022-10-10T14:26:02.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>在进行查询的时候，一定要想到 查询结果为空 有重复数据 数据中含有NULL ！</li></ol><h2 id="SQL-命令基本结构"><a href="#SQL-命令基本结构" class="headerlink" title="SQL 命令基本结构"></a>SQL 命令基本结构</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">&lt;</span>select_list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>table_name<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;</span>join_type<span class="operator">&gt;</span> <span class="keyword">join</span> <span class="operator">&lt;</span>join_table<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">where</span> <span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span> <span class="comment">-- 对笛卡尔积后的表进行过滤</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span> <span class="comment">-- 对制定的列的现有组合方式为依据进行分组，非分组依据的列，需要使用聚合函数来显示</span></span><br><span class="line"><span class="keyword">having</span> <span class="operator">&lt;</span>having_condition<span class="operator">&gt;</span>  <span class="comment">-- 对分组后的数据进行过滤，此时可以使用列别名</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>order_by_condition<span class="operator">&gt;</span> <span class="comment">-- 对结果进行排序</span></span><br><span class="line">limit <span class="operator">&lt;</span>limt_number<span class="operator">&gt;</span> <span class="comment">-- 对结果进行分页，只看部分结果</span></span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行注释：# 注释文字(MySQL特有的方式)</span><br><span class="line">单行注释：-- 注释文字(--后面必须包含一个空格。)</span><br><span class="line">多行注释：&#x2F;* 注释文字  *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="关键词冲突"><a href="#关键词冲突" class="headerlink" title="关键词冲突"></a>关键词冲突</h2><p>当名字、数据和 Mysql 关键词冲突的时候，可以使用 `` 来包裹它（着重号），比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &#96;user&#96; # user 是关键词 </span><br></pre></td></tr></table></figure><h2 id="导入数据库文件"><a href="#导入数据库文件" class="headerlink" title="导入数据库文件"></a>导入数据库文件</h2><p>在导入 <code>.sql</code> 文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source D:<span class="operator">/</span>downlaod<span class="operator">/</span>websites.sql;</span><br></pre></td></tr></table></figure><h2 id="别名-AS"><a href="#别名-AS" class="headerlink" title="别名 AS"></a>别名 AS</h2><p>as 是 SQL 语句中的别名，用来给列或者表起一个新的名字。</p><h3 id="列的别名"><a href="#列的别名" class="headerlink" title="列的别名"></a>列的别名</h3><p>比如把两个列相加产生的新数据重新命名为 12sum：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> column1<span class="operator">+</span>column2 <span class="keyword">as</span> <span class="number">12</span>sum <span class="keyword">from</span> &quot;table&quot;;</span><br></pre></td></tr></table></figure><p>在比如把合并的几个字符串产生的新字符串命名为 12add:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> comcat(column1,column2) <span class="keyword">as</span> <span class="number">12</span><span class="keyword">add</span> <span class="keyword">from</span> &quot;table&quot;;</span><br></pre></td></tr></table></figure><p>需要知道的是，因为 where 的计算优先级高于 select，所以在执行 where 的时候  还没有生效，因此无法在 where 中使用设置的别名。如果需要对别名的列进行过滤，则在 where 后面用 having 语句。having 优先级低于 select，此时已经生成了别名列，就可以使用别名了。</p><h3 id="表的别名"><a href="#表的别名" class="headerlink" title="表的别名"></a>表的别名</h3><p>可以给表起一个别名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp.last_name, dep.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees <span class="keyword">AS</span> emp, departments <span class="keyword">AS</span> dep</span><br><span class="line"><span class="keyword">WHERE</span> emp.department_id <span class="operator">=</span> dep.department_id;</span><br></pre></td></tr></table></figure><p>但是需要记住的是，from 语句的执行优先级是最高的，所以表名在最开始就覆盖为了别名，后面就只能使用别名。</p><h2 id="数据去重-distinct"><a href="#数据去重-distinct" class="headerlink" title="数据去重 distinct"></a>数据去重 distinct</h2><p>在 SELECT 后和列名前添加 DISTINCT 关键词，会对后面所有 <strong>列名的组合</strong> 进行去重。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id,salary </span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><h2 id="合并查询结果-UNION"><a href="#合并查询结果-UNION" class="headerlink" title="合并查询结果 UNION"></a>合并查询结果 UNION</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>,... <span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>,... <span class="keyword">FROM</span> table2</span><br></pre></td></tr></table></figure><p>将两个 SELECT 返回的查询结果进行合并为一个结果。合并的两个查询结果对应的列数和数据类型必须相同。可以用来实现 FULL JOIN 的效果。</p><ul><li><code>UNION</code> 对结果进行去重。</li><li><code>UNION ALL</code> 对结果不去重（建议考虑使用，效率高！）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;注意事项&quot;&gt;&lt;a href=&quot;#注意事项&quot; class=&quot;headerlink&quot; title=&quot;注意事项&quot;&gt;&lt;/a&gt;注意事项&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在进行查询的时候，一定要想到 查询结果为空 有重复数据 数据中含有NULL ！&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux-04-磁盘进程软件定时任务</title>
    <link href="https://xorex.space/2022/08/17/f4d82e031af3/"/>
    <id>https://xorex.space/2022/08/17/f4d82e031af3/</id>
    <published>2022-08-17T09:36:22.000Z</published>
    <updated>2022-08-25T03:42:53.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="目录结构-tree"><a href="#目录结构-tree" class="headerlink" title="目录结构 tree"></a>目录结构 tree</h3><p><code>tree /xxx</code> 查看 xxx 目录下递归子目录的所有内容，需要 yum 下载。</p><h3 id="文件大小-du"><a href="#文件大小-du" class="headerlink" title="文件大小 du"></a>文件大小 du</h3><p>du disk usage，可以查看磁盘使用情况。</p><p><code>du -ah /xxx</code> 查看目录下所有文件大小情况。</p><p><code>du -sh /xxx</code> 查看目录下文件总大小</p><p><code>du -ah --max-depth=n</code> 查看目录下 n 层的文件大小情况</p><h3 id="磁盘空间-df"><a href="#磁盘空间-df" class="headerlink" title="磁盘空间 df"></a>磁盘空间 df</h3><p>df disk free 查看当前机器的磁盘空间，剩余量，挂载位置等等。</p><p><code>df -h</code> -h 是 human 的意思，可以让数据方便易懂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        909M     0  909M   0% &#x2F;dev</span><br><span class="line">tmpfs           919M   32K  919M   1% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs           919M   17M  903M   2% &#x2F;run</span><br><span class="line">tmpfs           919M     0  919M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;vda1        50G  4.1G   43G   9% &#x2F;</span><br><span class="line">tmpfs           184M     0  184M   0% &#x2F;run&#x2F;user&#x2F;0</span><br><span class="line">tmpfs           184M     0  184M   0% &#x2F;run&#x2F;user&#x2F;1001</span><br></pre></td></tr></table></figure><p>这里的 <code>/dev.vdal</code> 是挂载的硬盘。 <code>tmpfs</code> 是 temporary file system 的缩写，指的是 内存 和 虚拟内存。<code>devtmpfs</code> 指的是基于内存的文件系统，用来加快系统速度。</p><h3 id="内存空间-free"><a href="#内存空间-free" class="headerlink" title="内存空间 free"></a>内存空间 free</h3><p><code>free -h</code> 查看内存和虚拟内存空间使用情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           1.8G        357M        233M         24M        1.2G        1.2G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure><h3 id="设备挂载查看-lsblk"><a href="#设备挂载查看-lsblk" class="headerlink" title="设备挂载查看 lsblk"></a>设备挂载查看 lsblk</h3><p>lsblk list block 表示展示块设备，也就是挂载的设备。</p><p><code>lsblk -f</code> 详细展示信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1 16.5M  0 rom  </span><br><span class="line">vda    253:0    0   50G  0 disk </span><br><span class="line">└─vda1 253:1    0   50G  0 part &#x2F; </span><br><span class="line"># 硬盘 vda 的第一个也是唯一一个分区，vda1，挂载到 &#x2F; 目录。</span><br></pre></td></tr></table></figure><p>sr0 指的是 scsi rom 0，是设备中存在的一块光盘。</p><p>vda 表示 visual disk A 第一块虚拟硬盘，B 表示第二块。也可能会遇到 sda ，s 表示 sata 接口。</p><h3 id="设备挂载-卸载-mount-umount"><a href="#设备挂载-卸载-mount-umount" class="headerlink" title="设备挂载/卸载 mount/umount"></a>设备挂载/卸载 mount/umount</h3><p>挂在之前需要查看 lsblk 看看是否存在为挂载设备，如果有可以挂载。</p><p><code>mount 设备地址 挂载地址</code> 选项有很多，设备地址一般在 <code>/dev</code> 下面，挂在地址一般设置再 <code>/mnt</code> 目录下。</p><p><code>mount 设备地址/挂载地址</code> 取消挂载。</p><p>比如 <code>mount /dev/cdrom /mnt/cdrom</code> 就是将设备 cdrom 挂载到 mnt 文件夹下面，然后就可以访问设备了。然后 <code>umount /mnt/cdrom</code> 解除挂载。</p><hr><p>如果要实现设备开机自动挂载，在 <code>/etc/fstab</code> file system table 中添加设备即可。</p><h3 id="磁盘分区-fdisk"><a href="#磁盘分区-fdisk" class="headerlink" title="磁盘分区 fdisk"></a>磁盘分区 fdisk</h3><p><code>fdisk -l</code> list 展示磁盘分区信息，内容非常详细。</p><p>当插入一块新的硬盘的时候，需要重启计算机，然后才能看到此硬盘。第一块硬盘结尾是 a，第二块是 b …。硬盘不能够直接被挂载，能够被挂载访问的是硬盘的分区。</p><p>分区过程：</p><ol><li><p><code>fdisk /dev/sdb</code> 对 sdb 新硬盘进行分区管理</p></li><li><p>输入 m 查看帮助。输入 n 进行分区，没有特殊要求一路回车，有特殊要求就研究一下。默认新的分区为 sdb1 设备，表示第一个分区。</p></li><li><p>分完之后输入 w 保存修改。然后就能在 fdisk 中看到分区，但是看不到文件系统信息。</p></li><li><p>然后对新的硬盘分区进行格式化，赋予文件系统。使用 mkfs  make file system 命令： <code>mksf /dev/sdb1</code> 使用的是默认的 ext2 系统，我们可以用 <code>-t ext4</code> 指定最新的文件系统类型。</p></li><li><p>分区完之后就可以被 Linux 识别访问了，这个时候将硬盘分区挂载到想要挂载的目录即可。</p></li></ol><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="查看进程-ps"><a href="#查看进程-ps" class="headerlink" title="查看进程 ps"></a>查看进程 ps</h3><p>ps process status，查看进程状态。<code>ps aux</code> 显示所有进程详细信息，<code>ps -ef</code> 显示进程的父子关系。</p><p>命令返回内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.2 125664  3956 ?        Ss   Jul19   2:42 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd --switched-root --system --desroot         2  0.0  0.0      0     0 ?        S    Jul19   0:00 [kthreadd]</span><br><span class="line">root         4  0.0  0.0      0     0 ?        S&lt;   Jul19   0:00 [kworker&#x2F;0:0H]</span><br><span class="line">root         6  0.0  0.0      0     0 ?        S    Jul19   1:41 [ksoftirqd&#x2F;0]</span><br></pre></td></tr></table></figure><p>USER：该进程是由哪个用户产生的；<br>PID：进程的 ID 号；<br>%CPU：该进程占用 CPU 资源的百分比，占用越高，进程越耗费资源；<br>%MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源；<br>VSZ：该进程占用虚拟内存的大小，单位 KB；<br>RSS：该进程占用实际物理内存的大小，单位 KB；<br>TTY：该进程是在哪个终端中运行的。对于 CentOS 来说，tty1 是图形化终端，tty2-tty6 是本地的字符界面终端。pts/0-255 代表虚拟终端。<br>STAT：进程状态。常见的状态有：R：运行状态、S：睡眠状态、T：暂停状态、Z：僵尸状态、s：包含子进程、l：多线程、+：前台显示、&lt; 高优先级、N 低优先级。<br>START：该进程的启动时间；<br>TIME：该进程占用 CPU 的运算时间，注意不是系统时间；<br>COMMAND：产生此进程的命令名；</p><h3 id="杀掉进程-kill"><a href="#杀掉进程-kill" class="headerlink" title="杀掉进程 kill"></a>杀掉进程 kill</h3><p><code>kill 进程号</code> 终止进程。<code>kill -9 进程号</code> 强行终止进程。</p><h3 id="进程启动树-pstree"><a href="#进程启动树-pstree" class="headerlink" title="进程启动树 pstree"></a>进程启动树 pstree</h3><p><code>pstree -pu</code> p 是 PID，u 是 user。表示 pstree 额外显示进程的 PID 和 User。</p><p>如果进程的所有者 User 和父进程相同，则不会显示 User ，不同才会显示。</p><h3 id="监控进程状态-top"><a href="#监控进程状态-top" class="headerlink" title="监控进程状态 top"></a>监控进程状态 top</h3><p><code>top [选项]</code> 返回实时的进程状态。</p><hr><p>参数：</p><ol><li><code>-d 秒数</code> 指定 top 命令每隔几秒更新。默认是 3 秒在 top 命令的交互模式当<br>中可以执行的命令：</li><li><code>-i</code> 使 top 不显示任何闲置或者僵死进程。</li><li><code>-p</code> 通过指定监控进程 ID 来仅仅监控某个进程的状态。</li></ol><hr><p>操作：（直接摁字母）</p><ol><li>P 以 CPU 使用率排序，默认就是此项</li><li>M 以内存的使用率排序</li><li>N 以 PID 排序</li><li>q 退出 top</li><li>u 显示输入用户的进程</li><li>k 杀掉指定进程，并发送信号 9（等效于 -9）</li></ol><h4 id="网络端口和进程-netstat"><a href="#网络端口和进程-netstat" class="headerlink" title="网络端口和进程 netstat"></a>网络端口和进程 netstat</h4><p><code>netstat -anp | grep 进程号</code> 查看和进程使用的相关端口。</p><p><code>netstat -lnp | grep 端口号</code> 查看端口占用情况。</p><p>参数里面 a 表示 all，所有的端口都显示，无论是否处于监听状态。l 表示 listen，只显示处于监听状态的端口，如果有返回值则被占用。np 是为了更好的显示，不显示别名，显示网路端口占用进程。</p><h2 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h2><p>借助于 crontab 命令，使用之前需要检查负责执行此命令的服务是否在运行：<code>systemctl restart crond</code>。</p><p>-e 编辑 crontab 定时任务<br>-l 查询 crontab 任务<br>-r 删除当前用户所有的 crontab 任务</p><p>剩下的具体设置方法，建议看一些更加详细的博文。</p><h2 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h2><h3 id="管理工具-RPM"><a href="#管理工具-RPM" class="headerlink" title="管理工具 RPM"></a>管理工具 RPM</h3><p>RPM（RedHat Package Manager），RedHat软件包管理工具。这是一个 RPM 包的名称：<code>Apache-1.3.23-11.i386.rpm</code></p><ul><li>“apache” 软件名称</li><li>“1.3.23-11”软件的版本号，主版本和此版本</li><li>“i386”是软件所运行的硬件平台，Intel 32位处理器的统称</li><li>“rpm”文件扩展名，代表RPM包</li></ul><p>此管理工具对应的命令是 <code>rpm</code>。 </p><h4 id="查询-q"><a href="#查询-q" class="headerlink" title="查询 -q"></a>查询 -q</h4><p><code>rpm -qa</code> query all，查询所有安装的应用。</p><p><code>rpm -qi 应用名</code> query information，查询应用的具体安装信息。</p><p>推荐使用 <code>rpm -qa | grep 应用名</code> 来判断是否安装某应用。</p><h4 id="卸载-e"><a href="#卸载-e" class="headerlink" title="卸载 -e"></a>卸载 -e</h4><p><code>rpm -e 应用名</code>  erase，检查应用依赖后再卸载。</p><p><code>rpm -e --nodeps</code> erase with no dependence，不检查依赖，直接卸载应用。</p><h4 id="安装-i"><a href="#安装-i" class="headerlink" title="安装 -i"></a>安装 -i</h4><p>需要有一个完整的 RPM 包，才可以安装。</p><p><code>rpm -ivh 安装包路径</code> install 安装，vh 表示显示详细过程。</p><h3 id="应用商店-yum"><a href="#应用商店-yum" class="headerlink" title="应用商店 yum"></a>应用商店 yum</h3><p>基于 rpm 的一个 下载安装 管理程序，会从默认的服务器下载对应的安装包。</p><ol><li><code>install 软件名</code> 下载安装软件</li><li><code>update 软件名</code> 更新软件</li><li><code>check-update 软件名</code> 查询更新 </li></ol><h3 id="指定连接下载-wget"><a href="#指定连接下载-wget" class="headerlink" title="指定连接下载 wget"></a>指定连接下载 wget</h3><p>全称是 web get，直接输入 <code>wget 资源URL</code> 就会下载到当前目录里面。如果要重命名下载好的文件，则：<code>wget -O 新名字 资源URL</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;磁盘管理&quot;&gt;&lt;a href=&quot;#磁盘管理&quot; class=&quot;headerlink&quot; title=&quot;磁盘管理&quot;&gt;&lt;/a&gt;磁盘管理&lt;/h2&gt;&lt;h3 id=&quot;目录结构-tree&quot;&gt;&lt;a href=&quot;#目录结构-tree&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Linux" scheme="https://xorex.space/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-03-控制符权限用户搜索压缩</title>
    <link href="https://xorex.space/2022/08/16/1a6344401e29/"/>
    <id>https://xorex.space/2022/08/16/1a6344401e29/</id>
    <published>2022-08-16T08:41:45.000Z</published>
    <updated>2022-08-17T09:36:31.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="控制符"><a href="#控制符" class="headerlink" title="控制符"></a>控制符</h2><h3 id="输出重定向-gt-gt-gt"><a href="#输出重定向-gt-gt-gt" class="headerlink" title="输出重定向 &gt; &gt;&gt;"></a>输出重定向 &gt; &gt;&gt;</h3><p><code>order1 &gt; file1</code> 将 order1 返回的内容覆盖写入 file1 中。</p><p><code>order1 &gt;&gt; file1</code> 将 order1 返回的内容追加写入 file1 中。</p><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符 |"></a>管道符 |</h3><p><code>order1 | order2</code> 将 命令1 执行的结果返回给 命令2 作为输入。</p><p>常用和 grep 一起用。</p><h2 id="权限概念"><a href="#权限概念" class="headerlink" title="权限概念"></a>权限概念</h2><h3 id="权限表示"><a href="#权限表示" class="headerlink" title="权限表示"></a>权限表示</h3><p>文件或者目录的权限表示： <code>r-xr-xr-x</code> 每三位一组，分别表示 user group others 所属的权限。 </p><p>u (user) 表示该文件的拥有者，g (group) 表示与该文件的拥有者属于同一个群体者，o (others) 表示其他以外的人，a (all) 表示这三者皆是。</p><p>一组的三位表示权限的意思分别是：r (read) 读取，w (write) 写入，x (executable) 执行，- 表示没有此项权限。文件和目录对于权限的解释是不同的。</p><hr><p>文件：注意拥有文件的 w 权限不代表可以删除文件。要删除文件需要有当前目录的 w 权限才可以。</p><p>目录：r 表示可以 ls 查看目录内容。w 表示可以删除新增重命名新目录或文件。x 表示可以进入当前目录。</p><h3 id="chmod-改变权限"><a href="#chmod-改变权限" class="headerlink" title="chmod 改变权限"></a>chmod 改变权限</h3><p>change mode 改变模式，用来改变文件的权限。</p><ul><li><p>权限作用人 <code>[who]</code> 分为：u (user) 表示该文件的拥有者，g (group) 表示与该文件的拥有者属于同一个群体者，o (others) 表示其他以外的人，a (all) 表示这三者皆是。</p></li><li><p>权限 <code>[mode]</code> 分为：r (read) 读取，w (write) 写入，x (executable) 执行。</p></li></ul><ul><li>权限操作 <code>[operator]</code> 分为：+ 增加权限，- 取消权限， = 表示唯一设定权限（也就是清除所有权限之后再增加设定权限）</li></ul><ol><li>对指定的用户组进行修改</li></ol><p>格式：<code>chmod [who][operator][mode] file</code> 。</p><p>例：<code>chmod u=rw waifu.jpg</code> 命令表示将 waifu.jpg 文件所有者的权限重新设定为只有读写权限。</p><ol start="2"><li>对所有用户组进行修改</li></ol><p>格式：<code>chmod [OperatorNumber][OperatorNumber][OperatorNumber] file</code>。</p><p>上面每一个都表示某一个用户组的权限：第一位表示 user 第二位表示 group 第三位表示 others。</p><p><code>[OperatorNumber]</code> 表示将权限符号用数字替代，没有权限用 - 代表，r 4、w 2、x 1，然后相加就是代表的权限。如 7 表示同时拥有读写执行权限。</p><p>例：<code>chmod 764 waifu.jpg</code>.</p><ol start="3"><li>对文件夹下面的所有文件/目录一起修改权限</li></ol><p><code>chomd -R [OperatorNumber][OperatorNumber][OperatorNumber]</code> -R 递归改变，包括子目录。要慎用此命令。</p><h3 id="改变所属用户和组"><a href="#改变所属用户和组" class="headerlink" title="改变所属用户和组"></a>改变所属用户和组</h3><p>可以将文件绑定的用户和组进行更改，使用 chown 和 chgrp 命令。</p><p><code>chown 用户 文件/目录</code> 更改绑定用户，加上 -R 则是目录递归修改。</p><p><code>chgrp 组名 文件/目录</code> 更改绑定组，加上 -R 则是目录递归修改。</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="添加切换删除修改查看用户"><a href="#添加切换删除修改查看用户" class="headerlink" title="添加切换删除修改查看用户"></a>添加切换删除修改查看用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd 用户名 （功能描述：添加新用户）</span><br><span class="line">useradd -g 组名 用户名 （功能描述：添加新用户到某个组）</span><br></pre></td></tr></table></figure><p>添加完用户之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 用户名 （功能描述：设置用户的密码）</span><br></pre></td></tr></table></figure><hr><p>可以使用 <code>su 用户名</code> 来切换当前登录的用户 switch user。</p><hr><p><code>userdel 用户名</code> 删除用户</p><hr><ul><li><code>usermod -g 用户组 用户名</code> modify 修改用户所在的用户组</li></ul><hr><ul><li><code>cat /etc/passwd</code> 查看所有用户信息。</li></ul><h3 id="sudo-管理员权限"><a href="#sudo-管理员权限" class="headerlink" title="sudo 管理员权限"></a>sudo 管理员权限</h3><p>一般我们禁止使用 root 账号，给一些重要的普通账号执行管理员命令的权限。这些普通账号想要执行管理员命令的时候，要加上 <code>sudo</code> 关键字。</p><p>首先我们需要用 root 账号下发权限给其他账号：修改 <code>/etc/sudoers</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root ALL&#x3D;(ALL) ALL</span><br><span class="line">Xorex ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><p>这样就给普通账户 Xorex 了执行 sudo 的权限，如果想用 root 权限执行命令，则在前面加上 sudo 前缀即可，比如 <code>sudo shutdown</code>。</p><hr><p>需要注意的是，sudo 不能作用在内嵌命令中（cd、history等），因为 sudo 也是外部程序，只能作用与外部程序，而不是自己所在的 bash。那么这个时候就需要想办法绕过这些内嵌命令（用外部命令实现类似的效果）。或者直接开一个 <code>sudo bash</code> 在里面调用内嵌命令，用完 exit 即可。</p><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><blockquote><p>用户组是拥有相同特征的一组用户集合，这里的特征主要指的是 权限。也就是在一个组里面的用户，拥有相同权限。</p></blockquote><ul><li><p><code>groupadd xxxx</code> 创建用户组</p></li><li><p><code>groupdel xxxx</code> 删除用户组</p></li><li><p><code>groupmod -n oldName newName</code> 修改用户组的名字</p></li><li><p><code>cat /etc/group</code> 查看所有用户组信息。</p></li></ul><h3 id="用户组权限管理"><a href="#用户组权限管理" class="headerlink" title="用户组权限管理"></a>用户组权限管理</h3><p>同样可以给用户组 Admin 里面的所有用户授权 sudo 权限：</p><p>就是多了一个 <code>%</code> 表示组名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## Allows people in group wheel to run all commands</span><br><span class="line">%wheel  ALL&#x3D;(ALL) ALL</span><br><span class="line">%Admin  ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><h2 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h2><h3 id="find-文件查找"><a href="#find-文件查找" class="headerlink" title="find 文件查找"></a>find 文件查找</h3><p>find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件显示在终端。</p><p><code>find [搜索范围] [选项]</code> </p><ul><li><p>搜索范围：不写就是从当前目录开始，写了就是从指定目录开始递归查找。</p></li><li><p>选项： <code>-xxx xxx</code> 的形式，前面是选项类别，后面是选项参数。比如 <code>find -name &quot;*.txt&quot;</code>。</p></li></ul><ol><li><code>-name &quot;Regex&quot;</code> 按照指定的文件名查找模式查找文件，如果是正则表达式，一定要加双引号 <code>find -name &quot;*.txt&quot;</code>。</li><li><code>-user 用户名</code> 查找属于指定用户名所有文件 <code>find -user Xorex</code>。</li><li><code>-size +大小 -size -大小</code> 按照指定的文件大小查找文件，单位为: </li></ol><p>b —— 块（512 字节）<br>c —— 字节<br>w —— 字（2 字节）<br>k —— 千字节<br>M —— 兆字节<br>G —— 吉字节</p><p><code>+</code> 表示文件大于此大小，<code>-</code> 表示文件小于此大小。找 10 到 15 MB 之内的文件：<code>find / -size +10M -size -15M</code> 这样。</p><h3 id="locate-路径匹配"><a href="#locate-路径匹配" class="headerlink" title="locate 路径匹配"></a>locate 路径匹配</h3><p>Linux 根据文件路径建立了一个数据库，每天自动更新一次，使用前输入 <code>updatedb</code> 手动更新， locate 命令可以从这个数据库来查找文件和路径，速度很快，但是不支持正则表达式。</p><p>命令：<code>locate 关键字</code> 从路径中找含有关键字的，然后返回。</p><h3 id="whereis-命令查找"><a href="#whereis-命令查找" class="headerlink" title="whereis 命令查找"></a>whereis 命令查找</h3><p>用于查看在环境变量中的命令的位置，<code>whereis vim</code> 就是查找 vim 的地址。</p><h3 id="grep-内容查找"><a href="#grep-内容查找" class="headerlink" title="grep 内容查找"></a>grep 内容查找</h3><p>grep：Global Regular Expression Print 全局正则匹配打印、用来对文件内容进行正则匹配并打印结果。</p><p><code>grep -n StringPattern FileName</code> -n 是显示匹配字符串行号</p><p><code>ls | grep -n &quot;Hello&quot;</code> 利用管道符去匹配命令返回结果。</p><h2 id="压缩包"><a href="#压缩包" class="headerlink" title="压缩包"></a>压缩包</h2><h3 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h3><ul><li><p>压缩：<code>zip 压缩文件名.zip 被压缩文件</code> 或者递归压缩目录，<code>zip -r 压缩文件名.zip 被压缩目录</code>。</p></li><li><p>解压 <code>unzip -d 文件解压目录 压缩文件名.zip</code> -d 用来指定解压位置。</p></li></ul><h3 id="tar-打包"><a href="#tar-打包" class="headerlink" title="tar 打包"></a>tar 打包</h3><p><code>tar</code> 命令用来对文件进行打包，压缩或者解压操作。需要配合各种命令进行操作，格式为：<code>tar -[选项] 压缩文件 源文件/目录</code></p><ul><li><code>-c</code> 创建压缩文件，后面需要写要创建的文件名称，一般后缀是 <code>.tar</code> 。</li><li><code>-x</code> 解压缩文件，后面需要写解压后的文件名称。</li><li><code>-t</code> 查看压缩包里都有什么文件。</li><li><code>-z</code> 使用 Gzip 压缩或者解压，后缀需要是 <code>.tar.gz</code></li><li><code>-v</code> 显示压缩或者解压的过程，强烈推荐使用。</li><li><code>-f</code> 需要被压缩或者解压的文件名，需要被放在最后。</li><li><code>-C</code> 指定解压到的目录。</li></ul><p>这些命令可以组合操作，比如:</p><ul><li><p>压缩：<code>tar -czvf Xorex.tar.gz Xorex</code> 就是将 Xorex 文件夹使用 Gzip 算法压缩成为 Xorex.tar.gz 压缩文件，如果不使用压缩算法，那么就是单纯的打包文件，不进行压缩。</p></li><li><p>解压：<code>tar -xzvf Xorex.tar.gz ./tmp</code> 将压缩文件解压到 <code>./tmp</code> 目录下面。</p></li></ul><hr><p>也可以选择文件进行压缩，只需要后面多写几个源文件即可：</p><p><code>tar -czvf Files.tar.gz file1.txt file2.txt file3.txt</code> 这样三个文件就被打成一个压缩包了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;控制符&quot;&gt;&lt;a href=&quot;#控制符&quot; class=&quot;headerlink&quot; title=&quot;控制符&quot;&gt;&lt;/a&gt;控制符&lt;/h2&gt;&lt;h3 id=&quot;输出重定向-gt-gt-gt&quot;&gt;&lt;a href=&quot;#输出重定向-gt-gt-gt&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Linux" scheme="https://xorex.space/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-02-网络系统目录文件</title>
    <link href="https://xorex.space/2022/08/03/e6fbbee5ed4f/"/>
    <id>https://xorex.space/2022/08/03/e6fbbee5ed4f/</id>
    <published>2022-08-03T08:10:16.000Z</published>
    <updated>2022-08-17T14:09:21.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络方面"><a href="#网络方面" class="headerlink" title="网络方面"></a>网络方面</h2><p>如果我们要修改网络配置的话，需要改相应的配置文件，配置文件在 <code>/etc</code> 目录下面，网络的话就是 <code>/etc/sysconfig/network-scripts/</code> </p><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>我们可以用 ifconfig （interfaces config）命令显示网络设备。下面是显示内容详解：</p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>eth0</td><td>网卡设备号</td></tr><tr><td>Link encap</td><td>基本描述，链接概况</td></tr><tr><td>HWaddr</td><td>硬件MAC地址</td></tr><tr><td>inet addr</td><td>网络ip地址</td></tr><tr><td>Bcast</td><td>广播ip地址</td></tr><tr><td>Mask</td><td>子网掩码</td></tr><tr><td>inet6 addr</td><td>对应的ipv6地址</td></tr><tr><td>Scope</td><td>作用域，范围</td></tr><tr><td>UP</td><td>网卡已经启用</td></tr><tr><td>BROADCAST</td><td>支持多播</td></tr><tr><td>RUNNING</td><td>网卡正在运行</td></tr><tr><td>MULTICAST</td><td>支持多播</td></tr><tr><td>MTU</td><td>最大传输单元</td></tr><tr><td>Metric</td><td>度量值，用于估算路由成本</td></tr><tr><td>RX packets:</td><td>接收正确的数据包数</td></tr><tr><td>errors:</td><td>错误的数据包数</td></tr><tr><td>dropped</td><td>接收丢弃的数据包数</td></tr><tr><td>overruns:</td><td>接收时由于过速丢弃的数据包数</td></tr><tr><td>frame:</td><td>接收时，由于frame错误而丢弃的数据包数</td></tr><tr><td>TX packets</td><td>发送时正确的数据包数</td></tr><tr><td>errors:</td><td>接收时错误的数据包数</td></tr><tr><td>dropped:</td><td>接收时，丢弃的数据包数</td></tr><tr><td>overruns:</td><td>发送时，由于过速丢弃的数据包数</td></tr><tr><td>carrier:</td><td>发送时，由于carrier错误而丢弃的数据包数</td></tr><tr><td>collisions:</td><td>冲突信息包的数目</td></tr><tr><td>txqueuelen:</td><td>发送队列的大小，此处是1000MB</td></tr><tr><td>RX bytes:</td><td>接收的数据包数</td></tr><tr><td>TX bytes:</td><td>发送的数据包数</td></tr><tr><td>Interrupt</td><td>IRQ中断地址</td></tr><tr><td>Base address</td><td>基址</td></tr></tbody></table><p>由于使用 ifconfig 的修改都是临时修改，重启就失效，所以建议去修改 <code>/etc/sysconfig/network-scripts/</code> 下面的配置文件然后重启 network 服务，实现永久修改的效果。</p><h3 id="修改-IP-地址"><a href="#修改-IP-地址" class="headerlink" title="修改 IP 地址"></a>修改 IP 地址</h3><p><code>/etc/sysconfig/network-scripts/</code> 下面的 <code>ifcfg-eth0</code> 文件，是网卡的配置文件。</p><p>只需要将 DHCP 协议 修改为静态分配 IP 即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">BOOTPROTO</span>=<span class="string">&quot;dhcp&quot; -&gt; BOOTPROTO=&quot;static&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后加上下面的配置：</span></span><br><span class="line"><span class="comment">#IP 地址</span></span><br><span class="line"><span class="attr">IPADDR</span>=<span class="string">192.168.1.100</span></span><br><span class="line"><span class="comment">#网关</span></span><br><span class="line"><span class="attr">GATEWAY</span>=<span class="string">192.168.1.2</span></span><br><span class="line"><span class="comment">#域名解析器</span></span><br><span class="line"><span class="attr">DNS1</span>=<span class="string">192.168.1.2</span></span><br></pre></td></tr></table></figure><p>记得修改完一样东西，需要重启它才能生效。<code>service network restart</code></p><h3 id="修改-hosts"><a href="#修改-hosts" class="headerlink" title="修改 hosts"></a>修改 hosts</h3><p>hosts 文件就在 <code>/etc/</code> 下面，用 vim 修改此文件即可，然后重启网络服务。</p><h3 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h3><p>修改 <code>/etc/hostname</code> 文件，然后重启主机。</p><p>或者用命令 <code>hostnamectl set-hostname XXXX</code> 来修改，无需重启。</p><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><p>在 Linux 中原本是编写服务的 init.d 文件，然后来管理系统服务的，但是这样并不好用，后来引入了 Systemd 进行管理。字母 d 是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>常驻内存的进程，是 守护进程 daemon，也被叫做 服务 Service。</p><p>一个守护进程要被注册为 服务，则需要配置 <code>.service</code> 文件到 <code>/etc/systemd/system/</code> 文件夹下面，这样就被注册为了一个服务。推荐使用 Systemd 体系下面的 systemctl 命令开控制服务的启动关闭等。</p><p>可以划分一系列的 <code>.service</code> 为一个集合，称之为 <code>.target</code>。通过 target 来启动一系列的 service 从而实现某个具体的目标。</p><p>Systemd 默认从目录 <code>/etc/systemd/system/</code> 读取服务的配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 <code>/usr/lib/systemd/system/</code> ，真正的配置文件存放在那个目录。</p><h3 id="Linux-启动级别"><a href="#Linux-启动级别" class="headerlink" title="Linux 启动级别"></a>Linux 启动级别</h3><p>0 halt 关机，代表系统停机状态，默认情况下，系统运行级别不能设置为0，否则电脑一开机就进入关机模式，电脑将不能正常启 动<br>1 Single user mode 单用户模式，只支持root账户，主要用于系统维护，禁止远程登陆，类似于Windows下的安全模式<br>2 Multiuser，without NFS 它是多用户模式，没有网络文件系统支持<br>3 Full Multiuser mode 完全多用户模式，有网络文件系统，用户登录后进入控制台命令行模式，在没有网络的环境下等同于运行级别2<br>4 unused 系统未使用，用作保留，一般不用，在一些特殊情况下可以用它来做一些事情，例如：在笔记本电脑的电池用尽时，可以切换到这一模式来做一些设置<br>5 X11 图形界面的多用户模式用户登录后直接进入X-Window系统<br>6 Reboot 重启，默认情况下，运行级别不能设为6，否则电脑一开机就进入重启模式会一直不停地重启，系统将不能正常的启动</p><p><code>systemctl get-default</code> 命令可以查询当前所处状态。</p><p>multi-user.target 等价于原运行级别 3（多用户有网，无图形界面）<br>graphical.target 等价于原运行级别 5（多用户有网，有图形界面）</p><p>这两个 <code>.target</code> 一系列对应运行级别的 service 的集合。</p><h3 id="服务开机自启"><a href="#服务开机自启" class="headerlink" title="服务开机自启"></a>服务开机自启</h3><p>输入命令 <code>setup</code> 进入远程登陆 GUI 页面（也就是 Linux 启动级别 5），里面可以通过空格控制服务是否开机自启。</p><h3 id="关机-重启"><a href="#关机-重启" class="headerlink" title="关机/重启"></a>关机/重启</h3><p>Linux 为了优化系统性能，对于硬盘的读写是有缓存区的。也就是不会立刻写入，只有缓存区满了，或者执行了 sync 命令，才会去写入硬盘。</p><p>（1）sync （功能描述：将数据由内存同步到硬盘中）<br>（2）halt （功能描述：停机，关闭系统，但不断电）<br>（3）poweroff （功能描述：关机，断电）<br>（3）reboot （功能描述：就是重启）<br>（4）shutdown time （功能描述：一段时间后 poweroff）</p><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="查看目录-ls"><a href="#查看目录-ls" class="headerlink" title="查看目录 ls"></a>查看目录 ls</h3><p><code>ls ./*</code> 这个符号 <code>*</code> 表示的是正则匹配，<code>file*</code> 就是匹配所有以<code>file</code> 开头的文件或者目录，如果只有 <code>*</code> 那就是匹配所有名称的文件或者目录。</p><h3 id="工作目录切换命令"><a href="#工作目录切换命令" class="headerlink" title="工作目录切换命令"></a>工作目录切换命令</h3><ol><li><p><code>pwd</code> 返回现在所处位置（Print Working Director）</p></li><li><p><code>cd</code> 切换工作目录 （change director）</p><ul><li><code>cd location</code> 打开对应的目录（文件夹）</li><li><code>cd ..</code> 返回上一级目录</li><li><code>cd ~</code> 可以快速返回当前用户的家目录里面。</li><li>如果路径里面包含有空格/问号/星号/货币符/逻辑符/括号，可以使用 <code>\</code> 来进行转义，让它变成路径名称而不是特殊字符。或者直接用双引号把路径名称名称括起来，<code>cd &quot;特殊字符的路径&quot;</code> 。</li></ul></li></ol><h3 id="文件目录管理"><a href="#文件目录管理" class="headerlink" title="文件目录管理"></a>文件目录管理</h3><ol><li><p><code>touch &lt;file&gt;</code> 可以创建一个新的空白文档。</p></li><li><p><code>mkdir &lt;director&gt;</code> 可以创建一个新的文件夹。</p><ul><li><code>mkdir -p &lt;director1/director2/directro3&gt;</code>可以创造嵌套的文件夹（parents）。</li></ul></li><li><p><code>cp &lt;file1/dire1&gt; &lt;file2/dire2&gt;</code> 复制 file1 或 dire1 到 dire2 目录或者到本地但是重命名为 file2。</p><ul><li><code>cp -r &lt;dir1&gt; &lt;dir2&gt;</code> recursive 递归，递归的复制目录过去（完全复制）</li></ul></li><li><p><code>mv &lt;file1/dire1&gt; &lt;file2/dire2&gt;</code> 移动 file1 或 dire1 到 dire2 目录或者到本地但是重命名为 file2。</p></li><li><p><code>rm &lt;file/dire&gt;</code> 命令用于删除文件或者目录。</p><ul><li><code>rm -r &lt;fire/dire&gt;</code> recursive 递归，用来递归删除目录，不适用 <code>-r</code> 没有办法删除。</li></ul></li><li><p><code>file &lt;filename&gt;</code> 命令用来查看文件的类型。</p><ul><li><code>&lt;filename&gt;</code> 可以使用 <code>*</code> 来进行正则匹配。</li></ul></li></ol><h2 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h2><h3 id="cat-查看小文本"><a href="#cat-查看小文本" class="headerlink" title="cat 查看小文本"></a>cat 查看小文本</h3><p>cat 是 catch 捕捉 的缩写。可以查看文件和拼接文件。</p><ul><li><p><code>cat -n &lt;file&gt;</code>在查看文本文件的同时标注行号。</p><ul><li>如果文件名用 <code>-</code> 开头，使用 <code>./-</code> 来打开</li><li>如果文件里面包含有空格/问号/星号/货币符/逻辑符/括号，可以使用 <code>cat &quot;特殊的文件名称&quot;</code> 。</li></ul></li><li><p><code>cat &gt; XXX</code> 创建一个名为 XXX 的新文件，并编辑其内容。</p><ul><li><code>cat XXX1 XXX2 &gt; XXX3</code> 将 XXX1 文件和 XXX2 文件的内容合并起来，覆盖 XXX3 文件。</li></ul></li></ul><h3 id="less-查看大文本"><a href="#less-查看大文本" class="headerlink" title="less 查看大文本"></a>less 查看大文本</h3><p>less 在查看大文件非常好用，可以一页一页显示。</p><table><thead><tr><th>语法</th><th>功能</th></tr></thead><tbody><tr><td>f</td><td>Front 向下翻一页</td></tr><tr><td>b</td><td>Back 向回翻一页</td></tr><tr><td>G</td><td>光标移动到最后一行</td></tr><tr><td>g</td><td>光标移动到第一行</td></tr><tr><td>/[Regex]</td><td>按照正则表达式匹配文本内容，n 下一个 N 上一个</td></tr><tr><td>q</td><td>退出 less</td></tr></tbody></table><h3 id="查看文件头和文件尾"><a href="#查看文件头和文件尾" class="headerlink" title="查看文件头和文件尾"></a>查看文件头和文件尾</h3><p><code>head fileName</code> 查看文件头前 5 行的内容。</p><p><code>tail fileName</code> 查看文件尾 10 行的内容。<code>tail -f fileName</code> follow 实时显示文件最后 10 行内容，vim 修改则无法追踪。</p><h3 id="ln-软连接"><a href="#ln-软连接" class="headerlink" title="ln 软连接"></a>ln 软连接</h3><p>软链接也称为符号链接，类似于 windows 里的快捷方式，是一种特殊的文件，指向其他文件。</p><p><code>ln -s [原文件或目录] [软链接名]</code> 创建一个新的软连接 link soft。</p><p><code>rm -rf 软链接名</code>，删除软连接文件，连接文件名不要加上 /，否则会访问绑定的文件夹然后删掉里面的东西。</p><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>比如我们用 ls -l 可以看到的文件信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">文件类型和权限  文件个数    所有者  所有组  大小</span><br><span class="line">lrwxrwxrwx.     1           root root     7 Mar  7  2019 bin -&gt; usr&#x2F;bin</span><br><span class="line">dr-xr-xr-x.     5           root root  4096 Feb  6  2022 boot</span><br><span class="line">drwxr-xr-x      2           root root  4096 Nov  5  2019 data</span><br><span class="line">drwxr-xr-x     19           root root  2980 Jul 19 10:14 dev</span><br><span class="line">drwxr-xr-x.    92           root root 12288 Aug 16 20:29 etc</span><br><span class="line">drwxr-xr-x.     4           root root  4096 Aug 16 20:29 home</span><br><span class="line">lrwxrwxrwx.     1           root root     7 Mar  7  2019 lib -&gt; usr&#x2F;lib</span><br><span class="line">lrwxrwxrwx.     1           root root     9 Mar  7  2019 lib64 -&gt; usr&#x2F;lib64</span><br><span class="line">drwx------.     2           root root 16384 Mar  7  2019 lost+found</span><br><span class="line">drwxr-xr-x.     2           root root  4096 Apr 11  2018 media</span><br><span class="line">drwxr-xr-x.     2           root root  4096 Apr 11  2018 mnt</span><br><span class="line">drwxr-xr-x.     4           root root  4096 Jun 27 19:30 opt</span><br><span class="line">dr-xr-xr-x    102           root root     0 Jul 19 10:14 proc</span><br><span class="line">dr-xr-x---.     8           root root  4096 Aug 16 20:48 root</span><br><span class="line">drwxr-xr-x     29           root root  1040 Aug 12 02:33 run</span><br><span class="line">lrwxrwxrwx.     1           root root     8 Mar  7  2019 sbin -&gt; usr&#x2F;sbin</span><br><span class="line">drwxr-xr-x.     2           root root  4096 Apr 11  2018 srv</span><br><span class="line">dr-xr-xr-x     13           root root     0 Aug  3 18:13 sys</span><br><span class="line">drwxrwxrwt.    10           root root  4096 Aug 16 20:56 tmp</span><br><span class="line">drwxr-xr-x.    13           root root  4096 Mar  7  2019 usr</span><br><span class="line">drwxr-xr-x.    19           root root  4096 Jan 14  2022 var</span><br><span class="line">drwxr-xr-x      7           root root  4096 Jan 14  2022 www</span><br></pre></td></tr></table></figure><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><table><thead><tr><th>文件属性</th><th>文件类型</th></tr></thead><tbody><tr><td>-</td><td>常规文件，即 file</td></tr><tr><td>d</td><td>directory 目录文件</td></tr><tr><td>b</td><td>block device 即块设备文件，如硬盘;支持以 block 为单位进行随机访问</td></tr><tr><td>c</td><td>character device 即字符设备文件，如键盘鼠标支持以 character 为单位进行线性访问</td></tr><tr><td>l</td><td>symbolic link 即符号链接文件，又称软链接文件</td></tr><tr><td>p</td><td>pipe 即命名管道文件</td></tr><tr><td>s</td><td>socket 即套接字文件，用于实现两个进程进行通信</td></tr></tbody></table><h3 id="文件个数"><a href="#文件个数" class="headerlink" title="文件个数"></a>文件个数</h3><p>对于文件夹来说是里面包括隐藏文件在内的个数，其他则都显示 <strong>指向它</strong> 的连接文件个数。</p><h3 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h3><p>这个大小在不同类型的文件有有不同的意义：</p><ol><li>对于普通文件，显示的是文件的大小（byte 字节数）</li><li>对于设备文件是指主设备号（第 6 列为次设备号）</li><li>对于目录，是指目录大小（目录内 inode 列表所占空间 4096 bit，而不是目录内文件所占的空间大小）</li><li>对于符号链接，是指链接文件的路径名的 byte 字节数</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网络方面&quot;&gt;&lt;a href=&quot;#网络方面&quot; class=&quot;headerlink&quot; title=&quot;网络方面&quot;&gt;&lt;/a&gt;网络方面&lt;/h2&gt;&lt;p&gt;如果我们要修改网络配置的话，需要改相应的配置文件，配置文件在 &lt;code&gt;/etc&lt;/code&gt; 目录下面，网络的话就是 &lt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Linux" scheme="https://xorex.space/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-01-基础概念</title>
    <link href="https://xorex.space/2022/08/03/9be090c95d2b/"/>
    <id>https://xorex.space/2022/08/03/9be090c95d2b/</id>
    <published>2022-08-03T08:05:09.000Z</published>
    <updated>2022-08-18T11:24:11.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h2><ul><li><p>最早的操作系统相关是 Unix 操作系统，诞生与 1970 年，是一个比较完善的分时操作系统。（分时操作系统是使一台计算机采用时间片轮转的方式同时为几个、几十个甚至几百个用户服务的一种操作系统，用来降低使用计算机的成本）</p></li><li><p>之后 C 语言诞生了，程序员们用这种高效的，可以移植性强的语言代替汇编语言重写了 Unix 系统，美国官方将 Unix，C 语言，ICP/IP 协议，当作标准开始推广。成功对后来的计算机发展产生了深远的影响。</p></li><li><p>有一天 Unix 突然宣布不开源了，因此有些程序员将 Unix 系统进行改编，于是就有了各种 Unix 的衍生版本，如：Sun Solaris、FreeBSD、IBM AIX、HP-UX 等等。</p></li><li><p>除此之外，还有一个编写 Unix 衍生版本的计划 GNU 被发起了，而 GNU 则是 GNU Not Unix 的递归缩写。自发起这个计划以来，GNU 开始大量的产生或收集各种系统所必备的组件，像是——函数库（libraries）、编译器（compilers）、调式工具（debugs）、文本编辑器（text editors）、网站服务器（web server），以及一个 Unix 的使用者接口（Unix shell）等等。但由于种种原因，GNU 一直没有开发操作系统的 kernel。正当 Richard Stallman 在为操作系统内核伤脑筋的时候，Linux 出现了。</p></li><li><p>Linus Torvalds 同学在上学时，觉得学校给用的 Unix 衍生操作系统 Minix 太难用了，于是就模仿 Unix 写了自己的操作系统 Linux，并且公开了 Linux 的源代码，允许所有程序员对 Linux 进行修改和完善，成功大火，所以其实可以说，Linux 是 Unix 的一个衍生系统（功能基本相同，但是系统开源）。而因为 Linux 因为借用了很多 GNU 的组件，所以现在 Linux 一般特指 内核层，整个系统则被称为 GNU/Linux。</p></li><li><p>根据国际公约，南极洲属于全人类的资产，任何国家都不能宣誓主权，于是 Linus 使用南极的特产——小企鹅，作为了 Linux 的 Logo，象征着 Linux 的开源精神。</p></li></ul><h2 id="Linux-的组成"><a href="#Linux-的组成" class="headerlink" title="Linux 的组成"></a>Linux 的组成</h2><ul><li><strong>内核层</strong> ：内核层是操作系统的核心，是直接依附在计算机的硬件系统上面，负责对计算机硬件资源和软件资源的调用。通过高效有序的控制，来最大化的发挥出来硬件的能力，为用户提供一个安全，可靠，高效的应用环境。</li><li><strong>Shell(壳)层</strong> ： 壳是用来区别核的，而着个 shell 的目的就是链接用户和 Core 核，因此这个 shell 也叫 命令解释器，用来接受用户的命令，然后解释给计算机执行，shell 分为图形界面和命令行界面。</li><li><strong>应用层</strong> ：应用层用来提供一个图形环境，用来支持操作系统中的各种应用，但是 Linux 不需要安装 GUI 就可以提供完整的功能。</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><blockquote><p>在 Linux 中，一切皆文件。</p></blockquote><h3 id="Linux-的分区"><a href="#Linux-的分区" class="headerlink" title="Linux 的分区"></a>Linux 的分区</h3><p>Linux 默认是进入根目录 <code>/</code> 所在的分区进行操作的。所以无论是物理扩展硬盘，还是对硬盘进行分区，都只能通过根目录 <code>/</code> 进行访问的。所以这些新的分区，都需要在根目录下面找一个 <strong>挂载点</strong>，也就是文件夹，作为访问分区的入口。</p><p>比如我们新分区一个 100G 的空间，使用了不同的文件系统格式。那么我们怎么访问这 100G 的空间呢，答案就是在根目录下给它找一个文件夹作为挂载点，挂载到主分区上面，这样就可以通过根目录下面的文件夹去访问新分区里面的数据了。</p><p>如图：</p><p><img src="https://xorex.space/image/351.jpg" alt="351.jpg"></p><p>根目录在 sda2 逻辑分区中，启动操作系统则会进入 sda2 分区的 根目录 <code>/</code> 下面，而其它的分区则挂载到根目录下面的文件夹下面。 </p><p>再来个例子：<a href="http://c.biancheng.net/view/2859.html">Linux 挂载详解</a></p><h3 id="安装-Linux"><a href="#安装-Linux" class="headerlink" title="安装 Linux"></a>安装 Linux</h3><p>Linux 系统安装必要的分区：</p><ol><li><p><strong>根目录分区</strong>：启动访问的目录，挂载到 <code>/</code>，</p></li><li><p><strong>引导分区</strong>：系统启动所需，需要挂载到 <code>/boot</code> 下面。文件系统格式可以采用 <code>ext4</code> 或者 <code>xfs</code>。</p></li><li><p><strong>交换分区</strong>：类似于 Win 的虚拟内存，不需要通过根目录访问，所以挂载到 <code>swap</code> 下面，和 <code>/</code> 级别平行。文件系统格式为 <code>swap</code> 格式。</p></li></ol><p><img src="https://xorex.space/image/352.jpg" alt="352.jpg"></p><h3 id="根目录文件结构"><a href="#根目录文件结构" class="headerlink" title="根目录文件结构"></a>根目录文件结构</h3><ul><li><p><code>/bin</code>：bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令的二进制可执行文件。是 <code>/usr/bin</code> 下面的一个链接。</p></li><li><p><code>/boot</code>：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p><code>/dev</code>：dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。比如 cpu disk core input output 等等。</p></li><li><p><code>/etc</code>：etc 是 Etcetera(等等) 的缩写，这个目录用来存放所有的系统管理所需要的配置文件和子目录，比如我们配置 Redis 加入系统服务就是增加了配置文件 <code>/etc/systemd/system/redis.service</code>。</p></li><li><p><code>/home</code>：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。Root 用户自己的目录在 <code>/root</code> 里面。一般用来放专属于某个用户的数据，比如 </p></li><li><p><code>/lib</code>：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库，是 <code>/usr/lib</code> 的链接。</p></li><li><p><code>/lib64</code>：和 lib 是一样的，不同的是里面是 64位 共享库，是 <code>/usr/lib64</code> 的链接。</p></li><li><p><code>/lost+found</code>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些关机丢失的文件。</p></li><li><p><code>/media</code>：linux 系统会自动识别一些媒体设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下，从这个目录下面去访问。</p></li><li><p><code>/mnt</code>：系统提供该目录是为了让用户临时挂载别的文件系统的，可以将外部设备挂载到 /mnt/ 上面，是一个可自己修改的 <code>/media</code></p></li><li><p><code>/opt</code>：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如 MySQL Redis 等等，默认是空的。</p></li><li><p><code>/proc</code>：proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure><ul><li><p><code>/root</code>：该目录为系统管理员，也称作超级权限者的用户主目录。用来放 Root 用户的资料的。</p></li><li><p><code>/sbin</code>：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员才能够调用的超级命令，和 <code>/bin</code> 一样，是 usr 文件夹下面的链接。</p></li><li><p><code>/srv</code>：service 所以，该目录存放一些系统服务启动所需要的数据。</p></li><li><p><code>/sys</code>：system，系统内核信息的文件夹。安装了新出现的一个文件系统 sys、fs。sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></li><li><p><code>/tmp</code>：tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。可以设置为下载目录。</p></li><li><p><code>/usr</code>：usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。除了安装应用程序之外，还有其他的共享资源，比如：<code>/usr/bin</code>、<code>/usr/sbin</code>、<code>/usr/src</code>（内核源代码）。</p></li><li><p><code>/var</code>：var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着、会变化的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li><li><p><code>/run</code>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p></li></ul><h2 id="文件编辑"><a href="#文件编辑" class="headerlink" title="文件编辑"></a>文件编辑</h2><h3 id="vim-编辑器"><a href="#vim-编辑器" class="headerlink" title="vim 编辑器"></a>vim 编辑器</h3><p>有三种模式，一般模式，编辑模式，指令模式。</p><p>一般模式：一进来就处于的模式，用于整体的操作文本。比如复制粘贴剪贴删除：段、行、词。和光标再文本中的移动。</p><p>编辑模式：按 i 进入编辑模式，可以输入内容。按 ESC 退出。</p><p>指令模式：按 <code>: /</code> 任意一个进入命令模式，后面跟着对应命令，回车执行。按 ESC 退出。</p><h4 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h4><table><thead><tr><th>语法</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl f</td><td>Front 向下翻一页</td></tr><tr><td>Ctrl b</td><td>Back 向回翻一页</td></tr><tr><td>G</td><td>光标移动到最后一行</td></tr><tr><td>gg</td><td>光标移动到第一行</td></tr><tr><td>p</td><td>在光标处粘贴</td></tr><tr><td>u</td><td>撤销</td></tr><tr><td>Ctrl r</td><td>取消撤销</td></tr></tbody></table><h4 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h4><p>使用 i insert 进入编辑模式。然后直接输入内容即可。使用 ESC 退出编辑模式。</p><h4 id="指令模式"><a href="#指令模式" class="headerlink" title="指令模式"></a>指令模式</h4><p>使用  <code>: /</code> 进入命令模式，不同命令可以组合使用。</p><table><thead><tr><th>语法</th><th>功能</th></tr></thead><tbody><tr><td>:!</td><td>强制执行命令</td></tr><tr><td>:w</td><td>write 保存内容到硬盘上</td></tr><tr><td>:q</td><td>quit 退出 vim</td></tr><tr><td>:w [filename]</td><td>另存为 filename</td></tr><tr><td>:r [filename]</td><td>读取外部 file 并写入到当前光标后</td></tr><tr><td>/[Regex]</td><td>按照正则表达式匹配文本内容，n 下一个 N 上一个</td></tr><tr><td>:set nu</td><td>开启行号</td></tr><tr><td>:noh</td><td>No High 取消高亮</td></tr></tbody></table><h2 id="Linux-命令"><a href="#Linux-命令" class="headerlink" title="Linux 命令"></a>Linux 命令</h2><h3 id="bash-or-shell"><a href="#bash-or-shell" class="headerlink" title="bash or shell"></a>bash or shell</h3><p>上面说了 shell 是壳，而 shell 有很多实现，在 Unix 中叫做 Bourre Shell。而 Linux 中重写了 Unix 的 shell，所以叫做 Bourre Again Shell，取首字母变为了 Bash，特指 Linux 的 shell。</p><p>所有的 bash 命令都是 sh-&gt;bash 应用程序负责的。你甚至可以嵌套调用 bash，不过需要 exit 好几次才能退出来就是了。</p><h3 id="内嵌命令"><a href="#内嵌命令" class="headerlink" title="内嵌命令"></a>内嵌命令</h3><p>一部分基础功能的系统命令是直接内嵌在 shell 中的，系统加载启动之后会随着 shell 一起加载，常驻系统内存中。这部分命令被称为“内置（built-in）命令”，比如 cd、history、exit。</p><p>而其他的命令，则是在 <code>/usr/bin/</code> 目录下面的应用程序了。比如 cat touch vim 等。</p><h3 id="POSIX-命令"><a href="#POSIX-命令" class="headerlink" title="POSIX 命令"></a>POSIX 命令</h3><p>POSIX 指的是 Portable Operating System Interface of UNIX，可移植 Unix 操作系统接口。是为了应用程序在各个类 Unix 系统上都能运行的一套标准，这套标准也规定了一些都必须有的 shell 命令，比如 cd 这些基础命令，它们也被成为 POSIX 命令。 </p><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><p>内嵌命令使用 help xxx 查看，其他命令使用 man xxx 查看。</p><h2 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h2><ol><li><code>date</code> 显示当前的时间。</li><li><code>reboot</code> 重启计算机。</li><li><code>poweroff</code> 关闭系统关闭电源</li><li><code>halt</code> 只关闭系统不关电源。</li><li><code>shutdown</code> 有条件的关闭系统关闭电源</li><li><code>ps</code> 用来查看系统中的进程状态。</li><li><code>top</code> 强化版本的任务管理器。</li><li><code>pidof</code> 后面加某一进程的名称，然后返回这一进程的 PID 值。</li><li><code>kill</code> 后面加后一进程的 PID 值，用来杀掉该进程。<ul><li><code>killall</code> 后面加某一应用的名称，会杀掉所有该应用的进程。</li></ul></li><li><code>echo</code> 后面加想要输出的内容，可以是变量，可以是字符串。</li></ol><h2 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h2><ol><li><code>ifconfig</code> 可以获取网卡配置和网络状态信息，inet 后面是 IP 地址，ether 后面是 MAC 地址。</li><li><code>uname -a</code> 可以查看当前系统的系统内核和版本什么的信息。</li><li><code>free -h</code> 用来显示当前主机的内存使用的相关信息。</li><li><code>who</code> 用来查看当前使用这台计算机的用户信息。</li><li><code>last</code> 用来查看最近的所用用户登录记录（这是个可修改的文档）</li><li><code>history</code> 可以展示你最近执行的进 1000 条命令。<ul><li><code>history -c</code> 删除最近执行的命令记录。</li></ul></li></ol><h2 id="打包压缩与搜索命令"><a href="#打包压缩与搜索命令" class="headerlink" title="打包压缩与搜索命令"></a>打包压缩与搜索命令</h2><ol start="2"><li><p><code>grep string/expression file</code> 用来对文件的内容进行搜索，非常强大，可以是需要匹配的字符串string或者正则表达式expression，file则是需要匹配的文件或者文件夹！</p><ul><li><code>-c</code> 显示找到的行数，也就是一共有多少行成功匹配到了关键字符串。</li><li><code>-i</code> 匹配时忽略大小写。</li><li><code>-n</code> 显示行号。</li><li><code>-v</code> 反向选择。</li></ul></li><li><p><code>find</code> 用来查找文件，如果不加任何参数的话，回将当前目录下所有能找到的文件全部列出来。</p><ul><li><code>-name</code>匹配名称。</li><li><code>-perm</code> 匹配权限。</li><li><code>-user</code> 匹配所有者。</li><li><code>-group</code> 匹配所有组。</li><li><code>-mtime -n +n</code> 匹配修改内容的时间，-n 表示在 n 天以内，+n 表示 n 天以前。</li><li><code>-atime -n +n</code> 匹配访问内容的时间，-n 表示在 n 天以内，+n 表示 n 天以前。</li><li><code>-ctime -n +n</code> 匹配修改文件的权限的时间，-n 表示在 n 天以内，+n 表示 n 天以前。</li><li><code>-type b/d/c/p/l/f</code> 匹配文件类型（后面的字幕参数依次表示块设备、目录、字符设备、管道、链接文件、文本文件）</li><li><code>-size</code> 匹配文件大小（+50kb 表示文件大于，- 表示小于）</li></ul></li></ol><h3 id="路径相关"><a href="#路径相关" class="headerlink" title="路径相关"></a>路径相关</h3><p>绝对路径使用 <code>/</code> 开头，表示根目录，而相对路径不用任何字符开头。</p><p>其中 <code>./</code> 表示当前目录，而 <code>../</code> 表示上一级目录。</p><p>使用 <code>pwd</code> (print work directory) 命令可以现实当前所在目录的绝对路径。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>连接，将一个表面文件和另外一个目标文件关联，点击表面文件打开目标文件。</p><p>硬链接：在当前目录下面添加一个目标文件的目录项（索引），从始至终只有一个文件：目标文件。</p><p>软连接：真的建立了一个文件（又有文件节点），将自己文件路径名链接到了目标文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux-简介&quot;&gt;&lt;a href=&quot;#Linux-简介&quot; class=&quot;headerlink&quot; title=&quot;Linux 简介&quot;&gt;&lt;/a&gt;Linux 简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最早的操作系统相关是 Unix 操作系统，诞生与 1970 年，是一个比较</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Linux" scheme="https://xorex.space/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis-02-整合Java</title>
    <link href="https://xorex.space/2022/08/03/095a6a7e9903/"/>
    <id>https://xorex.space/2022/08/03/095a6a7e9903/</id>
    <published>2022-08-03T02:08:41.000Z</published>
    <updated>2022-08-03T08:09:48.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven-整合-Jedis"><a href="#Maven-整合-Jedis" class="headerlink" title="Maven 整合 Jedis"></a>Maven 整合 Jedis</h2><p>在 Maven 中引入 Jedis 就可以使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span> <span class="comment">// 建立 Redis 链接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getReids</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;server.xorex.space&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;tempestxorex&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">// 按照使用 Redis 命令名字来调用方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = jedis.set(<span class="string">&quot;tempest&quot;</span>, <span class="string">&quot;xorex&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        result = jedis.get(<span class="string">&quot;tempest&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span> <span class="comment">// 关闭 Redis 链接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 虽然是原子性线程安全的，但是 Jedis 在获取和修改 Redis 的时候的代码，是线程不安全的。也就是如果多个 Java 线程共享一个 jedis 链接实例，就会出现线程不安全问题。为了解决这个问题，可以建立多个 jedis 的连接池，为每个 Java 线程分配不同的 jedis 连接实例。</p><p>创建连接池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConnectionPoolFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为静态的，一被加载就创建连接池</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig(); <span class="comment">// 获取连接池配置</span></span><br><span class="line">        config.setMaxTotal(<span class="number">8</span>); <span class="comment">// 设置最大连接数量</span></span><br><span class="line">        config.setMinIdle(<span class="number">8</span>); <span class="comment">// 设置最小连接数量</span></span><br><span class="line">        config.setMaxWait(Duration.ZERO); <span class="comment">// 设置最大等待时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 JedisPoolConfig配置信息 host地址 端口 最大连接时间 密码 来创建连接池</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(config, <span class="string">&quot;server.xorex.space&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;tempestxorex&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource(); <span class="comment">// 返回池子的 Jedis 连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用连接池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getReids</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从连接池获取 jedis 连接</span></span><br><span class="line">        jedis = JedisConnectionPoolFactory.getJedis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在连接池，close 的时候会将连接归还而不是关闭</span></span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot-整合-Jedis"><a href="#SpringBoot-整合-Jedis" class="headerlink" title="SpringBoot 整合 Jedis"></a>SpringBoot 整合 Jedis</h2><h3 id="前置操作"><a href="#前置操作" class="headerlink" title="前置操作"></a>前置操作</h3><p>这里是使用 Spring 全家桶中的 SpringData 系列（专注于数据处理）的 SpringDataRedis，它封装了第三方的 Redis Java 客户端，提供了统一的操作接口。</p><p>使用依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--连接池依赖 lettuce 和 jedis 都用它--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入完成之后，就是在 SpringBoot 的配置文件里面去配置 Redis 的信息。需要注意的是，SpringDataRedis 默认只下载了 lettuce 客户端，如果需要用 Jedis，那么就要引入 Jedis 的 Maven 了。版本号 SpringBoot 会仲裁。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完成配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">xxxxxxxx</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxxxxx</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>SpringDataRedis 中提供了 RedisTemplate 工具类，其中封装了各种对 Redis 的操作。并且将不同数据类型的操作 API 封装到了不同的类型中：</p><table><thead><tr><th><strong>API</strong></th><th><strong>返回值类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>redisTemplate</strong>.opsForValue()</td><td>ValueOperations</td><td>操作String类型数据</td></tr><tr><td><strong>redisTemplate</strong>.opsForHash()</td><td>HashOperations</td><td>操作Hash类型数据</td></tr><tr><td><strong>redisTemplate</strong>.opsForList()</td><td>ListOperations</td><td>操作List类型数据</td></tr><tr><td><strong>redisTemplate</strong>.opsForSet()</td><td>SetOperations</td><td>操作Set类型数据</td></tr><tr><td><strong>redisTemplate</strong>.opsForZSet()</td><td>ZSetOperations</td><td>操作SortedSet类型数据</td></tr><tr><td><strong>redisTemplate</strong></td><td></td><td>通用的命令</td></tr></tbody></table><p>操作 Redis：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 自动注入 RedisTemplate</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 ValueOperations 来操作 String 类型数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;testKey&quot;</span>, <span class="string">&quot;testValue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象序列化存储问"><a href="#对象序列化存储问" class="headerlink" title="对象序列化存储问"></a>对象序列化存储问</h3><p>RedisTemplate 的两种序列化实践方案：</p><p>方案一：</p><ul><li>自定义 RedisTemplate</li><li>修改 RedisTemplate 的序列化器为 GenericJackson2JsonRedisSerializer    </li></ul><p>方案二：</p><ul><li>使用 StringRedisTemplate</li><li>写入 Redis 时，手动把对象序列化为 JSON</li><li>读取 Redis 时，手动把读取到的 JSON 反序列化为对象</li></ul><h4 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h4><p>需要注意的是， RedisTemplate 操作的时候，输入的 Key 和 Value 都是 Object 对象，那么就需要有专门的工具类将对象转换为 Redis 需要的 Key 和 Value 字符串。</p><p>这个专门工具类的设置，是作用在 RedisTemplate 上面的，需要我们去修改他的参数。那么在 SpringBoot 中很好解决，只需要我们自定义一个 RedisTemplate，然后注入到 Spring 的 IOC 容器就可以了。这样我们 @AutoWired 拿到的就是我们自定义的 RedisTemplate 而不是默认创建的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 向 IOC 容器中注入我们自己创建的 RedisTemplate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123; <span class="comment">// 方法参数 connectionFactory 会从 IOC 容器中自己找</span></span><br><span class="line">        <span class="comment">// 创建 RedisTemplate 对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置连接工厂，使得 RedisTemplate 可以获取连接池中的 Redis 连接</span></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Key 的序列化</span></span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        redisTemplate.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Value 的序列化</span></span><br><span class="line">        redisTemplate.setValueSerializer(RedisSerializer.json());</span><br><span class="line">        redisTemplate.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样以后 @AutoWired 获取的 RedisTemplate 就是我们自己设置的了，中文编码也就不会出问题了。</p><ul><li>自动完成对象和 Json 字符串的序列化和反序列化：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>,<span class="keyword">new</span> User(<span class="number">100</span>,<span class="string">&quot;Xorex&quot;</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 Redis 中取出 Json 字符串，然后序列化成一个对象</span></span><br><span class="line">    User user = (User) redisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">    <span class="comment">// 反序列化过程是，先创建对象，然后使用 setter 方法进行填充</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动反序列化的结果</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@class&quot;</span>: <span class="string">&quot;space.xorex.boot.pojo.User&quot;</span>, <span class="comment">// 因为保存了 Class 信息，所以可以自动反序列化为对象</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="number">101</span>,</span><br><span class="line">  <span class="attr">&quot;userName&quot;</span>: <span class="string">&quot;你好&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h4><p>因为自动反序列化的结果多了一个 @Class，比较占用内存，我们可以通过将 Value 也设置为 String 序列化，这样就没有 @Class 了，但是这样做的坏处就是 get() 获取的 Redis 数据没有办法自动反序列化为对象了，需要我们手动完成。</p><p>Spring 默认提供了一个 StringRedisTemplate 类，它的 key 和 value 的序列化方式默认就是 String 方式。省去了我们自定义 RedisTemplate 的过程.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    <span class="comment">// jackson 提供的 json 字符串和对象互相转换的工具</span></span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="number">101</span>,<span class="string">&quot;你好&quot;</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 user 的 json</span></span><br><span class="line">    String json = mapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 key value</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:101&quot;</span>,json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 key value</span></span><br><span class="line">    String value = stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:101&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将读取的字符串结果转换为对象</span></span><br><span class="line">    User newUser = mapper.readValue(json, User.class);</span><br><span class="line">    </span><br><span class="line">    System.out.println(newUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样的序列化结果：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="number">101</span>,</span><br><span class="line">  <span class="attr">&quot;userName&quot;</span>: <span class="string">&quot;你好&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Maven-整合-Jedis&quot;&gt;&lt;a href=&quot;#Maven-整合-Jedis&quot; class=&quot;headerlink&quot; title=&quot;Maven 整合 Jedis&quot;&gt;&lt;/a&gt;Maven 整合 Jedis&lt;/h2&gt;&lt;p&gt;在 Maven 中引入 Jedis 就可以使</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Redis" scheme="https://xorex.space/tags/Redis/"/>
    
  </entry>
  
</feed>
