<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xorex</title>
  
  <subtitle>要成为世界上最幸福的人啊！</subtitle>
  <link href="https://xorex.space/atom.xml" rel="self"/>
  
  <link href="https://xorex.space/"/>
  <updated>2021-06-05T16:47:14.015Z</updated>
  <id>https://xorex.space/</id>
  
  <author>
    <name>Xorex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为美好的世界献上祝福</title>
    <link href="https://xorex.space/2022/05/20/567f91f8bbba/"/>
    <id>https://xorex.space/2022/05/20/567f91f8bbba/</id>
    <published>2022-05-20T11:58:03.000Z</published>
    <updated>2021-06-05T16:47:14.015Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="689bfc10a9fed57c789bc7685d36a5d9d75f31b34cafe041b99ff510386c6242">8a972074cb8fb594adf191142c932486f63d9db6a4bbbbf65eb58b44e7f3a502ca39de9d3c1e3d9c70fdc9a01ad868dc3486910eced5f4e34f64df4c5155d0e28740e7f637329c5391f9bbe6ff64e653a789e2cef71c949e21aa63f2fba5c2f8909ab81d64320e8cb4384ed74fbebab2050cb82c4a7d22b4b9fd24d8a61fc8d8029f2ecbce16d7ac4071fe5c0ae2c3425b4c421b4a82a69b6012152d7d464a3624e786c960a03a52f9cd3453ffde3f9e7f7f8db1b21b9fd158b70d49126036880e6f581475aa1c9265c50093981c7c70663d0a1e3bede2870b4a7e0a6dc0d1a1ce8dbc658189e95bd6888f0f4d48bc8d7fa179df02ce8435ed223754c508e2b86eb7748ba754993eb71d24a37e5f551d0164956aa4d5dd5f723185894b6581fdc9638900b4666fa18e9bd6f6874b22c630932f62849d260f383329527390267e1ae61d8591c4aeb352f4b29108c2465a5e074d349edb5a9af79cb59ade636bb557cc6cdecd797157def65921204d200554354bc3d381c49d4097e92d1d51fd01c2313cff9d6502cf7e7f4b2399cc1e6be251d80c7050309bf346d386a7b536645f5c4c96178bc331da5740a42b0bd02b9968ce31b992b998e972e1dd06841a9d53b1d8280616027ac636ce646b67ae2c98a4b2ce990afefc45bd9b4d068c8fde09917cd2e84b9ffdf59606a1a60816d2f994703dfbbad7039e96e0b658292bacb1858ba7d9e49eb3187431fa4a1f8363915dc73aad3d519447f7cc0ff818de1453e2ab8257e0057131b57981825fc2c9f788e75c5564eb2ad8404bab6a82c47ab0a53249beb3b2306c2e5554ac2302070a4190176ddf1f1a7c9f4e483174777de2b527a91c806a1327390ff9a7eb985697c66546afc772628cec06b528dccdd1cb1d1d13ad8f74668fa5f5d0195cde6adade74f3ee1870b9a5da2542345b0f3ccb4e45aa3e4ca19ee469c348bc52b7c915f9fd94f14a9ce369c3d58e5c0e6550c9e6944437b122bacc312d2eaf41ec6165983d4afd819eb351ba8b730ee916f9cd78fef8008dcb9c56e63761799af98a3a7f796a1fa589fb9951d440a514e59ecf489a527c3a856fb48273361bc634d065d3e1833fc4a3b59e3f44008e8a1565a63506724732b84253673b58773214fb18c6f216ce7f94a3000979160f8fbe89f7300870c0103288288d986af8c35cf489154c5116b9e29ea3806b83fb4fb5c13bf5fac94b9fbb3d4dbc0a39cf185ce78c526bc7ed204162cdae47a4d016b2d81ea2ba9fc9830fb3527f1841ccf23061c0b80b53f3ae74c11c56b01d7711482081a2fcee250f16af2cb412ec812dc57d4d1d6985a692f17764a8bda6787d62fb8612eb25c70420071fd319dbc83c5d7f8ab892ebe088697c5f2833a61978a2b3c68e6916e569324b6bba4123401b6cccf173cb6f5f16b310bd23c631794739ed100cba1697a02e0cd558489edd5b9fb774265919385617ef45af3e351137e2be1db5a0dc536cc5ab5a80897d655a4da942de4a3fc9462a7d2eb6b49a288980210c8bf4649156b1e7d1f2c6e6eb1b8cb056067a2306541b7828ad3c48713b7ddcd33bdc4c83aec20ea2f4812ad03fedb8d33e6214f83ca38ffcbb55ca3859cd0cf07b65dd04174589117adf9d5c76448c6786447889122c612fb0ba366bfd64384a5162e27375fa7747622c6cf3b1c9c09bae41d179b1ac15d3cdd3254c2498e37f38e8b43b6620a7898afadb4e74414a7783ae2ffefd6aaac8cd082f33fa0abb3c8271690175664331e3053092c2b6abbf7e66adb0530ddde01a965e6abe809db7bd6d79229a09bd7df84c25da01c92e73a035e2667a75229c48e889842fbd0a1d7dbf7c579292b8557b8f400157e95b2864450dc73474ca6520544b623d98a0445e62a98d184853b6cf236e48ffe6ede26b4ca737f3f8c2f19701125867ec08135ca682b3cedc732362def3eefbf16d0327fedf680a5dc50bbb5590feeffc83a065c7c09fee680f2395508e418e59c28bcce45dcb357e95c2590a7ef9049d04d6bdbebce82c03d09be7d60c90ff409231a5b8df0091ede2ea2abe007dce72a5565fa7792a143ea45e0f14c3eed8ac989811cb44a0cb0fa483aa5f25831ccd3124d07a5558b126178f10f3600a554228513b55f48fdc6ca3d88c9a4203c3f729197919ecaff8376f9535fd87232cb896294f9fc4fdb1c094dc5b8c13fc9c0af0f6d5d0649aceb4beec719f7032a9d68ec16a1f386654f29e0adf7ade3d6d883067a74baa45dd07ca46c074be4a2d4d3cedd9cb43aa79ea8605e4a843d693cd9a062524820c3ae94cd3ba631d7d2c844b4cfd17570d07e02bb79c647880cb8f4a0614ff595bd22cff36fae33ba66ff6b9614ce43b5e2c2e2103b2a7c36dee450c0294e61645f1ff62b02acba1a876583591a53d9995c97318865eac82e9ab2d7daaee2edc69d2f6240b9cb98c8f3cc1c140d3ccfdb1894a3a9ae4db3704f4bef50c79ed660d72c4d76ca15c7b090c3a3ec8b6a1663e8ef6b80b33a790d75a8f2cab63863cfbab878fb45829ac4b30877f4b44ebb6fb1bd3deef6d4bb492d9e8dcd8f44dfda2afc59f9957524ddc5a9d26235be96e405f99fc668073799bfc29c611f3d097c9bef8404dfd98753bd059c4ccb2dc28284fa4d26f7388f29f063c5924d5d793e65af69eea2a654c3ca088ed576cea7a496de608c7fdc8adf94e22690d642584b9d121a80980bff1d66f2dbc7abf03c7272b4bd1f74df56756a806d0e76f293912b968b023f95efc0779c20497e818842577470c33cf1f1412cea0944a4fa2cd2a145d2a4dc588712f11729cb1233d6eabd234e0556425985afe3cf2518e4f70bbf31c038d5c335f500e0125cd3429ce768886381d9bf7fa0236a3449fd423c501be99daf36e54f58f09e63462c975afb417a015bd5f4a918f66f022aa79981cb82c29087351b1afe7b5051ad3712c3150e62f9d01f429d0b1050f348592d09d22cd5dc3409e3d11e7664dc114d8c37160b9d39f7d594813fd90cd23ac43c86cce7f22a0ecc46e9c77c1a1097fab3af5c9e0bbd893630d1db32066c3aeb8544e5a3b1e9f4905a3685a041e7921c29f7eb36041f276e3de9da457c90c0a4e9b1ec38db531d7887628745c5f26194ad2c2bc892a0e62a63be8e7162540b04696ee38d1ffa3deef3f110517e9813d259eb2617581819a50a37da390650ba8a86f576db6036fe772c8f8d2b15633f5d1905f11d452d62d67121d9a7d30cf26419c7100f2f51a3f0f8597048cda90b68b1b86116671fed5953d70fa552b04bcd54001afaaa291346a9eef0cb871f350a08a2e2ad3ead37fbe7af6c5ea3fbb4e2af874efb0d4f33d149f83b525500d0d106ae12249119307c0242bcfff7425822d2f61aae575154c5499f03b06da9bdfabf4707602c20b2eb9173a7f01dd7ea77e0b44303670982c11b53a5603e22cc74ca166846ef28697572ae88504db22754792584f45a2a559813081ab34c8641550dc1259ba7cc55de0d8ea0ae7ab83afc533113272ad893f0106a087e6bd0eb90c464eca576a7a217ef654ea365834f37076cec52bb40f7c2ec76ca2fdfd93511f3132b68d5279d42422d4562ad20cba8e76ddf4570fdeb4a0b1e63f2b87edf688afd4f51ae842b14864a528c57686385e5e763d175bf04d26ffd612a90f5d5ed0d49d6dbd4e472a192665afa263e1d9c2dfafb17858b59b5957992af881daf5231757ae0a3733d0e032415f2e6147113228b4c342045de3f73e08d00f893f7c05ab15b64603ef42b1e300b879fe6a8703d130048a0ef4c43a0f5aae256cfbd422f76818720e45572b16b6aae06c7c9a8a2be60d6bc205e8a0bccfea6660196c6ccb73571d9fce6aec0dbf9a211c12769ce9f1d4d2dcaccffc5049e92fc42abc59c6b952abf55ce944bd619f23f17700a194a95daeae67c69a289b48ac154619c185012cae1d913657e9fcc2ea89ededbd49813fddef2a842336a0a62385844b872a5c648b7ab23e2015579b053780d4c2fc01e621dfdb0f169723e26e319948f6355a3d52c26774488a5f43a1d574e80c78730f8b825210e3a93d5b904cd14d74f09255b74f5e5185d35713038bfecaff6c4cbc9c3e6b3638c64ed1af85cd0746586e41377fa167c73f22a605639878844d9a73dc5c244e02e359c3ae6cb62540b36a4b5e2150898258f2f86d881fb21d0e5c1c4e3552eb48159529396d53cc96ff48320c1406acc328fe9c1cddb62363481ed658ec32273b5f6149e80d7f111cad43e8f989c6f9609f194d18319b7932ce1854265e28c93ad307ee5f638c795b49f625b6783187862743df526a3da373e9e814846ea92343d3d5979772a38dec79be44317f0c75efadac03409fc473af07b7c47adb8170959bb5d20d41362e96ff110bbecd6edb3a7fef4bab4470423113aa367d0e8a2425c87bd98550ac0e7db65c9c7d32db12cff2bcfa81cda4e41d0b308f9578b4b1e5d5794d5ce80ad0ef7eed3cf3039f85c28d6fc247f3e04e4da416c126c6a7453431952565dbd973ceb410451246d221b4c4c59bb45dc1e8f01d15456e4bc59b26feee41aa8ef0356eab5d03e4a9cced9df106708a16de62ca4bf2d9ca503747ed9f4b6b664916a7bf851b7392e1e71ded53d2576c775e15be1a4502a80dd2f5c34808e17f642d8a987ec273b5d0868a114466b331e563ac674abec48fd6783c8624a06a92dc359b3efbc0e9c28aa832f4a61417ff2859ddbda7ccc5617d1a9d17ce2843ea48c7b5bddf9e2d79aeae9d844002cae5545cceded9192bb31c3b49b7723b30da30318015acd6f16cabae11f2f2d197f0b0097fe222019bd1e82d6fb82b1b7a240b0be445cef0404adc7c55a1ff0bf296c88b6be1ce1b0083dd453c5a91cf01c0abe097a59f9f5771310187ee251f978945d21311f01ed29eb1ded81deda69d472642b543e0e8bf92781a96f9e576e3172770483f69c15fea7ec986b796d1a5c1f0a08e96b1090dd9119f840d9c016ac32b8cf483f3986934121380be1af639c7efc0ce4f4429aa99eabaf015c4f81a232aa9d030faa9c401c118532146e91ea4ccb77bbe21995fcdb4f16409a41715920a010d8adbca438d7c94852563dc36af172bd19e552fe44a45222fc43fe10e7ba6d4d857156399cd143de7caaeb001e14fcb3d03be87ea1717c748bce8c47ad170f8170c159e37f533dc7f0415eeb55dd07c7c28b7358f4cf62b257b6e3d972ee8d75e04c673e0cd267ac89badebc34fa445f6cac623c9ee9447556c5149db450291ba01c3dc62ebc7661da869d3c7f23b853f29af418a41890aab8c1093ba44d46019deb75043ee8b76f9fc9fbd149ad4b77ccbade7d360c94eba7766b1650414c48088892abb236903bac42fa1c32d90d972ef54da2a2d87b8e0f2ddbf5b006e6ff79660d4122fdb8332e5ec80a90bcd95db27fcf79376ed0baaea37dc99c00194e35cd48c3f93a78000fbbead43982ed3dacbea40785414ac60d9281353479cee2cae86b73a3769ebd29736f9dff2ca6be49d2908d7517f4f11d6145e23cab64929ca877bb055d9a547e4f13dfb1cc300487538fe065df2eb6cad120563d809978f54eb6337ddab9e509fd1ffb27217ccc59f8bdc582037569b46a1d88ca9641b721f5177a10abb2038b60945f5ddc42f0433c0062cf5410a8ca84a91930718f1ba1a0bb879da6130740911c5a7431c19985ea8a6f6a64ee53399cb40a1252e2dee4a36178fa2e25826e8787db25c33b3c11a1574a0bc8b5f58cb6f7bc7b31878ac035bce91319ed0f5bbef3e7b249ca8c7ecae0ed40e38f8881f73125aa4058883ed2e3241d9706bc3c185c9fe9f0c9a64318a0e848ad08864b747a38a166cfa55dbaf417deaf2781a8223d6b3856a69a48e53f3bea85f02eaab5a61d8185e7856ff545e2e666b839bac6ca08a34a9ed391eb859330148e35f0a9221f8000f1ba42a55a545688868027c4a34cf2d05dc12f3e512500e853e853fc713465766e55741d58b28a9b994fd03cb213d1475e84189329170f0160ed9f5cf75260be695c74fa812375c6f0ad329adc909e5f76cb3f12a98b4128d5b17677cbc9322360667ad6f2268f49e6c70f905adae18ef1a10b8ebcc6c5df15fbcaee97e5bf039a683af766b7ee350eeb564f7df1159c0cfc7b863ed7844ab0f55c147028bbc125822720807d0da21387520376d1f581235ae9887f952ee49b5d746989ce8d9378aa6bee5faf12d9ac3b2f79e3a684361dba69b657884b8cab25daec678f004f793a845fbe5bdec336aa74d05948fbafca14c7ec43a6569883b0ad31a801c38d78173453b632b65ccb08ac379aa6f0dcf7a11035415c58b39557dff5a4246860f5ce80cc862218a43986e3b9f27ceebcdd62f7fb645f5c77b7450995789545edb0a5c11119e87691691478b9d939ac95c43e2245d4c448e806b01c0918ed18805edd519d2a927adb92fbfd2c9dfc5d564d82f5b092b5203547ed28d731726e47fe054cecfa6b4137024e8ca9b943d46aac7b792bfdb857831de16281dc4b15ccf73a6774799cada60cd4e964b3ec56b057df054ac12f14c886dc99ffbe46426607d8b754058f944304ffa6dd7a19e96ff9fb9630948e0526ab72cad0633b507a48ed58f7d34cfb0dc68c6fd9523246b3b63d4db3ee7a6563787fc9f7cbd88966881671abf8c037f15d362a7ae43e3174ccd05716e3e595a36b45b42d16059f1ffe3f85acb416942c0d82de9db439b96e08aacf890b61a936c285397eef3e83ad4a47f00059c0e0e9675e6dd257f5db2cd06bdb0506cb696f9a698c85a95cd95aee8c354456a8fcc055818e2b4da0b44376810cd607b3809f03d7af96ea963adaf4a8abaae66ec2b993cff102c57380bb41030f6192163a8076dbd2e7b037553d1f3928804847b1f359563a0e752c3b9b80dad8102cf77d3f7100a6e881e52db01c42d9694c3cd6afc86a77fda767232b2e66a393b2011ac6af6f9d00d9be3d31e1065b61a118319daa5422a78bf06ba773bb2a5f9343b948483ad66b781222d9bcb211e13d4c851d5bbf7328025b38ca63c4907945cedf110a838aba27cad851f73ddc5c5ee6538ebecb22454cde54cefd0d808263364a9d3fab55df73b11e0ac7f426f22d3050163fecf163512def63d06ede8f842fc5a41bd7b65915eb55bf776e7460d8675ce525a3bd8ce12fb42134dbd97321fea31444376355c9163a30d28d09c43be25fc49d7c9286e4b13c4dde2ec4f425d2f8a50c5f9229d2d6714e05d41eac3f8c2df13b25af2d912472a5ad9b600ff739bec4386b96fbf28767a19cd7696cf194bb1822b0bba1d55ecb053024fbfaf595ffb2b62114e56608cb119c3d6b26f3800998e20c7697e33087f223d6cef191cdc11a61009321aeac4c757fccb57ad6880f05302b00c7c12309e882126ee82c2d65f236d6aba8297a9fa113ddeecfaec3bf578f964449f208f86a55e7c7fc680104ccacc8b51731eac235142f937d68d117766c6b97a0890c2f0c5906269d463b70a27fcf042d702d6a84816c0b04c615e4641b37b352a5bdef59f27ceb05fe42f15f85ee9d3a3cb109fc07f4ea42d8577921315a1d57995acda377a83a95277869401d204d0154e45231dfa418ba19565adeb6f947f85ba84ead98fd9f72ddf24173d8bb6c675d60eb4c0bd019e2c2e04904ec56b0570662f7686ee4cd789bb9bf9a7cdc6cd155be5bc6dcbc548914afaa55553e6c8f9f7eac4ae6a9b43d0f42e810250d9812b6726d59c7a2adcf70a051bd6b970a701e7385972939f42c34c08676b778787a96fceb316a48b9e94efb3cece703aef605279442697282a777b97a5aa22ca2cfbd694d2e7e786878bd5b67cccff6e6763c52b8b0a4e5485fdee23ad79007c7201371e010c8a24d80b18e7d35d4d7d9335f4990dc027a096d5cf811f8fa3e21fe8146307e98fe97bcca6bcc11a0a67d7e65288ef112033b9f13248cdf8634ea67d6051e92933aacad2e4bac99ba8ae764a3c63cfc1069d1922f47f3e48f46c7d818682b51c92e31caf6977926dd3df0e6e9dc65d9858133186907b94939e288f46cee43adb7ff69d369c5828e043d10f3f132d5098c687633080f027dd73f34b4f070299a2ed3579eb2f7068d66a7485f3e20c2e9bb963d760467cfba67fd1cc253e97c8c0cb054fd06b2ed7d612388a50e59b2268f7094783f19103c8ed86d86ada4fd4d6b63eee59240d19cc566d83b3d499f86f0da374362dd17b24eeef5f8ff2536f431a0ba9c5fe7955508bf5824b9829e38687448f2e83c726931838c4d038ff25d171486f5ba4fbb2499edb41fa89c2113701003cfd6703d040acdcf83c87324d33778e217d37da1d2b072c39067b23f9e980d59f1b73757168124746a5c3b15eb75b41c0ba004ffa77b12ba35b1e9b5d141348c39d499d0621b12e1aa022bd569cb2bb30e15e82b458f336e2f3285f10e0a7859f824af87fe5d65159e0ec969ecc2161bb0e33dc9125fbac004c2705a85be85bdba10b86ce22b7b06cf08757792e8592bf397398fc9627094221440b4ecdab198583376f3393bd5ddf19c9f6ec3ac94aa6c9a44aa6509508f9c1a242158084e475c6819ce401816f785a6bcb3e553fb0917355e92c2cabf25b2bcd4d4f1443a3fa3330a3a8f46534b8dd466ec18fc4bafe757f0980c35cd260cf7cc46518f4813bf5614c82709a99ed68cd32a17aa97b99a1ba9f468fa44ffc29202d4baf93b9240d6c34d7d2349feedbcb34e6f28d6d6cff003d28b319ae4c153bb5b82e286feb73638187bd02e9b6b21a3ef2281ae8d589c921d426330cf693eb80eb45e3dd83df3f7e5f92268351885c3aff655d09df11c9e4aa4e011bb1ddcbc715673f4308b76e281aed3335c8447f82667fcd64089ca564d199b96b826a8425c15d033b37a437595111808f946326a4a7547e1afc1f60bf5d6881d5682048fd3fda3cc034b8962e8e3ab397e167e4e7a67fb5f6405170cb7b8a93a151963957a0c7e5a10f5c831de7608f2dc4742e10a0bff962ba5509b2c987e644e866f968538ada9b9dc173f7d06c13d7fd976a9556c0b92399da6389a79920bd7a6449c10bc99c4d8621f8d82237e635025391224151ae2808e73c2955a60e60c501d0e9fa96b55ce0677e57fdbf149aecd83033c72896390072961db8da0c5f683ba2308d0815acd5b23311c530e15a5ec406435cbabf12617615ddde9db78f91be2c139a96e354f7e1276393d6b0e1f0f5c98b2ea4c5f13e925201dd683080379e5c1e52c244a7b61937b3acda4e40ceb5c1b879fa0fa3f556f2b8cd0b978169299c61fa2bd70bd8d4699dcbe70818945a8e36b234e554d92705390e9639b926e87bb1fcf22a60833cf2fd5e97c245a383e05c0a1b13f75135b3a742f652cd2e7da3e73e8da53493ee51fb001e7f12618f8cd52e05e4f653b88338bb3f50649e351b6fc9cefdcbcb40903acea8e572bfcae0b0571ce2e3d5363e578d13e6acb598d176f392a60638490f32c5e128fa2e7e444511e8281829cc11a39d59d789abd84b6002e84ce4ef485957b48b3210fa04f4552cad85f28be845f3812d72e86190af94b9c370c2a30d3b6eabcc3fdebd1b5f4e1258f054466cdfa2ba30aaf845046cc19db80c200ae27f90532be1526717f3a4152a78985c93e735f46edad5be9899b890368c7443bd8bf0ac52f33c0388d906d1ae2778dc9415f48fe5b4d0eb8dfbdf96400fc43247b8fc8603302649fd9938f5d8be1fd266a32d4bc33f07cadf49933d016ff6463617e1968bb04dcad750ff91fff3ddaa7eac57728aa4fda71b6562d5285138a90e7bfcd1c190684f8a4832c4bb77737b81cf021e01abe5a7371a0ebbe5617235503f804212feed8fcb82fc2eaee5dccff4c0423fd78e874c30ce500e1fe9c6722f768561c3c903cf1193342660764081c81cdf0a7cfa9e519becba3ab8fd7cb705ee5930d61f732151414f9ed04a548f1b6d7fdaa22ff84f94f787afd2bfcfbef75830dabadcd44d3db76f40e1e5f25bb08fb979499873f8e12d53976af844bf4b9d041a2784a23b4824b329a9cc7098605eb815c475fd8f7c525ec8879decce1c48dbb8250e58b9e3057bb355c954fd92034065744a2f2b9fc1970d4f61eec37d842e0ac703585960b13237e87d94764e9db6bc45918fde2a365ee5308c52f01576712f31ba9a8b0dcc27cae382</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Encrypted</summary>
    
    
    
    <category term="阶段性总结" scheme="https://xorex.space/categories/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="幸福" scheme="https://xorex.space/tags/%E5%B9%B8%E7%A6%8F/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 基础与配置</title>
    <link href="https://xorex.space/2022/01/01/2dfc14c136d8/"/>
    <id>https://xorex.space/2022/01/01/2dfc14c136d8/</id>
    <published>2022-01-01T11:56:51.000Z</published>
    <updated>2021-05-06T07:47:03.511Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>暂时放弃更新，等学完 MyBatis 再好好总结！！！</p></blockquote><h2 id="MyBatis-概述"><a href="#MyBatis-概述" class="headerlink" title="MyBatis 概述"></a>MyBatis 概述</h2><p>Mybatis 是一种持久层的框架，通过建立接口的方法和 XML 注册的 SQL 语句的映射关系来实现对数据库的操作。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="获取数据库连接之前"><a href="#获取数据库连接之前" class="headerlink" title="获取数据库连接之前"></a>获取数据库连接之前</h3><p>首先获取数据库的连接实例 SqlSession 的连接池 SqlSessionFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory factory; <span class="comment">//连接池</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String resource=<span class="string">&quot;MyBatis-config.xml&quot;</span>; <span class="comment">//连接池的配置文件</span></span><br><span class="line">        InputStream inputstream = Resources.getResourceAsStream(resource); <span class="comment">//将配置文件读入流中</span></span><br><span class="line">        factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputstream); <span class="comment">//按照配置文件建造 SqlSession 连接池</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSession</span><span class="params">()</span> </span>&#123; <span class="comment">//从连接池获取连接</span></span><br><span class="line">        <span class="keyword">return</span> factory.openSession();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取连接池需要在服务器启动的时候进行，所以放到静态代码块里面执行。上面的 <code>SqlSessionFactoryBuilder</code> 作用就是按照配置文件建造连接池，此实例用完就扔，所以不给外部引用，让 GC 把它回收了。留着 <code>SqlSessionFactory</code> 作为单独一个连接池管理 SQL 连接。</p><h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><p>在 <code>MyBatis-config.xml</code> 连接池配置中加入数据库连接环境，其中 <code>&lt;property&gt;</code> 标签中的 value 中依次填入所有的信息即可。</p><p>或者外部引入一个 properties 文件，里面写上数据库连接数据，然后用 <code>$&#123;PropertyName&#125;</code> 的方式引用。</p><p>外部文件 <code>DataBase.properties</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>然后配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;DataBase.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span> <span class="comment">&lt;!--引入外部的文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="建立-DAO-层方法和-SQL-语句的映射"><a href="#建立-DAO-层方法和-SQL-语句的映射" class="headerlink" title="建立 DAO 层方法和 SQL 语句的映射"></a>建立 DAO 层方法和 SQL 语句的映射</h3><p>DAO 层的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUserByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">queryUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">queryUserByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建数据库操作接口映射的 XML 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;space.xorex.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;space.xorex.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意上面的 <code>namespace</code> 是下方的 SQL 语句映射的<strong>执行方法</strong>名称所在的定义空间（就是定义这些方法的接口），接口只能写完整的类名，不可以用别名。然后每一条就是执行方法映射的 SQL 语句。</p><p>对于这些映射标签，比如下面的，就一定要注意对应的接口方法名称的 参数 和 返回值，写对应的信息，而对于常见的数据类型，MyBatis 进行了别名映射，可以<strong>不区分大小写</strong>的使用这些别名。然后就是占位符的填充，使用 <code>#&#123;&#125;</code> 里面写数据名，是从 parameterType 中寻找的。</p><p>如果为 Java 设置的 Java 内置数据类型（基本数据 + String + Map + List 之类的），则使用参数名即可，比如下面的 <code>#&#123;userName&#125;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByUserName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;space.xorex.pojo.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--这里 string 就是一个规定好的 java.lang.String 的别名--&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from user</span><br><span class="line">    where userName=#&#123;userName&#125;; <span class="tag">&lt;&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;暂时放弃更新，等学完 MyBatis 再好好总结！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;MyBatis-概述&quot;&gt;&lt;a href=&quot;#MyBatis-概述&quot; class=&quot;headerlink&quot; title=&quot;MyBatis 概述</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Spring 框架学习笔记</title>
    <link href="https://xorex.space/2022/01/01/d68ebc25d776/"/>
    <id>https://xorex.space/2022/01/01/d68ebc25d776/</id>
    <published>2022-01-01T09:53:05.000Z</published>
    <updated>2021-05-06T07:46:52.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-Spring-框架"><a href="#关于-Spring-框架" class="headerlink" title="关于 Spring 框架"></a>关于 Spring 框架</h2><blockquote><p>暂时放弃更新，完全学完 Spring 之后再来总结。</p></blockquote><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="set-方法属性注入"><a href="#set-方法属性注入" class="headerlink" title="set 方法属性注入"></a>set 方法属性注入</h3><p>具体方法就是使用 IOC 获取到对象之后，调用对象的 setXXX() 方法设置属性。</p><h3 id="lt-property-gt-注入"><a href="#lt-property-gt-注入" class="headerlink" title="&lt;property&gt; 注入"></a>&lt;property&gt; 注入</h3><p>在 Spring 的 Bean XML 文件的 <code>&lt;bean&gt;&lt;/bean&gt;</code> 标签里面添加属性标签，<code>&lt;property&gt;</code> 标签内部有属性 name 和 value，用于设置属性值。这种方法本质上使用的是 <strong>setXXX()</strong> 方法完成的。</p><h3 id="lt-constructor-arg-gt-注入"><a href="#lt-constructor-arg-gt-注入" class="headerlink" title="&lt;constructor-arg&gt; 注入"></a>&lt;constructor-arg&gt; 注入</h3><p>在 Spring 的 Bean XML 文件的 <code>&lt;bean&gt;&lt;/bean&gt;</code> 标签里面添加属性标签，<code>&lt;constructor-arg&gt;</code> 标签内部有属性 name 和 value，用于设置属性值。这种方法本质上使用的 <strong>构造方法</strong> 完成的，使用的时候一定要检查以下所对应的构造方法是否正确。</p><h3 id="p-名称空间注入"><a href="#p-名称空间注入" class="headerlink" title="p 名称空间注入"></a>p 名称空间注入</h3><p>本质上使用 <strong>getXXX()</strong> 方法完成的，首先需要在 xml 头添加一条固定的属性：<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code> 然后就可以在 <code>&lt;bean&gt;</code> 里面通过给属性 <code>p:XXX</code> 来 set 对象的属性值了（这里 XXX 为对象属性名称）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于-Spring-框架&quot;&gt;&lt;a href=&quot;#关于-Spring-框架&quot; class=&quot;headerlink&quot; title=&quot;关于 Spring 框架&quot;&gt;&lt;/a&gt;关于 Spring 框架&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;暂时放弃更新，完全学完 Sprin</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Spring" scheme="https://xorex.space/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-07-拦截器/国际化</title>
    <link href="https://xorex.space/2021/06/16/a51fb26d70c9/"/>
    <id>https://xorex.space/2021/06/16/a51fb26d70c9/</id>
    <published>2021-06-16T13:14:45.000Z</published>
    <updated>2021-06-16T14:38:36.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>加强版本的 Filter，MVC 中的接口为 HandlerInterceptor 处理拦截器，一共有三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">()</span></span>; <span class="comment">//执行请求处理方法之前执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">()</span></span>; <span class="comment">//执行请求处理方法之后执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">()</span></span>; <span class="comment">//视图渲染完成之后执行</span></span><br></pre></td></tr></table></figure><p>自己实现 HandlerInterceptor 之后，需要在 SpringMVC 中配置拦截器的信息才可以使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/Interceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.SpringMVC_01.Interceptor.MyInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多重拦截器"><a href="#多重拦截器" class="headerlink" title="多重拦截器"></a>多重拦截器</h3><p>当有多个拦截器匹配到某个方法的时候，整体拦截器的工作顺序是按照在 SpringMVC 配置的顺序执行的。</p><p>而对于 preHandle() 和 postHandle() 则是按照一层一层套娃执行的，拦截器执行顺序靠前的在最外层，拦截器配置 01 在 02 前面：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">01 preHandle() is invoked!</span><br><span class="line">02 preHandle() is invoked!</span><br><span class="line">testInterceptor() is invoked!</span><br><span class="line">02 postHandle() is invoked!</span><br><span class="line">01 postHandle() is invoked!</span><br><span class="line">02 afterCompletion() is invoked!</span><br><span class="line">01 afterCompletion() is invoked!</span><br></pre></td></tr></table></figure><p>而 afterCompletion() 作为最后执行的擦屁股方法，和 try-catch-finally 里面的 finally 代码块类似，等待前面的套娃执行完毕，再单独按照顺序套娃从内到外执行最后的处理。可以记忆为，prehandle 顺序执行，postHandle() 和 afterCompletion() 逆序执行。</p><h3 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h3><p>对于配置了一个拦截器的执行方法被 preHandler() return 了 false，那么后面的请求处理方法、postHandle() 和 afterCompletion() 都停止执行。</p><p>如果多个拦截器的执行方法被某一个 preHandler() return 了 false，那么这个 preHandler() 所在的截断了的拦截器的<strong>后面拦截器的</strong>所有方法（preHandler()、postHandle() 和 afterCompletion()）都不会再执行。而<strong>前面所有放行了的拦截器</strong>的 afterCompletion() 方法作为拦截器的结尾处理还是会被执行的！</p><p>举个例子，01、02 和 03 三个拦截器，02 的 preHandler() return false，进行截断，那么方法的执行结果为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01 preHandle() is invoked!</span><br><span class="line">02 preHandle() is invoked!</span><br><span class="line">01 afterCompletion() is invoked! //因为 01 的 preHandle() 放行了，所以需要执行收尾方法、</span><br></pre></td></tr></table></figure><p>所以如果一旦被拦截，整个请求就不会被处理了，也不会有有效的响应。</p><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;拦截器&quot;&gt;&lt;a href=&quot;#拦截器&quot; class=&quot;headerlink&quot; title=&quot;拦截器&quot;&gt;&lt;/a&gt;拦截器&lt;/h2&gt;&lt;h3 id=&quot;基础使用&quot;&gt;&lt;a href=&quot;#基础使用&quot; class=&quot;headerlink&quot; title=&quot;基础使用&quot;&gt;&lt;/a&gt;基础使</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-06-AJAX支持/文件上传</title>
    <link href="https://xorex.space/2021/06/15/de23fc4f3bd1/"/>
    <id>https://xorex.space/2021/06/15/de23fc4f3bd1/</id>
    <published>2021-06-15T14:46:38.000Z</published>
    <updated>2021-06-16T14:38:03.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="响应-AJAX-的-Json-类型"><a href="#响应-AJAX-的-Json-类型" class="headerlink" title="响应 AJAX 的 Json 类型"></a>响应 AJAX 的 Json 类型</h2><h3 id="设置响应内容"><a href="#设置响应内容" class="headerlink" title="设置响应内容"></a>设置响应内容</h3><p>只需要在请求处理方法前面加上 <code>@ResponseBody</code> 表示将方法返回值添加到响应体中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ajax&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAjax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;AJAX!&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会在响应体里面看到一串 JS 代码了。</p><h3 id="Json-处理"><a href="#Json-处理" class="headerlink" title="Json 处理"></a>Json 处理</h3><p>SpringMVC 支持自动将对象转化为 Json 格式的字符串，需要导入三个包：<code>jackson-core</code>，<code>jackson-annotations</code>，<code>jackson-databind</code>。然后对于将自定义对象返回的方法，会自动转化为 Json 字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ajax/get&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title">returnAjax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> employeeDao.getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法返回的值是一个 <code>Collection&lt;Employee&gt;</code> 对象，但是标注了 <code>@ResponseBody</code> 之后，这个对象会经过转换器转化为 Json 格式（因为我们引入的 <code>jackson-core</code> 里面的 Json 转化器被添加到了转化器列表里面）</p><p>还可以使用一些其他关于 Json 的注解来控制转化的过程，如 <code>@JsonIgnore</code> 用于标注被省略转化的字段，使用 <code>JsonFormat(pattern=&quot;XXXX&quot;)</code> 来规定向 Date Time 这样的字段的转化格式等等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"><span class="meta">@JsonIgnore</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure><p>然后响应体里面返回的转化 Json 就是按照我们的要求的了，没有 password，时间按照 yyyy-MM-dd 格式： <code>&#123;&quot;userName&quot;:&quot;Tempest&quot;,&quot;email&quot;:&quot;cloudloverain@Foxmail.com&quot;,&quot;date&quot;:&quot;2021-06-16&quot;&#125;</code></p><h3 id="获取请求内容"><a href="#获取请求内容" class="headerlink" title="获取请求内容"></a>获取请求内容</h3><p>只需要在请求处理方法的参数前面加上 <code>@RequestBody</code> 表示将请求中的请求体放入参数中，比如我们设置一个 userName 的 Post 提交，按照 SpringMVC 参数填充规则，是无法填充到 <code>String body</code> 上面的，没有设置注解，参数名也不匹配，但是我们标注 <code>@RequestBody</code> 之后，整个 Post 的请求体会作为一个 String 字符串填充到 body 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;ajax/post&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAjax</span><span class="params">(<span class="meta">@RequestBody</span> String body)</span> </span>&#123;</span><br><span class="line">    System.out.println(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果，为 Post 所有内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tempest=Xorex&amp;Submit=Submit</span><br></pre></td></tr></table></figure><hr><p>而 <code>@RequestBody</code> 也支持自动转化格式的功能，比如将请求体中的 Json 数据转化为对象：</p><p>请求体：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;userName&quot;</span>:<span class="string">&quot;Tempest&quot;</span>,<span class="attr">&quot;password&quot;</span>:<span class="string">&quot;Xorex&quot;</span>,<span class="attr">&quot;email&quot;</span>:<span class="string">&quot;cloudloverain@Foxmail.com&quot;</span>,<span class="attr">&quot;date&quot;</span>:<span class="string">&quot;2021-06-16&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>接收请求的处理方法，将 Json 自动转化为 User 对象并传入参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;ajax/post&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAjax</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Body-数据转化原理"><a href="#Body-数据转化原理" class="headerlink" title="Body 数据转化原理"></a>Body 数据转化原理</h2><h3 id="HttpMessageConverter-lt-T-gt"><a href="#HttpMessageConverter-lt-T-gt" class="headerlink" title="HttpMessageConverter&lt;T&gt;"></a>HttpMessageConverter&lt;T&gt;</h3><p>对于请求 Body 和响应 Body 和 Java 对象的数据转化流程如下：</p><p><img src="https://xorex.space/image/302.jpg" alt="302.jpg"></p><p>对于任意一个涉及到 Body 数据转换的请求或者响应，SpringMVC 会遍历自己拥有的所有 <code>HttpMessageConverter&lt;T&gt;</code>，去一一确认是否能处理此转换，默认实现了的转换器如下：</p><p><img src="https://xorex.space/image/303.jpg" alt="303.jpg"></p><h3 id="使用-HttpEntity-lt-T-gt-代替-RequestBody"><a href="#使用-HttpEntity-lt-T-gt-代替-RequestBody" class="headerlink" title="使用 HttpEntity&lt;T&gt; 代替 @RequestBody"></a>使用 HttpEntity&lt;T&gt; 代替 @RequestBody</h3><p>将这个类作为请求参数，泛型 T 写为 RequestBody 需要被转化的类型（会依次寻找能处理 T 的Converter）。然后调用 <code>getBody()</code> 、<code>getHeaders()</code> 等来获取更加完整的请求信息（请求头）;</p><h3 id="使用-ResponseEntity-lt-T-gt-代替-ResponseBody"><a href="#使用-ResponseEntity-lt-T-gt-代替-ResponseBody" class="headerlink" title="使用 ResponseEntity&lt;T&gt; 代替 @ResponseBody"></a>使用 ResponseEntity&lt;T&gt; 代替 @ResponseBody</h3><p>只需要将这个这个类作为请求处理方法的返回类型，泛型 T 为向响应体写入的数据类型，也就是 Object-&gt;String 转化的 Object 类型。</p><p>比如下面设置请求头（setcookie），设置请求体（User 用 Json 格式转 String），设置响应码（200 OK）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/Entity&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">getEntity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;cloudloverain@foxmail.com&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    MultiValueMap&lt;String,String&gt; headers=<span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    headers.set(HttpHeaders.SET_COOKIE, <span class="string">&quot;Temespt=Xorex&quot;</span>);</span><br><span class="line">    HttpStatus status=HttpStatus.OK;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(user, headers, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>对于多媒体文件的处理在 SpringMVC 中使用的是 MultipartResolver 这个组件来解决的，当我们需要处理文件上传的时候，就需要给这个组件设置一个实现类去处理。</p><p>从 MultipartResolver 的创建过程可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.multipartResolver = (MultipartResolver)context.getBean(<span class="string">&quot;multipartResolver&quot;</span>, MultipartResolver.class);</span><br></pre></td></tr></table></figure><p>我们只需要在 ioc 容器中注册一个 id 为 multipartResolver 的 Bean 即可，这里使用的是：<code>CommonsMultipartResolver</code> 这个实现类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;1024*1024*100&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置最大上传文件大小为100MB--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="单文件接收"><a href="#单文件接收" class="headerlink" title="单文件接收"></a>单文件接收</h3><p>然后使用 <code>MultipartFile</code> 类作为参数来接受请求发过来的文件，需要注意的是 <code>getName()</code> 指的是文件上传的 key 值 file，而 <code>getOriginalFileName()</code> 指的是文件本身的名字 <code>XXX.jpg</code>，使用它自带的 <code>transferTo(File)</code> 方法将上传来的文件转移到指定的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEntity</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    file.transferTo(<span class="keyword">new</span> File(<span class="string">&quot;D:\\Pictures\\Saved Pictures\\Tempest.jpg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>注意需要将文件上传的表单里面添加一项 <code>enctype=&quot;multipart/form-data&quot;</code>，其不对字符编码。当使用有文件上传控件的表单时，该值是必需的。</p><p>如果不加编码规则，那么上传的就是 <code>file=fileName</code>，并不包含多媒体数据（上传文件本身），惨痛结果：</p><p><img src="https://xorex.space/image/304.jpg" alt="304.jpg"></p><p>加了之后（没找到请求体 QAQ）：</p><p><img src="https://xorex.space/image/305.jpg" alt="305.jpg"></p><h3 id="多文件接收"><a href="#多文件接收" class="headerlink" title="多文件接收"></a>多文件接收</h3><p>这里的多文件指的是一个 name 对应多个文件的情景，这个时候只需要使用 <code>MultipartFile[]</code> 来接收文件即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEntity</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file,<span class="meta">@RequestParam(&quot;files&quot;)</span> MultipartFile[] files)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(file.getOriginalFilename());</span><br><span class="line">    <span class="keyword">for</span> (MultipartFile multipartFile : files) &#123;</span><br><span class="line">        System.out.println(multipartFile.getOriginalFilename());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;响应-AJAX-的-Json-类型&quot;&gt;&lt;a href=&quot;#响应-AJAX-的-Json-类型&quot; class=&quot;headerlink&quot; title=&quot;响应 AJAX 的 Json 类型&quot;&gt;&lt;/a&gt;响应 AJAX 的 Json 类型&lt;/h2&gt;&lt;h3 id=&quot;设置响应内</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-05-数据绑定/转化/校验</title>
    <link href="https://xorex.space/2021/06/11/4130a9517564/"/>
    <id>https://xorex.space/2021/06/11/4130a9517564/</id>
    <published>2021-06-11T06:16:40.000Z</published>
    <updated>2021-06-15T14:48:05.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="静动态资源处理管理"><a href="#静动态资源处理管理" class="headerlink" title="静动态资源处理管理"></a>静动态资源处理管理</h2><p>我们最初在配置 <code>DispatcherServlet</code> 来作为处理方法映射的时候，因为静态资源无法找到对应的处理方法，所以无法访问，针对这个问题，使用 <code>&lt;mvc:default-servlet-handler/&gt;</code> 之后，SpringMVC 将在容器中中定义一个 SimpleUrlhandlerMapping，它的作用就是将请求交给 WEB 应用服务器默认的 Tomcat 处理，这样静态资源的访问就得到了解决。</p><p>但是我们标注了 <code>&lt;mvc:default-servlet-handler/&gt;</code> 之后，会覆盖 SimpleUrlHandlerMapping 为我们处理方法映射的 DefaultAnnotationHandlerMapping。这样处理动态资源访问的映射关系就没有了，因此动态资源无法访问。</p><p>解决方法就是：使用 <code>&lt;mvc:annotation-driven/&gt;</code>，添加这个设置之后，就会多出来一个优先级最高的 RequestMappingHandlerMapping，专门处理动态资源访问和处理方法之间的映射关系。只有这个 Mapping 无法处理的资源（静态资源），才会交给后面的 SimpleUrlHandlerMapping 处理（交给 Tomcat）。</p><h2 id="lt-mcv-anntation-driven-gt"><a href="#lt-mcv-anntation-driven-gt" class="headerlink" title="&lt;mcv:anntation-driven&gt;"></a>&lt;mcv:anntation-driven&gt;</h2><p>这个配置的字面意思就是 MVC 注解驱动。那么这个配置有什么用呢？</p><ul><li><p><code>&lt;mvc:annotation-driven/&gt;</code> 会自动注册： RequestMappingHandlerMapping 、 RequestMappingHandlerAdapter 与 ExceptionHandlerExceptionResolver 三个 bean。</p></li><li><p>还将提供以下支持：</p></li></ul><ol><li>支持使用 ConversionService 实例对表单参数进行类型转换</li><li>支持使用 @NumberFormat、@DateTimeFormat 注解完成数据类型的格式化</li><li>支持使用 @Valid 注解对 JavaBean 实例进行 JSR 303 验证</li><li>支持使用 @RequestBody 和 @ResponseBody 注解实现 AJAX</li></ol><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>数据绑定指的是从请求的数据到处理方法中的参数这个过程，在 SpringMVC 中，数据绑定的流程大概如下：</p><ol><li>SpringMVC 主框架将 ServletRequest 对象及目标方法的入参实例传递给 WebDataBinderFactory 实例，以创建 DataBinder 实例对象</li><li>DataBinder 调用装配在 SpringMVC 上下文中的 ConversionService 组件进行数据类型转换、数据格式化工作。将 Servlet 中的请求信息填充到入参对象中</li><li>调用 Validator 组件对已经绑定了请求消息的入参对象进行数据合法性校验，并最终生成数据绑定结果 BindingData 对象</li><li>SpringMVC 抽取 BindingResult 中的入参对象和校验错误对象，将它们赋给处理方法的参数。</li></ol><p>也就是过程如下：</p><p><img src="https://xorex.space/image/301.jpg" alt="301.jpg"></p><p>在 SpringMVC 的 ConversionService 数据转化服务中，有大量的转化器 Converter 可以作为用于将 String 类型的数据转化为 Java 常间的类型，但是对于我们自己设置的类型，如果需要转化则需要我们手动实现 Converter 接口。</p><p>比如我们想要将 String 类型转化为 User 类型；<code>&quot;Xorex-Tempest-Xorex@Tempest.com&quot;</code> -&gt; <code>User&#123;username=Xorex,password=Tempest,email=Xorex@Tempest.com&#125;</code> 需要这样实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToUserConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] datas=s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(datas[<span class="number">0</span>],datas[<span class="number">1</span>],datas[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了 Converter 之后，需要将我们自己实现的 Converter 放入执行转化服务的 ConversionService 中。而麻烦之处在于 ConversionService 是由 ConversionServiceFactoryBean 生成的，那么我们最终其实是将 Converter 交给 FormattingConversionServiceFactoryBean，由这个工厂来生成含有自定义 Converter 的 ConversionService。</p><p>所以我们需要 SpringMVC 配置文件中，声明：将自定义 Converter 交给 FormattingConversionServiceFactoryBean 并告诉 SpringMVC 用这个含有我们自定义 Converter 的 FactoryBean 来生成 ConversionService:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.SpringMVC_01.Conversion.StringToUserConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数据格式化"><a href="#数据格式化" class="headerlink" title="数据格式化"></a>数据格式化</h2><p>前面介绍了通过实现 Converter 来实现自定义数据和请求数据的绑定。下面来介绍一下请求数据的格式化，也就是将请求发过来的数据转化为格式化的数据，比如将 <code>2021-06-01</code> 转化为 Date 对象。将 <code>$12,123,234.3242</code> 转化为 Double 对象等等。</p><p>这里使用的 Format 注解：<code>@DateTimeFormat</code> 和 <code>@NumberFormat</code> 等，只需要标注到需要接收格式化的参数或者字段前面，被 SpringMVC 自动填充的时候，就会根据 ConversionService 里面定义的 Format 规则进行格式化了。</p><p>而我们上面配置的 FormattingConversionServiceFactoryBean 这个工厂生成的 ConversionService 就包含一系列 Format 类型的 Class 用于数据格式化，而不同的注解也有不同的格式化方法，需要在注解参数 <code>pattern</code> 中填写。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/date&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDate</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date)</span> </span>&#123;</span><br><span class="line">    System.out.println(date);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/number&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNumber</span><span class="params">(<span class="meta">@NumberFormat(pattern = &quot;$#,###.##&quot;)</span> Double money)</span> </span>&#123;</span><br><span class="line">    System.out.println(money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间用 <code>yyyy-MM-dd</code> 规定传入的时间字符串格式，浮点数用 <code>$#,###.##</code> 规定传入的金钱的格式，对于 JavaBean 里面的数据使用格式化，则直接在 Bean 里面的字段加上注解即可，SpringMVC 进行参数填充的时候会读取上面的注解的。</p><h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><h3 id="JSR-303"><a href="#JSR-303" class="headerlink" title="JSR-303"></a>JSR-303</h3><p>对于数据在服务端进行的数据校验工作，我们自己写真的是太麻烦了，于是在 JAVA6 里面推出了一种规范：JSR-303，JSR 是 Java Specification Requests 的缩写，意思是 Java 规范提案，又叫做 Bean Validation。JSR 303 是 Java 为 bean 数据合法性校验提供的标准框架。</p><p>对于 JSR-303 的基本内容，Spring 本身就实现了，只需要 MVC 设置里面添加 Spring 的本地 validator 到 IOC 容器中并告诉注解驱动器用指定搞得 validator 去处理 JSR-303 的注解。validator 实现来源则是 LocalValidatorFactoryBean 生成的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;localValidatorFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> <span class="comment">&lt;!--IOC 中注册 validator 来源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">validator</span>=<span class="string">&quot;localValidatorFactoryBean&quot;</span>/&gt;</span>  <span class="comment">&lt;!--告诉注解驱动用哪个 validator 处理 JSR-303 驱动--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JavaBean-校验"><a href="#JavaBean-校验" class="headerlink" title="JavaBean 校验"></a>JavaBean 校验</h3><p>然后我们就可以利用 JSR-303 定义的注解，去去进行数据校验了，这里的所有注解可以查看文档。对于自定义 Bean ，在 Bean 的声明处向内部标校验注解，然后参数处标注 <code>@Valid</code> 表示需要要校验这个 Bean,并<strong>紧接着</strong>被校验的 Bean 声明一个参数：<code>BindingResult result</code> 或者 <code>Errors errors</code>，这个  两个类可以记录校验的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@Past</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/valid&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testValid</span><span class="params">(<span class="meta">@Valid</span> User user,BindingResult result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.hasErrors()) &#123; <span class="comment">//从校验结果中查看是否校验成功</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非自定义-JavaBean-校验"><a href="#非自定义-JavaBean-校验" class="headerlink" title="非自定义 JavaBean 校验"></a>非自定义 JavaBean 校验</h3><p>对于非自定义类型的数据，首先需要在 IOC 容器中注册一个 MethodValidationPostProcessor 用来校验方法参数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.validation.beanvalidation.MethodValidationPostProcessor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在处理方法所在的 Controller 类中加入注解 <code>@Validated</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmplController</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将 JSR-303 注解标注到对应参数头上，如果校验失败，则会抛出异常（javax.validation.ConstraintViolationException），需要注意的是，这里无法使用 BindingResult 和 Errors 来查看错误，只能拦截异常 （好麻烦啊！！！）</p><h3 id="自定义错误消息"><a href="#自定义错误消息" class="headerlink" title="自定义错误消息"></a>自定义错误消息</h3><p>最简单的方法就是在任何一个校验的注解里面添加 message 属性，里面填写需要自定错误的消息。这样我们取出来的 Message 就是我们自己设置的错误了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull(message = &quot;老哥不能空啊！&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="meta">@NotNull(message = &quot;老哥不能空啊！&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@Email(message = &quot;老哥你邮箱不对啊！&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure><p>但是如果需要实现国际化的话，具体的流程和 JstlView 实现国际化的流程都是一样的，唯一的不同是对国际化文件的 Key 进行一定的规则限制。</p><p>因为我们在回显错误信息的时候，比如使用 <code>&lt;form:errors path=&quot;email&quot;&gt;</code> 来现实隐含模型中属性为 email 的校验错误的时候，他会根据一定的规则从国际化文档中寻找对应的 Key：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Email.user.email=XXXX //在隐含模型的 user 对象的 email 字段使用 @Email 校验时，匹配此国际化错误信息</span><br><span class="line">Email.email=XXXX //在隐含模型任意对象中的 email 字段使用 @Email 校验时，匹配此国际化错误信息</span><br><span class="line">Email.java.lang.String=XXXX //字段为 String 的值使用 @Email 校验时，匹配此国际化错误信息</span><br><span class="line">Email=XXXX //任意字段使用 @Email 校验时，匹配此国际化错误信息</span><br></pre></td></tr></table></figure><p>当有多个国际化 Key 得到匹配的时候，同样按照精确度决定匹配优先级。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;静动态资源处理管理&quot;&gt;&lt;a href=&quot;#静动态资源处理管理&quot; class=&quot;headerlink&quot; title=&quot;静动态资源处理管理&quot;&gt;&lt;/a&gt;静动态资源处理管理&lt;/h2&gt;&lt;p&gt;我们最初在配置 &lt;code&gt;DispatcherServlet&lt;/code&gt; 来作为</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-04-视图/视图解析器</title>
    <link href="https://xorex.space/2021/06/09/b91e91480bcd/"/>
    <id>https://xorex.space/2021/06/09/b91e91480bcd/</id>
    <published>2021-06-09T14:54:23.000Z</published>
    <updated>2021-06-16T14:37:36.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h2><h3 id="forward-转发"><a href="#forward-转发" class="headerlink" title="forward: 转发"></a>forward: 转发</h3><p>和原本的 SpringMVC 一样，写在方法的返回值处，不过不同的是 forward: 不会被拼串，并且是以项目地址为相对路径的。</p><p>原：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/TestRequest/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView requestScope = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> requestScope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forward:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/TestRequest/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView requestScope = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;forward:/WEB-INF/pages/hello.jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> requestScope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redirect-重定向"><a href="#redirect-重定向" class="headerlink" title="redirect: 重定向"></a>redirect: 重定向</h3><p>使用方法和 <code>forward:</code> 转发是一样的，和使用 <code>response.sendRedirect(&quot;/XXX&quot;)</code> 唯一不同的是，相对地址会自动加上项目地址，方便浏览器解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/TestRequest/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView requestScope = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;redirect:/WEB-INF/pages/hello.jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> requestScope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="视图解析原理"><a href="#视图解析原理" class="headerlink" title="视图解析原理"></a>视图解析原理</h3><blockquote><p>这一段转自与知乎，其实自己也写了总结，但是觉得不太行，没有下文理解的清晰。</p></blockquote><ol><li><p>当我们对 SpringMVC 控制的资源发起请求时，这些请求都会被 SpringMVC 的 org.springframework.web.servlet.DispatcherServlet 处理，接着 SpringMVC 会分析看哪一个 HandlerMapping 定义的请求映射中存在对该请求的最合理的映射。然后通过该 HandlerMapping 取得其对应的 Handler（也就是我们定义的处理请求方法），接着再通过相应的 HandlerAdapter 处理该 Handler。HandlerAdapter 再对Handler 进行处理。</p></li><li><p>之后会返回一个 ModelAndView 对象。在获得了 ModelAndView 对象之后，Spring 就需要把该 View 渲染给用户，即返回给浏览器。在这个渲染的过程中，发挥作用的就是 ViewResolver 和 View。当 Handler 返回的 ModelAndView 中不包含真正的视图，只返回一个逻辑视图名称，ViewResolver 会把该逻辑视图名称解析为真正的视图 View 对象。View 真正进行视图渲染，把结果返回给浏览器。</p></li></ol><p>而 ViewResolver 和 View 都是一个接口，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">View <span class="title">resolveViewName</span><span class="params">(String var1, Locale var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125; <span class="comment">//用于解析 ModelAndView 里面保存的 viewName 然后根据解析结果生成一个合适的 View 实现对象。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String, ?&gt; var1, HttpServletRequest var2, HttpServletResponse var3)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125; <span class="comment">//实现 View 接口只需要实现 render() 方法即可，render 渲染，将获取的数据和展示模板一起渲染成一个用户收到的页面。</span></span><br></pre></td></tr></table></figure><p>调用 View 对象的 render 渲染（指生成用户看到的 html 页面）方法，进行请求转发（并将模型输入放入 Request 域中），或者请求重定向。SpringMVC 主要负责的是生成 View 的过程，至于不同的 View 接口实现可以五花八门，实现了视图层的解耦。</p><h2 id="使用-JstlView-实现国际化"><a href="#使用-JstlView-实现国际化" class="headerlink" title="使用 JstlView 实现国际化"></a>使用 JstlView 实现国际化</h2><p>在 Spring 中导入 taglibs-standard-impl 和 taglibs-standard-spec 这两个包之后，在 Spring 中配置的 InternalResourceViewResolver 中，添加 viewClass 属性值为 JstlView 之后，ViewResolver 将生成的 View 实例从原本的 InternalResourceView 更改为更强大的子类：JstlView。</p><p>这个 View 强大之处就是大大简化了国际化的配置与使用。</p><p>首先搞几个不同国家地区的文字：<code>i18n_en_US.properties</code> 和 <code>i18n_zh_CN.properties</code> 。然后在 Spring 中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;i18n&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意 id 一定要是 <code>messageSource</code> ，Spring 是根据这个 id 名字来寻找绑定的国际化信息的。然后在相关的 jsp 页面引入 fmt 标签，然后使用  <code>&lt;fmt:message&gt;</code> 来输出国际化信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">fmt:message</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fmt:message</span> <span class="attr">key</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="请求页面跳转访问"><a href="#请求页面跳转访问" class="headerlink" title="请求页面跳转访问"></a>请求页面跳转访问</h2><p>因为很多强大的功能只有经过 SpringMVC 才能实现，比如上面的国际化，这就需要我们对一些直接访问的资源经过 SpringMVC 处理，或者访问 WEB-INF 下面的资源，也需要进行请求转发才可以获取资源。那么大量的仅仅只进行请求转发的处理方法写起来太乱了，可以直接用一条 Spring 的配置解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/Login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Login&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringMVC 支持通过配置的方法，来实现访问地址直接向 WEB-INF 下资源的访问：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;Login&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>但是需要注意的是，使用了 <code>mvc:view-controller</code> 来接管对请求路径的访问之后，会打断原本注解标注的 <code>@RequestMapping</code>，需要额外添加一个 <code>mvc:annotation-driven</code> 来进行扫描注解接管请求映射。</p><h2 id="自定义视图解析器"><a href="#自定义视图解析器" class="headerlink" title="自定义视图解析器"></a>自定义视图解析器</h2><p>大致过程：首先实现 ViewResolver 和 View 两个接口。ViewResolver 还需要实现 Ordered ，来将优先级提高到高于 InternalResourceViewResolver，只需要获取的 order 值越低，权重越高！</p><p>如果开头是 Tempest ，则确认为本 ViewResolver 处理对象，返回一个本 ViewResolver 生成的 View 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewResolver</span> <span class="keyword">implements</span> <span class="title">ViewResolver</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> order;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">resolveViewName</span><span class="params">(String s, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.startsWith(<span class="string">&quot;Tempest:&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyView(s.substring(<span class="number">8</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">(<span class="keyword">int</span> order)</span> </span>&#123; <span class="comment">// 这个 order 值是在 Spring 的配置文件里面设置的</span></span><br><span class="line">        <span class="keyword">this</span>.order=order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 View 的渲染方式就是转发请求到指定的页面中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">implements</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    MyView(String address) &#123;</span><br><span class="line">        <span class="keyword">this</span>.address=address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String, ?&gt; map, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/pages/&quot;</span>+address+<span class="string">&quot;.jsp&quot;</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后记得将自己实现的 ViewResolver 添加到 IOC 容器（配置文件注册 bean 的 class 即可）中，Spring 会根据是否实现 ViewResolver 接口决定此类是否为视图解析类，并在控制 View 生成的时候，依次调用所有的 ViewResolver 的 resolveViewName() 方法。所以必须让 Spring 知道自己才有可能被调用去生成 View。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.SpringMVC.ViewResolver.MyViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们再进行请求映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Tempest:hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当我们发起 <code>XXXX/test/</code> 的请求的时候，就会将 <code>Tempest:hello</code> 视图名根据 order 权重依次传入 ViewResolver 的 resolveViewName() 中，我们写的 ViewResolver 看到了 <code>Tempest:</code> 的开头，匹配成功并返回我们自己实现的 View：MyView，最后调用 MyView 的渲染方法 render() 并执行我们指定的请求转发代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;视图层&quot;&gt;&lt;a href=&quot;#视图层&quot; class=&quot;headerlink&quot; title=&quot;视图层&quot;&gt;&lt;/a&gt;视图层&lt;/h2&gt;&lt;h3 id=&quot;forward-转发&quot;&gt;&lt;a href=&quot;#forward-转发&quot; class=&quot;headerlink&quot; title=&quot;f</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-03-处理模型数据</title>
    <link href="https://xorex.space/2021/06/07/70114f9842ce/"/>
    <id>https://xorex.space/2021/06/07/70114f9842ce/</id>
    <published>2021-06-07T14:17:56.000Z</published>
    <updated>2021-06-15T09:14:56.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h2><h3 id="操作-Map-系列参数"><a href="#操作-Map-系列参数" class="headerlink" title="操作 Map 系列参数"></a>操作 Map 系列参数</h3><p>方法参数加上 <code>Map&lt;String,Object&gt;</code>、<code>Model</code>、<code>ModelMap</code> 三个中的任意一个即可，我们只要将数据保存到这些的参数实例中，Spring 会自动帮我们把数据放到 <strong>Request</strong> 域中。</p><p>关于这三个有什么关系呢：</p><p><img src="https://xorex.space/image/300.jpg" alt="300.jpg"></p><p>其实 Spring 传入参数中的是 BindingAwareModelMap 实例，所以才能三个中任意一个作为参数都能实现数据的转发。</p><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h3><p>这里需要重点说一下用来处理隐含数据模型 bindingAwareModelMap 的注解 <code>@ModelAttribute</code>，此注解可被应用在方法或方法参数上。</p><h4 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h4><p>当 <code>@ModelAttribute</code> 标注到一个方法上面的时候，就意味着这个方法为数据模型处理方法，这个方法是用来在隐藏数据模型添加一些数据的。所以被这个注解标注的方法会在当前类下面的<strong>任意一个请求映射方法</strong>被调用<strong>之前运行</strong>。</p><p><code>@ModelAttribute</code> 标注方法有两种风格：</p><ul><li>在第一种写法中，方法通过返回值的方式默认地将添加一个属性；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute(&quot;Xorex&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;XXX&quot;</span>,<span class="string">&quot;XXX&quot;</span>,<span class="number">324234</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将返回的 User 对象添加到隐藏数据模型中，key 为我们在注解中设置的 <code>Xorex</code>，如果不设置，那么默认为添加的数据类型 User 的首字母小写 user。</p><ul><li>在第二种写法中，方法接收一个 Model 对象，然后可以向其中添加任意数量的属性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    model.addAtribute(<span class="string">&quot;Xorex&quot;</span>,<span class="keyword">new</span> User());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数注释"><a href="#参数注释" class="headerlink" title="参数注释"></a>参数注释</h4><p>标注在方法参数上的 <code>@ModelAttribute</code> 说明了该方法参数的值将由 model 中取得。如果 model 中找不到，那么该参数会先被实例化，然后被添加到 model 中。在 model 中存在以后，请求中所有名称匹配的参数都会填充到该参数中。</p><p>就是用来从隐含数据模型中取数据用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/XXX/XXX&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(<span class="meta">@ModelAttribute(&quot;Xorex&quot;)</span> User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;XXX/XXX&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而参数 user 可能来自于：</p><ol><li>因为 <code>@SessionAttributes</code> 标注的使用已经存在于 model 中</li><li>它可能因为在同个控制器中使用了 <code>@ModelAttribute</code> 方法已经存在于 model 中，正如上面所叙述的将注解标注到方法上面。</li><li>它可能是调用了自身的默认构造器被实例化出来的，在 model 中找不到实例，只能创建。</li></ol><h3 id="使用-ModelAndView"><a href="#使用-ModelAndView" class="headerlink" title="使用 ModelAndView"></a>使用 ModelAndView</h3><p>ModelAndView 模型（页面需要用到的数据）和视图（数据的展示），这个东西会同时起到两个作用，那就是 request 域数据的保存和页面的转发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/Test/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;hello&quot;</span>); <span class="comment">//确认转发的 View 层地址</span></span><br><span class="line">    mv.addObject(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>); <span class="comment">//向 request 域中写数据</span></span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 ModelAndView 作为方法返回对象，设置实例的转发 View 页面，设置 Model 数据。</p><h3 id="Session-中的数据"><a href="#Session-中的数据" class="headerlink" title="Session 中的数据"></a>Session 中的数据</h3><p>这里推荐还是使用原生的 API HttpSession 进行存取数据，更加方便安全。</p><p>而 SpringMVC 提供了两种和 Session 进行数据交互的注解，为标注在类上面的注解 <code>@SessionAttributes</code> 和标注在参数上面的注解 <code>@SessionAttribute</code>。</p><p>对于 <code>@SessionAttributes</code>：是用于在请求之间的 HTTP Servlet 会话中<strong>存储</strong> model 属性。其 Value 用来填写放入 Session 中的 Key，然后 Spring 会在隐含数据模型中寻找相同的 Key，并把里面的值复制一份放入 Session 中。也就是说 Session 有的，隐含数据域中也必须有。而注解的另外一个参数则是 Types，这个不是去隐含数据模型中寻找 Key 了，而是值的类型，将符合 Types 类型的数据放入 Session 中。这个很危险，不建议使用。</p><p>而且一旦在隐含数据模型中找不到指定的数据，那么 <code>@SessionAttributes</code> 注解就会报错。</p><hr><p>然后就是从 Session 中获取数据了，使用的是 <code>@SessionAttribute</code> 。</p><p>需要将 <code>@SessionAttribute(&quot;XXX&quot;)</code> 就可以将 Session 中保存的 key 为 XXX 的数据放入被标注的方法参数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/XXX/XXX&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(<span class="meta">@SessionAttribute(&quot;Xorex&quot;)</span> User user)</span> </span>&#123; <span class="comment">// 从 Session 中取出 key 为 Xorex 的值。</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;XXX/XXX&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据转发&quot;&gt;&lt;a href=&quot;#数据转发&quot; class=&quot;headerlink&quot; title=&quot;数据转发&quot;&gt;&lt;/a&gt;数据转发&lt;/h2&gt;&lt;h3 id=&quot;操作-Map-系列参数&quot;&gt;&lt;a href=&quot;#操作-Map-系列参数&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-02-请求数据获取</title>
    <link href="https://xorex.space/2021/06/06/fd142553b621/"/>
    <id>https://xorex.space/2021/06/06/fd142553b621/</id>
    <published>2021-06-05T16:36:36.000Z</published>
    <updated>2021-06-16T14:37:41.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>REST 即表述性状态传递（Representational State Transfer），是一种软件架构风格，指代使用不同的请求方式来表示这次请求需要完成的 CURD 的种类，然后在 URL 中携带被操作对象，</p><p>比如：</p><table><thead><tr><th>URL</th><th>请求方式</th><th>目的</th></tr></thead><tbody><tr><td>/book/1</td><td>get</td><td>获取 1 号图书</td></tr><tr><td>/book</td><td>post</td><td>添加图书</td></tr><tr><td>/book/1</td><td>put</td><td>更新图书</td></tr><tr><td>/book/1</td><td>delete</td><td>删除 1 号图书</td></tr></tbody></table><p>这里面要说一下 Post 和 Put 的区别，在官方 HTTP 协议中，规定 Put 为 idempotent（幂等） 方法，也就是多次连续请求造成结果应该相同。因此 Put 应该执行更新方法，而 Post 应该执行非幂等（多次执行添加请求会添加多个）的添加方法。</p><h3 id="实现-REST"><a href="#实现-REST" class="headerlink" title="实现 REST"></a>实现 REST</h3><p>因为 HTML 发起请求的方式只有 GET 和 POST，所以为了实现 REST，我们可以曲线救国。在 GET 或者 POST 里面添加请求参数，<code>_method</code>，放入 delete 和 put 作为参数，然后在 web.xml 中配置一个 Srping 的 Filter：<code>HiddenHttpMethodFilter</code>，过滤范围为所有的请求。</p><p>这个 Filter 会去查找是否拥有 <code>_method</code> 参数并且数据的请求类型是否为合法（指是否为 HTTP 协议里面的类型），如果合法，那么这个 Filter 会将 HttpRequest 里面的请求方法修改为我们设置的 <code>_method</code> 参数数据。</p><p>最后需要注意的是，在大于等于 8.0 版本的 Tomcat 里面使用 REST 的时候，因为 JSP 认为不是 Get 或者 Post 的请求都是有问题的，会爆出错误页面，为了掩盖这个问题，将当前 JSP 页面的页头添加设置 <code>isErrorPage=&quot;true&quot;</code>，就可以让 Tomcat 忽略这个问题了。</p><h2 id="获取请求信息"><a href="#获取请求信息" class="headerlink" title="获取请求信息"></a>获取请求信息</h2><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><h4 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h4><ol><li>方法声明变量名，参数名和变量名匹配的话就会将参数值传入方法中，比如下面当有参数： <code>username=XXX</code> 的时候，发现方法参数和请求参数名相匹配，就会将 XXX 传入方法中，没带则传入 null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>@RequestParam</code> 注解标注方法参数。</li></ol><p><code>(RequestParam(value = &quot;user&quot;,required = false,defaultValue = &quot;No_Name&quot;) String username)</code> 主要是解决方法参数名和请求参数名不一样的问题，给 value 附上别名即可（当然附上别名就<strong>只能使用别名</strong>来让方法参数接收数据了），required 则是标注这个参数是否必须要有（如果没有页面会报错 Required Parameter XXX）</p><hr><h4 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h4><p>SpringMVC 支持 POJO 类型的请求自动封装，会自动将符合匹配条件（名字一样）的请求参数放入 POJO 中。还支持 POJO 的级联封装，只需要加 <code>.</code> 即可：<code>address.home=Xorex&amp;address.school=CUIT</code> 就是对 Address 里的两个 String 进行赋值。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求：username=Xorex&amp;password=Xorex&amp;address.home=Xorex&amp;address.school=CUIT&amp;Xorex=Tempest</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">(User user,String username)</span>  </span>&#123;<span class="comment">// 两个封装并不冲突</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原生参数"><a href="#原生参数" class="headerlink" title="原生参数"></a>原生参数</h4><p>SpringMVC 支持自动传入原生 ServletAPI，直接写在方法的参数里面即可，会按照类型填入，支持类型：</p><ol><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li><li>java.security.Principal</li><li>Locale</li><li>InputStream</li><li>OutputStream</li><li>Reader</li><li>Writer</li></ol><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>使用 <code>@RequestHeader</code> 注解获取请求头信息，value 填写请求头名称， required 和 defaultValue 参考上面。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>使用 <code>@CookieValue</code> 注解获取请求中的 Cookie 信息，value 填写 Cookie 的 key，required 和 defaultValue 参考上面。</p><h2 id="请求响应乱码"><a href="#请求响应乱码" class="headerlink" title="请求响应乱码"></a>请求响应乱码</h2><ol><li>GET 请求乱码：</li></ol><p>GET 乱码主要是 Tomcat 中 Connector 对请求的解析的问题，只需要在 8080 端口的 Connector 的设置（在 server.xml 中）里添加 URLEncoding=”UTF-8” 即可、</p><ol start="2"><li>POST 请求乱码：\</li></ol><p>在 HttpServletRequest 实例设置 setCharacterEncoding(“UTF-8”)，或者写一个 Filter 将所有的请求提前设置一下。</p><p>最最最重要的是，Spring 内置了这个 Filter，不需要我们自己写！是 CharacterEncodingFilter ，直接配置到 web.xml 中即可，可选配置请求乱码 encoding 和相应乱码 forceEncoding 一起改:</p><p>更更更重要的是，这个 Filter 要<strong>放到其他的 Filter 前面</strong>，因为可能其他 Filter 回对请求里面的数据进行处理，应该修改完编码类型之后才可以！！！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;REST&quot;&gt;&lt;a href=&quot;#REST&quot; class=&quot;headerlink&quot; title=&quot;REST&quot;&gt;&lt;/a&gt;REST&lt;/h2&gt;&lt;p&gt;REST 即表述性状态传递（Representational State Transfer），是一种软件架构风格，指代使用不</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-01-基础请求处理</title>
    <link href="https://xorex.space/2021/06/05/28d8300ff21a/"/>
    <id>https://xorex.space/2021/06/05/28d8300ff21a/</id>
    <published>2021-06-05T08:49:25.000Z</published>
    <updated>2021-06-11T06:05:10.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先拿张图，这里面就是 Spring 可以胜任的功能，其中 Web 模块其实就是我们接下来要学习的 SpringMVC，使用 Spring 来控制 Web 项目里面的 Model View Controller 三层模型。</p><p><img src="https://xorex.space/image/298.jpg" alt="298.jpg"></p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>首先需要导入 Spring 的核心包，也就是支持 Spring 运作的 Beans Core Context SpEL 和用于测试 Spring 的 Test 包。</p><p>而对于 SpringMVC 来说，实现基础的功能只需要导入 Web 和 Servlet 两个包即可。</p><p>SpringMVC 的模式和传统的 MVC 有一点点不同，那就是多了一个前端控制器，这个控制器也是 SpringMVC 控制整个 Web MVC 流程的实现基础。而这个前端控制器本身是一个 Servlet，交给 Tomcat 控制。然后 Tomcat 会拦截所有的 Servlet 请求，全都交给前端控制器这个 Servlet，前端控制器则根据 SpringMVC 的框架标准，控制处于 Spring 容器中的各种对象来完成业务的实现。</p><p><img src="https://xorex.space/image/299.jpg" alt="299.jpg"></p><p>所以先在 web.xml 中配置 DispatcherServlet ，初始化参数给 spring 配置文件的地址，也就是 applicationContext.xml 用来控制 IOC 容器（如果不配置的话会默认去 WEB-INF/springDispathcherServlet-servlet.xml 读配置文件，其中文件前缀就是配置的 DispathcerServlet 的 servlet-name），并配置拦截 / 下的所有 Serlvet 请求（/* 会拦截所有资源的请求，包括 jsp， / 不会拦截 jsp），当然除了拦截 Servlet 请求，静态资源的请求也从 Tomcat 手里抢了过来，这个问题以后回补充解决方案。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispathcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispathcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>搞好了前端控制器之后，就可以写 Controller 层的控制器了，只需要随便写一个类，然后标注 @Controller ，就可以被 IOC 容器标注为控制层了，等到 DispathcerServlet 调用自己即可。</p><p>而对于这个伪装的 Servlet 如何有选择的处理不同的请求呢，这就依靠 @RequestMapping 注解，也就是请求映射，将请求和处理方法建立映射。</p><p>因为我们将请求映射配置为 /，所以 Spring MVC 将捕获 WEB 容器的所有请求，包括静态资源的请求， SpringMVC 会将他们当成一个普通请求处理，因找不到对应处理器将导致错误。解决方案就是在 SpringMVC 的配置文件中配置 <code>&lt;mvc:default-servlet-handler/&gt;</code> 的方式解决静态资源的问题：<br><code>&lt;mvc:default-servlet-handler/&gt;</code> 将在 SpringMVC 上下文中定义一个 DefaultServletHttpRequestHandler，它会对进入 DispatcherServlet 的请求进行筛查，如果发现是没有经过映射的请求，就将该请求交由 WEB 应用服务器默认的 Servlet 处理，如果不是静态资源的请求，才由 DispatcherServlet 继续处理。</p><h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&#123;&quot;/index.jsp&quot;,&quot;/index&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;WEB-INF/pages/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是将 <code>/index.jsp</code> 和 <code>/index</code> 两处的请求，转发到 return 里面填写的地址上面，这里使用的是请求转发。</p><h3 id="RequestMapping-相关"><a href="#RequestMapping-相关" class="headerlink" title="RequestMapping 相关"></a>RequestMapping 相关</h3><p>RequestMapping 定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;path&quot;)</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标注位置"><a href="#标注位置" class="headerlink" title="标注位置"></a>标注位置</h4><p>RequestMapping 可以被标注到 TYPE 也就是 Class 上和方法上，标注到 Class 上面是为了更大范围的前置约束，比如可以写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/fisrt&quot;,method=&quot;post&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/one&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;one&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/two&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">two</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;two&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样首先访问为 <code>/first/XXX</code> 的 POST 请求都会被定位到 FirstController 这个类中，然后根据 <code>/XXX</code> 的值精细化定位处理方法。</p><h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><ol><li><p>value/path 设置处理此方法映射的访问地址。详情请看：<a href="https://xorex.space/2021/06/05/28d8300ff21a/#%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84">请求路径</a></p></li><li><p>method 设置映射的访问方法，可以设置 <code>public enum RequestMethod</code> 里面设定的几种访问方法。</p></li><li><p>params 设置请求中的参数要求，必须包含某参数或者某参数为 XXX 值等。详情请看：<a href="https://xorex.space/2021/06/05/28d8300ff21a/#%E5%8F%82%E6%95%B0%E9%99%90%E5%88%B6">参数限制</a></p></li><li><p>headers 设置请求头包含 “请求头：设置” 的请求被本方法处理。</p></li><li><p>consumes 设置消费类型，是根据 Content-Type 请求头里面进行比对的，比如设置 application/json 就限制了请求里面的数据必须是 application/json 类型的请求才会被此方法处理</p></li><li><p>produces 设置要求生产类型，是根据 Accept 请求头进行比对的。根据请求想要获得的数据类型来决定本方法是否处理此请求。</p></li></ol><h4 id="请求路径"><a href="#请求路径" class="headerlink" title="请求路径"></a>请求路径</h4><p>其中可以使用 <code>&#123;VariableName&#125;</code> 的方式从 URI 中截取数据，保存到 VariableName 的变量中，然后下面通过注解 <code>@PathVariable</code> 将保存的截取数据送入方法参数中，如果参数名和截取数据所保存的变量名相等，就可以不在注解里面填写数据。如果注解标注的位置是 Map 类型，则会将<strong>所有</strong>截取的数据放入 Map 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/index/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toIndex</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对截取的数据加以正则限制，则可以使用：<code>&#123;varName:regex&#125;</code> 来对某部分进行正则表达式限制。或者比较粗暴的使用 <code>*</code> 来省略被限制的部分路径。</p><hr><p>当一个请求被多个方法映射成功之后，遵循的原则是映射匹配精确度越高，方法处理的优先级越高。</p><h4 id="参数限制"><a href="#参数限制" class="headerlink" title="参数限制"></a>参数限制</h4><p>在 params 上设置只有用户名为 Xorex 的用户才会被处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(params=&quot;username=Xorex&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toAdmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Admin] Xorex login.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <code>username!=XXX</code> 表示参数 username 不等于某个值即可（包括没有 username 参数），<code>!username</code> 表示必须没有 username 参数。<code>password</code> 表示必须要有密码参数。</p><h3 id="return-地址"><a href="#return-地址" class="headerlink" title="return 地址"></a>return 地址</h3><p>请求映射方法的 return 值（为 String）就是此方法处理完请求之后会被转发到的地址（一般是 View 层）。</p><p>而转发地址里面有很多都是重复的，如 <code>WEB-INF/pages/</code> 和 <code>.jsp</code> 所以就可以再搞一个内部资源视图控制器，也就是 jsp 的一个小的控制器，只需要将其放入 IOC 容器中，这个控制器就可以设置对视图资源的访问，设置一个前缀和后缀即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 放入 IOC 容器之后，这个实例会在转发 return 后面的地址之前自动被调用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先拿张图，这里面就是 Spring 可以胜任的功能，其中 Web 模块其实就是我们接下来要学习的 SpringMVC，使用 Spring </summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>《一课经济学》读书笔记</title>
    <link href="https://xorex.space/2021/06/03/85d5c9bb45a9/"/>
    <id>https://xorex.space/2021/06/03/85d5c9bb45a9/</id>
    <published>2021-06-03T12:29:50.000Z</published>
    <updated>2021-06-05T16:47:59.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本书内容"><a href="#本书内容" class="headerlink" title="本书内容"></a>本书内容</h2><p>由于在一段时间内的生产力综合是不变的，那么对一个群体的经济政策作用代价是所有人承受的，经济政策需要考虑所有的影响者。</p><p>换句话说：经济政策既需要考虑短时影响，也需要考虑长远影响，不能只关注任意一方。不仅要想行为的好处，也要想事实行为的代价承担着。</p><h2 id="破窗谬论"><a href="#破窗谬论" class="headerlink" title="破窗谬论"></a>破窗谬论</h2><p>破窗谬论：“打碎窗户虽然损失了钱，但是玻璃工人拿到了这份钱，提供了其他消费，刺激了生产。所以这是有好处的。”</p><p>原理：这份钱的消费可以由窗户所有者提供，但社会的所有财产综合损失了一扇窗户，原有的消费不变的情况，总财产损失，反而不利。这是因为忽视了金钱原本持有者的消费能力。</p><h2 id="战祸之福"><a href="#战祸之福" class="headerlink" title="战祸之福"></a>战祸之福</h2><p>战祸之福：“经过战争的国家战后经济会高速发展，因为战后带来了巨大的需要，重建不但贡献了经济，也有后来居上的作用（最新的工厂和大楼），因此也带来了更加先进的社会生产力。”</p><p>原理：战争摧毁了很多东西，带来了某方面的巨大需要，这些需要改变了人战后的努力方向，改变了工业结构。这些被需要工业结构拿到了大量的投资，人们因为迫切的生存需要而贡献了大量的生产力，使得造成了某些被迫切需要的产业的高速发展，但焦点被转移的产业生产力是大幅度下降的。总的来说由于战争破坏，社会的总体生产力下降，整体财富下降，只是因为努力方向的转移造成了部分被迫切需要的产业的快速发展，造成了战祸之福的假象。</p><p>此外，需求和需要时不相等的。需要是客观的，比如需要房子，需要汽车。而需求是一种意愿，必须需求居住能力更高的住所，需求更快的交通工具。需求=购买力（生产力）+ 购买欲望（需要），一个没有支付能力的购买意愿并不构成需求。印度比美国有更多的需要，但是需求并没有美国多。</p><p>也可以将国家经历放到个人身上，个人的财产被毁掉之后，开始拼命工作建造房子。你可以看到它的房子每天都在快速建成，但他只是在恢复到以前的状态，本身还是很贫穷。并且由于努力方向的转移，导致了生产其他东西的能力下降。</p><h2 id="公共工程建设"><a href="#公共工程建设" class="headerlink" title="公共工程建设"></a>公共工程建设</h2><p>公共工程建设：“工程建设增加了工作机会，如果没有工程建设，工作机会也会变少”</p><p>原理：不仅仅要考虑工程的直接影响者：被雇佣者，工程对当地的积极作用等，还要考虑其他影响者，也就是付出代价的人，全体纳税者人。这些代价在原本纳税人手里会产生其他的需求，而政府则是将这些需求转移到了工程的直接影响者。这种转移意味着没创造一个公共工作机会，就会破坏掉一个私人就业机会。而如果这些直接影响者带来的收益低于付出代价，那么工程就是不值得的，这也是因为只看到了直接影响者，而没有看到更广泛的影响者（那些出钱的全体纳税人）</p><h2 id="税收与生产"><a href="#税收与生产" class="headerlink" title="税收与生产"></a>税收与生产</h2><p>税收的作用就是拿出一部分社会整体的生产力，去生产一些个人和公司无法生产的东西，比如基础设施建设，全民医保等。</p><p>适量的税收去生产这些在一定程度上是有利于整体的社会生产力的发展的。但过量的税收会导致个人和公司在相同的投入下，有大量的生产力被政府抽走，自己剩余的生产力就会过低，整体会抑制社会对扩大生产的投资，从而影响生产力的发展。实际中需要寻找一个合适的平衡点。</p><h2 id="诅咒机器"><a href="#诅咒机器" class="headerlink" title="诅咒机器"></a>诅咒机器</h2><p>诅咒机器：“人们认为使用机器带来的生产力提升使得人们失去了工作机会，所以拒绝使用机器是保住就业的好方法。”</p><p>原理：更先进的生产力破坏了原有的生产关系，导致了一部分人失去工作机会。但更加先进的生产力意味着更加强大的购买力，这部分购买力会随着购买欲望一起变成新的需求，而新的需求就意味着工作机会。在这个过程之中，因为更加先进的生产力使得整个社会的财富变得更多了，意味着能够养活的人口变多了。按照原有的工作机会水平（生产力-需求）来看，社会的工作机会不减反增。</p><p>失去的工作机会是被关注的短期和局部影响，背后带来的社会生产力提高是长远的影响，两者都应该被同等的重视，而不是过分的关注一方。</p><h2 id="关税保护"><a href="#关税保护" class="headerlink" title="关税保护"></a>关税保护</h2><p>关税是对购买国外商品的国人进行征税。对国家内部来说，关税的好处只有提高本国某行业在全世界的生产力分配额度。</p><p>如日本高得离谱的农业进口税，作用仅仅只是维持本国的部分农业供给，保证一定程度的粮食安全。而为此付出的代价就是日本国内的一部分生产力需要被消耗在低效的日本农业上面，如果取消关税，那么国外农业优势国家（相同的投入获取更多的收益）的农业生产力将会更加发达，而日本本国的消费者可以将投入本国农业的低效生产力以消费的形式转移到其他的优势产业，如制造业。从全世界来看，国外的农业和日本的制造业生产力都得到了提升，创造出来了更多的财富，所有人都收益（当然收益程度是不同的，关税的本质就是通过抑制优势生产力的流动来调整国际生产力发展带来的收益）</p><p>长远来看并不利于全世界的整体生产力的提升，因此也制约了本国的整体生产力。但在全世界并没有出现一个统一的，以全人类发展为最终目标的，拥有最高权力的全球政府之前，人类还需要忍受关税带来的内耗。<br>但上面说的只是理想的情况啦，实际即使所有国家都开放市场，因为地理，国界，文化，发展水平等等因素限制，虽然整体上是利于全世界的发展，但开放市场带来的收益会很不平衡，可能会发达国家吃肉，强发展中国家喝汤，弱发展中国家吐血。</p><h2 id="进出口"><a href="#进出口" class="headerlink" title="进出口"></a>进出口</h2><p>最好的对外贸易状态就是进口等于出口，过多的贸易顺差会造成国内资源不断外流，抑制国内需求，带来本国货币升值压力。而过多的贸易逆差会造成本国货币贬值，国内生产力不足。</p><p>所以最好是出口等于进口，是当前经济最好的状态。但因为当前最好状态不太表最终最好状态，中国靠着贸易顺差积累了原始资本，大幅度的提高了生产力，为未来获取高附加值产业奠定了基础等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本书内容&quot;&gt;&lt;a href=&quot;#本书内容&quot; class=&quot;headerlink&quot; title=&quot;本书内容&quot;&gt;&lt;/a&gt;本书内容&lt;/h2&gt;&lt;p&gt;由于在一段时间内的生产力综合是不变的，那么对一个群体的经济政策作用代价是所有人承受的，经济政策需要考虑所有的影响者。&lt;/p&gt;</summary>
      
    
    
    
    <category term="杂七杂八" scheme="https://xorex.space/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="读书笔记" scheme="https://xorex.space/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>计组-IO系统</title>
    <link href="https://xorex.space/2021/06/01/ac17795a00ed/"/>
    <id>https://xorex.space/2021/06/01/ac17795a00ed/</id>
    <published>2021-06-01T09:54:49.000Z</published>
    <updated>2021-06-05T16:47:39.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO-基本概念"><a href="#IO-基本概念" class="headerlink" title="IO 基本概念"></a>IO 基本概念</h2><p>I/O 即输入／输出，通常指数据在存储器（内部和外部）或其他周边设备之间的输入和输出，输入是系统接收的信号或数据，输出则是从其发送的信号或数据。</p><h3 id="IO-系统的发展"><a href="#IO-系统的发展" class="headerlink" title="IO 系统的发展"></a>IO 系统的发展</h3><p>早期的 IO 系统是直接和 CPU 连接，由 CPU 直接控制 IO 系统，极大的降低了 CPU 的性能。</p><p>后来将一些和内存数据交换比较频繁的外设单独建立了 DMA （Direct Memory Access 直接存储访问） 总线。</p><p>再后来发展出了 IO 通道结构，主机只需要和 IO 上面的通道部件进行数据交换即可，再次加快了速度。</p><p>现在一般开始采用 IO 处理机，承担主机的功能来管理各种外设，基本拥有和 CPU 一样的结构。</p><p><img src="https://xorex.space/image/293.jpg" alt="293.jpg"></p><h3 id="IO-系统工作方式"><a href="#IO-系统工作方式" class="headerlink" title="IO 系统工作方式"></a>IO 系统工作方式</h3><p>IO 系统一般来说有三种工作方式，分别是：程序查询方式，程序中断方式，DMA 方式。三种方式的不同的地方就是使用了不同的设计来分担了一部分 CPU 对 IO 设备的控制，使得 IO 系统对 CPU 越来越简单，从而提升性能。</p><p><img src="https://xorex.space/image/294.jpg" alt="294.jpg"></p><h2 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h2><p>关于外设的各种信息，因为和生活比较接近，所以就不写了。</p><h2 id="IO-接口"><a href="#IO-接口" class="headerlink" title="IO 接口"></a>IO 接口</h2><p>IO 接口的相关结构，主要的作用就是建立起一个 CPU 和外设之间通讯的桥梁，来提高整个设备的性能和可拓展性，让各个部件都专注与自己本身的工作：</p><p><img src="https://xorex.space/image/295.jpg" alt="295.jpg"></p><p>以及 IO 接口结构的工作流程，CPU 只和接口进行交互，并且相关数据的获取都是从绿色的数据缓冲寄存器和设备状态标记寄存器，这也是为了减少 CPU 实际读取数据的时间，和通过主控芯片来提高外接设备的性能。</p><p><img src="https://xorex.space/image/296.jpg" alt="296.jpg"></p><p>这里需要注意一个概念，我们将上面绿色部分的寄存器称为端口 Prot，分为 数据端口，控制端口，状态端口。剩下的蓝色部分和控制逻辑电路作为控制逻辑。</p><p><img src="https://xorex.space/image/297.jpg" alt="297.jpg"></p><p>也就是说，CPU 实际上和外设进行数据交换的时候，本质上是和接口里面的端口进行数据交换，所以获取数据只需要知道数据所在的端口的地址即可。统一端口设计模式之后，CPU 就完全不需要关心实际外部设备的内部设计了，这些交给端口的控制逻辑解决即可。</p><hr><p>对不起，实在不想学了，以后学了操作系统，之后再来看看 IO 系统这一章吧！</p><p>一定会补完的，QAQ</p><p>滚去学 Spring 了……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IO-基本概念&quot;&gt;&lt;a href=&quot;#IO-基本概念&quot; class=&quot;headerlink&quot; title=&quot;IO 基本概念&quot;&gt;&lt;/a&gt;IO 基本概念&lt;/h2&gt;&lt;p&gt;I/O 即输入／输出，通常指数据在存储器（内部和外部）或其他周边设备之间的输入和输出，输入是系统接收</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-总线设计</title>
    <link href="https://xorex.space/2021/05/31/1b7d3a309aca/"/>
    <id>https://xorex.space/2021/05/31/1b7d3a309aca/</id>
    <published>2021-05-31T12:43:50.000Z</published>
    <updated>2021-06-05T16:47:20.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总线（Bus）概念"><a href="#总线（Bus）概念" class="headerlink" title="总线（Bus）概念"></a>总线（Bus）概念</h2><p>总线是主机为了解决不同可更换设备之间的通信问题而产生的，计算机各种功能部件之间传送信息的公共通信干线。</p><h3 id="总线分类"><a href="#总线分类" class="headerlink" title="总线分类"></a>总线分类</h3><p>总线可以根据不同的特征进行不同的分类：</p><ol><li><p>机械特性：尺寸，形状，管脚数量，排列顺序。</p></li><li><p>电气特性：传输方向（单向 or 双向）和有效的电平范围（0 - 0.5 低电平 0.5 - 1 V 高电平）</p></li><li><p>功能特性：地址总线，数据总线，控制总线。</p></li><li><p>时间特性：信号和时序的关系。</p></li></ol><p>以及下图：</p><p><img src="https://xorex.space/image/284.jpg" alt="284.jpg"></p><p>数据传输格式：里面串行总线和并行总线的区别就是同时传输数据的位数，串行总线一次传输一位数，并行总线一次可以传输多位数。</p><p>总线的功能：主要内容看下图。</p><p><img src="https://xorex.space/image/285.jpg" alt="285.jpg"></p><h3 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h3><p>总线的结构：总线的结构设计分为单总线设计，双总线设计，三总线设计。当然这里的单总线指的是每种总线（数据总线，控制总线，地址总线）只有一根。</p><p>单总线结构，就是最基本的总线：</p><p><img src="https://xorex.space/image/286.jpg" alt="286.jpg"></p><p>双总线结构，将 CPU 与主存的总线和 IO 总线分离开来，高速的用一根，低速的用一根，从而提高整体的效率。</p><p>注意里面的通道是一个小控制器，它有自己的控制系统，负责控制 IO 和内存之间的交互。</p><p><img src="https://xorex.space/image/287.jpg" alt="287.jpg"></p><p>三总线结构，思路还是将不同的速度分级，从而提高整体的速度。这里多出来的就是 DMA 总线，也就是 Direct Memory Access 直接内存访问总线。将 IO 里面速度较快的部分（硬盘）单独和内存使用总线连接，提高硬盘速度。</p><p><img src="https://xorex.space/image/288.jpg" alt="288.jpg"></p><h2 id="总线性能指标"><a href="#总线性能指标" class="headerlink" title="总线性能指标"></a>总线性能指标</h2><p>总线带宽：也就是总线的数据传输速率，单位时间内总线上可传送数据的速率。</p><p>总线复用：有些总线是将地址总线和数据总线放在一起复用。</p><h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><p>因为在同一时间之内只能由一个设备控制总线发出信号，同一时间内只能由一个或多个设备接收总线的信号。</p><p>所以当多个设备想要向总线发送信号的时候，就需要决定哪个设备来使用总线，这便是总线仲裁。</p><h3 id="集中仲裁"><a href="#集中仲裁" class="headerlink" title="集中仲裁"></a>集中仲裁</h3><p>指的是使用一个单独的仲裁器，用它来决定谁获取总线的使用权限。当一个设备正在使用总线的时候，发出 BS 总线忙信号，仲裁器停止分配总线。当没有总线忙信号并且有设备正在请求总线的时候，发出 BG 总线允许信号，需要总线的设备接收到 BG 信号之后，开始使用总线并发出 BS 总线忙信号。这就是集中仲裁的基本原型。</p><p><img src="https://xorex.space/image/289.jpg" alt="289.jpg"></p><h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2><p>总线标准就是国际上公布过推荐的一种模块设计标准，设计设备和总线的通信的时候，只需要遵守相关的模块设计标准，就可以接入任何一条总线。</p><p>PCI 总线，局部总线：</p><p><img src="https://xorex.space/image/290.jpg" alt="290.jpg"></p><p>PCI-E 总线，</p><p><img src="https://xorex.space/image/291.jpg" alt="291.jpg"></p><p>最后用一个奔腾3的主板设计模式，来大概感受一下总线：</p><p><img src="https://xorex.space/image/292.jpg" alt="292.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;总线（Bus）概念&quot;&gt;&lt;a href=&quot;#总线（Bus）概念&quot; class=&quot;headerlink&quot; title=&quot;总线（Bus）概念&quot;&gt;&lt;/a&gt;总线（Bus）概念&lt;/h2&gt;&lt;p&gt;总线是主机为了解决不同可更换设备之间的通信问题而产生的，计算机各种功能部件之间传送信</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-中央处理器</title>
    <link href="https://xorex.space/2021/05/16/46406054684d/"/>
    <id>https://xorex.space/2021/05/16/46406054684d/</id>
    <published>2021-05-16T14:47:32.000Z</published>
    <updated>2021-05-31T12:45:13.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU-的主要职责分析"><a href="#CPU-的主要职责分析" class="headerlink" title="CPU 的主要职责分析"></a>CPU 的主要职责分析</h2><p>CPU 需要有运算器和控制器两个基本的结构，然后完成大概下面的任务：</p><ul><li><p><strong>指令控制</strong>：完成取指令，分析指令和指令执行的操作，即程序的顺序控制。</p></li><li><p><strong>操作控制</strong>：控制产生操作信号，然后传送到所对应的部件上，让其来配合完成整条指令。</p></li><li><p><strong>时间控制</strong>：对各种操作加以时间上的控制。</p></li><li><p><strong>数据加工</strong>：对数据进行算数和逻辑运算，这里主要由运算器完成。</p></li><li><p><strong>中断处理</strong>：处理异常情况和特殊请求。</p></li></ul><h2 id="运算器-Calculator-的基本结构"><a href="#运算器-Calculator-的基本结构" class="headerlink" title="运算器 Calculator 的基本结构"></a>运算器 Calculator 的基本结构</h2><p>下图可以看出运算器 Calculator 主要是由 ALU 和各类寄存器组成的：</p><p><img src="https://xorex.space/image/255.jpg" alt="255.jpg"></p><p>主要部件 ALU 的工作原理在前面章节的数据表示和运算里面已经说明了，下面主要说一下运算器的工作流程。</p><p>首先引入了一个叫作 CPU 内部总线的东西，这个东西负责整个 CPU 内部的数据传输，但是 CPU 有很多个部件，同一时间只能有一个数据信号发送方，为了防止数据传送冲突，就在每个部件上都接入一根 in 和一根 out 控制线，负责控制元器件数据信号的发送和接收。只有 in 控制线有电流，元器件才会从总线上接收数据，只有 out 控制线有电流，元器件才能将自己存储的数据传送到数据总线上去。</p><p>这样通过控制器控制对应元器件的 in 和 out 线路，实现元器通过总线的数据传输。</p><h2 id="控制器-Controlor-的基本结构"><a href="#控制器-Controlor-的基本结构" class="headerlink" title="控制器 Controlor 的基本结构"></a>控制器 Controlor 的基本结构</h2><p>下面的内容都是控制器的所有包括内容，PC：Program Counter，IR：Instruction Register，ID：Instruction Decoder，PSW：Program Status Word，MAR，MDR，CU而里面的核心：微操作信号发生器</p><p><img src="https://xorex.space/image/256.jpg" alt="256.jpg"></p><p>同样也是利用了 CPU 的内部总线，需要注意的是上面的 PSW，是一组程序状态字寄存器，上面的图片是有介绍的，用来记录当前程序运行所产生的特殊的状态。</p><p>因为 MAR 和 MDR 都是集成在 CPU 的内部，所以在和主存进行通信的时候，需要额外的数据总线和地址总线，用来传输信息。</p><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p>我们首先引入一系列的周期概念，主要分为运行时间决定的时间周期，和指令执行过程的指令周期。</p><h4 id="周期概念"><a href="#周期概念" class="headerlink" title="周期概念"></a>周期概念</h4><p><strong>时钟周期</strong> CLK，也被称为节拍，是 CPU 的最基本单位，也就是我们常用的 GHZ 单位。</p><p><strong>机器周期</strong> 是一个微指令完成的实现，由若干个时钟周期组成，如从 PC 中取出指令并送入 MAR 中为一个取址机器周期.</p><p><strong>指令周期</strong> 是通过执行若干个机器周期完成一条明确的指令所需要的时间被称为一个指令周期。</p><p><img src="https://xorex.space/image/257.jpg" alt="257.jpg"></p><p>我们将一个指令拆分成不同的周期就是为了能够利用执行不同机器周期所需要的硬件资源不同，从而实现多个指令同时执行的并行效果。要实现并行就要记录指令正在执行的机器周期，这里使用不同的触发器来记录。</p><p>就是上面的 FE IND EX INT 几种不同的触发器来记录目前的程序有什么特殊的状态。</p><h4 id="取址周期"><a href="#取址周期" class="headerlink" title="取址周期"></a>取址周期</h4><p>非常普通的一个周期，PC -&gt; MAR -&gt; 地址总线 -&gt; 内存 -&gt; 数据总线 -&gt; MDR -&gt; IR ，其中 PC 会自增。</p><h4 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h4><p>没啥好说的，就是多了个间址。</p><h4 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h4><p>中断的目的就是暂停当前正在执行的任务，转去执行其他的任务（这也是多线程的实现基础），为了恢复当前任务，会使用堆栈保存当前任务的断点，将当前的程序指令的地址（从 PC 中获取），压入堆栈中，然后通过<strong>向量地址</strong>来获取下一个程序要执行的指令的地址，将其放入 PC 中，然后继续取址执行等等。</p><h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><p>执行方案指的是指令的运行顺序和时间的设计方案。</p><ul><li><p>单指令周期：所有指令使用相同的执行时间，只需要一个计数器数够次数即可，电路设计简单，是但是因为所有的指令使用的执行时间都是耗时最长的那个指令的执行时间，所以速度会很慢。</p></li><li><p>多指令周期：指每个不同的指令使用不同的执行时间，虽然电路设计会复杂一点，但是相较于单指令周期，整体的效率是提高了。</p></li><li><p>流水线模式：每间隔一段时间都启动一个指令的执行，让指令并行执行，效率最高，但也最难设计。（原理是指令执行的不同截断会使用不同的硬件）</p></li></ul><h3 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h3><ul><li>总线模式</li></ul><p>一条总线负责整个 CPU 内部的所有的数据的传输，电路设计简单，但是没有办法实现数据的并行传输，效率低。</p><p><img src="https://xorex.space/image/258.jpg" alt="258.jpg"></p><ul><li>专线模式</li></ul><p>每个部件之间的数据传输使用部件之间的专有线路，可以并行传输，效率高。</p><p><img src="https://xorex.space/image/259.jpg" alt="259.jpg"></p><h3 id="CU-的输入输出"><a href="#CU-的输入输出" class="headerlink" title="CU 的输入输出"></a>CU 的输入输出</h3><p><img src="https://xorex.space/image/269.jpg" alt="269.jpg"></p><p>控制单元就是根据当前执行指令内容（IR），当前执行时期（标志位），执行时间间隔（时钟周期），突发情况（外来信号），结合这些信息之后，发出来合适的控制信号给各种部件来完成指令的执行。</p><p>而输入进来的数据其实是下面这样的：</p><p><img src="https://xorex.space/image/270.jpg" alt="270.jpg"></p><p>其中多了操作码译码器和节拍发生器对输入进来的数据进行处理，其中前者我们已经非常清楚了，而节拍发生器的作用则是将内部的统一时钟信号 CLK 转化为 T0 ~ Tm 的固定周期的电路信号，从而组成一个机器周期：</p><p><img src="https://xorex.space/image/260.jpg" alt="260.jpg"></p><h2 id="控制器-CU-设计"><a href="#控制器-CU-设计" class="headerlink" title="控制器 CU 设计"></a>控制器 CU 设计</h2><p>一般来说 CU 就是解析指令，然后根据解析的结果，像各个部件发出控制信号，指挥它们去完成指令的执行。</p><p>而生成控制型号的 CU 单元，有两种不同的设计模式，分别是硬布线设计模式和微指令设计模式。</p><p>硬布线设计模式：CU 控制信号是依靠输入进来的指令信息，时序系统，标志等经过内部复杂电路的计算之后，得到的一个控制信号的输出。是依靠硬件电路设计得到控制信号的，因此也叫硬布线。因为只要电流流过相应的电路，结果就直接被计算出来了，所以速度很快。</p><p>微指令设计模式：CU 控制信号是被完整的存储到了一个微指令存储器中，输入指令，直接从微指令内存中读取相应的控制信号，然后输出。因为涉及到微指令存储器的读取，所以速度会慢一点。但是这样设计的电路会简单一些。</p><p>比对图：<img src="https://xorex.space/image/273.jpg" alt="273.jpg"></p><h2 id="硬布线-CU"><a href="#硬布线-CU" class="headerlink" title="硬布线 CU"></a>硬布线 CU</h2><h3 id="CU-设计流程"><a href="#CU-设计流程" class="headerlink" title="CU 设计流程"></a>CU 设计流程</h3><ol><li>分析每个阶段应该执行的微操作序列，举个例子，加法指令应该执行的微操作序列如下：</li></ol><p><img src="https://xorex.space/image/271.jpg" alt="271.jpt"></p><ol start="2"><li><p>选择 CPU 的控制方式，即：产生不同的微操作命令序列所用的时序控制方式。后面会介绍三种不同的 CPU 控制方式。</p></li><li><p>安排微操作时序。</p></li><li><p>电路设计。</p></li></ol><h4 id="CPU-的控制方式"><a href="#CPU-的控制方式" class="headerlink" title="CPU 的控制方式"></a>CPU 的控制方式</h4><p>CPU 控制方式：产生不同的微操作命令序列所用的时序控制方式。作用就是用来控制微指令在执行过程中消耗的时间。</p><ul><li><p><strong>同步控制方式</strong>：整个系统的控制信号均来自于一个<strong>统一的时钟信号</strong>，也就是 CPU 的主频。这样的话所有的微指令执行时间长度都必须是主频周期的整数倍，可能会有点慢。</p></li><li><p><strong>异步控制方式</strong>：这里是使用应答机制来确定微指令的执行时间，当一个微指令执行完毕，就会发送信号给 CU，然后 CU 启动下一条微指令的执行进程。这种方式微指令执行周期不受 CPU 主频的约束，但是电路设计会复杂很多。</p></li><li><p><strong>联合控制方式</strong>：将上面两种控制方式结合在一起，大部分使用同步控制方式，小部分使用异步执行方式。</p></li></ul><h4 id="微操作时序"><a href="#微操作时序" class="headerlink" title="微操作时序"></a>微操作时序</h4><p>微操作时序也就是设定一个指令所需要执行的所有微操作被执行的顺序和时间段，然后才能按照设定的时间去执行。</p><p>设计原则：</p><ol><li>微操作的<strong>先后顺序</strong>不得被随意更改。</li><li><strong>被控对象不同</strong>的微操作尽量被安排到一个节拍中完成</li><li><strong>占用时间较短</strong>的微操作尽量安排在一个节拍中完成，并允许有先后顺序。</li></ol><p>下面的 T0 T1 T2 就是节拍时间，后面跟着这个节拍中需要被执行的微操作，PC+1 被控对象和主存寻址不同，所以一起安排到了 T1 节拍中，4 5 指令执行占用时间较短，所以也被安排到了一个节拍中：</p><p><img src="https://xorex.space/image/272.jpg" alt="272.jpg"></p><p>而这个安排节拍就是上面一个 CLK 生成的一个 Tn 周期，上图所安排的 T0 T1 T2 三个节拍指令会在三个 CLK 的时间内完成指令的执行。这三个节拍指令组成了一个机器指令完成所需要的时间的机器周期。</p><h4 id="电路设计"><a href="#电路设计" class="headerlink" title="电路设计"></a>电路设计</h4><p>因为微操作的数量是有限的，所以我们的基本设计思路就是用电路来计算在当前状态和时间，当前指令下，应该发出的控制型号是否为某种微操作。</p><p>这样计算出来的为 true 的微操作，就可以直接向外界发送自己对应的控制信号了。</p><p>状态的话有三个变量：工作周期标记，当前节拍，和状态标记。</p><p>剩下的输入就是 IR 提供的指令内容了，通过译码器会被转化为某一根线的电信号，代表着某个指令。</p><p>我们将指令作为横坐标，整个机器周期的工作周期，工作周期的节拍，节拍对应可能微操作命令作为纵坐标，列一个表格。然后将指令和对应的微操作命令符合的地方写上 1 ，表示一个指令的微操作命令的组合（当然这是一个简化的版本，省略了很多其他的指令，也没有特殊的状态条件）。</p><p><img src="https://xorex.space/image/274.jpg" alt="274.jpg"></p><p>我们就根据当前正在执行的指令，当前的工作周期，节拍，条件状态，判断某个微操作是否要将自己执行的控制信号发送出去。用 M(MAR)-&gt;MDR 这条微操作为例子，计算是否发送本微操作的控制信号的计算公式如下：</p><p><code>FE*T1+IND*T1*(ADD+STA+LDA+JMP+BAN)+EX*T1(ADD+LDA)</code></p><p>首先看 <code>FE*T1</code> 这里是指在取指周期 FE 中的 T1 节拍的所有机器指令都需要执行 M(MAR)-&gt;MDR 这个微操作。所以将 FE 周期信号线和 T1 节拍信号线做 and 运算，如果结果为 true 那么就确定此状态为取值周期中的 T1 节拍，因为无论任何指令都需要执行 M(MAR)-&gt;MDR 这个微操作，所以仅凭 FE 和 T1 两个信号就可以决定是否发送 M(MAR)-&gt;MDR 这个微指令的控制信号了。</p><p>后面的则是对其他周期可能执行情况的计算。分别是处于间址周期 IND 的 T1 节拍的 ADD STA LDA JMP BAN 指令，还有处于执行周期 EX 的 T1 节拍的 ADD LDA 指令。</p><p>将上面的计算式子进行化简，也就是将 T1 提出来，简化电路，然后就可以根据这个画出来计算电路了，只要有电路能够流入 IV 中，他就会向控制总线中发送自己存储的 M(MAR)-&gt;MDR 微操控制信号。</p><p><img src="https://xorex.space/image/275.jpg" alt="275.jpg"></p><h3 id="微指令-CU"><a href="#微指令-CU" class="headerlink" title="微指令 CU"></a>微指令 CU</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>将每一条机器指令编写成一个微程序，这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。</p><p>我们应该很清楚了微操作命令这个东西，比如上面一直使用的 M(MAR)-&gt;MDR 就是一个微操作命令。我们将能同时执行的微操作命令称为相容性微操作命令，不能同时执行的称为互斥性微操作命令。</p><p>我们可以将我们所需要的若干个相容性微操作命令组合编码成一个<strong>微指令</strong>，因为微指令控制器的核心就是将机器指令转化为若干个微指令，这若干个微指令组成的一个集合就是此机器指令的微程序。读取到机器指令之后从控制存储器中读取对应机器指令执行的微程序，然后依次解析微程序的组成：微指令，微指令里面就记录了该向控制总线发送哪个微操作的控制信号。</p><p>这里微指令里面微操作的组成类似于硬布线对微操作进行节拍安排，会将可容性微操作命令放到一个节拍中执行，同理，可以将可容性微操作命令放到一个微指令中执行。</p><p>就像下面这样，微指令中为 1 的位表示此位对应的微操作需要被执行：</p><p><img src="https://xorex.space/image/276.jpg" alt="276.jpg"></p><hr><ul><li><p><strong>微操作</strong>：一条机器指令可以分解成一个微操作序列，这些微操作是计算机中最基本的、不可再分解的操作。比如寻址中将 PC 地址放入 MAR 中：PC-&gt;MAR，就是一个不可分解的微操作。</p></li><li><p><strong>微命令</strong>：在微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为微命令，它是构成控制序列的最小单位。每个微操作都对应一个自己的微命令。</p></li><li><p><strong>微指令</strong>：此概念只存在于微指令控制器中，微指令是若干微命令的集合，微指令又分为操作控制字段和顺序控制字段，操作控制地段决定本微指令在一个节拍中需要被执行的所有微操作，顺序控制字段决定下一条微指令的地址。</p></li><li><p><strong>微程序</strong>：微指令的有序集合，一条机器指令的功能由一段微程序来实现。</p></li><li><p><strong>微周期</strong>：微周期通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。</p></li></ul><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>微指令控制器内部像是一个砍掉了 CU 和 ALU 的小主机，任务就是将传入的机器指令解析成对应微程序在控制存储器中的地址，在顺序逻辑器的控制下，依次读取微程序在存储器里面的每一条微指令，然后解析微指令将对应的微操作的控制信号发送给控制总线，作为整个大主机的控制信号。</p><p>需要说明的是，微指令里面不仅仅包括要之心干的微操作，还有下一条微指令的地址，下地址会被送入顺序逻辑器中，顺序逻辑器会自己判断使用微地址形成部件的地址还是 CMDR 送来的微地址，作为地址中转传入 CMAR 中，控制微程序的完整读取。</p><p><img src="https://xorex.space/image/277.jpg" alt="277.jpg"></p><h4 id="控制存储器"><a href="#控制存储器" class="headerlink" title="控制存储器"></a>控制存储器</h4><p>这里比较值得一说的就是控制存储器里面的结构，首先会将所有指令都会有的取值周期放到控制存储器的一个公共的部分，来减少存储占用。而组成指令的其他微程序则每个单独存储在一块中。</p><p><img src="https://xorex.space/image/278.jpg" alt="278.jpg"></p><h4 id="微指令"><a href="#微指令" class="headerlink" title="微指令"></a>微指令</h4><h5 id="水平和垂直"><a href="#水平和垂直" class="headerlink" title="水平和垂直"></a>水平和垂直</h5><p>水平型微指令：一次能够定义并执行多个并行操作。<code>操作控制 + 顺序控制</code> 微程序短，速度快。</p><p>垂直型微指令：微操作码决定微指令的功能。<code>微操作码 + 目的地址 + 源地址</code> 微指令短，速度慢。</p><h4 id="水平微指令编码"><a href="#水平微指令编码" class="headerlink" title="水平微指令编码"></a>水平微指令编码</h4><p>我们直接讲字段直接编码方式，水平微指令组成是 <code>操作控制 + 顺序控制</code>，我们先来看操作控制。</p><p>这里讲操作控制部分分段，每段经过<strong>译码</strong>之后发出一个微操作控制信号，分了多少段就能同时执行多少个微操作。所以分段原则为：</p><p><img src="https://xorex.space/image/279.jpg" alt="279.jpg"></p><p>（当然直接编码方式可以看图）</p><h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><p>设计原理如下图，具体的我也不会……</p><p><img src="https://xorex.space/image/280.jpg" alt="280.jpg"></p><h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><h3 id="指令流水线设计概念"><a href="#指令流水线设计概念" class="headerlink" title="指令流水线设计概念"></a>指令流水线设计概念</h3><p>流水线的设计是通过将机器指令的执行过程拆分成多个步骤，然后将每个步骤错开运行，来保证最大的硬件使用率。</p><p>比如将机器指令周期拆分为：取指，解码，执行，定位，回写。这五个步骤所用位置是不一样的，就可以同时执行不同的指令。一些设计的细节可以看图：</p><p><img src="https://xorex.space/image/281.jpg" alt="281.jpg"></p><h3 id="流水线设计影响因素"><a href="#流水线设计影响因素" class="headerlink" title="流水线设计影响因素"></a>流水线设计影响因素</h3><h4 id="资源冲突"><a href="#资源冲突" class="headerlink" title="资源冲突"></a>资源冲突</h4><p>指两个指令在同一时间争夺同一硬件资源导致的冲突。</p><p>解决方法：</p><ol><li>后一指令运行暂停一个周期。</li><li>进行硬件分组，比如将指令和数据分别存储到不同的存储器中，两个周期访问的硬件资源分开，从而避免资源冲突。</li></ol><h4 id="数据冲突"><a href="#数据冲突" class="headerlink" title="数据冲突"></a>数据冲突</h4><p>即前一个指令的计算结果，是下一个指令所需要的内容。这就导致下一个指令的执行必须等上一个指令完整执行结束才可以进行。</p><p>解决方法：</p><ol><li>硬件阻塞：发现这种情况的时候，就然下一条指令无限等待，直到上一条指令执行结束，数据能被访问到后再执行下一条指令。</li><li>软件插入 NOP：也就是编译器在编译代码的时候，就考虑这样的问题，在两个有数据冲突的指令之间，插入合适数量的不执行的空指令 NOP</li><li>数据旁路：将上一条指令执行出结果，但没存储的数据直接用旁路给下一条指令，不过这样电路设计就过于复杂了。</li><li>编译优化：编译器调整指令顺序，将两个数据冲突指令之间，插入不影响执行顺序的其他需要被执行的指令，尽可能利用资源。</li></ol><h4 id="控制冲突"><a href="#控制冲突" class="headerlink" title="控制冲突"></a>控制冲突</h4><p>由于控制相关的转移指令的存在，导致了流水线断流。</p><p>断流的解决方法就是尽快的将流接上，尽量不影响效率：</p><ol><li>尽早判断转移是否发生，然后填入应该执行的指令到流水线里。</li><li>将转移和不转移两种情况的指令都放到流水线里。</li><li>用统计学统计转移概率，然后将概率大的指令放入流水线中。</li></ol><h3 id="多发技术"><a href="#多发技术" class="headerlink" title="多发技术"></a>多发技术</h3><p>指令流水线的多发技术指的是：</p><h4 id="超标量技术"><a href="#超标量技术" class="headerlink" title="超标量技术"></a>超标量技术</h4><p>通过一种元器件复制多份，从而在实现流水线的同时，每个流水线阶段又能同时执行多个指令。如下图：</p><p><img src="https://xorex.space/image/282.jpg" alt="282.jpg"></p><p>这样的实现就需要对指令的顺序做一个优化，在编译程序的时候，将能够同时执行的指令放到一起。</p><h4 id="超流水技术"><a href="#超流水技术" class="headerlink" title="超流水技术"></a>超流水技术</h4><p>在一个时钟周期之内，在细分多段，也就是能在同一个时钟周期，将一个部件功能同时使用多次。</p><p><img src="https://xorex.space/image/283.jpg" alt="283.jpg"></p><h4 id="超长指令字"><a href="#超长指令字" class="headerlink" title="超长指令字"></a>超长指令字</h4><p>由编译器分析一些可以同时执行的指令，然后将这些指令的执行阶段合并成一条超长的指令字，然后设计多个相同部件来同时执行它们。</p><p><img src="https://xorex.space/image/284.jpg" alt="284.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CPU-的主要职责分析&quot;&gt;&lt;a href=&quot;#CPU-的主要职责分析&quot; class=&quot;headerlink&quot; title=&quot;CPU 的主要职责分析&quot;&gt;&lt;/a&gt;CPU 的主要职责分析&lt;/h2&gt;&lt;p&gt;CPU 需要有运算器和控制器两个基本的结构，然后完成大概下面的任务：</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-指令系统</title>
    <link href="https://xorex.space/2021/05/12/53570cd3ff73/"/>
    <id>https://xorex.space/2021/05/12/53570cd3ff73/</id>
    <published>2021-05-12T13:36:40.000Z</published>
    <updated>2021-05-17T06:52:19.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指令构成"><a href="#指令构成" class="headerlink" title="指令构成"></a>指令构成</h2><p>指令是由指令集架构定义的单个的 CPU 操作，指令包括一个操作码和地址码，操作码用来指示这条指令执行什么任务，地址码用来表示这条指令作用的对象的所在位置。</p><p>下面是对于指令的基本分析：</p><iframe src="https://www.xmind.net/embed/PNfh5B" width="800px" height="540px" frameborder="0" scrolling="no"></iframe><p>定长操作码很简单，按照指令数量的最大长度编号即可，但是地址码不是定长的，所以这样的话虽然操作码定长了，但是整体的指令不会定长。</p><p>而变长操作码，下面的图就是规划变长操作码对应不同数量的地址指令的一种方式，通过让操作码变长来适应不同长度的地址码，从而让整个指令定长：</p><p><img src="https://xorex.space/image/251.jpg" alt="251.jpg"></p><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><p>指令寻址指的是 CPU 去获取指令的方式，目前来说有两种寻址模式，分别为顺序寻址和跳跃寻址。</p><p>顺序寻址：借助于 PC (Programme Counter) 不断的地址 +1 实现的，实现也很简单，只需要将所有要执行的指令按照顺序在内存中放在一起即可。</p><p>跳跃寻址：当遇到跳跃指令的时候，往往会给出要 PC 跳到的指令的地址，就需要修改 PC 里面的内容，然后跳到对应的地址读取指令。</p><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><p>数据寻址方式就是指令在计算机中寻找要操作的对象的过程，有很多种：</p><p>大概的图：</p><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>立即寻址指形式地址 A 表示的就是操作数本身，也就是立即数，用补码表示，常用于常量的操作。</p><p>比如 C 语言里面写 X=2+5; 那么这条代码执行背后的指令一定是使用立即寻址的，不需要去内存中寻找数据，操作码后面就跟着数据 2 和 5 ，速度相当快，只需要访问一次主存即可。</p><p>但是这样就会导致数据可表示范围大大缩小，毕竟操作码占用了不少地方。</p><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>直接寻址：指的是地址码表示的就是数据在内存中的实际地址，直接按照地址码的标识去内存中找就可以拿到数据了。</p><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>间接寻址：指的是地址码表示并不是数据的地址，数据地址的地址。</p><p>需要先根据地址码表示的地址从内存中拿到另外一个地址，这个地址才是数据的真实地址，所以叫作间接寻址。当然间接寻址也分间接多少次，可以是一重间接寻址，二重间接寻址等等。</p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><h4 id="寄存器直接寻址"><a href="#寄存器直接寻址" class="headerlink" title="寄存器直接寻址"></a>寄存器直接寻址</h4><p>和直接寻址唯一不同的就是，它的地址表示的不是内存的地址，而是寄存器的地址，这样可以以最快的数据获取想要的数据。</p><h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>和间接寻址唯一不同的就是，它的地址表示的不是内存的地址，而是寄存器的地址，这样可以以最快的数据获取想要的数据。</p><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><p>就是可以通过操作码推断出来所需要的数据在什么地方，比如加法指令，相加是需要两个输入数的地址和结果写入的目的地址一共三个。但是因为加法器的设计就隐含了其中一个输入数就在 ACC 中，结果写入目的地址也在 ACC 中，所以因为隐含了两个的寻址，最终只需要一次寻址即可。</p><p><img src="https://xorex.space/image/252.jpg" alt="252.jpg"></p><h3 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h3><p>偏移寻址指的是地址码里面表示的地址都需要进行加法运算才可以获取到真正的地址，优点就是可以扩大寻址范围，并且用户不需要关心自己的实际地址在哪里，只要有相对于某个地址的偏移量即可。</p><h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><p>相对寻址，会直接在地址码的地方给出偏移量，这个偏移是相对于<strong>当前指令的下一条指令的地址</strong>做偏移的，因此会将偏移量和 PC 中的当前地址送入 ALU 中进行相加，获取真实地址。</p><p>之所以是下一条指令的地址的原因是 PC 在取出当前指令之后，会将自身的内容自动加一，所以实际上从 PC 中取出来的东西是当前执行的指令的下一条指令的地址。</p><p><img src="https://xorex.space/image/254.jpg" alt="254.jpg"></p><h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><p>首先先引入一个寄存器，基址寄存器（BR），里面存放的地址将作为基准地址。首先基址寻址的地址码表示一个偏移量，用补码表示，寻址的时候会将偏移量和基址寄存器一起放进 ALU 中执行加法运算。然后获取的结果作为一个内存地址去寻找操作数。</p><p>当然用通用寄存器代替基址寄存器也是可以的，那么就需要在地址码里面多加一个寄存器编号了，指明去哪个通用寄存器中寻找基本地址。</p><h4 id="改变址寻址"><a href="#改变址寻址" class="headerlink" title="改变址寻址"></a>改变址寻址</h4><p>首先引入一个寄存器，变址寄存器（IX），里面存放偏移量，而操作码里面的地址 A 表示基本地址，和 IX 里面的偏移量进行相加运算之后，获取真实地址。</p><p><img src="https://xorex.space/image/253.jpg" alt="253.jpg"></p><p>这玩意和上面的基址寻址基本相反，里面的变址寄存器是用户可控的，常用于遍历数组，将 A 作为数组首地址，不断迭代基址寄存器，就可以快速遍历整个数组了。</p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><p>属于隐含寻址的一部分，它隐含了地址为堆栈指针（StackPointer）的地址，没啥可讲的。</p><h2 id="CISC-和-RISC"><a href="#CISC-和-RISC" class="headerlink" title="CISC 和 RISC"></a>CISC 和 RISC</h2><p>Complex Instruction Set Computer 复杂指令集：X86。</p><p>复杂指令集的设计思路就是让一条指令执行一个复杂的任务。因此有以下特点：复杂庞大，指令不定长，不太好实现指令流水线。</p><p>Reduced Instruction Set Computer 精简指令集：RISC。</p><p>精简指令集的设计思路就是让一个复杂任务被多条指令执行。因此有以下特点：简单精简，指令定长，必须实现指令流水线。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;指令构成&quot;&gt;&lt;a href=&quot;#指令构成&quot; class=&quot;headerlink&quot; title=&quot;指令构成&quot;&gt;&lt;/a&gt;指令构成&lt;/h2&gt;&lt;p&gt;指令是由指令集架构定义的单个的 CPU 操作，指令包括一个操作码和地址码，操作码用来指示这条指令执行什么任务，地址码用来表示</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-深入虚拟内存</title>
    <link href="https://xorex.space/2021/05/12/d1cccaf324ae/"/>
    <id>https://xorex.space/2021/05/12/d1cccaf324ae/</id>
    <published>2021-05-12T13:36:22.000Z</published>
    <updated>2021-05-20T10:36:16.484Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文转自与 知乎-安佳玮 <a href="https://zhuanlan.zhihu.com/p/61587598">深入虚拟内存（Virtual Memory，VM）</a></li></ul><p>我们应该知道<strong>物理内存（Physical Memory）</strong>指的是硬件上的内存，即 RAM。它通常指的是插在主板上的内存条，给进程提供临时数据存储的设备。因为 CPU 可以直接从物理内存中读取数据和指令，所以物理内存又叫做主存。</p><p><strong>虚拟内存（virtual memory，VM）</strong>又叫做虚拟存储 **(virtual storage)**，是一种内存管理技术。它是操作系统提供的一种对主存的抽象。虚拟内存的实现由操作系统软件和硬件结合完成，包括硬件异常、地址翻译、磁盘文件、内核程序等。</p><p>本文将深入虚拟内存的实现机制，讨论它是怎么将磁盘和主存结合共同提供这种抽象的。</p><h2 id="虚拟内存解决了什么问题？"><a href="#虚拟内存解决了什么问题？" class="headerlink" title="虚拟内存解决了什么问题？"></a>虚拟内存解决了什么问题？</h2><p>1）虚拟内存给进程提供了一个更大的内存空间，不再受物理内存大小的限制。它将物理内存看作是存储在磁盘上的地址空间的缓存。 现在的电脑好一点的差不多就是 16GB 或者 32GB 的内存，而且内存越大，肯定就越贵。那如果只有物理内存，在很多情况下根本不够用，特别是需要运行很多程序的情况下。而磁盘空间相对来说是很便宜的，即使是 SSD，在同样的容积下也便宜太多了。虚拟内存技术在主存中只保留活动区域，然后根据需要在磁盘和主存之间来回传送数据，这样，它就可以更加高效的利用主存。</p><p>2）虚拟内存为程序提供内存管理。我们在敲代码的时候，不需要考虑这个变量会不会被其它程序错误的修改。因为虚拟内存帮我们做了这些事情，它给程序提供了内存隔离，为程序提供了安全的共享物理内存的途径。使得每个进程的地址空间不会被其它进程破坏。 比如说我们在程序中定义了一个指针，并且为它分配了空间，这块内存最终会分配到物理内存上。你不用担心其它程序会分配相同的物理内存。</p><p>3）虚拟内存技术也给每个进程提供了一致的、完整的地址空间。比如在操作系统上执行若干个进程，每个进程都有相同的地址空间，都在同样的起始位置放置了堆、栈以及代码段等。这样，它简化了像链接器、加载器这样的程序的内存管理。</p><h2 id="内存管理单元——页（Page）"><a href="#内存管理单元——页（Page）" class="headerlink" title="内存管理单元——页（Page）"></a>内存管理单元——页（Page）</h2><p>前文我们已经了解过，虚拟内存将主存视为磁盘的缓存，主存和磁盘上会通过数据传输来完成同步。然而，磁盘（特别是机械磁盘）的设计不能快速的读取或者写入一个字节一个字节的数据，因为它的<strong>随机读写</strong>性能比较差。比如系统要读取一个数组的所有数据，它就要访问数组的所有内存，而如果这些内存不在主存中，就得从磁盘上去装载数据到主存。那么如果是一个字节一个字节的读，可能就要在磁盘和主存之间传输 N 次数据，这样就会导致性能变得很差。</p><p>另外我们得为每个字节记录点什么信息，才可以知道这个内存是否已经被分配了，是否已经存在于主存中了。如果是按照一个字节一个字节的记录，那我们的大部分内存空间会用在了信息记录上面，而不是用于数据存储。</p><p>所以要想虚拟内存获得比较高的性能和内存利用率，必须由另外一种机制来提供。通过将虚拟内存分割为<strong>虚拟页（Virtual Page, VP）</strong>的大小固定的块来解决这些问题。也就是说，在磁盘和主存中传输数据，每次至少传输一个虚拟页，记录内存信息，也是按照虚拟页来记录。即虚拟页是磁盘和主存的数据传输和管理单元。这样如果是访问刚才那个数组，大部分情况下只要在磁盘和主存之间传输一次数据就够了（当然如果你的数组内存占用比较大，超过了一个虚拟页所能表示的大小，就要传输多次，但也比一个字节一个字节传输来得快非常多）。</p><p>和虚拟页对应的还有<strong>物理页</strong>，概念和虚拟页基本相同，除了它是存储在主存中的。因为是按照页作为传输单元的，所以物理页和虚拟页的大小一致。</p><p>一个虚拟页的大小通常通常由处理器的结构决定，一般情况下系统中的页大小都是一致的，比如说都是 4KB。当然，有些处理器还支持同时存在多个页大小。虚拟页的大小可以通过 sysconf 函数查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* sysconf(3) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The page size for this system is %ld bytes.\n&quot;</span>,</span><br><span class="line">           sysconf(_SC_PAGESIZE)); <span class="comment">/* _SC_PAGE_SIZE is OK too. */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="虚拟寻址"><a href="#虚拟寻址" class="headerlink" title="虚拟寻址"></a>虚拟寻址</h2><p>那一个进程可以用的内存究竟是多大呢？这主要受两方面的限制：</p><p>1）设置的<strong>交换空间</strong>的大小与物理内存大小的总和，虚拟内存存储在磁盘上面的空间就叫做交换空间，它通常对应一个文件或者是一个分区。所有进程共享同一个交换空间。如果交换空间和物理内存都被耗尽了，那么就不能再分配内存了。</p><p>2）进程可用的内存大小还受<strong>虚拟地址空间</strong>大小的影响。当一个进程的虚拟地址空间的所有地址都被分配了，那也不能再分配内存了。</p><p>在 32 位的程序中，由于指针的大小是 4 字节，所以它只能访问地址为 [0, 2^32) 的内存，它的地址数的总和是 4GB。而在 64 位的程序中，它能访问的地址范围是 [0, 2^64)，地址数的总和为 16EB (E = 2^60,exa,千兆兆)。</p><p>上面说的范围，如 [0, 2^32）表示的就是<strong>虚拟地址空间</strong>，指的是进程所能访问的所有的虚拟内存地址的集合。虚拟地址空间主要受程序的位数影响。除此之外，它还受 CPU 的实现的影响，比如 i7 处理器，它所支持的虚拟地址空间的范围是 [0, 2^48），即 256TB，不过一般这也够了。</p><p>除了虚拟地址空间之外，还有一个叫做<strong>物理地址空间</strong>的东西。顾名思义，物理地址空间表示的是所有能访问的物理地址的集合，它受计算机的主存大小影响。比如说，计算机的内存是 4GB，那么物理地址空间就是 [0, 2^32)。</p><p><strong>虚拟寻址</strong> 的意思就是将 <strong>虚拟地址空间</strong> 中的地址翻译成 <strong>物理地址空间</strong> 中的地址，然后再执行相关的读指令或者写指令。</p><h3 id="页表（Page-Table）"><a href="#页表（Page-Table）" class="headerlink" title="页表（Page Table）"></a>页表（Page Table）</h3><p>页表是记录页的状态的表，不同的进程间的页表是独立的。页表中的项叫做<strong>页表项（Page Table Entry, PTE）</strong>。</p><p>PTE 的数量为 <code>X=N/P</code>，其中 N 表示虚拟地址空间中的地址数量，P 表示页的大小。可以看出，在虚拟地址空间大小不变的情况下，页的大小越大，那么 PTE 的数量就越少；页的大小越小， PTE 的数量就越多。</p><p>PTE 记录了很多信息，这里列举几个重要的：</p><ol><li>有效位(P)，它标识对应的虚拟页面是否在物理内存中。</li><li>关联的物理页地址（Base addr），它表示的是对应的虚拟页存储在物理内存中的哪一页。</li><li>读写访问权限（R/W），表示对应的页是否为只读的，或者是可读可写的。</li><li>超级权限（U/S）表示该页是否只允许内核模式访问，还是用户模式也可以访问。</li><li>修改位（D），表示被加载到物理内存之后，页面的内容是否发生了修改。</li></ol><h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>PTE 按照<strong>虚拟页索引（VPN）</strong>排序，比如第 0 页位于的起始位置，第 1 页位于第 0 页后面，依此类推。VPN 是根据虚拟地址、页大小算出来的，比如页大小为 4KB，那第 0 页的地址就是页表的起始地址，第 1 页的地址就是页表地址+页大小，即 0x00001000。位于第 0 页和第 1 页之间的地址都属于第 0 页。</p><p>假设页大小为 4KB，地址空间为 32 位。系统将虚拟地址视为两部分组成，前 20 位表示页索引（VPN），后 12 位表示页偏移（VPO）。如果根据虚拟地址(VA)来写一个获取页索引(VPN)的公式就是： <code>VPN=VA&gt;&gt;12</code>。因为页大小是 4KB，所以一个虚拟地址需要使用 12（ 2^12=4KB ）位来描述这个地址在某页中的偏移量。那么剩下的位就用来索引 PTE。</p><p>在 CPU 中地址翻译由一个叫做 <strong>MMU（Memory Management Unit，内存管理单元）</strong>的硬件完成。 MMU 接收一个虚拟地址，并且输出一个物理地址。如果这个虚拟地址在物理内存中存在，那么就叫做页命中。如果这个虚拟地址在物理内存中不存在，那么 MMU 将产生一个<strong>缺页错误</strong>。</p><p>下图展示了 MMU 如何利用页表来实现虚拟地址到物理地址的映射。n 位的虚拟地址包括两个部分：一个 p 位的虚拟 VPO，和一个 n-p 位的 VPN。MMU 利用 VPN 来选择适当的 PTE。将 PTE 中的<strong>物理页号（PPN）</strong>与 VPO串联起来，就得到了相应的物理地址。注意：<strong>物理页面偏移（PPO）</strong>和 VPO 是相同的。</p><p><img src="https://xorex.space/image/243.jpg" alt="243.jpg"></p><p>下面具体描述页命中和缺页的处理流程。</p><h4 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h4><p>页命中指的是当 MMU 需要根据虚拟地址输出物理地址时，这个地址所在的页已经被装载到物理内存中了。即对应的 PTE 的有效为为 1。</p><p>下面是页命中时的地址翻译的过程：</p><ol><li>处理器生成一个虚拟地址，并把它传送给 MMU</li><li>MMU 生成根据虚拟地址生成 VPN，然后请求高速缓存/主存，获取 PTE 的数据。</li><li>高速缓存/主存向 MMU 返回 PTE 的数据</li><li>从 PTE 获取对应的物理页号 PPN。用物理页的基址加上页偏移 PPO（假设页大小为 4KB，那么页偏移就是虚拟地址的低 12 位，物理页的页偏移和虚拟页的页偏移相同），获取对应的物理地址。</li><li>主存/高速缓存将数据返回给 CPU。</li></ol><p><img src="https://xorex.space/image/244.jpg" alt="244.jpg"></p><h4 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h4><p>缺页是指当 CPU 请求一个虚拟地址时，虚拟地址所对应的页在物理内存中不存在。此时 MMU 会残生缺页错误，然后由内核的缺页处理程序从磁盘中调入对应的页到主存中。在处理完成后，CPU 会重新执行导致错误的指令，从而读取到对应的内存数据。</p><p>下面是缺页时的地址翻译的过程（第 1 步到第 3 步与页命中时相同）：</p><ol><li>处理器生成一个虚拟地址，并把它传送给 MMU</li><li>MMU 生成根据虚拟地址生成 VPN，然后请求高速缓存/主存，获取 PTE 的数据。</li><li>高速缓存/主存向 MMU 返回 PTE 的数据</li><li>由于判断出 PTE 的有效位是 0，所以 CPU 将出发一次异常，将控制权转移给内核中的缺页异常处理程序。</li><li>缺页异常处理程序确定出物理内存中的牺牲页，如果这个页面被修改过了（D 标志位为 1），那么将牺牲页换出到磁盘。</li><li>缺页处理程序从磁盘中调入新的页面到主存中，并且更新 PTE</li><li>缺页处理程序将控制权返回给原来的进程，再次执行导致缺页的指令。再次执行后，就会产生页命中时的情况了。</li></ol><p><img src="https://xorex.space/image/245.jpg" alt="245.jpg"></p><h4 id="翻译加速"><a href="#翻译加速" class="headerlink" title="翻译加速"></a>翻译加速</h4><p>从页命中的流程图中可以看出，CPU 每次需要请求一个虚拟地址，MMU 就需要从内存/高速缓存中获取 PTE ，然后再根据 PTE 的内容去从物理内存中加载数据。</p><p>这样在最坏的情况下，相当于从内存/高速缓存中多读取了一次数据。许多 MMU 包含了一个关于 PTE 的小缓存，叫做 <strong>TLB（Translation Lookaside Buffer，翻译后备缓冲器）</strong>来消除这样的开销。</p><p>TLB 将虚拟内存的 VPN 视为由索引和标记组成，<strong>索引部分（TLBI）</strong>用来定位 TLB 中的缓存数据项，<strong>标记部分（TLBT）</strong>用来校验存储的数据项是否为指定的 VPN 对应的数据。</p><p><img src="https://xorex.space/image/246.jpg" alt="246.jpg"></p><p>如果 TLB 命中了，那么所有的地址翻译步骤都是在 MMU 中执行的，所以非常快。下面是 TLB 命中时的操作流程</p><ol><li>处理器生成 1 个虚拟地址</li><li>MMU 向 TLB 请求 PTE</li><li>TLB 返回 PTE 到 MMU</li></ol><p>如下图所示，其中第 4 步和第 5 步与之前的流程一致。</p><p><img src="https://xorex.space/image/247.jpg" alt="247.jpg"></p><p>如果 TLB 未命中，MMU 就必须从高速缓存/内存中获取相应的 PTE，然后将新取出来的 PTE 放在 TLB 中。如下图所示</p><p><img src="https://xorex.space/image/248.jpg" alt="248.jpg"></p><p>理解 TLB 需要注意的是，因为不同进程的页表内容是不一致的，因此内核在切换上下文时，会重置 TLB。</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>前文有提到过，PTE 的数量由虚拟地址空间的大小和页大小决定。也就是：X=N/P。那如果我们有一个 32 位的物理地址空间、4KB 的页面和 一个 4 字节的 PTE。即使程序只使用了一小部分虚拟地址空间，也总是需要一个 4MB （ 4*2^32/2^12 )的页表常驻主存。对于 64 位的系统来说，情况将变得更加复杂。</p><p>设计者非常聪明，它将页表设计成一个包括多级的层次结构来解决这个问题。</p><p>下图展示了一个两级页表的层次结构。二级页表中的每个 PTE 项都负责一个 4KB 页面，而一级页表中的每个 PTE 负责 1024 个二级页表项。</p><p><img src="https://xorex.space/image/249.jpg" alt="249.jpg"></p><p>注意，常驻内存的只是一级页表，系统可以在需要时才创建、页面调入二级页表。这样就减少了主存的压力。另外如果一级页表中的一个 PTE 是空的，那么相应的二级页表就根本不存在。这样在一个只需要少量内存的程序上，绝大部分二级页表是不存在的。</p><p>下图展示的是一个 k 级层次页表的结构图，起始就是将 VPN 部分划分为多个段，每个段都代表某一级页表。而每一级中的 PTE 的 Base addr 为下一级提供入口地址。最后一级的 Base addr 则表示最终物理地址的 PPN。</p><p><img src="https://xorex.space/image/250.jpg" alt="250.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;本文转自与 知乎-安佳玮 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/61587598&quot;&gt;深入虚拟内存（Virtual Memory，VM）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们应该知道&lt;strong&gt;物理内存（Physica</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-存储系统</title>
    <link href="https://xorex.space/2021/05/08/530c4fb06907/"/>
    <id>https://xorex.space/2021/05/08/530c4fb06907/</id>
    <published>2021-05-08T09:04:25.000Z</published>
    <updated>2021-05-14T12:06:05.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主存的简单模型"><a href="#主存的简单模型" class="headerlink" title="主存的简单模型"></a>主存的简单模型</h2><p>首先看一个主存储器的模型图：</p><p><img src="https://xorex.space/image/228.jpg" alt="228.jpg"></p><p>存储元：存储一个高低电位的最小单位。</p><p>存储单元：多个存储元组成的集合。</p><p>存储字：存放在一个存储单元中的二进制代码组合，也就是一组数据。</p><p>译码器：将地址存储器中的读写地址翻译成主存的读取控制电路。</p><p>片选线：整个芯片的开关，用高低电平表示是否在工作。作用于控制存储容量的扩充。多个存储器芯片同时开，同时关，实现存储器每次取出的位数的扩充，位扩展（一个存储单元能存储的最长信息位）。多个芯片轮流开轮流关，实现存储器存储单元数量的扩充，字扩展（增加内存地址的范围，能存下更多条数据）。两者结合可以实现字和位同时的扩充。</p><p>寻址：按照地址寻找到在某处的操作数。寻址有很多中，比如按字节寻址（也就是 8bit 大小位一个地址），按字寻址（计算机字长大小位一个地址），等等。</p><h2 id="RAM-分类"><a href="#RAM-分类" class="headerlink" title="RAM 分类"></a>RAM 分类</h2><p>随机存储器 Random Access Memory，这里的随机存储意思是无论在存储器的任何位置写入数据，所需要的时间都为电流经过的时间，耗时基本相同。并不是写入的数据会随机分布的意思。大部分随机存储器的特点就是保存数据需要通电，一旦断电就会数据丢失。</p><p>RAM 为了减少译码器的控制电路的复杂度，往往将大量的存储单元编上行地址和列地址，这样能大大减少控制电路电线的数量并通过两次分别传入行地址和列地址来降低地址线的带宽，如下行地址器和列地址器：</p><p><img src="https://xorex.space/image/229.jpg" alt="229.jpg"></p><p>但是需要注意的是，因为将地址复用，并分两次分别传入行地址和列地址，所以就需要单独将确定存储器工作状态的片选线给拆分成<strong>行片选线</strong>和<strong>列片选线</strong>，分别确定行和列是否在工作状态。</p><ol><li>SRAM (Static) 静态随机存储器：</li></ol><ul><li><p>是使用双稳态多谐振荡器/触发器（设计复杂）作为数据存储的容器，读取数据不会破坏原有的状态。</p></li><li><p>这里的静态表示存储器只要保持通电，里面储存的数据就可以恒常保持。</p></li><li><p>特点是：能耗高，速度极快，成本极高，集成度较低，常常作为 Cache。</p></li></ul><ol start="2"><li>DRAM (Dynamic) 动态随机存储器，</li></ol><ul><li><p>是使用电容/晶体管（设计简单）作为数据存储的容器，读取数据会破坏原有的状态。</p></li><li><p>这里的动态表示电容会漏电，所以需要定时充电才可以保持存储的数据。</p></li><li><p>特点是：能耗低，速度较快，成本较低，集成度较高，常常作为主存。</p></li></ul><h2 id="DRAM-读取刷新周期"><a href="#DRAM-读取刷新周期" class="headerlink" title="DRAM 读取刷新周期"></a>DRAM 读取刷新周期</h2><ul><li>内存刷新</li></ul><p>因为 DRAM 的电容器一般来说只能在 2ms 内保证存储数据的稳定，所以说在 2ms 内，需要进行一次充电来刷新数据。刷新的过程为读取原有内容并按照原有内容进行一次完全充电，时间基本等同于一次读写周期</p><p>而由于主存的单次控制的读写每一次只能作用于一整行或者一整列，所以 2ms 内需要执行刷新电路 n 或 m 次。对于这么多的刷新次数，要么在 2ms 内分散开来刷新，要么在 2ms 内挑一个时间集中刷新完毕。</p><p>前者为异步刷新，后者为集中刷新。因为刷新的时候内存是无法被访问的，所以为了保证连续的性能，一般采用异步刷新：将所有的刷新任务均匀的分散在 2ms 内。</p><ul><li>内存读取周期</li></ul><p>A 表示 Address 表示读取地址。</p><p>CS 表示片选线，上面加上横线表示低电位为工作状态，高电位为无效状态。</p><p>Dout 表示读取数据总线，用于接收读取的数据。</p><p><img src="https://xorex.space/image/230.jpg" alt="230.jpg"></p><ul><li>内存写入周期</li></ul><p>Din 表示写入数据总线，用于提供要写入的数据。</p><p><img src="https://xorex.space/image/231.jpg" alt="231.jpg"></p><hr><p>通过上面的读写周期的图可以看到，每一个过程并不是严格的同时进行，完成就关闭的，而是维持为了维持电路的稳定性做了一些等待。</p><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>ROM 指的是 Read Only Memory 只读存储器。</p><p>我们使用 CPU + RAM 作为一个主机就可以单独工作了，CPU 从 RAM 中读取指令并解析执行。但是因为 RAM 拥有断电就失去数据的特性，所以需要外界有一个能持久存储数据的介质存储操作系统运行执行，在主机开始运行之前，将持久存储的指令通过 IO 来写入 RAM 中，为 CPU 的最初运行提供指令。</p><p>而当时能够提供持久化存储的介质只有 ROM，也就是它们只能写入一次，之后只能读取。</p><p>但是市场越来越需要能够持久化存储的介质，并且对他们的写入要求也越来越高（能写入的话就可以自己存储数据了），于是随着科技的进步，逐渐发展出来了读和写都非常厉害的持久化存储介质。虽说这些介质能能够写入数据，但是由于历史原因、本身写入性能低于读取、和 RAM 有较大差别，这些介质仍然被称为 ROM。</p><ul><li><p>MROM (Mask) 掩模式只读存储器 只有在出厂前的制造过程可以存储数据，出场之后就无法写入了，只能读，严格意义上的 ROM。</p></li><li><p>PROM (Programmable) 可编程只读存储器，出场后可以自己用专门的写入机器写入数据，写入之后同样是只能读取内容。CD-ROM 就是 PROM 的一种。</p></li><li><p>EPROM (Erasable Programmable) 可擦除可编程存储器，很有限的擦除重写，严格意义上已经脱离了只读存储器了。</p></li><li><p>Flash-ROM 基于 Flash 闪存技术的存储器，发展于 RAM，通过在电容间加入绝缘层和电感应读取数据解决了漏电的问题，变成了可持久化的存储介质。</p></li><li><p>HDD-ROM 机械硬盘，基于机械运动寻址和磁力存储，基本已经被淘汰。</p></li><li><p>SSD-ROM Flash 闪存的加强版，通过加入强大的读写驱动来大幅度提高读写性能，现在已经烂大街了。</p></li></ul><p>需要注意的是 Flash 和加强版的 SSD 不仅仅属于 ROM，同样数据 RAM，因为它们作为半导体的电存储元器件也满足随机存储的特性：无论在存储器的任何位置写入数据，所需要的时间都为电流经过的时间，耗时基本相同。</p><p>SSD 为什么叫作固态硬盘呢，可能是 固体电容 在英语中为 Solid，被翻译成了固态的原因吧，反正各种命名都奇奇怪怪的。</p><h2 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h2><ul><li><p>随机存储器 这里专门指的是 RAM，也就是电脑里面的内存，大部分语境里面都不是指无论在存储器的任何位置写入数据，所需要的时间都为电流经过的时间，耗时基本相同，所以这里要记住！！！</p></li><li><p>顺序存取存储器 这里的顺序就是完全定义上的顺序，指的是像磁带这种，不能精确定位数据并读取的存储器，只能从头到尾顺序读取。</p></li><li><p>直接存取存储器 这里指能够计算定位并直接去相应位置存储数据的存储器，现代存储器基本上都支持这个功能。</p></li><li><p>相联存储器 是一种不根据地址而是根据存储内容来进行存取的存储器，里面内置了比较器。相联：两个无关之物之间的联系。</p></li></ul><h2 id="存储器性能指标"><a href="#存储器性能指标" class="headerlink" title="存储器性能指标"></a>存储器性能指标</h2><p>存取周期：存储器进行一次完整的读写操作所需要的时间。</p><p>主存带宽：又称为数据传输率或存储速度，每秒从主存中进出信息的最大数量，计算方式为：数据宽度/存储周期。</p><h2 id="存储器的扩展"><a href="#存储器的扩展" class="headerlink" title="存储器的扩展"></a>存储器的扩展</h2><h3 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h3><p>指增加存储器的存储字的长度，通过片选线控制多个存储器芯片同时开，同时关，实现存储器每次取出的位数的扩充，位扩展（一个存储单元能存储的最长信息位）。</p><p>下图表示将 8 个 1 位的存储器通过位扩展的方式扩展为字长为 8 的存储器，存储器芯片处于同时开的状态，其中 WE 表示的是读写控制总线：</p><p><img src="https://xorex.space/image/232.jpg" alt="232.jpg"></p><h3 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h3><p>指增加存储器的存储字的数量，多个芯片轮流开轮流关，实现存储器存储单元数量的扩充，字扩展（增加内存地址的范围，能存下更多条数据）。</p><p>下图表示将四个 8k 个存储字数量的存储器通过字扩展为 24k 的存储字数量的存储器，其中译码器负责将传送过来的的存储器工作编号移码为对应的片选线电路：</p><p><img src="https://xorex.space/image/233.jpg" alt="233.jpg"></p><p>译码器的存在还有一个非常重要的作用就是让整个内存地址都有意义，地址的开头几位可以表示子存储器的编号，对应整个大存储器也保证了地址的连续性。</p><h3 id="字和位同时扩展"><a href="#字和位同时扩展" class="headerlink" title="字和位同时扩展"></a>字和位同时扩展</h3><p>将上面的两个结合在一起就可以了：</p><p><img src="https://xorex.space/image/234.jpg" alt="234.jpg"></p><h3 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h3><p>下面是一个常见的 38 译码器，A1 A2 A3 接收一个 3 位二进制数，然后能映射到对应的 Yn 的电位输出，常用于映射对应片选线来决定子存储器的工作状态。</p><p>需要注意的是译码器还有三个接口的使能端，带圆点要接入低电位（接地），第一个要接入高电位，只有 100 这样的使能端被接入，才能支持译码器的正确工作。否则译码器会将所有的 Y 都输出高电位。</p><p><img src="https://xorex.space/image/235.jpg" alt="235.jpg"></p><h2 id="存储器性能优化"><a href="#存储器性能优化" class="headerlink" title="存储器性能优化"></a>存储器性能优化</h2><p>因为 CPU 的性能提升实在是太快了，存储器也需要提高自己的性能来满足 CPU 才可以。</p><h3 id="双端口-RAM"><a href="#双端口-RAM" class="headerlink" title="双端口 RAM"></a>双端口 RAM</h3><p>双端口 RAM 指的是一个 RAM 可以连接两个 CPU，和两个 CPU 进行数据交换，提高 RAM 的利用率。</p><p><img src="https://xorex.space/image/236.jpg" alt="236.jpg"></p><p>同时读取不同的数据：允许</p><p>同时写入不同的数据：允许</p><p>同时读取相同的数据：允许</p><p>同时写入相同的数据：禁止</p><p>同时一个读取一个写入相同的数据：禁止</p><p>这种双端口 RAM 其实也就大规模服务器（会有很多个 CPU）会用到，提高 RAM 的利用率，对于实际的读写性能提升并不明显。</p><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><p><img src="https://xorex.space/image/237.jpg" alt="237.jpg"></p><p>多模块存储器的性能优化有两个方向，正如上面的图一样，一个方向是实现多体并行存储器，另外一个方向是实现单体多字存储器。</p><h4 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h4><p>多体并行看字面意思就是实现了一个有多个存储体能并行读取的存储器。</p><p>我们都知道在读取内存数据的时候整个读写周期为 <code>读写时间+恢复时间</code> 因为恢复时间有点耗时，那么多体并行存储器就想办法那它做文章。</p><p>看上图的地址编址，连续的地址是分散在不同的存储体中的，那么我们在读取连续的数据的时候，就可以先读取第一个存储器的 01 数据，拿到数据之后无需等待回复时间，直接去读取下一个存储体 02 数据。就像下面一样，避免在同一个存储体中连续读取数据，从而节约了恢复时间的开销。</p><p><img src="https://xorex.space/image/238.jpg" alt="238.jpg"></p><p>实现在不同的存储体连续读写的只需要改变对原本地址的解析方式即可，截取最后几位（取决于存储体的数量）解析为体号，确定去哪个存储体中读写数据，而前面数据为存储体内地址，用来寻找具体的存储单元。</p><p>比如 00010110 这个地址，为寻找 22 号存储体，按照最上面的多体并行存储器的图，我们截取后两位为体号，却认为 2 号存储体。然后解析前面的 000101 确定为 2 号存储体的 5 号存储体，这样就找到了多体并行存储器里面的 22 号存储体了，也就是 00010110 地址。</p><h4 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h4><p>看上面的图，单体多字存储器有点类似于位扩展，都是扩展了同时读取的数据长度，但是不同的是单体多字存储器是同时读取多个字。</p><p>扩张 MDR 和数据线路，来实现同时读取多个连续字的数据，从而提高读取速度，真正的并发处理。</p><p>实现原理就是电路一次读取一行的多个存储单元的信息，然后同时输出到数据线路，将这些连续的数据交给 CPU（其实是 Cache）。</p><p>一般来说优化都是上面两种存储器的结合体，多体多字并行存储器。</p><h2 id="Cache-概念"><a href="#Cache-概念" class="headerlink" title="Cache 概念"></a>Cache 概念</h2><p>因为 CPU 运算时间和内存的数据读取时间差异实在是太大了，导致了 CPU 大量的时间都浪费在了等待内存数据上面，为了提高数据读取效率，这里引入了一个中间存储器，叫作缓存，使用快速而又昂贵的 SRAM ，这个东西的速度能大大减少 CPU 等待数据时间。</p><p>因为昂贵，那么能存在 Cache 里面的数据只能是少量的，那么 Cache 是怎么知道 CPU 需要内存的哪些数据呢？</p><p>这里是根据局部性原理，分为空间局部性和时间局部性，空间局部性就是当前使用的数据的周围数据很有可能未来被使用，例子就是数组数据。时间局部性就是当前使用的数据很有可能未来被使用，例子就是循环变量。</p><p>通过局部性原理来设计预测算法，提高 CPU 所需数据在 Cache 里面的命中率，从而提高整体的存储结构的性能。</p><p>这里计算 Cache 的效率取决于 Cache 速度和命中率，都很好理解，就不单独解释了。</p><h2 id="Cache-工作原理"><a href="#Cache-工作原理" class="headerlink" title="Cache 工作原理"></a>Cache 工作原理</h2><h3 id="内存-gt-Cache"><a href="#内存-gt-Cache" class="headerlink" title="内存 -&gt; Cache"></a>内存 -&gt; Cache</h3><p>内存和 Cache 进行一次数据交换的单位是 Cache Line 的大小，需要一个存储单元的数据就将这个存储单元所属于的以 Cache Line 大小分的小组的全部成员全部放到 Cache 中，这也是局部性原理的体现。而内存以 Cache Line 的大小划分为单元，被称为内存 Line 。</p><p>下面主要是介绍内存中数据是放置到 Cache 中的哪些数据，并且是如何识别是否为 CPU 想要的数据的。</p><h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><p>全相联映射指的是所有的内存和 Cache 映射都是采用相联映射方式，也就是根据在 Cache 行开头标记的内存地址前几位来确定在内存中的位置（用比较器来根据内容映射）。因此采用全相联映射的 Cache 可以将内存中的数据随意放置。</p><p>需要放置到 Cache 的数据，依次从 Cache 中寻找空位，如果有，就直接放进去。假设 Cache 大小为 512B（2^17），有八条 Cache Line 每条大小为 64B（2^14），于其进行数据交换的内存大小为 256MB（2^36），则：</p><p><img src="http://xorex.space/image/239.jpg" alt="239.jpg"></p><ol><li><p>需要有效位 1 位，用来表示这个位置是否已经存在数据，1 表示有数据，0 表示没有数据。</p></li><li><p>需要内存 Line 编号 22 位（36-14），确定这个 Cache Line 里面的数据是属于内存的哪一块区域的，直接截取里面任意数据内存地址的前 22 位，其值即为内存 Line 的编号。</p></li><li><p>需要 17 位来存放一个 Cache Line 单位的内存数据，用来和 CPU 进行快速数据读写。</p></li></ol><p>CPU 去命中数据只需要先去找内存 Line 编号是否存在，如果存在则直接按照地址后 17 位从所在的 Cache line 中读取即可。</p><ul><li><p>优势：利用空余位置比较灵活，看到空位就可以直接使用。</p></li><li><p>劣势：Cache Line 为了定位差找里面数据对应内存的位置，需要有设计较为复杂的比对电路。</p></li></ul><h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p><img src="http://xorex.space/image/240.jpg" alt="240.jpg"></p><p>直接映射就好办了，我们将内存 Line 分为 Cache Line 数量个的小组（意味着属于这个小组的内存 Line 数据会放到小组所需与的 Cache Line 中）</p><p>将小组内部的的内存 Line 的后几位作为在小组里面的编号（从 0 到 最大数量-1），记录到 Cache Line 前面，用来定位里面的数据具体属于这个小组里面的那个成员的。</p><ul><li><p>优势：因为一个 Cache Line 中的数据内存建立了严格的位置映射关系，所以 CPU 差找数据方便快速，不用设计复杂的对比电路。</p></li><li><p>劣势：因为一个内存 Line 映射的 Cache Line 只有一个位置，所以需要频繁的更替数据，灵活性差。</p></li></ul><h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><p><img src="https://xorex.space/image/241.jpg" alt="241.jpg"></p><p>组相联映射的意思就是以小组划分的方式映射位置（根据位置映射），小组而内部采用相联映射（根据内容映射）。</p><p>这种方法是将上面的两种方法结合起来（老经典了），先分组，但是每一组里面有多条 Cache Line，这些可以被所属于此分组的内存 Line 数据随意放入。</p><p>这样就结合了上面两者的优点。</p><p>最后总结一下上面的三种映射方式：</p><p><img src="https://xorex.space/image/242.jpg" alt="242.jpg"></p><h3 id="Cache-满了处理"><a href="#Cache-满了处理" class="headerlink" title="Cache 满了处理"></a>Cache 满了处理</h3><p>当内存的数据放入 Cache 中时，发现已经没有位置了，那么对于有多个可选择的替换位置，该替换哪个位置的数据呢？下面介绍四种算法。</p><ol><li><strong>随机算法 RAND</strong></li></ol><p>Random，虽说是随机，但是还是有一些算法的，这里需要参考操作系统相关。</p><ol start="2"><li><strong>先进先出算法 FIFO</strong></li></ol><p>First In First Out，使用队列实现，找出最早加入 Cache 的数据，将其替换。</p><ol start="3"><li><strong>近期最少使用 LRU</strong></li></ol><p>Least Recently Used，使用计数法，所有的数据都随着 CPU 访问而加一，如果数据被 CPU 命中，则计数清零。找出里面数据最大的，就是近期最少被命中的数据，将其替换，如果有多个最大，使用 FIFO 原则。</p><ol start="4"><li><strong>最不经常使用 LFU</strong></li></ol><p>Least Frequency Used，使用计数法，被 CPU 命中则加一，找出命中次数最少的，将其替换，如果有多个最小，则参看操作系统相关内容。</p><h3 id="Cache-内存数据同步"><a href="#Cache-内存数据同步" class="headerlink" title="Cache 内存数据同步"></a>Cache 内存数据同步</h3><p>当 CPU 需要修改内存中的数据，那么 Cache 和 内存 之间的数据如何同步呢，下面是几种方法。</p><p><strong>写回法 Write-Back</strong>：Cache 被命中：CPU 修改 Cache 内的数据之后，暂不做处理，当整行 Cache Line 被替换之后，再将里面被修改的数据更新到内存中。</p><p><strong>全写法 Write-Through</strong>：Cache 被命中：CPU 修改 Cache 内的数据之后，将被修改的数据加入到写缓冲区中，缓冲区慢慢的去内存中更新数据。</p><p><strong>写分配法 Write-Allocate</strong>：Cache 无数据：将内存数据调入 Cache 中，在 Cache 中修改数据。</p><p><strong>非写分配法 No-Write-Allocate</strong>：Cache 无数据：直接在内存中修改数据，不调入 Cache 中。</p><p>一般来说，会让写回法和写分配法结合，大大减少了内存的读写，但是两者数据之间往往不同。</p><p>剩下的就是全写法和写分配法结合，借助写缓冲区 Write Buffer，提升两者数据的同步率，但是会对内存进行频繁的读写。</p><hr><p>重点来了，现代 CPU 当然是会考虑到它们之间的各自优劣性，所以就将这两种组合了起来，第二种结合方法作为 L1 Cache 和 L2 Cache 数据同步的方法，第一种结合方法作为 L2 Cache 和内存之间的数据同步方法。</p><p>这样更快的 L1 和 L2 能快速的完成数据修改</p><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>首先遇事不决，先看一篇非常棒的文章：<a href="https://xorex.space/2021/05/12/d1cccaf324ae/">深入虚拟内存</a></p><p>因为一般来说我们用户运行的程序，调用的程序/数据的位置都是在硬盘中的，能够得到的指令/数据地址也都是硬盘中的地址（我们称为虚拟地址）。而和 CPU 进行数据交换的，一般都是在内存中。所以我们需要将用到的指令和数据根据 IO 总线读取到内存中，CPU 去调用这些指令和数据是，因为只知道它在硬盘中的地址，不知道被读取到内存的那个位置了，因此我们在将硬盘的东西写入内存中的时候，就需要建立一个映射表，供 CPU 映射查找数据在内存中的真实地址。</p><p>里面具体的内容有很多，具体看上面的文章吧，写的非常好，本质上主存也是对硬盘的一个缓存优化，内存中存储程序最近运行会用到的数据，用页表来管理缓存映射，如果 CPU 命中就调用内存数据，没有命中就将硬盘数据调入内存中，CPU 再次去页表找映射最终命中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;主存的简单模型&quot;&gt;&lt;a href=&quot;#主存的简单模型&quot; class=&quot;headerlink&quot; title=&quot;主存的简单模型&quot;&gt;&lt;/a&gt;主存的简单模型&lt;/h2&gt;&lt;p&gt;首先看一个主存储器的模型图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://xorex.spac</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-数据的表示和运算</title>
    <link href="https://xorex.space/2021/05/06/a39242fd7884/"/>
    <id>https://xorex.space/2021/05/06/a39242fd7884/</id>
    <published>2021-05-06T07:39:00.000Z</published>
    <updated>2021-05-08T09:06:39.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据的检验"><a href="#数据的检验" class="headerlink" title="数据的检验"></a>数据的检验</h2><h3 id="BCD-码"><a href="#BCD-码" class="headerlink" title="BCD 码"></a>BCD 码</h3><p>BCD 码用 4 位二进制数来表示 1 位十进制数中的 0~9 这 10 个数码，对于浮点数来说，BCD 码的最大作作用就是能和十进制完美对接，不会产生 <strong>精度损失</strong> ，因为其他二进制编码表示浮点小数的时候，为离散的，像 0.3 这样的数浮点数就无法表示。但是 BCD 码因为四位表示十进制的一位，所以就没有这个问题。</p><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>奇校验码规定校验码的 1 有奇数个，也就是所有位（有效信息位+校验位）进行异或运算得到结果为 1</p><p>偶校验码规定校验码的 1 有偶数个，也就是所有位（有效信息位+校验位）进行异或运算得到结果为 0</p><p>这种校验码只能检测有奇数位发生错误的情况，不具备纠错能力。</p><h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h3><p>海明码具有两位检错，一位纠错的能力。</p><p>首先设需要验证的位数为 n，需要 k 位作为校验位，根据公式：<code>n+k&lt;=2^k-1</code> 计算出来所需要的额外验证位 k。</p><p>这些验证位在验证码的位置是按照二进制位权决定的，比如当 k 等于 3 的时候，在二进制里面就可以表示 1 2 4 这三个位权，那么就把所需要的 3 个验证位放在验证码的第 1 2 4 位上面。这是因为海明码的纠错是依靠判断验证位正确性然后将位权累加得到错误的地方，将验证位放到自己对应的位权的位置的话，一旦验证位错误也能获取错误的地方。这篇文章讲的很好：<a href="https://www.huaweicloud.com/articles/e21f939952893bdebef76eeab885c424.html">带你从头思考海明码的创造过程</a></p><p>验证位的计算也是根据分组决定的，分组的原因就是将某一个数据位的对错和几位位验证位绑定为一组，从而获取多组绑定结果。而分组的根据就是数据位在验证码的位权的二进制表示，比如一个数据位的位权是 5 也就是在验证码的地 5 位，那么 5 的二进制表示就是 101 对应分组就绑定到了 1 4 位上面的验证位上面了（想想为什么我们将验证位放到 2^n 上面），这样一旦 1 4 位的验证位验证失败，就可以一定确定是第 5 位出了错，因为只有第五位出错才会导致 1 4 位验证位同时验证失败。</p><p>这样我们就可以根据数据的二进制表示来分组了，分完组就可以计算验证位的值了，一般来说海明码这里采用偶验证，将某验证位加上他能表示的所有数据位一起进行偶验证得到 0，从而反计算得到此验证位的值。海明码验证的过程也是此过程，将所有的验证位按照上面的方式进行偶验证，结果正确表示 0，错误表示 1。</p><p>获取每一位验证位验证的结果之后，按照验证位位权将其求得十进制结果，得到错误数据位的标号。能得到原因就是因为分组，1 4 位验证位验证失败，一定是同时分到 1 4 位验证为组的数据位错误了，才能同时导致两个验证位失败，而同时分到 1 4 位的是第 4+1=5 位。</p><p>下面的图也可以参考验证位的分组。</p><p><img src="https://xorex.space/image/223.jpg" alt="223.jpg"></p><h2 id="数据的表示"><a href="#数据的表示" class="headerlink" title="数据的表示"></a>数据的表示</h2><h3 id="定点小数和整数"><a href="#定点小数和整数" class="headerlink" title="定点小数和整数"></a>定点小数和整数</h3><p>定点数一般来说不怎么用到，虽然精度较高，但是表示的位数太低。</p><p>定点小数是一个纯小数，第一位为符号位，后面全都是小数点后面的位数，权值为 <code>1-2^(-n)</code></p><p>定点整数是一个纯整数，第一位为符号位，后面全都是小数点前面的位数，权值为 <code>2^n</code></p><h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><p>移码的作用主要是为了表示浮点数的阶码（也就是科学计数法乘上去的 2^n）。</p><p>那么作为根据它的用途，就需要满足以下特性：快速比对大小。（涉及到浮点数的计算必须比大小）</p><p>因此移码就是将 <strong>真值</strong> 向右偏移，使得负数变成正数。注意这里的移码是没有符号位的，通过加一个数将真值向右偏移，所有的数都是正数，可以快速比大小。</p><p>用 8bit 举例，经过偏移之后，00000000 表示原有的最小值 -2^8，11111111 表示原有的最大值 2^8-1。</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>对于位移运算来说，正数的原码、补码、反码、以及负数的原码，在进行位运算位移的时候，都是补零。</p><p>唯一的不一样的是，负数的补码，在向左移的时候添 0 效果等价于乘 2，向右移的时候补 1 效果等价于除 2 。这里可以想想补码原理相关。</p><h3 id="定点数的乘法运算"><a href="#定点数的乘法运算" class="headerlink" title="定点数的乘法运算"></a>定点数的乘法运算</h3><p>定点数的原码乘法运算和我们手算乘法是一模一样的，不同的是，它全程只有占用三个寄存器，通用寄存器，ACC 寄存器，MQ 寄存器。其中通用寄存器和 MQ 寄存器初始存储乘数，而 ACC 寄存器最后和 MQ 寄存器一起存储乘积结果。运算原理如下图：</p><p><img src="https://xorex.space/image/224.jpg" alt="224.jpg"></p><p>它通过检测 MQ 的最末尾值，如果为 1，那么在 ACC 中加上通用寄存器中的被乘数，为零则什么都不做，然后将 ACC 和 MQ 的内容一起左移一位。重复上面的步骤 MQ 的长度次数。最后 ACC 寄存器最后和 MQ 寄存器一起存储乘积结果。而符号位则直接采用两个乘数符号位的异或运算结果。</p><p>对于原码的乘法运算来说，还是很简单的，但是计算机里面的定点数为了方便减法的运算，一般都是用补码来存储，所以这里要么直接转化成原码，要么直接使用补码的乘法器。</p><hr><p>这里的补码的乘法，有亿点点复杂，想了很久也没有想明白，只在知乎上找到了一个写的很好的文章，解释了 Booth 算法为什么要 Yn+1 - Yn 来决定是加还是减，用到了一点高中数列的知识。但是前面的很多推导他都省略了，结果导致根本看不懂。</p><p>下面是计算过程：</p><p><img src="https://xorex.space/image/225.jpg" alt="225.jpg"></p><p>哭了，别说直观理解了，连推导过程都不给啊……</p><p>学个计组也太难了吧……</p><h3 id="C-语言类型转化"><a href="#C-语言类型转化" class="headerlink" title="C 语言类型转化"></a>C 语言类型转化</h3><p>里面的整形都使用的补码表示，long -&gt; int -&gt; short 都是直接截断后面的部分作为下一个类型的数据的，会直接丢失高位。</p><p>对于 double -&gt; float 的尾数是丢失小数点最后几位的精度，而阶码则是截断后面部分舍去前面部分的。</p><h3 id="IEEE-规范"><a href="#IEEE-规范" class="headerlink" title="IEEE 规范"></a>IEEE 规范</h3><p>浮点数在计算机中的表示方式为：</p><p><img src="https://xorex.space/image/226.jpg" alt="226.jpg"></p><p>其中符号位 S 为一位，0 表示正，1 表示负，而指数位（阶码） E 使用移码来表示，偏移量为 <code>2^n-1</code>。数值位 M 使用原码，表示小数的尾数。</p><p>对于阶码，这里是根据补码进行加偏移量的，因为偏移量为 <code>2^n-1</code> 所以会导致表示范围为 <code>-1</code> 到 <code>2*2^n -2</code>，也就是说，阶码的实际表示范围为 <code>1</code> 到 <code>2*2^n -2</code>。</p><table><thead><tr><th>阶码 E 值</th><th>尾码 M 值</th><th>表示内容</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>浮点数为 0</td></tr><tr><td>0</td><td>≠0</td><td>表示为非规格化数尾数，没有默认的第一位 0.1</td></tr><tr><td>-1</td><td>0</td><td>表示为无穷大</td></tr><tr><td>-1</td><td>≠0</td><td>表示为 NaN，非数值</td></tr></tbody></table><p>而尾数最终是需要被规格化的，规格化是指：将尾数部分化为 0.1XXXX 的形式，这样第一位的默认 1 就可以省略了。当然规格化的时候需要将阶码进行加减运算。</p><h3 id="ALU-运算"><a href="#ALU-运算" class="headerlink" title="ALU 运算"></a>ALU 运算</h3><p>对于加法的电路设计来说，因为需要获取上一位的进位信息，所以需要串行计算，总的延时有点高。那么为了降低延时，可以通过数学逻辑进行并行计算（某种意义上的真正的多线程），也就是每一位的获取的计算都是独立的。</p><p>首先构造一个并行的四位加法器，然后将四个四位加法器串行，得到一个较快的十六位加法器。（直接搞一个十六位并行的加法器电路设计过于复杂，所以还是四个拼接好了）</p><p><img src="https://xorex.space/image/227.jpg" alt="227.jpg"></p><p>这里面的并行计算的数学推导有点复杂啊，不学了……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据的检验&quot;&gt;&lt;a href=&quot;#数据的检验&quot; class=&quot;headerlink&quot; title=&quot;数据的检验&quot;&gt;&lt;/a&gt;数据的检验&lt;/h2&gt;&lt;h3 id=&quot;BCD-码&quot;&gt;&lt;a href=&quot;#BCD-码&quot; class=&quot;headerlink&quot; title=&quot;BCD</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-计算机基本结构/工作流程</title>
    <link href="https://xorex.space/2021/04/29/138ad4d24eb9/"/>
    <id>https://xorex.space/2021/04/29/138ad4d24eb9/</id>
    <published>2021-04-29T12:32:50.000Z</published>
    <updated>2021-05-08T16:53:18.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>已经很久没有写过博客了，发现这样的效果真的是不太好，所以觉得还是继续保持经长写博客的习惯吧，为了缓解记忆枯燥的 Spring API，我决定并发学习计算机组成原理（视频当电视剧看）</p></blockquote><h2 id="计算机基本结构-计算流程"><a href="#计算机基本结构-计算流程" class="headerlink" title="计算机基本结构/计算流程"></a>计算机基本结构/计算流程</h2><iframe src="https://www.xmind.net/embed/x3pUA5" width="800px" height="540px" frameborder="0" scrolling="no"></iframe><p><img src="https://xorex.space/image/222.jpg" alt="222.jpg"></p><p>需要注意几点：</p><ol><li><p>上面计算流程中，CPU 区分从存储器中取出来的是指令还是数据的方法是根据指令执行周期，一个指令从 PC 中取出地址到完全执行完毕为一整个指令执行周期，其中周期的都会有取指令阶段和执行阶段。CPU 通过区分从存储器中获取内容是在取指令阶段还是执行阶段来判断取出来的是指令还是数据。</p></li><li><p>在计算机中，<code>透明</code> 的概念是等价与黑盒的，即无法对外显示。据此，寄存器对汇编语言是非透明的，汇编语言可以直接操作寄存器。</p></li></ol><h2 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h2><iframe src="https://www.xmind.net/embed/3E9LQy" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;已经很久没有写过博客了，发现这样的效果真的是不太好，所以觉得还是继续保持经长写博客的习惯吧，为了缓解记忆枯燥的 S</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>快捷键整合</title>
    <link href="https://xorex.space/2021/04/20/20ca0302e5c5/"/>
    <id>https://xorex.space/2021/04/20/20ca0302e5c5/</id>
    <published>2021-04-20T09:37:01.000Z</published>
    <updated>2021-05-11T12:41:04.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows-快捷键"><a href="#Windows-快捷键" class="headerlink" title="Windows 快捷键"></a>Windows 快捷键</h2><p><code>Ctrl + Shift + N</code> 创建新文件夹</p><p><code>Ctrl + D</code> 删除文件</p><p><code>Win + E</code> 打开文件管理器</p><p><code>Ctrl + 拖拽</code> 创建文件副本</p><p><code>Ctrl + N</code> 新建同级界面（常用于文件管理器）</p><p><code>Alt + 双击</code> 查看文件属性</p><p><code>Win + X + U + S</code> 快速睡眠</p><p><code>Win + D</code> 显示桌面</p><p><code>Win + L</code> 锁屏</p><h2 id="IDEA-快捷键"><a href="#IDEA-快捷键" class="headerlink" title="IDEA 快捷键"></a>IDEA 快捷键</h2><h3 id="视野移动"><a href="#视野移动" class="headerlink" title="视野移动"></a>视野移动</h3><p><code>Ctrl + +</code> 展开当前折叠的代码块</p><p><code>Ctrl + Shift + +</code> 展开所有折叠的代码块</p><p><code>Ctrl + -</code> 折叠当前展开的代码块</p><p><code>Ctrl + Shift + -</code> 折叠所有展开的代码块</p><p><code>Ctrl + ↑/↓</code> 向上/下滚轮</p><p><code>Alt + ↑/↓</code> 光标移动到上/下一个方法中</p><p><code>Shift + 滚轮</code> 横向滚动滚轴</p><h3 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h3><p><code>Ctrl + R</code> 当前文件进行文本替换 Replace</p><p><code>Ctrl + Shift + F</code> 全局搜索</p><p><code>Ctrl + Shift + R</code> 全局替换</p><p><code>Ctrl + Shift + U</code> 选中内容进行大小写替换</p><p><code>Ctrl + W</code> 递进选择光标处代码</p><p><code>Ctrl + Y</code> 删除当前行</p><p><code>Ctrl + D</code> 复制当前行</p><p><code>Ctrl + /</code> 将选中的部分标记为单行注释</p><p><code>Ctrl + Shift + /</code> 将选中的部分标记为多行注释</p><p><code>Ctrl + Backspace</code> 删除光标前的一串英文单词</p><p><code>Ctrl + Alt + L</code> 格式化代码</p><p><code>Ctrl + Alt + O</code> 整理导入的包</p><p><code>Ctrl + Alt + T</code> 对选中代码进行语句包裹（if try..）</p><p><code>Shift + Enter</code> 创建空行</p><p><code>Shift + Tab</code> 取消缩进</p><p><code>Alt + Shift + ↑/↓</code> 带着光标所在行上下移动</p><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><p><code>Ctrl + O</code> 选择可以重写的方法</p><p><code>Ctrl + I</code> 选择可以实现的方法</p><p><code>Ctrl + ,</code> 普通代码提示</p><p><code>Ctrl + J</code> 提示插入固定语句模板</p><p><code>Ctrl + P</code> 提示方法的参数列表</p><hr><p>后缀补全：表达式后面加 <code>.</code> 之后，选择对应的补全。比如 <code>sout</code> <code>if</code> <code>try</code> 等。</p><p>语句补全：直接输入语句模板的关键词，然后选择即可，如输入 <code>itar</code> 并回车自动生成迭代数组的 for 语句。如果想不起来语句模板的关键词，可以用 <code>Ctrl +J</code> 来进行提示。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><code>Ctrl + E</code> 显示最近打开过的文件</p><p><code>Ctrl + 左键单击</code> 弹出文件所在位置的文件管理器</p><p><code>Shift + Esc</code> 隐藏最后激活的窗口（如输出栏）</p><p><code>Alt + S</code> 打开设置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Windows-快捷键&quot;&gt;&lt;a href=&quot;#Windows-快捷键&quot; class=&quot;headerlink&quot; title=&quot;Windows 快捷键&quot;&gt;&lt;/a&gt;Windows 快捷键&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Ctrl + Shift + N&lt;/code&gt; 创建新文</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="快捷键" scheme="https://xorex.space/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
</feed>
