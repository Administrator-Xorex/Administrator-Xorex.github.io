<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xorex</title>
  
  <subtitle>要成为世界上最幸福的人啊！</subtitle>
  <link href="https://xorex.space/atom.xml" rel="self"/>
  
  <link href="https://xorex.space/"/>
  <updated>2021-06-05T16:47:14.015Z</updated>
  <id>https://xorex.space/</id>
  
  <author>
    <name>Xorex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为美好的世界献上祝福</title>
    <link href="https://xorex.space/2022/05/20/567f91f8bbba/"/>
    <id>https://xorex.space/2022/05/20/567f91f8bbba/</id>
    <published>2022-05-20T11:58:03.000Z</published>
    <updated>2021-06-05T16:47:14.015Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="689bfc10a9fed57c789bc7685d36a5d9d75f31b34cafe041b99ff510386c6242">8a972074cb8fb594adf191142c932486f63d9db6a4bbbbf65eb58b44e7f3a502ca39de9d3c1e3d9c70fdc9a01ad868dc3486910eced5f4e34f64df4c5155d0e28740e7f637329c5391f9bbe6ff64e653a789e2cef71c949e21aa63f2fba5c2f8909ab81d64320e8cb4384ed74fbebab2050cb82c4a7d22b4b9fd24d8a61fc8d8029f2ecbce16d7ac4071fe5c0ae2c3425b4c421b4a82a69b6012152d7d464a3624e786c960a03a52f9cd3453ffde3f9e7f7f8db1b21b9fd158b70d49126036880e6f581475aa1c9265c50093981c7c70663d0a1e3bede2870b4a7e0a6dc0d1a1ce8dbc658189e95bd6888f0f4d48bc8d7fa179df02ce8435ed223754c508e2b86eb7748ba754993eb71d24a37e5f551d0164956aa4d5dd5f723185894b6581fdc9638900b4666fa18e9bd6f6874b22c630932f62849d260f383329527390267e1ae61d8591c4aeb352f4b29108c2465a5e074d349edb5a9af79cb59ade636bb557cc6cdecd797157def65921204d200554354bc3d381c49d4097e92d1d51fd01c2313cff9d6502cf7e7f4b2399cc1e6be251d80c7050309bf346d386a7b536645f5c4c96178bc331da5740a42b0bd02b9968ce31b992b998e972e1dd06841a9d53b1d8280616027ac636ce646b67ae2c98a4b2ce990afefc45bd9b4d068c8fde09917cd2e84b9ffdf59606a1a60816d2f994703dfbbad7039e96e0b658292bacb1858ba7d9e49eb3187431fa4a1f8363915dc73aad3d519447f7cc0ff818de1453e2ab8257e0057131b57981825fc2c9f788e75c5564eb2ad8404bab6a82c47ab0a53249beb3b2306c2e5554ac2302070a4190176ddf1f1a7c9f4e483174777de2b527a91c806a1327390ff9a7eb985697c66546afc772628cec06b528dccdd1cb1d1d13ad8f74668fa5f5d0195cde6adade74f3ee1870b9a5da2542345b0f3ccb4e45aa3e4ca19ee469c348bc52b7c915f9fd94f14a9ce369c3d58e5c0e6550c9e6944437b122bacc312d2eaf41ec6165983d4afd819eb351ba8b730ee916f9cd78fef8008dcb9c56e63761799af98a3a7f796a1fa589fb9951d440a514e59ecf489a527c3a856fb48273361bc634d065d3e1833fc4a3b59e3f44008e8a1565a63506724732b84253673b58773214fb18c6f216ce7f94a3000979160f8fbe89f7300870c0103288288d986af8c35cf489154c5116b9e29ea3806b83fb4fb5c13bf5fac94b9fbb3d4dbc0a39cf185ce78c526bc7ed204162cdae47a4d016b2d81ea2ba9fc9830fb3527f1841ccf23061c0b80b53f3ae74c11c56b01d7711482081a2fcee250f16af2cb412ec812dc57d4d1d6985a692f17764a8bda6787d62fb8612eb25c70420071fd319dbc83c5d7f8ab892ebe088697c5f2833a61978a2b3c68e6916e569324b6bba4123401b6cccf173cb6f5f16b310bd23c631794739ed100cba1697a02e0cd558489edd5b9fb774265919385617ef45af3e351137e2be1db5a0dc536cc5ab5a80897d655a4da942de4a3fc9462a7d2eb6b49a288980210c8bf4649156b1e7d1f2c6e6eb1b8cb056067a2306541b7828ad3c48713b7ddcd33bdc4c83aec20ea2f4812ad03fedb8d33e6214f83ca38ffcbb55ca3859cd0cf07b65dd04174589117adf9d5c76448c6786447889122c612fb0ba366bfd64384a5162e27375fa7747622c6cf3b1c9c09bae41d179b1ac15d3cdd3254c2498e37f38e8b43b6620a7898afadb4e74414a7783ae2ffefd6aaac8cd082f33fa0abb3c8271690175664331e3053092c2b6abbf7e66adb0530ddde01a965e6abe809db7bd6d79229a09bd7df84c25da01c92e73a035e2667a75229c48e889842fbd0a1d7dbf7c579292b8557b8f400157e95b2864450dc73474ca6520544b623d98a0445e62a98d184853b6cf236e48ffe6ede26b4ca737f3f8c2f19701125867ec08135ca682b3cedc732362def3eefbf16d0327fedf680a5dc50bbb5590feeffc83a065c7c09fee680f2395508e418e59c28bcce45dcb357e95c2590a7ef9049d04d6bdbebce82c03d09be7d60c90ff409231a5b8df0091ede2ea2abe007dce72a5565fa7792a143ea45e0f14c3eed8ac989811cb44a0cb0fa483aa5f25831ccd3124d07a5558b126178f10f3600a554228513b55f48fdc6ca3d88c9a4203c3f729197919ecaff8376f9535fd87232cb896294f9fc4fdb1c094dc5b8c13fc9c0af0f6d5d0649aceb4beec719f7032a9d68ec16a1f386654f29e0adf7ade3d6d883067a74baa45dd07ca46c074be4a2d4d3cedd9cb43aa79ea8605e4a843d693cd9a062524820c3ae94cd3ba631d7d2c844b4cfd17570d07e02bb79c647880cb8f4a0614ff595bd22cff36fae33ba66ff6b9614ce43b5e2c2e2103b2a7c36dee450c0294e61645f1ff62b02acba1a876583591a53d9995c97318865eac82e9ab2d7daaee2edc69d2f6240b9cb98c8f3cc1c140d3ccfdb1894a3a9ae4db3704f4bef50c79ed660d72c4d76ca15c7b090c3a3ec8b6a1663e8ef6b80b33a790d75a8f2cab63863cfbab878fb45829ac4b30877f4b44ebb6fb1bd3deef6d4bb492d9e8dcd8f44dfda2afc59f9957524ddc5a9d26235be96e405f99fc668073799bfc29c611f3d097c9bef8404dfd98753bd059c4ccb2dc28284fa4d26f7388f29f063c5924d5d793e65af69eea2a654c3ca088ed576cea7a496de608c7fdc8adf94e22690d642584b9d121a80980bff1d66f2dbc7abf03c7272b4bd1f74df56756a806d0e76f293912b968b023f95efc0779c20497e818842577470c33cf1f1412cea0944a4fa2cd2a145d2a4dc588712f11729cb1233d6eabd234e0556425985afe3cf2518e4f70bbf31c038d5c335f500e0125cd3429ce768886381d9bf7fa0236a3449fd423c501be99daf36e54f58f09e63462c975afb417a015bd5f4a918f66f022aa79981cb82c29087351b1afe7b5051ad3712c3150e62f9d01f429d0b1050f348592d09d22cd5dc3409e3d11e7664dc114d8c37160b9d39f7d594813fd90cd23ac43c86cce7f22a0ecc46e9c77c1a1097fab3af5c9e0bbd893630d1db32066c3aeb8544e5a3b1e9f4905a3685a041e7921c29f7eb36041f276e3de9da457c90c0a4e9b1ec38db531d7887628745c5f26194ad2c2bc892a0e62a63be8e7162540b04696ee38d1ffa3deef3f110517e9813d259eb2617581819a50a37da390650ba8a86f576db6036fe772c8f8d2b15633f5d1905f11d452d62d67121d9a7d30cf26419c7100f2f51a3f0f8597048cda90b68b1b86116671fed5953d70fa552b04bcd54001afaaa291346a9eef0cb871f350a08a2e2ad3ead37fbe7af6c5ea3fbb4e2af874efb0d4f33d149f83b525500d0d106ae12249119307c0242bcfff7425822d2f61aae575154c5499f03b06da9bdfabf4707602c20b2eb9173a7f01dd7ea77e0b44303670982c11b53a5603e22cc74ca166846ef28697572ae88504db22754792584f45a2a559813081ab34c8641550dc1259ba7cc55de0d8ea0ae7ab83afc533113272ad893f0106a087e6bd0eb90c464eca576a7a217ef654ea365834f37076cec52bb40f7c2ec76ca2fdfd93511f3132b68d5279d42422d4562ad20cba8e76ddf4570fdeb4a0b1e63f2b87edf688afd4f51ae842b14864a528c57686385e5e763d175bf04d26ffd612a90f5d5ed0d49d6dbd4e472a192665afa263e1d9c2dfafb17858b59b5957992af881daf5231757ae0a3733d0e032415f2e6147113228b4c342045de3f73e08d00f893f7c05ab15b64603ef42b1e300b879fe6a8703d130048a0ef4c43a0f5aae256cfbd422f76818720e45572b16b6aae06c7c9a8a2be60d6bc205e8a0bccfea6660196c6ccb73571d9fce6aec0dbf9a211c12769ce9f1d4d2dcaccffc5049e92fc42abc59c6b952abf55ce944bd619f23f17700a194a95daeae67c69a289b48ac154619c185012cae1d913657e9fcc2ea89ededbd49813fddef2a842336a0a62385844b872a5c648b7ab23e2015579b053780d4c2fc01e621dfdb0f169723e26e319948f6355a3d52c26774488a5f43a1d574e80c78730f8b825210e3a93d5b904cd14d74f09255b74f5e5185d35713038bfecaff6c4cbc9c3e6b3638c64ed1af85cd0746586e41377fa167c73f22a605639878844d9a73dc5c244e02e359c3ae6cb62540b36a4b5e2150898258f2f86d881fb21d0e5c1c4e3552eb48159529396d53cc96ff48320c1406acc328fe9c1cddb62363481ed658ec32273b5f6149e80d7f111cad43e8f989c6f9609f194d18319b7932ce1854265e28c93ad307ee5f638c795b49f625b6783187862743df526a3da373e9e814846ea92343d3d5979772a38dec79be44317f0c75efadac03409fc473af07b7c47adb8170959bb5d20d41362e96ff110bbecd6edb3a7fef4bab4470423113aa367d0e8a2425c87bd98550ac0e7db65c9c7d32db12cff2bcfa81cda4e41d0b308f9578b4b1e5d5794d5ce80ad0ef7eed3cf3039f85c28d6fc247f3e04e4da416c126c6a7453431952565dbd973ceb410451246d221b4c4c59bb45dc1e8f01d15456e4bc59b26feee41aa8ef0356eab5d03e4a9cced9df106708a16de62ca4bf2d9ca503747ed9f4b6b664916a7bf851b7392e1e71ded53d2576c775e15be1a4502a80dd2f5c34808e17f642d8a987ec273b5d0868a114466b331e563ac674abec48fd6783c8624a06a92dc359b3efbc0e9c28aa832f4a61417ff2859ddbda7ccc5617d1a9d17ce2843ea48c7b5bddf9e2d79aeae9d844002cae5545cceded9192bb31c3b49b7723b30da30318015acd6f16cabae11f2f2d197f0b0097fe222019bd1e82d6fb82b1b7a240b0be445cef0404adc7c55a1ff0bf296c88b6be1ce1b0083dd453c5a91cf01c0abe097a59f9f5771310187ee251f978945d21311f01ed29eb1ded81deda69d472642b543e0e8bf92781a96f9e576e3172770483f69c15fea7ec986b796d1a5c1f0a08e96b1090dd9119f840d9c016ac32b8cf483f3986934121380be1af639c7efc0ce4f4429aa99eabaf015c4f81a232aa9d030faa9c401c118532146e91ea4ccb77bbe21995fcdb4f16409a41715920a010d8adbca438d7c94852563dc36af172bd19e552fe44a45222fc43fe10e7ba6d4d857156399cd143de7caaeb001e14fcb3d03be87ea1717c748bce8c47ad170f8170c159e37f533dc7f0415eeb55dd07c7c28b7358f4cf62b257b6e3d972ee8d75e04c673e0cd267ac89badebc34fa445f6cac623c9ee9447556c5149db450291ba01c3dc62ebc7661da869d3c7f23b853f29af418a41890aab8c1093ba44d46019deb75043ee8b76f9fc9fbd149ad4b77ccbade7d360c94eba7766b1650414c48088892abb236903bac42fa1c32d90d972ef54da2a2d87b8e0f2ddbf5b006e6ff79660d4122fdb8332e5ec80a90bcd95db27fcf79376ed0baaea37dc99c00194e35cd48c3f93a78000fbbead43982ed3dacbea40785414ac60d9281353479cee2cae86b73a3769ebd29736f9dff2ca6be49d2908d7517f4f11d6145e23cab64929ca877bb055d9a547e4f13dfb1cc300487538fe065df2eb6cad120563d809978f54eb6337ddab9e509fd1ffb27217ccc59f8bdc582037569b46a1d88ca9641b721f5177a10abb2038b60945f5ddc42f0433c0062cf5410a8ca84a91930718f1ba1a0bb879da6130740911c5a7431c19985ea8a6f6a64ee53399cb40a1252e2dee4a36178fa2e25826e8787db25c33b3c11a1574a0bc8b5f58cb6f7bc7b31878ac035bce91319ed0f5bbef3e7b249ca8c7ecae0ed40e38f8881f73125aa4058883ed2e3241d9706bc3c185c9fe9f0c9a64318a0e848ad08864b747a38a166cfa55dbaf417deaf2781a8223d6b3856a69a48e53f3bea85f02eaab5a61d8185e7856ff545e2e666b839bac6ca08a34a9ed391eb859330148e35f0a9221f8000f1ba42a55a545688868027c4a34cf2d05dc12f3e512500e853e853fc713465766e55741d58b28a9b994fd03cb213d1475e84189329170f0160ed9f5cf75260be695c74fa812375c6f0ad329adc909e5f76cb3f12a98b4128d5b17677cbc9322360667ad6f2268f49e6c70f905adae18ef1a10b8ebcc6c5df15fbcaee97e5bf039a683af766b7ee350eeb564f7df1159c0cfc7b863ed7844ab0f55c147028bbc125822720807d0da21387520376d1f581235ae9887f952ee49b5d746989ce8d9378aa6bee5faf12d9ac3b2f79e3a684361dba69b657884b8cab25daec678f004f793a845fbe5bdec336aa74d05948fbafca14c7ec43a6569883b0ad31a801c38d78173453b632b65ccb08ac379aa6f0dcf7a11035415c58b39557dff5a4246860f5ce80cc862218a43986e3b9f27ceebcdd62f7fb645f5c77b7450995789545edb0a5c11119e87691691478b9d939ac95c43e2245d4c448e806b01c0918ed18805edd519d2a927adb92fbfd2c9dfc5d564d82f5b092b5203547ed28d731726e47fe054cecfa6b4137024e8ca9b943d46aac7b792bfdb857831de16281dc4b15ccf73a6774799cada60cd4e964b3ec56b057df054ac12f14c886dc99ffbe46426607d8b754058f944304ffa6dd7a19e96ff9fb9630948e0526ab72cad0633b507a48ed58f7d34cfb0dc68c6fd9523246b3b63d4db3ee7a6563787fc9f7cbd88966881671abf8c037f15d362a7ae43e3174ccd05716e3e595a36b45b42d16059f1ffe3f85acb416942c0d82de9db439b96e08aacf890b61a936c285397eef3e83ad4a47f00059c0e0e9675e6dd257f5db2cd06bdb0506cb696f9a698c85a95cd95aee8c354456a8fcc055818e2b4da0b44376810cd607b3809f03d7af96ea963adaf4a8abaae66ec2b993cff102c57380bb41030f6192163a8076dbd2e7b037553d1f3928804847b1f359563a0e752c3b9b80dad8102cf77d3f7100a6e881e52db01c42d9694c3cd6afc86a77fda767232b2e66a393b2011ac6af6f9d00d9be3d31e1065b61a118319daa5422a78bf06ba773bb2a5f9343b948483ad66b781222d9bcb211e13d4c851d5bbf7328025b38ca63c4907945cedf110a838aba27cad851f73ddc5c5ee6538ebecb22454cde54cefd0d808263364a9d3fab55df73b11e0ac7f426f22d3050163fecf163512def63d06ede8f842fc5a41bd7b65915eb55bf776e7460d8675ce525a3bd8ce12fb42134dbd97321fea31444376355c9163a30d28d09c43be25fc49d7c9286e4b13c4dde2ec4f425d2f8a50c5f9229d2d6714e05d41eac3f8c2df13b25af2d912472a5ad9b600ff739bec4386b96fbf28767a19cd7696cf194bb1822b0bba1d55ecb053024fbfaf595ffb2b62114e56608cb119c3d6b26f3800998e20c7697e33087f223d6cef191cdc11a61009321aeac4c757fccb57ad6880f05302b00c7c12309e882126ee82c2d65f236d6aba8297a9fa113ddeecfaec3bf578f964449f208f86a55e7c7fc680104ccacc8b51731eac235142f937d68d117766c6b97a0890c2f0c5906269d463b70a27fcf042d702d6a84816c0b04c615e4641b37b352a5bdef59f27ceb05fe42f15f85ee9d3a3cb109fc07f4ea42d8577921315a1d57995acda377a83a95277869401d204d0154e45231dfa418ba19565adeb6f947f85ba84ead98fd9f72ddf24173d8bb6c675d60eb4c0bd019e2c2e04904ec56b0570662f7686ee4cd789bb9bf9a7cdc6cd155be5bc6dcbc548914afaa55553e6c8f9f7eac4ae6a9b43d0f42e810250d9812b6726d59c7a2adcf70a051bd6b970a701e7385972939f42c34c08676b778787a96fceb316a48b9e94efb3cece703aef605279442697282a777b97a5aa22ca2cfbd694d2e7e786878bd5b67cccff6e6763c52b8b0a4e5485fdee23ad79007c7201371e010c8a24d80b18e7d35d4d7d9335f4990dc027a096d5cf811f8fa3e21fe8146307e98fe97bcca6bcc11a0a67d7e65288ef112033b9f13248cdf8634ea67d6051e92933aacad2e4bac99ba8ae764a3c63cfc1069d1922f47f3e48f46c7d818682b51c92e31caf6977926dd3df0e6e9dc65d9858133186907b94939e288f46cee43adb7ff69d369c5828e043d10f3f132d5098c687633080f027dd73f34b4f070299a2ed3579eb2f7068d66a7485f3e20c2e9bb963d760467cfba67fd1cc253e97c8c0cb054fd06b2ed7d612388a50e59b2268f7094783f19103c8ed86d86ada4fd4d6b63eee59240d19cc566d83b3d499f86f0da374362dd17b24eeef5f8ff2536f431a0ba9c5fe7955508bf5824b9829e38687448f2e83c726931838c4d038ff25d171486f5ba4fbb2499edb41fa89c2113701003cfd6703d040acdcf83c87324d33778e217d37da1d2b072c39067b23f9e980d59f1b73757168124746a5c3b15eb75b41c0ba004ffa77b12ba35b1e9b5d141348c39d499d0621b12e1aa022bd569cb2bb30e15e82b458f336e2f3285f10e0a7859f824af87fe5d65159e0ec969ecc2161bb0e33dc9125fbac004c2705a85be85bdba10b86ce22b7b06cf08757792e8592bf397398fc9627094221440b4ecdab198583376f3393bd5ddf19c9f6ec3ac94aa6c9a44aa6509508f9c1a242158084e475c6819ce401816f785a6bcb3e553fb0917355e92c2cabf25b2bcd4d4f1443a3fa3330a3a8f46534b8dd466ec18fc4bafe757f0980c35cd260cf7cc46518f4813bf5614c82709a99ed68cd32a17aa97b99a1ba9f468fa44ffc29202d4baf93b9240d6c34d7d2349feedbcb34e6f28d6d6cff003d28b319ae4c153bb5b82e286feb73638187bd02e9b6b21a3ef2281ae8d589c921d426330cf693eb80eb45e3dd83df3f7e5f92268351885c3aff655d09df11c9e4aa4e011bb1ddcbc715673f4308b76e281aed3335c8447f82667fcd64089ca564d199b96b826a8425c15d033b37a437595111808f946326a4a7547e1afc1f60bf5d6881d5682048fd3fda3cc034b8962e8e3ab397e167e4e7a67fb5f6405170cb7b8a93a151963957a0c7e5a10f5c831de7608f2dc4742e10a0bff962ba5509b2c987e644e866f968538ada9b9dc173f7d06c13d7fd976a9556c0b92399da6389a79920bd7a6449c10bc99c4d8621f8d82237e635025391224151ae2808e73c2955a60e60c501d0e9fa96b55ce0677e57fdbf149aecd83033c72896390072961db8da0c5f683ba2308d0815acd5b23311c530e15a5ec406435cbabf12617615ddde9db78f91be2c139a96e354f7e1276393d6b0e1f0f5c98b2ea4c5f13e925201dd683080379e5c1e52c244a7b61937b3acda4e40ceb5c1b879fa0fa3f556f2b8cd0b978169299c61fa2bd70bd8d4699dcbe70818945a8e36b234e554d92705390e9639b926e87bb1fcf22a60833cf2fd5e97c245a383e05c0a1b13f75135b3a742f652cd2e7da3e73e8da53493ee51fb001e7f12618f8cd52e05e4f653b88338bb3f50649e351b6fc9cefdcbcb40903acea8e572bfcae0b0571ce2e3d5363e578d13e6acb598d176f392a60638490f32c5e128fa2e7e444511e8281829cc11a39d59d789abd84b6002e84ce4ef485957b48b3210fa04f4552cad85f28be845f3812d72e86190af94b9c370c2a30d3b6eabcc3fdebd1b5f4e1258f054466cdfa2ba30aaf845046cc19db80c200ae27f90532be1526717f3a4152a78985c93e735f46edad5be9899b890368c7443bd8bf0ac52f33c0388d906d1ae2778dc9415f48fe5b4d0eb8dfbdf96400fc43247b8fc8603302649fd9938f5d8be1fd266a32d4bc33f07cadf49933d016ff6463617e1968bb04dcad750ff91fff3ddaa7eac57728aa4fda71b6562d5285138a90e7bfcd1c190684f8a4832c4bb77737b81cf021e01abe5a7371a0ebbe5617235503f804212feed8fcb82fc2eaee5dccff4c0423fd78e874c30ce500e1fe9c6722f768561c3c903cf1193342660764081c81cdf0a7cfa9e519becba3ab8fd7cb705ee5930d61f732151414f9ed04a548f1b6d7fdaa22ff84f94f787afd2bfcfbef75830dabadcd44d3db76f40e1e5f25bb08fb979499873f8e12d53976af844bf4b9d041a2784a23b4824b329a9cc7098605eb815c475fd8f7c525ec8879decce1c48dbb8250e58b9e3057bb355c954fd92034065744a2f2b9fc1970d4f61eec37d842e0ac703585960b13237e87d94764e9db6bc45918fde2a365ee5308c52f01576712f31ba9a8b0dcc27cae382</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Encrypted</summary>
    
    
    
    <category term="阶段性总结" scheme="https://xorex.space/categories/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="幸福" scheme="https://xorex.space/tags/%E5%B9%B8%E7%A6%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring 框架学习笔记</title>
    <link href="https://xorex.space/2022/01/01/d68ebc25d776/"/>
    <id>https://xorex.space/2022/01/01/d68ebc25d776/</id>
    <published>2022-01-01T09:53:05.000Z</published>
    <updated>2021-05-06T07:46:52.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-Spring-框架"><a href="#关于-Spring-框架" class="headerlink" title="关于 Spring 框架"></a>关于 Spring 框架</h2><blockquote><p>暂时放弃更新，完全学完 Spring 之后再来总结。</p></blockquote><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="set-方法属性注入"><a href="#set-方法属性注入" class="headerlink" title="set 方法属性注入"></a>set 方法属性注入</h3><p>具体方法就是使用 IOC 获取到对象之后，调用对象的 setXXX() 方法设置属性。</p><h3 id="lt-property-gt-注入"><a href="#lt-property-gt-注入" class="headerlink" title="&lt;property&gt; 注入"></a>&lt;property&gt; 注入</h3><p>在 Spring 的 Bean XML 文件的 <code>&lt;bean&gt;&lt;/bean&gt;</code> 标签里面添加属性标签，<code>&lt;property&gt;</code> 标签内部有属性 name 和 value，用于设置属性值。这种方法本质上使用的是 <strong>setXXX()</strong> 方法完成的。</p><h3 id="lt-constructor-arg-gt-注入"><a href="#lt-constructor-arg-gt-注入" class="headerlink" title="&lt;constructor-arg&gt; 注入"></a>&lt;constructor-arg&gt; 注入</h3><p>在 Spring 的 Bean XML 文件的 <code>&lt;bean&gt;&lt;/bean&gt;</code> 标签里面添加属性标签，<code>&lt;constructor-arg&gt;</code> 标签内部有属性 name 和 value，用于设置属性值。这种方法本质上使用的 <strong>构造方法</strong> 完成的，使用的时候一定要检查以下所对应的构造方法是否正确。</p><h3 id="p-名称空间注入"><a href="#p-名称空间注入" class="headerlink" title="p 名称空间注入"></a>p 名称空间注入</h3><p>本质上使用 <strong>getXXX()</strong> 方法完成的，首先需要在 xml 头添加一条固定的属性：<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code> 然后就可以在 <code>&lt;bean&gt;</code> 里面通过给属性 <code>p:XXX</code> 来 set 对象的属性值了（这里 XXX 为对象属性名称）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于-Spring-框架&quot;&gt;&lt;a href=&quot;#关于-Spring-框架&quot; class=&quot;headerlink&quot; title=&quot;关于 Spring 框架&quot;&gt;&lt;/a&gt;关于 Spring 框架&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;暂时放弃更新，完全学完 Sprin</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Spring" scheme="https://xorex.space/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Git学习笔记</title>
    <link href="https://xorex.space/2021/07/20/6a60c37480ef/"/>
    <id>https://xorex.space/2021/07/20/6a60c37480ef/</id>
    <published>2021-07-20T04:42:34.000Z</published>
    <updated>2021-07-22T14:34:48.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git-概念"><a href="#Git-概念" class="headerlink" title="Git 概念"></a>Git 概念</h2><h3 id="分布式与集中式"><a href="#分布式与集中式" class="headerlink" title="分布式与集中式"></a>分布式与集中式</h3><p>其实这两个在版本控制系统里面区别就是历史版本存放位置。</p><p>集中式版本控制系统单的历史版本是存放在一个固定的服务器上面的，每次写代码只是拿到其中的一个版本，写完之后提交。这样一旦服务器挂掉，就无法工作了。</p><p>而分布式版本控制系统的历史版本是所有人都在本地有一份的，服务器的作用是用来方便大家同步本地的版本（合并别人的修改），这样即使服务器挂掉，可以一对一的同步代码，甚至不同步也可以，手里有整个历史版本，可以回退，不影响工作。</p><p>所以这就是 Git 分布式版本控制系统的强大之处！</p><h3 id="Git-历史"><a href="#Git-历史" class="headerlink" title="Git 历史"></a>Git 历史</h3><p>Git 的来源是 Linus 不满意其他人写的版本控制系统，自己花了两个星期写的。牛的牛的！</p><h3 id="Git-工作原理"><a href="#Git-工作原理" class="headerlink" title="Git 工作原理"></a>Git 工作原理</h3><p>Git 将文件分为三个区域：</p><p>工作区的文件 -&gt; git add -&gt; 暂存区的文件 -&gt; git commit -&gt; 本地库的文件 -&gt; git push —&gt; 远程库</p><p>工作区其实就是我们写代码的地方，写好一个代码文件之后添加到暂存区，等到整个版本的很多代码文件都写好并加入暂存区之后，就可以将暂存区里面的所有内容作为一个版本更新提交到本地库里面了。本地有了一个版本的记录，就可以推送到远程库里面，让所有人都看到这次版本更新了。不过具体的实际原理还是看后面的分析吧。</p><h2 id="Git-基础命令"><a href="#Git-基础命令" class="headerlink" title="Git 基础命令"></a>Git 基础命令</h2><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>用来查看当前工作状态，告诉你当前分支 <code>On branch master</code> ，哪些暂存区文件被修改了还没有提交 <code>Changes not staged for commit</code>，哪些文件没有被记录到暂存区 <code>Untracked files</code>。</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p><code>git add FILENAME</code> 将 FILENAME 文件加入暂存区中，实测加入到暂存区之后的文件，修改之后可以不经过 add 直接 commit 该文件。</p><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p><code>git commit -m &quot;INFO&quot;</code> 将暂存区的所有文件的都提交到本地库中并附上说明 INFO。</p><p><code>git commit -m &quot;INFO&quot; FILENAME</code> 将工作区的 FILENAME 文件提交到本地库并附上说明 INFO。</p><p>所以如果指定文件，是从工作区找的，如果不指定文件，则只会 <strong>将修改后使用 add 命令提交到暂存区的文件们</strong> 提交到本地库！</p><p>当然如果不想指定文件，也想将所有被追踪的工作区文件提交到本地库，而不经过暂存区，就直接用命令： <code>git commit -m &quot;INFO&quot; -a</code></p><h3 id="git-commit-–amend"><a href="#git-commit-–amend" class="headerlink" title="git commit –amend"></a>git commit –amend</h3><p>amend <code>[ə&#39;mɛnd]</code> 修正改善，故名思意，这个命令是用来修复上一次提交的。</p><p>说是修复提交，其实就是合并提交，当你发现上一次提交不足以作为一个版本记录之后，就可以先将代码修改到一个版本记录级别，然后使用命令 <code>git commit --amend -m &quot;AMEND_INFO&quot;</code> 这样回将这次新修改的和上次提交的修改合并为一个新的修改并提交，提交信息为新设置的 AMEND_INFO。</p><h3 id="git-log-relog"><a href="#git-log-relog" class="headerlink" title="git log/relog"></a>git log/relog</h3><p>relog 是用来查看简单的版本记录（只包括版本号，版本名，当前版本和当前指向分支）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">c939839 (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: The second commit!</span><br><span class="line">69663c7 HEAD@&#123;1&#125;: commit (initial): Just test commit!</span><br></pre></td></tr></table></figure><p>log 会现实更加详细的内容，包括日期和提交者签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit c939839a1549e2dfd718c3d6bf9ad4b7cc61214b (HEAD -&gt; master)</span><br><span class="line">Author: Xorex &lt;cloudloverain@Foxmail.com&gt;</span><br><span class="line">Date:   Tue Jul 20 13:37:31 2021 +0800</span><br><span class="line"></span><br><span class="line">    The second commit!</span><br><span class="line"></span><br><span class="line">commit 69663c76cc270f8a7e0914730d6d184a66632012</span><br><span class="line">Author: Xorex &lt;cloudloverain@Foxmail.com&gt;</span><br><span class="line">Date:   Tue Jul 20 13:19:49 2021 +0800</span><br><span class="line"></span><br><span class="line">    Just test commit!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>git reset 主要用于当前工作分支的版本回退，格式为：<code>git reset --MODE VERSION_ID</code>。</p><p>用 MODE 级别的模式，回退到 VERSION_ID 的版本（将本分支指针指向对应的版本号）。下面是 MODE 的对应的几种模式：</p><p><img src="https://segmentfault.com/a/1190000012071372" alt="我是看着这篇文章学会的！！！"></p><ol><li>–soft 等同于将状态恢复到执行 <code>commit</code> 之前（也就是撤销 commit，工作区代码修改完成，全部放到了暂存区，就差 commit 的状态。）</li><li>–mixed 等同于将状态恢复到写好了代码，但是没有 add 和 commit 的状态。（工作区内容不变，暂存区变为指定的版本）</li><li>–keep 比较特殊，工作区的内容根据版本重置（恢复到对应版本状态），但是暂存区还是原来的，和 mixed 相反。</li><li>–hard 将所有状态都同步到当时版本的状态，工作区，暂存区，都是目标版本执行完 commit 之前的状态。</li></ol><h2 id="Git-分支系统"><a href="#Git-分支系统" class="headerlink" title="Git 分支系统"></a>Git 分支系统</h2><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p><code>git branch -v</code> 查看所有的分支。</p><p><code>git branch BRANCH_NAME</code> 创建一个新的分支，BRANCH_NAME 。</p><p><code>git checkout BRANCH_NAME</code> 查看另外一个分支（将指针移动到 BRANCH_NAME 分支上面）</p><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p><code>git merge BRANCH_NAME</code> 会将分支 BRANCH_NAME 合并到当前的分支上面。</p><p>当两个分支的同一个文件的相同行都有修改的时候（不同行被两个分支分别修改没关系，两个修改都会被保留），自动合并就会出问题了，需要我们手动处理冲突。</p><p>出现合并冲突之后，打开冲突的文件，会自动标注冲突的地方，也就是 … 的地方就是冲突的文本。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt; HEAD            //开始分隔符</span><br><span class="line">...</span><br><span class="line">======                 //中间分隔符</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt; MERGED_BRANCE   //结束分隔符</span><br></pre></td></tr></table></figure><p>只需要将分隔符删掉，两个冲突文本选择要保留的，就可以保存了。保存完之后只能添加到暂存区，然后统一提交。（提交 + 文件名的方法不可以，会报错找不到哪个文件）</p><h3 id="Git-游离-Head"><a href="#Git-游离-Head" class="headerlink" title="Git 游离 Head"></a>Git 游离 Head</h3><p>checkout 就是很简单的查看的意思，就是为了查看某个版本的状态。当然我们一般都是查看某个分支所处的状态，然后用 reset 不断切换分支所属的版本。那能不能不切换分支所属版本，也能查看某个版本的状态呢，答案是可以的，让 HEAD 指针不指向分支，而是指向版本（某次提交的版本号）</p><p>比如 <code>git checkout 7ea3922</code> 就直接到了 7ea3922 提交过后的版本状态了，但是这个时候 HEAD 不在任何一个分支上面，是游离的，也就是 Detached HEAD。</p><p>我们到了游离分支也可以发展自己，不断的 commit，或者当作一个分支使用，不过由于都是版本名，不太好进行版本控制，还是直接在游离分支上建立一个真正的 Branch 并取一个名字，方便对这个分支进行版本控制。</p><h2 id="文件忽略"><a href="#文件忽略" class="headerlink" title="文件忽略"></a>文件忽略</h2><p>对于一些不需要版本控制的文件，比如数据库配置文件，IDEA 配置文件，.class 编译的文件，则可以都配置成 <code>git.ignore</code>，然后声明到 .gitconfig 文件里面，让 Git 放弃对这些文件的版本控制。</p><p>而我们设置的 git.ignore 和 .gitconfig 都是在 C 盘的 Users/Xorex 目录下面的，做的是一个全局的配置。</p><p><code>.ignore</code> 使用 # 做注释，支持正则表达式，一行为一句表达式。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for java</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target/</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure><p>然后将这个文件路径在 .gitconfig 中添加配置：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">    excludesfile = C:/Users/Xorex/git.ignore</span><br></pre></td></tr></table></figure><p>一定要多次比对配置信息啊，千万别写错，写错了就执行不了！！！</p><h2 id="代码托管平台"><a href="#代码托管平台" class="headerlink" title="代码托管平台"></a>代码托管平台</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>在 Github 上面创建完一个仓库之后，有两种连接方式：</p><ol><li>HTTP 连接: <code>https://github.com/Administrator-Xorex/Git.git</code></li><li>SSH 连接：<code>git@github.com:Administrator-Xorex/Git.git</code></li></ol><p>因为连接太长，所以可以建立一个别名：<code>git remote add ALIAS https://xxx.xxx</code> ALIAS 就是我们给后面连接设置的别名。</p><p>推送本地库某个分支到仓库里面：<code>git push ALIAS BRANCH_NAME</code> 需要指定推送的分支名。</p><p>拉取仓库代码：<code>git pull ALIAS BRANCH_NAMEs</code> 需要指定拉去的分支名。</p><p>克隆仓库代码：<code>git clone https://xxx.xxx/xx.git</code> 然后就会在当前目录下面将仓库所有代码用仓库名作为文件夹保存下来，克隆之后会创建项目地址的别名 origin。</p><p>对于多人协作的时候，自己编写完代码需要先将远程库里面的代码 pull 下来，解决完冲突之后，才可以将自己的代码 push 上去。</p><hr><p>HTTPS 连接每次都需要输入 Github 的密码，解决方案一个是使用 Windows 自带的 Credential Manager 添加验证，另外一个是在 Git 里面保存一定时常的密码，只需要输入命令：<code>git config --global credential.helper store</code> 即可，下次输入完密码就被保存了。</p><p>或者配置好 SSH 的公钥到 Github 中，走 SSH 连接。</p><h3 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h3><p>第一种团队协作方式就是将另外一个人加入到自己的团队中开发，这就需要 Github 里面的团队邀请机制了，把别人邀请到自己的团队里面，然后给予他 pull 和 push 的权限，一起开发。</p><p>这个只需要在 Manage access 里面添加用户就可以了。</p><hr><p>另外一种就是让另外一个团队复制一份仓库，然后他们开发完之后，请求让仓库主人将开发完的复制仓库拉去到自己的主仓库中。解决完冲突之后，另外团队的开发内容就合并到主仓库里面了。</p><p>复制使用 fork 来将仓库拉过来一份，开发完点击 pull request 发起请求。仓库主人审核完代码自会后，统一请求，向被 forked 出来的仓库发起 pull，从而合并代码。</p><p><img src="https://xorex.space/image/311.jpg" alt="311.jpg"></p><p>比如上面的图片就是对项目 UpStream 进行的一个多团队开发过程。</p><p>先 fork 出来一个 origin 的仓库，然后在 clone 到本地，经过开发之后，向项目 UpStream 发起 Pull Request 请求，项目管理员同意之后，会 pull origin 仓库，完成代码合并。</p><h2 id="和-IDEA-整合"><a href="#和-IDEA-整合" class="headerlink" title="和 IDEA 整合"></a>和 IDEA 整合</h2><h3 id="分支合并-1"><a href="#分支合并-1" class="headerlink" title="分支合并"></a>分支合并</h3><p>原理和命令都是相同的，都是选择分支，然后让其合并到当前的分支上面。</p><h2 id="Git-实现原理"><a href="#Git-实现原理" class="headerlink" title="Git 实现原理"></a>Git 实现原理</h2><p>Git 的实现原理就是通过 HEAD 指针和分支指针所指向内容的变化，来描述当前分支的变化和当前分支所在历史版本的变化。然后每一次 commit 都记录下来此次提交每一行的变化记录，然后根据这个变化记录来计算不同版本的文本内容。</p><p>先看看 Git 的目录：</p><p><img src="https://xorex.space/image/307.jpg" alt="307.jpg"></p><h3 id="hooks-目录"><a href="#hooks-目录" class="headerlink" title="hooks 目录"></a>hooks 目录</h3><p>这个文件夹里面保存了下面这些东西：</p><p><img src="https://xorex.space/image/308.jpg" alt="308.jpg"></p><p>这些都是一些脚本，在执行 git 一些命令的前后执行，所以被称为钩子，来钩在命令的前后，做一些检查之类的工作。</p><h3 id="info-目录"><a href="#info-目录" class="headerlink" title="info 目录"></a>info 目录</h3><p>里面只有 exclude 一个文件，用来配置不纳入 git 管理文件信息。</p><h3 id="logs-目录"><a href="#logs-目录" class="headerlink" title="logs 目录"></a>logs 目录</h3><p>记录提交的提交记录，下属有一个 HEAD 文件和 refs 文件夹，HEAD 文件记录所有的提交记录，而 refs 文件夹分别保存着不同分支的提交记录文件。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| -- refs</span><br><span class="line">|   -- heads</span><br><span class="line">|       -- master //主分支提交记录文件</span><br><span class="line">|       -- feature //featrure 分支提交记录文件</span><br><span class="line">| -- HEAD //所有提交记录文件</span><br></pre></td></tr></table></figure><p>在我们调用 <code>git reflog</code> 和 <code>git log</code> 命令来获取提交记录的时候，就是从这些文件里面读取的。</p><h3 id="objects-目录"><a href="#objects-目录" class="headerlink" title="objects 目录"></a>objects 目录</h3><p>执行完 git add 之后，文件的更改信息（每一行的变化）就会被存储到 objects 目录了，会根据版本名的前两位做一个类似于 HashTable 的分组优化。</p><p><img src="https://xorex.space/image/309.jpg" alt="309.jpg"></p><p>然后里面的文件名为历史版本名（其实就是内容计算 SHA1 作为文件名），文件内容就是此版本文件的每一行变化记录，根据记录来计算不同版本下文件的内容，</p><p>当我们执行了 git gc 或者将代码 push 到远程仓库之后，git 就会将这些零散的文件更改信息打包，放入 pack 文件夹里面，并在 info 文件夹里面的文件留下记录。</p><h3 id="refs-目录"><a href="#refs-目录" class="headerlink" title="refs 目录"></a>refs 目录</h3><p>里面有存储着分支和标签的引用，用来记录当前 HEAD 指针指向的分支和标签内容。实际上根据 HEAD 指针找到当前分支以及当前分支所处的记录节点（历史版本节点）就是在这个目录里面的文件里保存的。</p><h3 id="config-文件"><a href="#config-文件" class="headerlink" title="config 文件"></a>config 文件</h3><p>主要是 Git 的一些配置保存的地方：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">    repositoryformatversion = 0</span><br><span class="line">    filemode = false</span><br><span class="line">    bare = false</span><br><span class="line">    logallrefupdates = true</span><br><span class="line">    symlinks = false</span><br><span class="line">    ignorecase = true</span><br><span class="line">[user]</span><br><span class="line">    username = Tempest</span><br><span class="line">    email = Xorex@Tempest.com</span><br></pre></td></tr></table></figure><h3 id="HEAD-文件"><a href="#HEAD-文件" class="headerlink" title="HEAD 文件"></a>HEAD 文件</h3><p>存储着当前位置的指针，表示当前所在的分支名称，内容为一个 ref 的地址，从 refs 目录里面找分支引用。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><p>目录文件的结果是当前分支 master 的记录节点名（其实就是根据内容计算 SHA1 作为文件名）：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">96e8d208240398683deb39dd4de2aeb576136ca6</span><br></pre></td></tr></table></figure><h3 id="index-文件"><a href="#index-文件" class="headerlink" title="index 文件"></a>index 文件</h3><p>index 在 Git 里面是暂存区记录，并不是真正的暂存区。当我们使用 add 之后，会直接将更改记录添加到 objects 文件夹里面，然后在 index 文件里面留下来记录。commit 的时候是从 index 里面找到缓存区内容的索引信息。</p><h2 id="add-和-commmit-命令分别做了什么"><a href="#add-和-commmit-命令分别做了什么" class="headerlink" title="add 和 commmit 命令分别做了什么"></a>add 和 commmit 命令分别做了什么</h2><p>对于 objects 文件夹里面的东西，虽然名字都是 SHA1 生成的，但是还是有区别的，分为四类：</p><ol><li>Commit 包含提交人、日期、消息还有目录树，作为一个版本的快照。</li><li>Tree 引用其他的 Tree 或者 Blob</li><li>Blob 存储一个文件的修改数据</li><li>Tag 存储某个提交的引用。</li></ol><p>关系如下：</p><p><img src="https://xorex.space/image/310.jpg" alt="310.jpg"></p><p>当我们执行了 add 命令之后，就会在 objects 生成 Blob 文件，文件的数量取决于 add 加入暂存区并修改内容的文件的数量。使用 commit 提交之后，会生成一个快照 Tree 文件，来记录本次提交所有文件修改记录的索引（SHA1 文件名）。生成完快照之后，会生成一个提交记录，里面包括快照的索引（SHA1 文件名），上一次提交记录的索引（SHA1 文件名），本次提交的作者签名（name 和 email），以及提交描述。</p><p>观察上面的图片，有一点点细节，那就是 Blob 文件并不会存储文件名，文件名是交给 Tree 文件保存的，所以一旦移动文件或者改名字，是认不出来的，只会被当作一个新的文件。其次是这个文件需要手动删除，也就是使用命令 <code>git rm test.txt</code> 将其从暂存区删除，不然从另外一个版本跳过来的时候，会根据快照重新生成这个文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Git-概念&quot;&gt;&lt;a href=&quot;#Git-概念&quot; class=&quot;headerlink&quot; title=&quot;Git 概念&quot;&gt;&lt;/a&gt;Git 概念&lt;/h2&gt;&lt;h3 id=&quot;分布式与集中式&quot;&gt;&lt;a href=&quot;#分布式与集中式&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Git" scheme="https://xorex.space/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-04-动态SQL和缓存系统</title>
    <link href="https://xorex.space/2021/07/19/6df2c6bea164/"/>
    <id>https://xorex.space/2021/07/19/6df2c6bea164/</id>
    <published>2021-07-19T07:15:47.000Z</published>
    <updated>2021-07-19T16:12:33.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="if-标签"><a href="#if-标签" class="headerlink" title="if 标签"></a>if 标签</h2><p><code>&lt;if test=&quot;Expression&quot;&gt;&lt;/if&gt;</code></p><p>其中 Expression 为加强版本的 if 表达式，就是 Java 里面的 if 表达式（指可以调用其他方法），并且可以使用 and or 代替 &amp;&amp; || 符号。</p><h2 id="choose、when、otherwise-标签"><a href="#choose、when、otherwise-标签" class="headerlink" title="choose、when、otherwise 标签"></a>choose、when、otherwise 标签</h2><p>故名思意就是很常规的标签罢了。</p><h2 id="trim、where、set-标签"><a href="#trim、where、set-标签" class="headerlink" title="trim、where、set 标签"></a>trim、where、set 标签</h2><p>这三个标签主要是为了拓展 if 标签存在的。</p><p>主要是比如 and , 这些符号在拼接的时候不是很可控，所以多了这些标签。</p><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>where 标签有两个作用：</p><ol><li>在内部有 if 判断成立的时候添加 where 符号</li><li>去掉句子开头的 and or 符号</li></ol><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 标签也有两个作用：</p><ol><li>在内部有 if 判断成立的时候添加 set 符号</li><li>去掉句子开头的 and or 符号</li></ol><h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h3><p>trim 其实就是自定义版本的前两者，拥有属性 prefix 和 suffix 来设置内部 if 成立之后添加的关键词，suffixOverrides preffixOverrides 用来去除 if 里面可能会多出来的前后缀 <code>and</code> 或者 <code>,</code> 这些。</p><p>代替 where 的 trim：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代替 set 的 trim：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>forEach 标签主要用来对 Collection 和 Map 进行遍历：</p><ol><li>collection 用来指明遍历的集合或者 Map</li><li>item 单个元素的变量名</li><li>open 遍历内容之前的东西，如 (</li><li>close 遍历内容之后的东西，如 )</li><li>separator 遍历内容之间的分隔符</li><li>index 遍历内容的索引（Map 中是键）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;users&quot;</span> <span class="attr">item</span>=<span class="string">&quot;user&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">index</span>=<span class="string">&quot;i&quot;</span>&gt;</span></span><br><span class="line">    #&#123;user&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><p>大概就这样啦！</p><h2 id="sql-include-标签"><a href="#sql-include-标签" class="headerlink" title="sql include 标签"></a>sql include 标签</h2><p>这两个标签是放在一起使用的，sql 标签用来抽取 SQL 语句， inlcude 标签用来引用被抽取的 SQL 语句。</p><h2 id="OGNL-表达式"><a href="#OGNL-表达式" class="headerlink" title="OGNL 表达式"></a>OGNL 表达式</h2><p>OGNL Object Graph Navigation Language 对象导航图语言，也就是 test 判断里面使用的语言。</p><p>内容有亿点点复杂，先不研究了！</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>在 MyBatis 里面缓存其实就是一个 Map，一个用 SQL 语句作为 Key，查询结果作为 Value 的一个 Map，缓存能减少数据库的压力，大大加快系统的运行速度。</p><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>MyBatis 的一级缓存就是 SqlSession 级别的缓存，是线程级别的缓存，是默认生效的。每个 SqlSession 的连接都有自己单独的一级缓存区域，不同连接的一级缓存不共享。</p><p>对于同一个 Session 连接来说，只要缓存不刷新，缓存就能一直用。当这个 Session 调用了 update delete create 方法之后，一级缓存就会被刷新（Map 清空）。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>二级缓存是一个作用与所有 SqlSession 的共享缓存，二级缓存默认不使用。如果想要打开的话，需要开启全局配置 cacheEnabled 为 true，然后在 mapper.xml 文件里面加入 <code>&lt;cache&gt;&lt;/cache&gt;</code> 标签。</p><p>当一个 SqlSession 被 commit() 或者 close() 之后，它的一级缓存就会被放入二级缓存中。</p><p>二级缓存的刷新是需要设置的，SQL 标签里面有一个选项 flushCache，设置为 true 之后，执行语句会连着二级缓存一起刷新。</p><p>在 <code>&lt;cache&gt;&lt;/cache&gt;</code> 标签里面有一些属性，可以设置缓存回收策略（当缓存空间满了之后处理），返回的缓存是复制出来的还是直接给引用等等。</p><p>MyBatis 使用缓存的原则是先从二级缓存找数据，没有再去一级缓存。</p><p>不过以后我们都是使用第三方的缓存系统的比如 Redis，MyBatis 本身做的有点菜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;if-标签&quot;&gt;&lt;a href=&quot;#if-标签&quot; class=&quot;headerlink&quot; title=&quot;if 标签&quot;&gt;&lt;/a&gt;if 标签&lt;/h2&gt;&lt;p&gt;&lt;code&gt;&amp;lt;if test=&amp;quot;Expression&amp;quot;&amp;gt;&amp;lt;/if&amp;gt;&lt;/c</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-03-XML映射文件</title>
    <link href="https://xorex.space/2021/07/18/bd50545aca34/"/>
    <id>https://xorex.space/2021/07/18/bd50545aca34/</id>
    <published>2021-07-18T08:04:33.000Z</published>
    <updated>2021-07-19T15:48:36.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h2><h3 id="insert-update-delete"><a href="#insert-update-delete" class="headerlink" title="insert update delete"></a>insert update delete</h3><p>这个三个标签分别负责实现：插入更新和删除，三者的属性非常接近。</p><h4 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>此语句绑定接口的方法</td></tr><tr><td>parameterType</td><td>用来说明方法输入的参数类型，但这个类型通过反射可以拿到，所以不需要写</td></tr><tr><td>flushCache</td><td><code>true/false:true</code>此语句被调用之后刷新本地缓存和二级缓存。</td></tr><tr><td>timeout</td><td>整形等待数据库的最长秒数，这个不用填，交给 Spring 控制</td></tr><tr><td>statementType</td><td>执行 SQL 使用的语句类型，可选 STATEMENT，PREPARED 或 CALLABLE，表示 Statement，PreparedStatement 和 CallableStatement，默认PREPARED</td></tr><tr><td>useGeneratedKeys（适用于 insert 和 update）</td><td><code>true/false:false</code> 开启之后，执行完 SQL 会在传入的对象中自动填写数据库生成的主键值（需要设置keyProperty）</td></tr><tr><td>keyProperty（适用于 insert 和 update）</td><td>搭配上面的 useGeneratedKeys 使用，指明传入参数的哪个属性对应数据库主键。</td></tr><tr><td>keyColumn（适用于 insert 和 update）</td><td>对于某些主键列不在第一个的数据库，需要设置这个，指明哪一列是主键的列，才能配合使用上面两项设置。</td></tr><tr><td>databaseId</td><td>用来指明这条 SQL 语句执行的数据库类型。</td></tr></tbody></table><h4 id="获取自增主键"><a href="#获取自增主键" class="headerlink" title="获取自增主键"></a>获取自增主键</h4><p>在 SQL 语句里面设置 useGeneratedKeys 和 keyProperty：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    SQL statement...</span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后用于新插入的对象 user 执行完 SQL 语句之后，就会被自动赋值 id 属性为生成的主键值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">    User user=<span class="keyword">new</span> User(<span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;Tempest&quot;</span>, <span class="keyword">new</span> UserAddress(<span class="string">&quot;Xorex&quot;</span>,<span class="string">&quot;China&quot;</span>));</span><br><span class="line">    mapper.insertUser(user);</span><br><span class="line">    System.out.println(user.getId());</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><h4 id="属性设置-1"><a href="#属性设置-1" class="headerlink" title="属性设置"></a>属性设置</h4><p>这里只说说和上面三条不太一样的：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>resultType</td><td>设置返回值类型，非常用类型必须填写。</td></tr><tr><td>resultMap</td><td>设置结果映射，和 resultType 二选一</td></tr><tr><td>useCache</td><td><code>true/false:true</code> 查询结果会放在二级缓存中</td></tr><tr><td>resultSetType</td><td>用于设置 JDBC 获取的结果集的类型 FORWARD_ONLY 指的是只能用 next() 向下读取，SCROLL_SENSITIVE 可以实现结果前后滚动读取和相对坐标跳跃读取，而选项 SCROLL_INSENSITIVE 的结果集不仅可以前后滚动读取，还可以实时感知数据库的更新（不包括插入和删除），也就是获取的结果集在不同时间调用的时候，拿到的都是最新的数据。一般这个选项不需要我们设置，使用默认的 unset 即可。</td></tr><tr><td>resultOrdered</td><td>和 MyBatis 缓存有关，设置为 true 之后表示数据是根据 key 相同分好组的，MyBatis 就可以进行解析优化。具体用法后面再讨论。</td></tr><tr><td>resultSet</td><td>由于一些特殊语句（比如两条 selete 查询）会返回多个结果集，为了操作不同结果集，就需要区分。这里是按照顺序设置结果集的名称 <code>resultSet=&quot;User,Address&quot;</code> 这样为两条 SQL 返回的不同结果集命名。</td></tr></tbody></table><h2 id="参数映射"><a href="#参数映射" class="headerlink" title="参数映射"></a>参数映射</h2><h3 id="单参数映射"><a href="#单参数映射" class="headerlink" title="单参数映射"></a>单参数映射</h3><p>当我们的方法参数为一个单个参的时候，又分为很多种情况。</p><ol><li><p>为 MyBatis 内置的较为基本的类型的时候，MyBatis 会直接将其返回调用 toString() 填充到 SQL 语句中。</p></li><li><p>为 POJO 类型的时候，会根据 <code>#&#123;VarName&#125;</code> 构造 getVarName() 方法获取 POJO 值，填充 SQL 语句。</p></li><li><p>为 Map 类型的时候，会根据 <code>#&#123;Varname&#125;</code> 名字作为 Key 从 Map 中取出 value，填充到 SQL 语句中。</p></li><li><p>为 List 类型的时候：</p></li><li><p>为 数组类型的时候：</p></li></ol><h3 id="多参数映射"><a href="#多参数映射" class="headerlink" title="多参数映射"></a>多参数映射</h3><h4 id="多参数入参解决方案"><a href="#多参数入参解决方案" class="headerlink" title="多参数入参解决方案"></a>多参数入参解决方案</h4><p>这里主要是 SQL 语句中 parameterType 属性和 @Param 注解的解释。</p><p>其中因为 Java 基本上所有的版本都是支持反射获取方法参数类型 （Method 类 getParameterTypes()），所以对于 parameterType 这个属性完全可以不写，Mybatis 完全可以通过反射拿到。</p><p>但是 Mybatis 拿到的仅仅只是方法参数的类型，是拿不到参数名的，编译之后就成了 var1 var2 这样的，所以对于多个参数进行的映射如 <code>public void insertUser(String userName,String password);</code> 这样，只能用一些特殊的技巧填入 SQL 语句中的 #{} 里面：</p><ol><li>使用数字表示参数顺序</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user (username,password) values (#&#123;0&#125;,#&#123;1&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过数字来表示方法中的第 0 个参数，第 1 个参数等等。</p><ol start="2"><li>使用 @Param(“Name”) 来定义参数名</li></ol><p>使用 Mybatis 提供的注解 @Param 来对方法中的参数起一个别名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">(<span class="meta">@Param(&quot;userNameVar&quot;)</span> String userName,<span class="meta">@Param(&quot;passwordVar&quot;)</span> String password)</span></span>;</span><br></pre></td></tr></table></figure><p>然后就可以在 SQL 语句中使用我们在 @Param 中定义的别名了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user (username,password) values (#&#123;userNameVar&#125;,#&#123;passwordVar&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>将多个参数封装为 Map 之后传入</li></ol><p>自己构造一个参数的 参数名-&gt;参数值 的 Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;Tempest&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;userAddress&quot;</span>,<span class="string">&quot;China&quot;</span>);</span><br><span class="line">    mapper.insertUser(map);</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 SQL 里面直接写 Map 的 key 就能获取自己传入的 value。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user (user_name,password)</span><br><span class="line">    values(#&#123;userName&#125;,#&#123;password&#125;);</span><br><span class="line">    insert into address (user_name,user_address)</span><br><span class="line">    values(#&#123;userName&#125;,#&#123;userAddress&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>封装成 POJO 入参</li></ol><p>将所有需要入参的参数封装为一个 POJO，然后就能像使用 Map 一样，用属性名取出参数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">    mapper.insertUser(<span class="keyword">new</span> User(<span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;Tempest&quot;</span>, <span class="keyword">new</span> UserAddress(<span class="string">&quot;Xorex&quot;</span>,<span class="string">&quot;China&quot;</span>)));</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">    insert into user (user_name,password)</span><br><span class="line">    values(#&#123;userName&#125;,#&#123;password&#125;);</span><br><span class="line">    insert into address (user_name,user_address)</span><br><span class="line">    values(#&#123;userAddress.userName&#125;,#&#123;userAddress.userAddress&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="多参数入参原理"><a href="#多参数入参原理" class="headerlink" title="多参数入参原理"></a>多参数入参原理</h4><p>其实只要你的方法参数数量大于 1 ，那么就会被 MyBatis 封装为 Map 类型，通过 Key-&gt;Value 来在 SQL 中填充值。</p><p>如果在方法参数的地方标注了 @Param(“Alias”)，那么封装 Map 的时候这里的 Key 就是自己设置的 Alias，如果没标注，那么就是 arg1 arg2 这些。</p><p>而从 Map 中取出来的值也是原原本本的传入的参数类型，不会改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="meta">@Param(&quot;user&quot;)</span> User user,<span class="meta">@Param(&quot;address&quot;)</span> String address)</span></span>;</span><br></pre></td></tr></table></figure><p>这里面需要取值的时候，user 取出来一个 User 对象，address 取出来一个 String 对象。</p><h2 id="结果映射"><a href="#结果映射" class="headerlink" title="结果映射"></a>结果映射</h2><p>Java 是可以通过反射拿到方法的返回值类型，但是对于 List Map 这样用到了泛型的，是无法拿到泛型的具体类型，也自然无法进行封装，所以才会引入 resultType 和 resultMap 来解决这个问题，两者将作为反射的一个补充。</p><h3 id="列名和属性一一对应"><a href="#列名和属性一一对应" class="headerlink" title="列名和属性一一对应"></a>列名和属性一一对应</h3><p>当数据库的列名和属性名一一对应的时候，就不需要自定义映射规则了，只需要指定映射结果类型即可。</p><ol><li><p>当设置为 POJO 类型的时候，会根据列名和属性名进行一一映射，如果名字相同，则可以映射成功，如果不相同，则需要引入 resultMap 来自定义映射规则。</p></li><li><p>当设置为 List 类型的时候，resultType 应该填写 <code>List&lt;Type&gt;</code> 里面的数据类型 Type，多条结果会自动封装为 List。</p></li><li><p>当想要将一条数据的列名作为 Key，值作为 Value，返回值类型为 Map&lt;String,Object&gt;，resultType 应该填写 map。</p></li><li><p>当想要将主键作为 Key，剩下其余的值封装为 POJO 作为 Value 的时候，返回值类型为 Map&lt;KeyType,POJOType&gt;，resultType 应该填写 POJO 的类型。并在接口方法出添加注解 <code>@MapKey(&quot;KeyColumn&quot;)</code> 来指明拿哪一列的值作为 Map 中 POJO 的 Key。</p></li></ol><h3 id="列名和属性不对应"><a href="#列名和属性不对应" class="headerlink" title="列名和属性不对应"></a>列名和属性不对应</h3><p>这个时候就无法自动映射了，需要我们指定映射规则，也就是填写 resultMap。</p><p>需要注意的是，当我们设置了驼峰下划线自动映射之后，也就是 mapUnderScoreToCamelCase 之后。这玩意只能在 <strong>自动匹配</strong> 的时候生效，也就是使用 resultType 或者 resultMap 设置属性 autoMapping=ture 的时候，会在自动映射的属性-列中自动进行下划线驼峰转化。</p><p>当你进行手动映射的时候，只能老老实实写 SQL 语句里面的真实列名进行手动映射，mapUnderScoreToCamelCase 不会生效的！！！</p><h4 id="resultMap-标签属性"><a href="#resultMap-标签属性" class="headerlink" title="resultMap 标签属性"></a>resultMap 标签属性</h4><ol><li>id 定义此 resultMap 的 id。</li><li>type 定义此 resultMap 结果映射的类。</li><li>autoMapping <code>true/false:false</code>，在 resultMap 中开启自动映射。</li><li>extends 外部继承一个 resultMap，并在它后面补充（概念上是和 Java 的继承是一样的）</li></ol><h4 id="resultMap-内部标签"><a href="#resultMap-内部标签" class="headerlink" title="resultMap 内部标签"></a>resultMap 内部标签</h4><ol><li>&lt;id&gt; 定义 ID 映射，有特殊优化。</li><li>&lt;result&gt; 定义一个普通的映射</li><li>&lt;association&gt; 关联，定义一个内联的 resultMap，给是属性的 POJO 赋值。</li><li>&lt;constructor&gt; 构造器，利用构造器给结果赋值。</li><li>&lt;collection&gt; 集合，将一对多的查询结果的多的部分封装为集合类型。</li><li>&lt;discriminator&gt; 鉴别器，</li></ol><p>下面主要介绍后三个的用法:</p><h5 id="constructor-构造器"><a href="#constructor-构造器" class="headerlink" title="constructor 构造器"></a>constructor 构造器</h5><p>指的是使用 POJO 里面的构造器进行封装参数，参数传入顺序是按照标签顺序进行的，只需要写 javaType 和 column 两个属性即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;userAddress&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;useraddress&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_address&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想要按照参数名来进行传参而不是顺序，则需要在 POJO 的构造方法的参数里面添加 <code>@Param(&quot;paramName&quot;)</code> 注解，然后在 arg 标签里面指定属性 <code>name=paramName</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserAddress</span><span class="params">(<span class="meta">@Param(&quot;userName&quot;)</span> String userName, <span class="meta">@Param(&quot;userAddress&quot;)</span> String userAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    <span class="keyword">this</span>.userAddress = userAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;userAddress&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;false&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;useraddress&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor</span>&gt;</span> <span class="comment">&lt;!--更换位置之后也不需要担心顺序哦--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_address&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userAddress&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">arg</span> <span class="attr">javaType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="collection-集合"><a href="#collection-集合" class="headerlink" title="collection 集合"></a>collection 集合</h5><p>collection 主要是用来封装一对多的情况，也就是 POJO 属性有集合类型的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> List&lt;UserAddress&gt; userAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是一对多，所以查出来的条数是多的数量，因此在<strong>对一使用自动映射</strong>的时候，会因为有多条数据无法对应上一而报错。 <code>Expected one result (or null) to be returned by selectOne(), but found: 3</code></p><p>正确的解决方案就是：先手动映射上一列，到后面映射集合元素的时候，就会对应上多条数据，从而避免多条数据无法对应上，手动映射随便一列就行，我这里选的是主键。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;userAddress&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;arraylist&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;useraddress&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>collection 和其他标签<strong>唯一不同</strong>的地方是，标注集合内元素类型使用的是 <code>ofType</code> 属性，而我们在其他标签（比如 association）指明映射类型使用的 javaType 在这里面则是值生成的集合的类型，比如 ArrayList，LinkedList 等等。</p><h5 id="discriminator-鉴别器"><a href="#discriminator-鉴别器" class="headerlink" title="discriminator 鉴别器"></a>discriminator 鉴别器</h5><p>这个东西用的不多，就先不学了。</p><h5 id="分级查询"><a href="#分级查询" class="headerlink" title="分级查询"></a>分级查询</h5><p>记得在配置中有 lazyLoadingEnabled aggressiveLazyLoading 两条关于懒加载，按需加载，延迟加载的配置，这些配置就是作用于分级查询的语句的。</p><p>分级查询针对对象是内联属性，也就是 collection 和 association 标签，实现方式就是将联合查询的 SQL 语句拆分成两句简单的查询，然后分两次调用。不同的是第二次调用是通过配置来完成的：</p><p>还是这样一个 POJO：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> List&lt;UserAddress&gt; userAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将内联查询拆分成两条单独的 SQL 语句，第一条 SQL 只处理非内联属性的值获取，第二条 SQL 负责处理内联属性的值获取。然后在 resultMap 对内联属性进行映射处理的时候，添加数据获取源 <code>select=&quot;&quot;</code> 表明通过另外一条 SQL 查询获取数据，对于此 SQL 的输入参数，则通过上一条 SQL 查询结果获取，设置为属性 column 将上一条结果的某一列的值传给下一条 SQL。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;UserMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;user&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;userAddress&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;useraddress&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getUserAddressByUserName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUserName&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;UserMap&quot;</span>&gt;</span></span><br><span class="line">    select * from user where user_name=#&#123;userName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserAddressByUserName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;useraddress&quot;</span>&gt;</span></span><br><span class="line">    select * from address where user_name=#&#123;userName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，指定的数据传递 column 属性之后，回<strong>对这一列数据的自动封装有一定影响</strong>，需要重新手动映射一下，也就是因为 <code>column=&quot;user_name&quot;</code> 多出来的 <code>&lt;result column=&quot;user_name&quot; property=&quot;userName&quot;/&gt;</code>。</p><p>这样分级查询就构建好了！！！</p><p>对于第二级 SQL 的输入为多个参数的情况，使用 <code>column=&#123;key1=column1,key2=column2&#125;</code> 这样来解决，key 为我们在 <code>@Param()</code> 定义的别名，column 为上一条查询结果的列名。</p><hr><p>构建完分级查询之后，最大的意义就是使用延迟加载来提高数据库性能！！！</p><p>只需要将 lazyLoadingEnabled 设置为 true 表明系统可以使用延迟加载，然后将 aggressiveLazyLoading 设置为 false ，关闭延迟加载侵入。这样分级查询的第二级就只会在需要（被调用的时候）进行了！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;标签属性&quot;&gt;&lt;a href=&quot;#标签属性&quot; class=&quot;headerlink&quot; title=&quot;标签属性&quot;&gt;&lt;/a&gt;标签属性&lt;/h2&gt;&lt;h3 id=&quot;insert-update-delete&quot;&gt;&lt;a href=&quot;#insert-update-delete&quot; cla</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-02-全局配置文件</title>
    <link href="https://xorex.space/2021/07/17/10f39f81a384/"/>
    <id>https://xorex.space/2021/07/17/10f39f81a384/</id>
    <published>2021-07-17T07:33:02.000Z</published>
    <updated>2021-07-19T12:55:16.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="properties-属性"><a href="#properties-属性" class="headerlink" title="properties 属性"></a>properties 属性</h2><p>这里的 properties 有三种配置方式：</p><ol><li>在 properties 内部标签定义：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Xorex&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;https://xorex.space/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbc.driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;space.xorex.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>引入外部的配置文件</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;JDBC.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在创建 SqlSessionFactory 的时候，给 Builder 传入一份配置文件。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, Properties properties)</span></span>;</span><br></pre></td></tr></table></figure><p>这三种方式传入的配置信息的优先级是依次递增的，后面的会覆盖前面的配置条目的信息，只需要注意第一种和第二种的优先级关系，有点反常 QAQ。</p><h2 id="settings-设置"><a href="#settings-设置" class="headerlink" title="settings 设置"></a>settings 设置</h2><h3 id="cacheEnabled"><a href="#cacheEnabled" class="headerlink" title="cacheEnabled"></a>cacheEnabled</h3><p><code>true/false:true</code></p><p>允许缓存：全局性的打开或者关闭缓存设置。</p><h3 id="lazyLoadingEnable"><a href="#lazyLoadingEnable" class="headerlink" title="lazyLoadingEnable"></a>lazyLoadingEnable</h3><p><code>true/false:false</code></p><p>允许延迟加载：全局性的打开或者关闭数据库延迟加载，可被 fetchType 覆盖。</p><h3 id="aggressiveLazyLoading"><a href="#aggressiveLazyLoading" class="headerlink" title="aggressiveLazyLoading"></a>aggressiveLazyLoading</h3><p><code>true/false:false</code></p><p>侵入式延迟加载：开启时，任一方法的调用都会加载该对象的所有延迟加载属性（被侵入了就不懒加载了）。 否则，每个延迟加载属性会按需加载（所以要懒加载这条必须是 false）</p><h3 id="multipleResultSetsEnable"><a href="#multipleResultSetsEnable" class="headerlink" title="multipleResultSetsEnable"></a>multipleResultSetsEnable</h3><p><code>true/false:true</code></p><p>是否允许单语句查询返回多结果集（需要数据库支持），比如一条 &lt;select&gt; 标签里面有两条 select 语句，查询到了两个结果集。</p><h3 id="useColumnLabel"><a href="#useColumnLabel" class="headerlink" title="useColumnLabel"></a>useColumnLabel</h3><p><code>true/false:true</code></p><p>使用列标签代替列名，是解决查询结果映射集的一种方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> userName <span class="keyword">as</span> <span class="keyword">user</span> <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure><p>这样就给 userName 起了一个别名（列标签）user，在进行结果映射的时候，如果开启了 useColumnLabel，那么就用别名 user 去找结果映射填充而不是原名的 userName。<strong>建议一直开着</strong>。</p><h3 id="useGeneratedKeys"><a href="#useGeneratedKeys" class="headerlink" title="useGeneratedKeys"></a>useGeneratedKeys</h3><p><code>true/false:false</code></p><p>在调用 insert 和 update 语句更新数据库的时候，允许 JDBC 自动生成主键，并将主键内容返回给传入参数的 keyProperty 一项。</p><p>也就是传入一个 User 实例后，利用 userName 和 password 插入数据库，数据库生成的主键回赋值给传入参数 id 属性。</p><p>这个在 settings 设置之后，只对接口映射器有效（也就是在 Mapper 接口处使用注解开发），而对 XML 映射器无效。因此如果想要 XML 处实现，则需要到具体的 insert 和 update 语句里面设置：<code>useGeneratedKyes=&quot;true&quot; keyProperty=&quot;id&quot;</code> 打开开关并指定赋值主键的属性。</p><h3 id="autoMappingBehavior"><a href="#autoMappingBehavior" class="headerlink" title="autoMappingBehavior"></a>autoMappingBehavior</h3><p><code>NONE/PARTIAL/FULL:PARTIAL</code></p><p>表示自动结果映射行为的等级，none 表示不自动映射，partial [pɑːrʃl] 局部的，表示只会自动映射没有定义嵌套结果映射的字段，FULL 自动映射任何复杂的结果集，无论是否有嵌套。</p><p>不过一般默认的 PARTIAL 级别就够用了，FULL 就有点不太可控了，对于嵌套映射，还是自己写一个 ResultMap 爽。</p><h3 id="autoMappingUnknowColumnBehavior"><a href="#autoMappingUnknowColumnBehavior" class="headerlink" title="autoMappingUnknowColumnBehavior"></a>autoMappingUnknowColumnBehavior</h3><p><code>NONE/WARNING/FAILING:NONE</code></p><p>表示开启自动映射的时候，遇到未知列或者未知属性的时候，应该怎么做。</p><p>NONE 表示什么都不做，WARNING 表示日志输出 WARN 级别，FAILING 表示抛出 SqlSessionException。</p><h3 id="defaultExecutorType"><a href="#defaultExecutorType" class="headerlink" title="defaultExecutorType"></a>defaultExecutorType</h3><p><code>SIMPLE/REUSE/BATCH:SIMPLE</code></p><p>配置默认的执行器，SIMPLE 为简单执行器，没执行一句 SQL 就创建一个新的 Statement 实例。REUSE 为重复使用执行器，将执行过的 Statement 实例放入 Map 中缓存，方便下次相同 SQL 语句使用。BATCH 为批量执行器，会将多个 SQL 一次性执行。</p><h3 id="defaultStatementTimeout"><a href="#defaultStatementTimeout" class="headerlink" title="defaultStatementTimeout"></a>defaultStatementTimeout</h3><p><code>正整数:null</code></p><p>设置 Mybatis 等待数据库响应的最长时间，默认没有设置，单位秒。</p><h3 id="defaultFetchSize"><a href="#defaultFetchSize" class="headerlink" title="defaultFetchSize"></a>defaultFetchSize</h3><p><code>正整数:null</code></p><p>设置 Mybatis 获取 SQL 结果集的缓冲区大小的建议值，避免因为结果集数据过大，单位为条。</p><h3 id="mapUnderScoreToCamelCase"><a href="#mapUnderScoreToCamelCase" class="headerlink" title="mapUnderScoreToCamelCase"></a>mapUnderScoreToCamelCase</h3><p><code>true/false:false</code></p><p>设置将数据库列里面的下划线命名法和 Java 中的驼峰命名法进行映射匹配。</p><p>……</p><p>其实还有很多很多设置，但是时间和精力关系，就先这样了，等学到后面回把这些补上的。</p><h2 id="typeAliases-别名"><a href="#typeAliases-别名" class="headerlink" title="typeAliases 别名"></a>typeAliases 别名</h2><p>TypeAliases 主要作用就是为我们自己写的 POJO 起别名，这样只要遇到需要写全类名的地方，都可以用别名来代替。需要注意的是，所有的别名都是<strong>不区分大小写</strong>的！！！</p><h3 id="单独指定"><a href="#单独指定" class="headerlink" title="单独指定"></a>单独指定</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;space.xorex.mybatis.POJO.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>单独给某一个类指定<strong>任意</strong>一个名字作为他的别名。</p><hr><p>或者使用注解 <code>@Alias(&quot;name&quot;)</code> 标注在需要别名的 POJO 的申明类上面，也可以起别名。</p><h3 id="整个包执行"><a href="#整个包执行" class="headerlink" title="整个包执行"></a>整个包执行</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;space.xorex.mybatis.POJO&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>会将 <code>space.xorex.mybatis.POJO</code> 下面所有的 POJO 都起一个和<strong>类名相同</strong>不区分大小写的别名。</p><h3 id="MyBatis-内部设置的别名"><a href="#MyBatis-内部设置的别名" class="headerlink" title="MyBatis 内部设置的别名"></a>MyBatis 内部设置的别名</h3><p>MyBatis 给 Java 常见的一些类设置了别名，包含几乎所有的数据类型，不过对于基本类型和包装器类型，因为本来差距就是首字母大小写，所以两者的别名有所不同。基本类型的数据别名<strong>前面多了下划线</strong>。</p><table><thead><tr><th>别名</th><th>映射的类型</th></tr></thead><tbody><tr><td>_byte</td><td>byte</td></tr><tr><td>_long</td><td>long</td></tr><tr><td>_short</td><td>short</td></tr><tr><td>_int</td><td>int</td></tr><tr><td>_integer</td><td>int</td></tr><tr><td>_double</td><td>double</td></tr><tr><td>_float</td><td>float</td></tr><tr><td>_boolean</td><td>boolean</td></tr><tr><td>string</td><td>String</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>integer</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>date</td><td>Date</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr><tr><td>bigdecimal</td><td>BigDecimal</td></tr><tr><td>object</td><td>Object</td></tr><tr><td>map</td><td>Map</td></tr><tr><td>hashmap</td><td>HashMap</td></tr><tr><td>list</td><td>List</td></tr><tr><td>arraylist</td><td>ArrayList</td></tr><tr><td>collection</td><td>Collection</td></tr><tr><td>iterator</td><td>Iterator</td></tr></tbody></table><h2 id="typeHandlers-类型处理器"><a href="#typeHandlers-类型处理器" class="headerlink" title="typeHandlers 类型处理器"></a>typeHandlers 类型处理器</h2><p>类型处理器主要的工作内容就是将 SQL 数据库中的数据类型和 Java 的数据类型做一个转化，MyBatis 本身已经内置了很多类型处理器了，基本足够我们使用，但是如果想要实现自己的 typeHandler 的话，也不是不可以，只需要实现 TypeHandler 接口或者继承 BaseTypeHandler 即可。</p><p>实现完自己 typeHandler 后，需要将其加入 MyBatis 全局配置文件的 <code>&lt;typeHandlers&gt;</code> 里面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;space.xorex.handlers.MyHandler&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="objectFactory-对象工厂"><a href="#objectFactory-对象工厂" class="headerlink" title="objectFactory 对象工厂"></a>objectFactory 对象工厂</h2><p>这个没啥可说的，就是单纯的用来创造一个填充数据库查询来的数据的对象实例。这个选项的意义就是当自己实现了 objectFactory 之后，将自己的实现的工厂替换 MyBatis 自带的工厂。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;space.xorex.mybatis.objectFactorys.MyObjectFactory&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins 插件"></a>plugins 插件</h2><p>插件的作用其实就是一个拦截器，它可以拦截 MyBatis 里面的四大组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executor(update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) <span class="comment">//负责 SQL 语句的执行</span></span><br><span class="line">ParameterHandler(getParameterObject, setParameters) <span class="comment">//负责参数的填充</span></span><br><span class="line">ResultSetHandler(handleResultSets, handleOutputParameters) <span class="comment">//负责查询结果集的映射</span></span><br><span class="line">StatementHandler(prepare, parameterize, batch, update, query) <span class="comment">//负责 SQL 语句的构造</span></span><br></pre></td></tr></table></figure><p>我们只要实现了 Interceptor 接口，就可以在这个拦截器里面对上面类里面的任意执行方法进行拦截，比如执行器 Executor 的更新方法 update()，然后加入一些自定义的东西。最后加入到配置中就生效了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;space.xorex.mybatis.interceptors.MyInterceptors&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="environment-环境"><a href="#environment-环境" class="headerlink" title="environment 环境"></a>environment 环境</h2><p>MyBatis 里面的环境就是数据库相关的配置，在 <code>&lt;environments&gt;</code> 标签里面可以添加多个数据库环境配置，然后在 default 选项里面指明要使用的环境 id 即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;Dep-Env&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;Test-Env&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;Dep-Env&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 transactionManager 标签主要是设置事务管理的级别，其属性 type 有两个选项 <code>JDBC/MANAGED</code> ，JDBC 指的是使用 JDBC 自带的 commit rollback 进心事务管理，而 MANAGED 表示啥都不做。</p><p>当我们单独使用 MyBatis 的时候，可以用 JDBC 来控制事务。而和 Spring 整合之后，所以这条可以不配置（Spring 的事务控制的配置会直接覆盖 MyBatis 的！）</p><p>其次的 dataSource 用来配置数据源，其属性 type 有 <code>UNPOOLED/POOLED/JNDI</code>，UNPOOLED 表示一次访问新建一个连接，POOLED 表示使用连接池来优化连接，JNDI 是在 EJB 服务器上使用的，这个可以先不管。</p><p>然后 dataSource 里面就是设置各种数据源的信息了。</p><hr><p>当我们使用 Spring 进行整合的时候，上面的配置其实都没啥用（也不需要配置），我们将数据源和事务管理都交给 Spring 来完成，MyBatis 做好自己的 CRUD 即可。</p><h2 id="databaseIdProvider-数据库厂商标识"><a href="#databaseIdProvider-数据库厂商标识" class="headerlink" title="databaseIdProvider 数据库厂商标识"></a>databaseIdProvider 数据库厂商标识</h2><p>这个主要是用来设置多数据库连接的时候，一个数据库厂商标识别名的问题，其中属性 type 的值 DB_VENDOR 是固定的，表示通过方法 <code>DatabaseMetaData#getDatabaseProductName()</code> 自动获取当前数据库连接的数据库厂商标识。</p><p>获取标识之后，会在下面 property 标签里面的 name 属性匹配相同的数据库厂商标识，然后给它设置一个别名，为 value 里面的值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;MySQL&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;SQL Server&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlserver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置别名是为了方便，但是要在那里需要这个数据库厂商标识别名呢，答案就是在 Mapper.xml 的 SQL 语句映射文件里面，每一句 SQL 标签都有一个属性 databaseId 里面可以填写数据库厂商标识别名，标识这句 SQL 是在对应数据库上执行的。这样面对不停切换的数据库源，可以轻松的用不同 SQL 语句来应对。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">    select * from users;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">databaseId</span>=<span class="string">&quot;sqlserver&quot;</span>&gt;</span></span><br><span class="line">    select * from users;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="mappers-映射器"><a href="#mappers-映射器" class="headerlink" title="mappers 映射器"></a>mappers 映射器</h2><p>用来找 SQL 的 mapper.xml 映射文件的，分为单个配置和批量配置：</p><h3 id="单个配置"><a href="#单个配置" class="headerlink" title="单个配置"></a>单个配置</h3><p>使用 mapper 标签，resource 是从类路径下面开始找的指定配置文件，class 根据接口全类名在同级目录下找同名配置文件的，url 是从磁盘（格式为本地文件传输协议 <code>file:///</code> ）或者网络上根据路径找的映射文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;space/xorex/mybatis/Mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.mybatis.Mapper.UserMapper&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///D:/MyBatis/src/main/java/space/xorex/mybatis/Mapper/UserMapper.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="批量配置"><a href="#批量配置" class="headerlink" title="批量配置"></a>批量配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;space.xorex.mybatis.Mapper&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 package 标签，设置一个包名，然后会自动在包的同级目录下面找到所有的 xml 映射文件，根据类和 xml 文件名称相同进行匹配。</p><h3 id="优先级问题"><a href="#优先级问题" class="headerlink" title="优先级问题"></a>优先级问题</h3><p>需要注意的是，四者完全冲突，建议一个 mapper 只使用一种方法进行映射。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;properties-属性&quot;&gt;&lt;a href=&quot;#properties-属性&quot; class=&quot;headerlink&quot; title=&quot;properties 属性&quot;&gt;&lt;/a&gt;properties 属性&lt;/h2&gt;&lt;p&gt;这里的 properties 有三种配置方式：&lt;/p</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis-01-基础与配置</title>
    <link href="https://xorex.space/2021/07/16/3074f743feb9/"/>
    <id>https://xorex.space/2021/07/16/3074f743feb9/</id>
    <published>2021-07-16T02:56:51.000Z</published>
    <updated>2021-07-18T03:49:58.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MyBatis-概述"><a href="#MyBatis-概述" class="headerlink" title="MyBatis 概述"></a>MyBatis 概述</h2><p>Mybatis 是一种持久层的框架，通过建立接口的方法和 XML 注册的 SQL 语句的映射关系来实现对数据库的操作。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="获取数据库连接之前"><a href="#获取数据库连接之前" class="headerlink" title="获取数据库连接之前"></a>获取数据库连接之前</h3><p>首先获取数据库的连接实例 SqlSession 的连接池 SqlSessionFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory factory; <span class="comment">//连接池</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String resource=<span class="string">&quot;MyBatis-config.xml&quot;</span>; <span class="comment">//连接池的配置文件</span></span><br><span class="line">        InputStream inputstream = Resources.getResourceAsStream(resource); <span class="comment">//将配置文件读入流中</span></span><br><span class="line">        factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputstream); <span class="comment">//按照配置文件建造 SqlSession 连接池</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSession</span><span class="params">()</span> </span>&#123; <span class="comment">//从连接池获取连接</span></span><br><span class="line">        <span class="keyword">return</span> factory.openSession();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取连接池需要在服务器启动的时候进行，所以放到静态代码块里面执行。上面的 <code>SqlSessionFactoryBuilder</code> 作用就是按照配置文件建造连接池，此实例用完就扔，所以不给外部引用，让 GC 把它回收了。留着 <code>SqlSessionFactory</code> 作为单独一个连接池管理 SQL 连接。</p><h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><p>在 <code>MyBatis-config.xml</code> 连接池配置中加入数据库连接环境，其中 <code>&lt;property&gt;</code> 标签中的 value 中依次填入所有的信息即可。</p><p>或者外部引入一个 properties 文件，里面写上数据库连接数据，然后用 <code>$&#123;PropertyName&#125;</code> 的方式引用。</p><p>外部文件 <code>DataBase.properties</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>然后配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;DataBase.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span> <span class="comment">&lt;!--引入外部的文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="建立-DAO-层方法和-SQL-语句的映射"><a href="#建立-DAO-层方法和-SQL-语句的映射" class="headerlink" title="建立 DAO 层方法和 SQL 语句的映射"></a>建立 DAO 层方法和 SQL 语句的映射</h3><p>DAO 层的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUserByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">queryUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">queryUserByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建数据库操作接口映射的 XML 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;space.xorex.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;space.xorex.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意上面的 <code>namespace</code> 是下方的 SQL 语句映射的<strong>执行方法</strong>名称所在的定义空间（就是定义这些方法的接口），接口只能写完整的类名，不可以用别名。然后每一条就是执行方法映射的 SQL 语句。</p><p>对于这些映射标签，比如下面的，就一定要注意对应的接口方法名称的 参数 和 返回值，写对应的信息，而对于常见的数据类型，MyBatis 进行了别名映射，可以<strong>不区分大小写</strong>的使用这些别名。然后就是占位符的填充，使用 <code>#&#123;&#125;</code> 里面写数据名，是从 parameterType 中寻找的（但其实这个属性完全可以不写）。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByUserName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;space.xorex.pojo.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--这里 string 就是一个规定好的 java.lang.String 的别名--&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from user</span><br><span class="line">    where userName=#&#123;userName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="获取-Mapper-实例"><a href="#获取-Mapper-实例" class="headerlink" title="获取 Mapper 实例"></a>获取 Mapper 实例</h3><p>直接用 MybatisUtils 里面的 getSession() 获取连接，然后调用 SqlSession 的 getMapper() 获取对应 Mapper 接口的实现对象。都用完之后，SqlSession 需要提交 commit() 和关闭 close()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMapperTest</span> </span>&#123;</span><br><span class="line">    SqlSession session=MybatisUtils.getSession();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserMapper mapper=session.getMapper(UserMapper.class);</span><br><span class="line">        mapper.insertUser(<span class="string">&quot;This&quot;</span>, <span class="string">&quot;That&quot;</span>);</span><br><span class="line">        session.commit(); <span class="comment">//修改完数据库需要提交</span></span><br><span class="line">        session.close(); <span class="comment">//使用完连接记得关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>需要说一下的是，这里获取的 Mapper 接口实现类，其实是一个动态代理类，叫作 MapperProxy，这个动态代理类是 Mybatis 根据配置文件自动生成的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MyBatis-概述&quot;&gt;&lt;a href=&quot;#MyBatis-概述&quot; class=&quot;headerlink&quot; title=&quot;MyBatis 概述&quot;&gt;&lt;/a&gt;MyBatis 概述&lt;/h2&gt;&lt;p&gt;Mybatis 是一种持久层的框架，通过建立接口的方法和 XML 注册的 S</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-架构解析</title>
    <link href="https://xorex.space/2021/07/15/39ec926b82d1/"/>
    <id>https://xorex.space/2021/07/15/39ec926b82d1/</id>
    <published>2021-07-15T13:09:31.000Z</published>
    <updated>2021-07-16T07:34:06.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringMVC-工作流程"><a href="#SpringMVC-工作流程" class="headerlink" title="SpringMVC 工作流程"></a>SpringMVC 工作流程</h2><iframe src="https://www.xmind.net/embed/969fGv" width="800px" height="540px" frameborder="0" scrolling="no"></iframe><h2 id="流程图补充说明"><a href="#流程图补充说明" class="headerlink" title="流程图补充说明"></a>流程图补充说明</h2><p>待更新…</p><h2 id="DispatcherServlet-九大组件"><a href="#DispatcherServlet-九大组件" class="headerlink" title="DispatcherServlet 九大组件"></a>DispatcherServlet 九大组件</h2><h3 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h3><p>多媒体解析器，一般用来实现上传下载的功能</p><h3 id="LocaleResolver"><a href="#LocaleResolver" class="headerlink" title="LocaleResolver"></a>LocaleResolver</h3><p>国际化解析器，自动从请求头中的地区和语言信息解析并获取 Locale 对象，并设置到响应内容中，来实现国际化。</p><h3 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h3><p>主题解析器，主题是样式、图片及它们所形成的显示效果的集合。一套主题对应一个 properties文件，里面存放着与当前主题相关的所有资源。</p><h3 id="List-lt-HandlerMapping-gt"><a href="#List-lt-HandlerMapping-gt" class="headerlink" title="List&lt;HandlerMapping&gt;"></a>List&lt;HandlerMapping&gt;</h3><p>请求映射处理的集合，作用是判断请求和对应的处理器之间的映射关系，确保请求能找到对应的处理器。</p><h3 id="List-lt-HandlerAdapter-gt"><a href="#List-lt-HandlerAdapter-gt" class="headerlink" title="List&lt;HandlerAdapter&gt;"></a>List&lt;HandlerAdapter&gt;</h3><p>处理器适配器集合，因为在 SpringMVC 中 Handler 可以是任意形式的，比如 @RequestMapping 的方法，实现 Controller 接口的类，为了将这些 Handler 统一规格给 SpringMVC 使用，就需要能转化这些 Handler 的 Adapter。</p><h3 id="List-lt-HandlerExceptionResolver-gt"><a href="#List-lt-HandlerExceptionResolver-gt" class="headerlink" title="List&lt;HandlerExceptionResolver&gt;"></a>List&lt;HandlerExceptionResolver&gt;</h3><p>异常处理解析器集合，判断是否能处理所抛出来的异常，转化为目标的 ModelAndView，如果不能处理，则会将异常抛给 Tomcat。</p><h3 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h3><p>请求名到视图名翻译器，当我们自己写的 Handler 没有定义 viewName 的时候，就会调用它，将请求的目标截取，作为 viewName，供 ViewResolver 进行解析。</p><h3 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h3><p>重定向参数传递，当我们将 Post 请求进行重定向为 Get 请求的时候（防止重复提交），为了将 Post 数据体现在 Get 请求页面中，用 FlashMapManager 实现重定向参数传递。  </p><h3 id="List-lt-ViewResolver-gt"><a href="#List-lt-ViewResolver-gt" class="headerlink" title="List&lt;ViewResolver&gt;"></a>List&lt;ViewResolver&gt;</h3><p>视图解析器集合，用来通过视图名解析成视图 View 的解析器，从而进行渲染页面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SpringMVC-工作流程&quot;&gt;&lt;a href=&quot;#SpringMVC-工作流程&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC 工作流程&quot;&gt;&lt;/a&gt;SpringMVC 工作流程&lt;/h2&gt;&lt;iframe src=&quot;https://www.</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常阅读</title>
    <link href="https://xorex.space/2021/07/06/cb7f2bf06a64/"/>
    <id>https://xorex.space/2021/07/06/cb7f2bf06a64/</id>
    <published>2021-07-06T03:22:24.000Z</published>
    <updated>2021-07-06T05:51:44.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常信息解读"><a href="#异常信息解读" class="headerlink" title="异常信息解读"></a>异常信息解读</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;level 1 exception&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fun1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;level 2 exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> Test().fun2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: level 2 exception</span><br><span class="line">    at space.xorex.SSM_CRUD.DAO.Test.fun2(Test.java:15)</span><br><span class="line">    at space.xorex.SSM_CRUD.DAO.Test.main(Test.java:21)</span><br><span class="line">Caused by: java.io.IOException: level 1 exception</span><br><span class="line">    at space.xorex.SSM_CRUD.DAO.Test.fun1(Test.java:8)</span><br><span class="line">    at space.xorex.SSM_CRUD.DAO.Test.fun2(Test.java:13)</span><br><span class="line">    ... 1 more</span><br></pre></td></tr></table></figure><p>对于整个异常栈来说，最下面的 Caused by 就是异常最初被抛出来的类型和原因。然后依次向上的 Caused by 就是上一个异常被捕获之后，catch 语句里面抛出来的其他的异常。每一个 Caused by 都是捕获下一层抛出的异常，经过分析后被抛出的新异常。而没有 Caused by 修饰的最顶层异常，就是没有被任何程序捕捉处理的异常。</p><p>异常栈里每一层都有这些信息组成：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Caused by] 异常名 自定义异常出现原因 </span><br><span class="line">异常在被捕获之前经过的第一个方法</span><br><span class="line">异常在被捕获之前经过的第二个方法</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>需要注意的是，异常中会有 <code>XXX more</code> 的语句，这是指没有被打印出来的方法对异常的抛接过程，是不重要的信息，可以不用管。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;异常信息解读&quot;&gt;&lt;a href=&quot;#异常信息解读&quot; class=&quot;headerlink&quot; title=&quot;异常信息解读&quot;&gt;&lt;/a&gt;异常信息解读&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="异常" scheme="https://xorex.space/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>SSM_CRUD 搭建架构（一）</title>
    <link href="https://xorex.space/2021/07/03/f4ad326f7d77/"/>
    <id>https://xorex.space/2021/07/03/f4ad326f7d77/</id>
    <published>2021-07-03T02:26:45.000Z</published>
    <updated>2021-07-19T15:49:35.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>等完全搭建好了再更新。</p><h2 id="实现目标"><a href="#实现目标" class="headerlink" title="实现目标"></a>实现目标</h2><p>一个基于 SSM 整合的 CRUD，并使用 Mybatis-Generator 自动生成数据库代码。bootstrap 和 jQuery 作为前端框架。</p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><ol><li><p>三大框架的核心包 Spring-Core Spring-WebMVC Mybatis</p></li><li><p>用于自动分页的 Pagehelper ，生成代码的 Mybatis-Generator-Core</p></li><li><p>数据库原生的 Mysql-Connector-Java 数据库连接池 c3p0</p></li><li><p>实现 jsp 中 JSTL 标签语言的 JSTL 库</p></li></ol><h2 id="Spring-和-SpringMVC-配置"><a href="#Spring-和-SpringMVC-配置" class="headerlink" title="Spring 和 SpringMVC 配置"></a>Spring 和 SpringMVC 配置</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>在 Web.xml 中配置一启动服务器就创建 Spring 容器的 Listener 和指定 Spring 配置文件位置的 context-param 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>contextLoaderListener 监听启动后执行内容：</p><blockquote><p>Initialize Spring’s web application context for the given servlet context, using the application context provided at construction time, or creating a new one according to the “contextClass” and “contextConfigLocation” context-params.</p></blockquote><h3 id="配置杂七杂八"><a href="#配置杂七杂八" class="headerlink" title="配置杂七杂八"></a>配置杂七杂八</h3><ol><li>Filter 字符编码 CharacterEncodingFilter 设置初始参数，encoding=utf-8，forceRequestEncoding 和 forceResponseEncoding 都设置为 true 。拦截路径为全路径 <code>/*</code> 。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--字符编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Filter REST 风格，HiddenHttpMethodFilter，拦截路径为全路径 <code>/*</code> 。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--REST风格实现过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>hiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="关于两个容器分工问题"><a href="#关于两个容器分工问题" class="headerlink" title="关于两个容器分工问题"></a>关于两个容器分工问题</h3><p>Spring 的容器是一个父容器，SpringMVC 的容器是子容器。<strong>子容器可以访问父容器</strong>，<strong>而父容器不能访问子容器</strong>。</p><p>所以这就决定了用于自动注入的对象必须放入 Spring 容器中（放入到 SpringMVC 容器 Spring 访问不到），而又因为 Spring 并没有区分四大组件： @Controller @Service @Component @Repository 的功能，所以虽然 SpringMVC 可以访问到 Spring 的容器，但是却无法找到 Controller 的实例。</p><p>总之就是 Controller 必须放到 SpringMVC 的容器中，其他的组件可以随意放置两个容器中。</p><p>但是一般来说我们会把其他的组件都放到 Spring 的容器中，因为 Spring 可以轻易和其他框架进行整合。</p><h2 id="整合-Mybatis"><a href="#整合-Mybatis" class="headerlink" title="整合 Mybatis"></a>整合 Mybatis</h2><h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>整合 Mybatis 的核心就是将 SqlSessionFactory 以及 Mybatis 自动生成的 DAO 接口实现实例交给 IOC 容器进行管理。Mybatis 有和 Spring 的整合包： Mybatis-Spring.jar。</p><p>Spring 中配置实现了 BeanFactory 接口的 SqlSessionFactoryBean 实例加入 IOC 容器中，负责获取 SqlSessionFactory。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--实现了BeanFactory，调用getBean() 返回 sqlSessionFactory 用于获取连接--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:Mybatis-config.xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;pooledDataSource&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:space.xorex.SSM_CRUD.DAO*&quot;</span> /&gt;</span> <span class="comment">&lt;!--将Mapper和映射文件放到同级目录下面--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DAO-接口实现"><a href="#DAO-接口实现" class="headerlink" title="DAO 接口实现"></a>DAO 接口实现</h3><p>MapperScannerConfigurer 扫描 DAO 中规定的接口，并加入 IOC 容器中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将Mybatis生成的DAO接口实现类加入 IOC 容器中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mapperScannerConfigurer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--扫描所有 DAO 接口的实现--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;space.xorex.SSM_CRUD.DAO&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h3><h4 id="基于命名空间"><a href="#基于命名空间" class="headerlink" title="基于命名空间"></a>基于命名空间</h4><p>这里使用 Spring 的 tx 包和 aop 功能实现事务的控制，</p><p>首先使用 tx 注解进行配置确定对于被标注使用 AOP 功能的方法中，哪些是需要进行事务管理的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 选择控制事务的方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 搞个 get 优化 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后就是配置 AOP 的切入点表达式，声明哪些包下面的哪些类的哪些方法需要进行 AOP 管理，其实就是 DAO 包下面所有接口的所有方法，同时将事务管理配置的 AOP 配置进行一个整合。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPoint&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(public * space.xorex.SSM_CRUD..*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置事务增强，也就是将 AOP 和 TX 所选择的方法进行一个整合--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPoint&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h4><p>直接无脑标注 @Trancational 即可。</p><p>然后在 Spring 中进行扫描，真的是方便极了！！！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h2><p>决定自己写 SQL，来锻炼对 MyBatis 和 SQL 语句的熟练程度！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本流程&quot;&gt;&lt;a href=&quot;#基本流程&quot; class=&quot;headerlink&quot; title=&quot;基本流程&quot;&gt;&lt;/a&gt;基本流程&lt;/h2&gt;&lt;p&gt;等完全搭建好了再更新。&lt;/p&gt;
&lt;h2 id=&quot;实现目标&quot;&gt;&lt;a href=&quot;#实现目标&quot; class=&quot;headerlin</summary>
      
    
    
    
    <category term="项目记录" scheme="https://xorex.space/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="SSM" scheme="https://xorex.space/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-07-拦截器/异常处理</title>
    <link href="https://xorex.space/2021/06/16/0372728335e9/"/>
    <id>https://xorex.space/2021/06/16/0372728335e9/</id>
    <published>2021-06-16T13:14:45.000Z</published>
    <updated>2021-07-15T15:45:01.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>加强版本的 Filter，MVC 中的接口为 HandlerInterceptor 处理拦截器，一共有三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">()</span></span>; <span class="comment">//执行请求处理方法之前执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">()</span></span>; <span class="comment">//执行请求处理方法之后执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">()</span></span>; <span class="comment">//视图渲染完成之后执行</span></span><br></pre></td></tr></table></figure><p>自己实现 HandlerInterceptor 之后，需要在 SpringMVC 中配置拦截器的信息才可以使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/Interceptor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.SpringMVC_01.Interceptor.MyInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多重拦截器"><a href="#多重拦截器" class="headerlink" title="多重拦截器"></a>多重拦截器</h3><p>当有多个拦截器匹配到某个方法的时候，整体拦截器的工作顺序是按照在 SpringMVC 配置的顺序执行的。</p><p>而对于 preHandle() 和 postHandle() 则是按照一层一层套娃执行的，拦截器执行顺序靠前的在最外层，拦截器配置 01 在 02 前面：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">01 preHandle() is invoked!</span><br><span class="line">02 preHandle() is invoked!</span><br><span class="line">testInterceptor() is invoked!</span><br><span class="line">02 postHandle() is invoked!</span><br><span class="line">01 postHandle() is invoked!</span><br><span class="line">02 afterCompletion() is invoked!</span><br><span class="line">01 afterCompletion() is invoked!</span><br></pre></td></tr></table></figure><p>而 afterCompletion() 作为最后执行的擦屁股方法，和 try-catch-finally 里面的 finally 代码块类似，等待前面的套娃执行完毕，再单独按照顺序套娃从内到外执行最后的处理。可以记忆为，prehandle 顺序执行，postHandle() 和 afterCompletion() 逆序执行。</p><h3 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h3><p>对于配置了一个拦截器的执行方法被 preHandler() return 了 false，那么后面的请求处理方法、postHandle() 和 afterCompletion() 都停止执行。</p><p>如果多个拦截器的执行方法被某一个 preHandler() return 了 false，那么这个 preHandler() 所在的截断了的拦截器的<strong>后面拦截器的</strong>所有方法（preHandler()、postHandle() 和 afterCompletion()）都不会再执行。而<strong>前面所有放行了的拦截器</strong>的 afterCompletion() 方法作为拦截器的结尾处理还是会被执行的！</p><p>举个例子，01、02 和 03 三个拦截器，02 的 preHandler() return false，进行截断，那么方法的执行结果为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01 preHandle() is invoked!</span><br><span class="line">02 preHandle() is invoked!</span><br><span class="line">01 afterCompletion() is invoked! //因为 01 的 preHandle() 放行了，所以需要执行收尾方法、</span><br></pre></td></tr></table></figure><p>所以如果一旦被拦截，整个请求就不会被处理了，也不会有有效的响应。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h3><p>SpringMVC 的异常处理是通过 <code>List&lt;HandlerExceptionResolver&gt;</code> 来解决的，如果在调用请求处理方法的时候抛出了异常，那么会依次枚举实现了 HandlerExceptionResolver 接口的类，如果抛出来的这些异常能被这些异常处理解析器解决，那么就交给他们，如果不能解决，那么会直接抛出异常到 Tomcat，最终在页面上显示一个丑丑的 500 服务器内部错误的页面。</p><p>在 SpringMVC 中，有三个默认加载的 HandlerExceptionResolver 实现：ExceptionHandlerExceptionResolver、ResponseStatusExceptionResolver 和 DefaultHandlerExceptionResolver。</p><ol><li>ExceptionHandlerExceptionResolver</li></ol><p>第一个处理类可以处理的异常为所有使用了注解 <code>@ExcpetionHandler(Class)</code> 中参数输入的异常。也是我们用来自定义异常处理的方式，详情看下面介绍。</p><ol start="2"><li>ResponseStatusExceptionResolver</li></ol><p>用于设置当我们出现了自定义异常的时候，应该返回什么状态码和错误信息，而使用核心就是注解 <code>@ResponseStatus</code>：</p><p>我们首先自定义一个异常，并使用注解 <code>@ResponseStatus</code> 来定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus(value = HttpStatus.NOT_ACCEPTABLE,reason = &quot;拒绝访问！&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanNotAccsessException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/exception&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CanNotAccsessException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后当我们抛出我们自定义的异常 CanNotAccessException 无法被 ExceptionHandlerExceptionResolver 里面的异常处理方法处理之后，就会交给 ResponseStatusExceptionResolver ，发现异常拥有注解 <code>@ResponseStatus</code> 之后，会读取注解信息，然后返回一个自定义的错误页面， 406 拒绝访问。</p><p><img src="https://xorex.space/image/306.jpg" alt="306.jpg"></p><ol start="3"><li>DefaulthandlerExceptionResolver</li></ol><p>是用来处理和 SpringMVC 相关的异常，我们可以忽略它，比如这些异常：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">handleNoSuchRequestHandlingMethod</span><br><span class="line">handleHttpRequestMethodNotSupported</span><br><span class="line">handleHttpMediaTypeNotSupported</span><br><span class="line">handleMissingServletRequestParameter</span><br><span class="line">handleServletRequestBindingException</span><br><span class="line">handleTypeMismatch</span><br><span class="line">handleHttpMessageNotReadable</span><br><span class="line">handleHttpMessageNotWritable</span><br><span class="line">handleMethodArgumentNotValidException</span><br><span class="line">handleMissingServletRequestParameter</span><br><span class="line">handleMissingServletRequestPartException</span><br><span class="line">handleBindException</span><br></pre></td></tr></table></figure><h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><p>只需要在某个方法前面加上 <code>@ExceptionHandler</code> 这个注解，就可以让这个方法变为异常处理器。处理的异常取决于注解里面的参数填写的异常种类。可以自己在异常处理器中返回 ModelAndView 来自定义视图，不写也没关系。获取异常实例通过异常处理器的参数处获取，参数类型一定要匹配被 catch 异常的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/exception&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exception</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CanNotAccsessException(); <span class="comment">//抛出异常供下面处理器处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExceptionHandler(CanNotAccsessException.class)</span> <span class="comment">//指明这个方法是处理 CanNotAccessException 异常的处理器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">mathException</span><span class="params">(Exception exception)</span> </span>&#123; <span class="comment">//获取被抛出来的实例</span></span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;Hello/error&quot;</span>);</span><br><span class="line">    mv.addObject(<span class="string">&quot;error&quot;</span>, exception);</span><br><span class="line">    <span class="keyword">return</span> mv; <span class="comment">//当然如果不想跳转页面的话也可以不返回 ModelAndView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h3><p>可以将多个 ExceptionHandler 异常处理器方法集中到一个类中去，然后使用注解 <code>@ControllerAdvice</code> 告诉 SpringMVC 这个类里面的东西都是控制层的建议方法。这个属于全局的异常处理器，而上面在 <code>@Controller</code> 里面定义的处理器则是局部处理器，只能处理本类里面抛出的异常。</p><p>当 <code>@Controller</code> 和 <code>@ControllerAdvice</code> 都拥有能处理异常的方法的时候，本类处理器优先级高于全局处理器。而对于两个在同一个地方的异常处理器，则是优先选择匹配精度最高的那一个。</p><h3 id="SimpleMappingExceptionHandlerResovler"><a href="#SimpleMappingExceptionHandlerResovler" class="headerlink" title="SimpleMappingExceptionHandlerResovler"></a>SimpleMappingExceptionHandlerResovler</h3><p>这个异常处理解析器是通过配置的方式来对某些异常进行指定页面处理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span> <span class="comment">&lt;!--设置捕捉异常之后前往的页面--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.NullPointerException&quot;</span>&gt;</span>Hello/error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> <span class="comment">&lt;!-- 设置将异常实例放入请求域的 Key --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;exception&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;拦截器&quot;&gt;&lt;a href=&quot;#拦截器&quot; class=&quot;headerlink&quot; title=&quot;拦截器&quot;&gt;&lt;/a&gt;拦截器&lt;/h2&gt;&lt;h3 id=&quot;基础使用&quot;&gt;&lt;a href=&quot;#基础使用&quot; class=&quot;headerlink&quot; title=&quot;基础使用&quot;&gt;&lt;/a&gt;基础使</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-06-AJAX支持/文件上传</title>
    <link href="https://xorex.space/2021/06/15/de23fc4f3bd1/"/>
    <id>https://xorex.space/2021/06/15/de23fc4f3bd1/</id>
    <published>2021-06-15T14:46:38.000Z</published>
    <updated>2021-06-18T05:36:50.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="响应-AJAX-的-Json-类型"><a href="#响应-AJAX-的-Json-类型" class="headerlink" title="响应 AJAX 的 Json 类型"></a>响应 AJAX 的 Json 类型</h2><h3 id="设置响应内容"><a href="#设置响应内容" class="headerlink" title="设置响应内容"></a>设置响应内容</h3><p>只需要在请求处理方法前面加上 <code>@ResponseBody</code> 表示将方法返回值添加到响应体中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ajax&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAjax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;AJAX!&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会在响应体里面看到一串 JS 代码了。</p><h3 id="Json-处理"><a href="#Json-处理" class="headerlink" title="Json 处理"></a>Json 处理</h3><p>SpringMVC 支持自动将对象转化为 Json 格式的字符串，需要导入三个包：<code>jackson-core</code>，<code>jackson-annotations</code>，<code>jackson-databind</code>。然后对于将自定义对象返回的方法，会自动转化为 Json 字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ajax/get&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title">returnAjax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> employeeDao.getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法返回的值是一个 <code>Collection&lt;Employee&gt;</code> 对象，但是标注了 <code>@ResponseBody</code> 之后，这个对象会经过转换器转化为 Json 格式（因为我们引入的 <code>jackson-core</code> 里面的 Json 转化器被添加到了转化器列表里面）</p><p>还可以使用一些其他关于 Json 的注解来控制转化的过程，如 <code>@JsonIgnore</code> 用于标注被省略转化的字段，使用 <code>JsonFormat(pattern=&quot;XXXX&quot;)</code> 来规定向 Date Time 这样的字段的转化格式等等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Date date;</span><br><span class="line"><span class="meta">@JsonIgnore</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure><p>然后响应体里面返回的转化 Json 就是按照我们的要求的了，没有 password，时间按照 yyyy-MM-dd 格式： <code>&#123;&quot;userName&quot;:&quot;Tempest&quot;,&quot;email&quot;:&quot;cloudloverain@Foxmail.com&quot;,&quot;date&quot;:&quot;2021-06-16&quot;&#125;</code></p><h3 id="获取请求内容"><a href="#获取请求内容" class="headerlink" title="获取请求内容"></a>获取请求内容</h3><p>只需要在请求处理方法的参数前面加上 <code>@RequestBody</code> 表示将请求中的请求体放入参数中，比如我们设置一个 userName 的 Post 提交，按照 SpringMVC 参数填充规则，是无法填充到 <code>String body</code> 上面的，没有设置注解，参数名也不匹配，但是我们标注 <code>@RequestBody</code> 之后，整个 Post 的请求体会作为一个 String 字符串填充到 body 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;ajax/post&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAjax</span><span class="params">(<span class="meta">@RequestBody</span> String body)</span> </span>&#123;</span><br><span class="line">    System.out.println(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果，为 Post 所有内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tempest=Xorex&amp;Submit=Submit</span><br></pre></td></tr></table></figure><hr><p>而 <code>@RequestBody</code> 也支持自动转化格式的功能，比如将请求体中的 Json 数据转化为对象：</p><p>请求体：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;userName&quot;</span>:<span class="string">&quot;Tempest&quot;</span>,<span class="attr">&quot;password&quot;</span>:<span class="string">&quot;Xorex&quot;</span>,<span class="attr">&quot;email&quot;</span>:<span class="string">&quot;cloudloverain@Foxmail.com&quot;</span>,<span class="attr">&quot;date&quot;</span>:<span class="string">&quot;2021-06-16&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>接收请求的处理方法，将 Json 自动转化为 User 对象并传入参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;ajax/post&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAjax</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Body-数据转化原理"><a href="#Body-数据转化原理" class="headerlink" title="Body 数据转化原理"></a>Body 数据转化原理</h2><h3 id="HttpMessageConverter-lt-T-gt"><a href="#HttpMessageConverter-lt-T-gt" class="headerlink" title="HttpMessageConverter&lt;T&gt;"></a>HttpMessageConverter&lt;T&gt;</h3><p>对于请求 Body 和响应 Body 和 Java 对象的数据转化流程如下：</p><p><img src="https://xorex.space/image/302.jpg" alt="302.jpg"></p><p>对于任意一个涉及到 Body 数据转换的请求或者响应，SpringMVC 会遍历自己拥有的所有 <code>HttpMessageConverter&lt;T&gt;</code>，去一一确认是否能处理此转换，默认实现了的转换器如下：</p><p><img src="https://xorex.space/image/303.jpg" alt="303.jpg"></p><h3 id="使用-HttpEntity-lt-T-gt-代替-RequestBody"><a href="#使用-HttpEntity-lt-T-gt-代替-RequestBody" class="headerlink" title="使用 HttpEntity&lt;T&gt; 代替 @RequestBody"></a>使用 HttpEntity&lt;T&gt; 代替 @RequestBody</h3><p>将这个类作为请求参数，泛型 T 写为 RequestBody 需要被转化的类型（会依次寻找能处理 T 的Converter）。然后调用 <code>getBody()</code> 、<code>getHeaders()</code> 等来获取更加完整的请求信息（请求头）;</p><h3 id="使用-ResponseEntity-lt-T-gt-代替-ResponseBody"><a href="#使用-ResponseEntity-lt-T-gt-代替-ResponseBody" class="headerlink" title="使用 ResponseEntity&lt;T&gt; 代替 @ResponseBody"></a>使用 ResponseEntity&lt;T&gt; 代替 @ResponseBody</h3><p>只需要将这个这个类作为请求处理方法的返回类型，泛型 T 为向响应体写入的数据类型，也就是 Object-&gt;String 转化的 Object 类型。</p><p>比如下面设置请求头（setcookie），设置请求体（User 用 Json 格式转 String），设置响应码（200 OK）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/Entity&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title">getEntity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;cloudloverain@foxmail.com&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    MultiValueMap&lt;String,String&gt; headers=<span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    headers.set(HttpHeaders.SET_COOKIE, <span class="string">&quot;Temespt=Xorex&quot;</span>);</span><br><span class="line">    HttpStatus status=HttpStatus.OK;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(user, headers, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>对于多媒体文件的处理在 SpringMVC 中使用的是 MultipartResolver 这个组件来解决的，当我们需要处理文件上传的时候，就需要给这个组件设置一个实现类去处理。</p><p>从 MultipartResolver 的创建过程可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.multipartResolver = (MultipartResolver)context.getBean(<span class="string">&quot;multipartResolver&quot;</span>, MultipartResolver.class);</span><br></pre></td></tr></table></figure><p>我们只需要在 ioc 容器中注册一个 id 为 multipartResolver 的 Bean 即可，这里使用的是：<code>CommonsMultipartResolver</code> 这个实现类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;#&#123;1024*1024*100&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置最大上传文件大小为100MB--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="单文件接收"><a href="#单文件接收" class="headerlink" title="单文件接收"></a>单文件接收</h3><p>然后使用 <code>MultipartFile</code> 类作为参数来接受请求发过来的文件，需要注意的是 <code>getName()</code> 指的是文件上传的 key 值 file，而 <code>getOriginalFileName()</code> 指的是文件本身的名字 <code>XXX.jpg</code>，使用它自带的 <code>transferTo(File)</code> 方法将上传来的文件转移到指定的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEntity</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    file.transferTo(<span class="keyword">new</span> File(<span class="string">&quot;D:\\Pictures\\Saved Pictures\\Tempest.jpg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>注意需要将文件上传的表单里面添加一项 <code>enctype=&quot;multipart/form-data&quot;</code>，其不对字符编码。当使用有文件上传控件的表单时，该值是必需的。</p><p>如果不加编码规则，那么上传的就是 <code>file=fileName</code>，并不包含多媒体数据（上传文件本身），惨痛结果：</p><p><img src="https://xorex.space/image/304.jpg" alt="304.jpg"></p><p>加了之后（没找到请求体 QAQ）：</p><p><img src="https://xorex.space/image/305.jpg" alt="305.jpg"></p><h3 id="多文件接收"><a href="#多文件接收" class="headerlink" title="多文件接收"></a>多文件接收</h3><p>这里的多文件指的是一个 name 对应多个文件的情景，这个时候只需要使用 <code>MultipartFile[]</code> 来接收文件即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEntity</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file,<span class="meta">@RequestParam(&quot;files&quot;)</span> MultipartFile[] files)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(file.getOriginalFilename());</span><br><span class="line">    <span class="keyword">for</span> (MultipartFile multipartFile : files) &#123;</span><br><span class="line">        System.out.println(multipartFile.getOriginalFilename());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;响应-AJAX-的-Json-类型&quot;&gt;&lt;a href=&quot;#响应-AJAX-的-Json-类型&quot; class=&quot;headerlink&quot; title=&quot;响应 AJAX 的 Json 类型&quot;&gt;&lt;/a&gt;响应 AJAX 的 Json 类型&lt;/h2&gt;&lt;h3 id=&quot;设置响应内</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-05-数据绑定/转化/校验</title>
    <link href="https://xorex.space/2021/06/11/4130a9517564/"/>
    <id>https://xorex.space/2021/06/11/4130a9517564/</id>
    <published>2021-06-11T06:16:40.000Z</published>
    <updated>2021-07-19T16:34:20.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="静动态资源处理管理"><a href="#静动态资源处理管理" class="headerlink" title="静动态资源处理管理"></a>静动态资源处理管理</h2><p>我们最初在配置 <code>DispatcherServlet</code> 来作为处理方法映射的时候，因为静态资源无法找到对应的处理方法，所以无法访问，针对这个问题，使用 <code>&lt;mvc:default-servlet-handler/&gt;</code> 之后，SpringMVC 将在容器中中定义一个 SimpleUrlhandlerMapping，它的作用就是将请求交给 WEB 应用服务器默认的 Tomcat 处理，这样静态资源的访问就得到了解决。</p><p>但是我们标注了 <code>&lt;mvc:default-servlet-handler/&gt;</code> 之后，新加入的 SimpleUrlHandlerMapping 会覆盖我们原本用来处理方法映射的 DefaultAnnotationHandlerMapping。这样处理动态资源访问的映射关系就没有了，因此动态资源无法访问。</p><p>解决方法就是：使用 <code>&lt;mvc:annotation-driven/&gt;</code>，添加这个设置之后，就会多出来一个优先级最高的 RequestMappingHandlerMapping，专门处理动态资源访问和处理方法之间的映射关系。只有这个 Mapping 无法处理的资源（静态资源），才会交给后面的 SimpleUrlHandlerMapping 处理（交给 Tomcat）。</p><h2 id="lt-mcv-anntation-driven-gt"><a href="#lt-mcv-anntation-driven-gt" class="headerlink" title="&lt;mcv:anntation-driven&gt;"></a>&lt;mcv:anntation-driven&gt;</h2><p>这个配置的字面意思就是 MVC 注解驱动。那么这个配置有什么用呢？</p><ul><li><p><code>&lt;mvc:annotation-driven/&gt;</code> 会自动注册： RequestMappingHandlerMapping 、 RequestMappingHandlerAdapter 与 ExceptionHandlerExceptionResolver 三个 bean。</p></li><li><p>还将提供以下支持：</p></li></ul><ol><li>支持使用 ConversionService 实例对表单参数进行类型转换</li><li>支持使用 @NumberFormat、@DateTimeFormat 注解完成数据类型的格式化</li><li>支持使用 @Valid 注解对 JavaBean 实例进行 JSR 303 验证</li><li>支持使用 @RequestBody 和 @ResponseBody 注解实现 AJAX</li></ol><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>数据绑定指的是从请求的数据到处理方法中的参数这个过程，在 SpringMVC 中，数据绑定的流程大概如下：</p><ol><li>SpringMVC 主框架将 ServletRequest 对象及目标方法的入参实例传递给 WebDataBinderFactory 实例，以创建 DataBinder 实例对象</li><li>DataBinder 调用装配在 SpringMVC 上下文中的 ConversionService 组件进行数据类型转换、数据格式化工作。将 Servlet 中的请求信息填充到入参对象中</li><li>调用 Validator 组件对已经绑定了请求消息的入参对象进行数据合法性校验，并最终生成数据绑定结果 BindingData 对象</li><li>SpringMVC 抽取 BindingResult 中的入参对象和校验错误对象，将它们赋给处理方法的参数。</li></ol><p>也就是过程如下：</p><p><img src="https://xorex.space/image/301.jpg" alt="301.jpg"></p><p>在 SpringMVC 的 ConversionService 数据转化服务中，有大量的转化器 Converter 可以作为用于将 String 类型的数据转化为 Java 常间的类型，但是对于我们自己设置的类型，如果需要转化则需要我们手动实现 Converter 接口。</p><p>比如我们想要将 String 类型转化为 User 类型；<code>&quot;Xorex-Tempest-Xorex@Tempest.com&quot;</code> -&gt; <code>User&#123;username=Xorex,password=Tempest,email=Xorex@Tempest.com&#125;</code> 需要这样实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToUserConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String[] datas=s.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(datas[<span class="number">0</span>],datas[<span class="number">1</span>],datas[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了 Converter 之后，需要将我们自己实现的 Converter 放入执行转化服务的 ConversionService 中。而麻烦之处在于 ConversionService 是由 ConversionServiceFactoryBean 生成的，那么我们最终其实是将 Converter 交给 FormattingConversionServiceFactoryBean，由这个工厂来生成含有自定义 Converter 的 ConversionService。</p><p>所以我们需要 SpringMVC 配置文件中，声明：将自定义 Converter 交给 FormattingConversionServiceFactoryBean 并告诉 SpringMVC 用这个含有我们自定义 Converter 的 FactoryBean 来生成 ConversionService:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.SpringMVC_01.Conversion.StringToUserConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数据格式化"><a href="#数据格式化" class="headerlink" title="数据格式化"></a>数据格式化</h2><p>前面介绍了通过实现 Converter 来实现自定义数据和请求数据的绑定。下面来介绍一下请求数据的格式化，也就是将请求发过来的数据转化为格式化的数据，比如将 <code>2021-06-01</code> 转化为 Date 对象。将 <code>$12,123,234.3242</code> 转化为 Double 对象等等。</p><p>这里使用的 Format 注解：<code>@DateTimeFormat</code> 和 <code>@NumberFormat</code> 等，只需要标注到需要接收格式化的参数或者字段前面，被 SpringMVC 自动填充的时候，就会根据 ConversionService 里面定义的 Format 规则进行格式化了。</p><p>而我们上面配置的 FormattingConversionServiceFactoryBean 这个工厂生成的 ConversionService 就包含一系列 Format 类型的 Class 用于数据格式化，而不同的注解也有不同的格式化方法，需要在注解参数 <code>pattern</code> 中填写。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/date&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDate</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date)</span> </span>&#123;</span><br><span class="line">    System.out.println(date);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/number&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNumber</span><span class="params">(<span class="meta">@NumberFormat(pattern = &quot;$#,###.##&quot;)</span> Double money)</span> </span>&#123;</span><br><span class="line">    System.out.println(money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间用 <code>yyyy-MM-dd</code> 规定传入的时间字符串格式，浮点数用 <code>$#,###.##</code> 规定传入的金钱的格式，对于 JavaBean 里面的数据使用格式化，则直接在 Bean 里面的字段加上注解即可，SpringMVC 进行参数填充的时候会读取上面的注解的。</p><h2 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h2><h3 id="JSR-303"><a href="#JSR-303" class="headerlink" title="JSR-303"></a>JSR-303</h3><p>对于数据在服务端进行的数据校验工作，我们自己写真的是太麻烦了，于是在 JAVA6 里面推出了一种规范：JSR-303，JSR 是 Java Specification Requests 的缩写，意思是 Java 规范提案，又叫做 Bean Validation。JSR 303 是 Java 为 bean 数据合法性校验提供的标准框架。</p><p>对于 JSR-303 的基本内容，Spring 本身就实现了，只需要 MVC 设置里面添加 Spring 的本地 validator 到 IOC 容器中并告诉注解驱动器用指定搞得 validator 去处理 JSR-303 的注解。validator 实现来源则是 LocalValidatorFactoryBean 生成的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;localValidatorFactoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> <span class="comment">&lt;!--IOC 中注册 validator 来源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">validator</span>=<span class="string">&quot;localValidatorFactoryBean&quot;</span>/&gt;</span>  <span class="comment">&lt;!--告诉注解驱动用哪个 validator 处理 JSR-303 驱动--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JavaBean-校验"><a href="#JavaBean-校验" class="headerlink" title="JavaBean 校验"></a>JavaBean 校验</h3><p>然后我们就可以利用 JSR-303 定义的注解，去去进行数据校验了，这里的所有注解可以查看文档。对于自定义 Bean ，在 Bean 的声明处向内部标校验注解，然后参数处标注 <code>@Valid</code> 表示需要要校验这个 Bean,并<strong>紧接着</strong>被校验的 Bean 声明一个参数：<code>BindingResult result</code> 或者 <code>Errors errors</code>，这个  两个类可以记录校验的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@Past</span></span><br><span class="line">    <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/valid&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testValid</span><span class="params">(<span class="meta">@Valid</span> User user,BindingResult result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(result.hasErrors()) &#123; <span class="comment">//从校验结果中查看是否校验成功</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非自定义-JavaBean-校验"><a href="#非自定义-JavaBean-校验" class="headerlink" title="非自定义 JavaBean 校验"></a>非自定义 JavaBean 校验</h3><p>对于非自定义类型的数据，首先需要在 IOC 容器中注册一个 MethodValidationPostProcessor 用来校验方法参数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.validation.beanvalidation.MethodValidationPostProcessor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在处理方法所在的 Controller 类中加入注解 <code>@Validated</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmplController</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将 JSR-303 注解标注到对应参数头上，如果校验失败，则会抛出异常（javax.validation.ConstraintViolationException），需要注意的是，这里无法使用 BindingResult 和 Errors 来查看错误，只能拦截异常 （好麻烦啊！！！）</p><h3 id="自定义错误消息"><a href="#自定义错误消息" class="headerlink" title="自定义错误消息"></a>自定义错误消息</h3><p>最简单的方法就是在任何一个校验的注解里面添加 message 属性，里面填写需要自定错误的消息。这样我们取出来的 Message 就是我们自己设置的错误了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotNull(message = &quot;老哥不能空啊！&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="meta">@NotNull(message = &quot;老哥不能空啊！&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="meta">@Email(message = &quot;老哥你邮箱不对啊！&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br></pre></td></tr></table></figure><p>但是如果需要实现国际化的话，具体的流程和 JstlView 实现国际化的流程都是一样的，唯一的不同是对国际化文件的 Key 进行一定的规则限制。</p><p>因为我们在回显错误信息的时候，比如使用 <code>&lt;form:errors path=&quot;email&quot;&gt;</code> 来现实隐含模型中属性为 email 的校验错误的时候，他会根据一定的规则从国际化文档中寻找对应的 Key：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Email.user.email=XXXX //在隐含模型的 user 对象的 email 字段使用 @Email 校验时，匹配此国际化错误信息</span><br><span class="line">Email.email=XXXX //在隐含模型任意对象中的 email 字段使用 @Email 校验时，匹配此国际化错误信息</span><br><span class="line">Email.java.lang.String=XXXX //字段为 String 的值使用 @Email 校验时，匹配此国际化错误信息</span><br><span class="line">Email=XXXX //任意字段使用 @Email 校验时，匹配此国际化错误信息</span><br></pre></td></tr></table></figure><p>当有多个国际化 Key 得到匹配的时候，同样按照精确度决定匹配优先级。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;静动态资源处理管理&quot;&gt;&lt;a href=&quot;#静动态资源处理管理&quot; class=&quot;headerlink&quot; title=&quot;静动态资源处理管理&quot;&gt;&lt;/a&gt;静动态资源处理管理&lt;/h2&gt;&lt;p&gt;我们最初在配置 &lt;code&gt;DispatcherServlet&lt;/code&gt; 来作为</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-04-视图/视图解析器</title>
    <link href="https://xorex.space/2021/06/09/b91e91480bcd/"/>
    <id>https://xorex.space/2021/06/09/b91e91480bcd/</id>
    <published>2021-06-09T14:54:23.000Z</published>
    <updated>2021-06-16T14:37:36.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h2><h3 id="forward-转发"><a href="#forward-转发" class="headerlink" title="forward: 转发"></a>forward: 转发</h3><p>和原本的 SpringMVC 一样，写在方法的返回值处，不过不同的是 forward: 不会被拼串，并且是以项目地址为相对路径的。</p><p>原：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/TestRequest/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView requestScope = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> requestScope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forward:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/TestRequest/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView requestScope = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;forward:/WEB-INF/pages/hello.jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> requestScope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redirect-重定向"><a href="#redirect-重定向" class="headerlink" title="redirect: 重定向"></a>redirect: 重定向</h3><p>使用方法和 <code>forward:</code> 转发是一样的，和使用 <code>response.sendRedirect(&quot;/XXX&quot;)</code> 唯一不同的是，相对地址会自动加上项目地址，方便浏览器解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/TestRequest/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView requestScope = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;redirect:/WEB-INF/pages/hello.jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> requestScope;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="视图解析原理"><a href="#视图解析原理" class="headerlink" title="视图解析原理"></a>视图解析原理</h3><blockquote><p>这一段转自与知乎，其实自己也写了总结，但是觉得不太行，没有下文理解的清晰。</p></blockquote><ol><li><p>当我们对 SpringMVC 控制的资源发起请求时，这些请求都会被 SpringMVC 的 org.springframework.web.servlet.DispatcherServlet 处理，接着 SpringMVC 会分析看哪一个 HandlerMapping 定义的请求映射中存在对该请求的最合理的映射。然后通过该 HandlerMapping 取得其对应的 Handler（也就是我们定义的处理请求方法），接着再通过相应的 HandlerAdapter 处理该 Handler。HandlerAdapter 再对Handler 进行处理。</p></li><li><p>之后会返回一个 ModelAndView 对象。在获得了 ModelAndView 对象之后，Spring 就需要把该 View 渲染给用户，即返回给浏览器。在这个渲染的过程中，发挥作用的就是 ViewResolver 和 View。当 Handler 返回的 ModelAndView 中不包含真正的视图，只返回一个逻辑视图名称，ViewResolver 会把该逻辑视图名称解析为真正的视图 View 对象。View 真正进行视图渲染，把结果返回给浏览器。</p></li></ol><p>而 ViewResolver 和 View 都是一个接口，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewResolver</span> </span>&#123;</span><br><span class="line">    <span class="function">View <span class="title">resolveViewName</span><span class="params">(String var1, Locale var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125; <span class="comment">//用于解析 ModelAndView 里面保存的 viewName 然后根据解析结果生成一个合适的 View 实现对象。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String, ?&gt; var1, HttpServletRequest var2, HttpServletResponse var3)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125; <span class="comment">//实现 View 接口只需要实现 render() 方法即可，render 渲染，将获取的数据和展示模板一起渲染成一个用户收到的页面。</span></span><br></pre></td></tr></table></figure><p>调用 View 对象的 render 渲染（指生成用户看到的 html 页面）方法，进行请求转发（并将模型输入放入 Request 域中），或者请求重定向。SpringMVC 主要负责的是生成 View 的过程，至于不同的 View 接口实现可以五花八门，实现了视图层的解耦。</p><h2 id="使用-JstlView-实现国际化"><a href="#使用-JstlView-实现国际化" class="headerlink" title="使用 JstlView 实现国际化"></a>使用 JstlView 实现国际化</h2><p>在 Spring 中导入 taglibs-standard-impl 和 taglibs-standard-spec 这两个包之后，在 Spring 中配置的 InternalResourceViewResolver 中，添加 viewClass 属性值为 JstlView 之后，ViewResolver 将生成的 View 实例从原本的 InternalResourceView 更改为更强大的子类：JstlView。</p><p>这个 View 强大之处就是大大简化了国际化的配置与使用。</p><p>首先搞几个不同国家地区的文字：<code>i18n_en_US.properties</code> 和 <code>i18n_zh_CN.properties</code> 。然后在 Spring 中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basename&quot;</span> <span class="attr">value</span>=<span class="string">&quot;i18n&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意 id 一定要是 <code>messageSource</code> ，Spring 是根据这个 id 名字来寻找绑定的国际化信息的。然后在相关的 jsp 页面引入 fmt 标签，然后使用  <code>&lt;fmt:message&gt;</code> 来输出国际化信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">fmt:message</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fmt:message</span> <span class="attr">key</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="请求页面跳转访问"><a href="#请求页面跳转访问" class="headerlink" title="请求页面跳转访问"></a>请求页面跳转访问</h2><p>因为很多强大的功能只有经过 SpringMVC 才能实现，比如上面的国际化，这就需要我们对一些直接访问的资源经过 SpringMVC 处理，或者访问 WEB-INF 下面的资源，也需要进行请求转发才可以获取资源。那么大量的仅仅只进行请求转发的处理方法写起来太乱了，可以直接用一条 Spring 的配置解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/Login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Login&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringMVC 支持通过配置的方法，来实现访问地址直接向 WEB-INF 下资源的访问：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;Login&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>但是需要注意的是，使用了 <code>mvc:view-controller</code> 来接管对请求路径的访问之后，会打断原本注解标注的 <code>@RequestMapping</code>，需要额外添加一个 <code>mvc:annotation-driven</code> 来进行扫描注解接管请求映射。</p><h2 id="自定义视图解析器"><a href="#自定义视图解析器" class="headerlink" title="自定义视图解析器"></a>自定义视图解析器</h2><p>大致过程：首先实现 ViewResolver 和 View 两个接口。ViewResolver 还需要实现 Ordered ，来将优先级提高到高于 InternalResourceViewResolver，只需要获取的 order 值越低，权重越高！</p><p>如果开头是 Tempest ，则确认为本 ViewResolver 处理对象，返回一个本 ViewResolver 生成的 View 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewResolver</span> <span class="keyword">implements</span> <span class="title">ViewResolver</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> order;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">resolveViewName</span><span class="params">(String s, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.startsWith(<span class="string">&quot;Tempest:&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MyView(s.substring(<span class="number">8</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrder</span><span class="params">(<span class="keyword">int</span> order)</span> </span>&#123; <span class="comment">// 这个 order 值是在 Spring 的配置文件里面设置的</span></span><br><span class="line">        <span class="keyword">this</span>.order=order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 View 的渲染方式就是转发请求到指定的页面中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">implements</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    MyView(String address) &#123;</span><br><span class="line">        <span class="keyword">this</span>.address=address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text/html&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String, ?&gt; map, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/pages/&quot;</span>+address+<span class="string">&quot;.jsp&quot;</span>).forward(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后记得将自己实现的 ViewResolver 添加到 IOC 容器（配置文件注册 bean 的 class 即可）中，Spring 会根据是否实现 ViewResolver 接口决定此类是否为视图解析类，并在控制 View 生成的时候，依次调用所有的 ViewResolver 的 resolveViewName() 方法。所以必须让 Spring 知道自己才有可能被调用去生成 View。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;space.xorex.SpringMVC.ViewResolver.MyViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们再进行请求映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Tempest:hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当我们发起 <code>XXXX/test/</code> 的请求的时候，就会将 <code>Tempest:hello</code> 视图名根据 order 权重依次传入 ViewResolver 的 resolveViewName() 中，我们写的 ViewResolver 看到了 <code>Tempest:</code> 的开头，匹配成功并返回我们自己实现的 View：MyView，最后调用 MyView 的渲染方法 render() 并执行我们指定的请求转发代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;视图层&quot;&gt;&lt;a href=&quot;#视图层&quot; class=&quot;headerlink&quot; title=&quot;视图层&quot;&gt;&lt;/a&gt;视图层&lt;/h2&gt;&lt;h3 id=&quot;forward-转发&quot;&gt;&lt;a href=&quot;#forward-转发&quot; class=&quot;headerlink&quot; title=&quot;f</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-03-处理模型数据</title>
    <link href="https://xorex.space/2021/06/07/70114f9842ce/"/>
    <id>https://xorex.space/2021/06/07/70114f9842ce/</id>
    <published>2021-06-07T14:17:56.000Z</published>
    <updated>2021-06-15T09:14:56.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h2><h3 id="操作-Map-系列参数"><a href="#操作-Map-系列参数" class="headerlink" title="操作 Map 系列参数"></a>操作 Map 系列参数</h3><p>方法参数加上 <code>Map&lt;String,Object&gt;</code>、<code>Model</code>、<code>ModelMap</code> 三个中的任意一个即可，我们只要将数据保存到这些的参数实例中，Spring 会自动帮我们把数据放到 <strong>Request</strong> 域中。</p><p>关于这三个有什么关系呢：</p><p><img src="https://xorex.space/image/300.jpg" alt="300.jpg"></p><p>其实 Spring 传入参数中的是 BindingAwareModelMap 实例，所以才能三个中任意一个作为参数都能实现数据的转发。</p><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h3><p>这里需要重点说一下用来处理隐含数据模型 bindingAwareModelMap 的注解 <code>@ModelAttribute</code>，此注解可被应用在方法或方法参数上。</p><h4 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h4><p>当 <code>@ModelAttribute</code> 标注到一个方法上面的时候，就意味着这个方法为数据模型处理方法，这个方法是用来在隐藏数据模型添加一些数据的。所以被这个注解标注的方法会在当前类下面的<strong>任意一个请求映射方法</strong>被调用<strong>之前运行</strong>。</p><p><code>@ModelAttribute</code> 标注方法有两种风格：</p><ul><li>在第一种写法中，方法通过返回值的方式默认地将添加一个属性；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute(&quot;Xorex&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">addUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;XXX&quot;</span>,<span class="string">&quot;XXX&quot;</span>,<span class="number">324234</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将返回的 User 对象添加到隐藏数据模型中，key 为我们在注解中设置的 <code>Xorex</code>，如果不设置，那么默认为添加的数据类型 User 的首字母小写 user。</p><ul><li>在第二种写法中，方法接收一个 Model 对象，然后可以向其中添加任意数量的属性。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    model.addAtribute(<span class="string">&quot;Xorex&quot;</span>,<span class="keyword">new</span> User());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数注释"><a href="#参数注释" class="headerlink" title="参数注释"></a>参数注释</h4><p>标注在方法参数上的 <code>@ModelAttribute</code> 说明了该方法参数的值将由 model 中取得。如果 model 中找不到，那么该参数会先被实例化，然后被添加到 model 中。在 model 中存在以后，请求中所有名称匹配的参数都会填充到该参数中。</p><p>就是用来从隐含数据模型中取数据用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/XXX/XXX&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(<span class="meta">@ModelAttribute(&quot;Xorex&quot;)</span> User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;XXX/XXX&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而参数 user 可能来自于：</p><ol><li>因为 <code>@SessionAttributes</code> 标注的使用已经存在于 model 中</li><li>它可能因为在同个控制器中使用了 <code>@ModelAttribute</code> 方法已经存在于 model 中，正如上面所叙述的将注解标注到方法上面。</li><li>它可能是调用了自身的默认构造器被实例化出来的，在 model 中找不到实例，只能创建。</li></ol><h3 id="使用-ModelAndView"><a href="#使用-ModelAndView" class="headerlink" title="使用 ModelAndView"></a>使用 ModelAndView</h3><p>ModelAndView 模型（页面需要用到的数据）和视图（数据的展示），这个东西会同时起到两个作用，那就是 request 域数据的保存和页面的转发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/Test/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;hello&quot;</span>); <span class="comment">//确认转发的 View 层地址</span></span><br><span class="line">    mv.addObject(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>); <span class="comment">//向 request 域中写数据</span></span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 ModelAndView 作为方法返回对象，设置实例的转发 View 页面，设置 Model 数据。</p><h3 id="Session-中的数据"><a href="#Session-中的数据" class="headerlink" title="Session 中的数据"></a>Session 中的数据</h3><p>这里推荐还是使用原生的 API HttpSession 进行存取数据，更加方便安全。</p><p>而 SpringMVC 提供了两种和 Session 进行数据交互的注解，为标注在类上面的注解 <code>@SessionAttributes</code> 和标注在参数上面的注解 <code>@SessionAttribute</code>。</p><p>对于 <code>@SessionAttributes</code>：是用于在请求之间的 HTTP Servlet 会话中<strong>存储</strong> model 属性。其 Value 用来填写放入 Session 中的 Key，然后 Spring 会在隐含数据模型中寻找相同的 Key，并把里面的值复制一份放入 Session 中。也就是说 Session 有的，隐含数据域中也必须有。而注解的另外一个参数则是 Types，这个不是去隐含数据模型中寻找 Key 了，而是值的类型，将符合 Types 类型的数据放入 Session 中。这个很危险，不建议使用。</p><p>而且一旦在隐含数据模型中找不到指定的数据，那么 <code>@SessionAttributes</code> 注解就会报错。</p><hr><p>然后就是从 Session 中获取数据了，使用的是 <code>@SessionAttribute</code> 。</p><p>需要将 <code>@SessionAttribute(&quot;XXX&quot;)</code> 就可以将 Session 中保存的 key 为 XXX 的数据放入被标注的方法参数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/XXX/XXX&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(<span class="meta">@SessionAttribute(&quot;Xorex&quot;)</span> User user)</span> </span>&#123; <span class="comment">// 从 Session 中取出 key 为 Xorex 的值。</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;XXX/XXX&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据转发&quot;&gt;&lt;a href=&quot;#数据转发&quot; class=&quot;headerlink&quot; title=&quot;数据转发&quot;&gt;&lt;/a&gt;数据转发&lt;/h2&gt;&lt;h3 id=&quot;操作-Map-系列参数&quot;&gt;&lt;a href=&quot;#操作-Map-系列参数&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-02-请求数据获取</title>
    <link href="https://xorex.space/2021/06/06/fd142553b621/"/>
    <id>https://xorex.space/2021/06/06/fd142553b621/</id>
    <published>2021-06-05T16:36:36.000Z</published>
    <updated>2021-06-16T14:37:41.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>REST 即表述性状态传递（Representational State Transfer），是一种软件架构风格，指代使用不同的请求方式来表示这次请求需要完成的 CURD 的种类，然后在 URL 中携带被操作对象，</p><p>比如：</p><table><thead><tr><th>URL</th><th>请求方式</th><th>目的</th></tr></thead><tbody><tr><td>/book/1</td><td>get</td><td>获取 1 号图书</td></tr><tr><td>/book</td><td>post</td><td>添加图书</td></tr><tr><td>/book/1</td><td>put</td><td>更新图书</td></tr><tr><td>/book/1</td><td>delete</td><td>删除 1 号图书</td></tr></tbody></table><p>这里面要说一下 Post 和 Put 的区别，在官方 HTTP 协议中，规定 Put 为 idempotent（幂等） 方法，也就是多次连续请求造成结果应该相同。因此 Put 应该执行更新方法，而 Post 应该执行非幂等（多次执行添加请求会添加多个）的添加方法。</p><h3 id="实现-REST"><a href="#实现-REST" class="headerlink" title="实现 REST"></a>实现 REST</h3><p>因为 HTML 发起请求的方式只有 GET 和 POST，所以为了实现 REST，我们可以曲线救国。在 GET 或者 POST 里面添加请求参数，<code>_method</code>，放入 delete 和 put 作为参数，然后在 web.xml 中配置一个 Srping 的 Filter：<code>HiddenHttpMethodFilter</code>，过滤范围为所有的请求。</p><p>这个 Filter 会去查找是否拥有 <code>_method</code> 参数并且数据的请求类型是否为合法（指是否为 HTTP 协议里面的类型），如果合法，那么这个 Filter 会将 HttpRequest 里面的请求方法修改为我们设置的 <code>_method</code> 参数数据。</p><p>最后需要注意的是，在大于等于 8.0 版本的 Tomcat 里面使用 REST 的时候，因为 JSP 认为不是 Get 或者 Post 的请求都是有问题的，会爆出错误页面，为了掩盖这个问题，将当前 JSP 页面的页头添加设置 <code>isErrorPage=&quot;true&quot;</code>，就可以让 Tomcat 忽略这个问题了。</p><h2 id="获取请求信息"><a href="#获取请求信息" class="headerlink" title="获取请求信息"></a>获取请求信息</h2><h3 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h3><h4 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h4><ol><li>方法声明变量名，参数名和变量名匹配的话就会将参数值传入方法中，比如下面当有参数： <code>username=XXX</code> 的时候，发现方法参数和请求参数名相匹配，就会将 XXX 传入方法中，没带则传入 null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>@RequestParam</code> 注解标注方法参数。</li></ol><p><code>(RequestParam(value = &quot;user&quot;,required = false,defaultValue = &quot;No_Name&quot;) String username)</code> 主要是解决方法参数名和请求参数名不一样的问题，给 value 附上别名即可（当然附上别名就<strong>只能使用别名</strong>来让方法参数接收数据了），required 则是标注这个参数是否必须要有（如果没有页面会报错 Required Parameter XXX）</p><hr><h4 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h4><p>SpringMVC 支持 POJO 类型的请求自动封装，会自动将符合匹配条件（名字一样）的请求参数放入 POJO 中。还支持 POJO 的级联封装，只需要加 <code>.</code> 即可：<code>address.home=Xorex&amp;address.school=CUIT</code> 就是对 Address 里的两个 String 进行赋值。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求：username=Xorex&amp;password=Xorex&amp;address.home=Xorex&amp;address.school=CUIT&amp;Xorex=Tempest</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">(User user,String username)</span>  </span>&#123;<span class="comment">// 两个封装并不冲突</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原生参数"><a href="#原生参数" class="headerlink" title="原生参数"></a>原生参数</h4><p>SpringMVC 支持自动传入原生 ServletAPI，直接写在方法的参数里面即可，会按照类型填入，支持类型：</p><ol><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li><li>java.security.Principal</li><li>Locale</li><li>InputStream</li><li>OutputStream</li><li>Reader</li><li>Writer</li></ol><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>使用 <code>@RequestHeader</code> 注解获取请求头信息，value 填写请求头名称， required 和 defaultValue 参考上面。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>使用 <code>@CookieValue</code> 注解获取请求中的 Cookie 信息，value 填写 Cookie 的 key，required 和 defaultValue 参考上面。</p><h2 id="请求响应乱码"><a href="#请求响应乱码" class="headerlink" title="请求响应乱码"></a>请求响应乱码</h2><ol><li>GET 请求乱码：</li></ol><p>GET 乱码主要是 Tomcat 中 Connector 对请求的解析的问题，只需要在 8080 端口的 Connector 的设置（在 server.xml 中）里添加 URLEncoding=”UTF-8” 即可、</p><ol start="2"><li>POST 请求乱码：\</li></ol><p>在 HttpServletRequest 实例设置 setCharacterEncoding(“UTF-8”)，或者写一个 Filter 将所有的请求提前设置一下。</p><p>最最最重要的是，Spring 内置了这个 Filter，不需要我们自己写！是 CharacterEncodingFilter ，直接配置到 web.xml 中即可，可选配置请求乱码 encoding 和相应乱码 forceEncoding 一起改:</p><p>更更更重要的是，这个 Filter 要<strong>放到其他的 Filter 前面</strong>，因为可能其他 Filter 回对请求里面的数据进行处理，应该修改完编码类型之后才可以！！！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;REST&quot;&gt;&lt;a href=&quot;#REST&quot; class=&quot;headerlink&quot; title=&quot;REST&quot;&gt;&lt;/a&gt;REST&lt;/h2&gt;&lt;p&gt;REST 即表述性状态传递（Representational State Transfer），是一种软件架构风格，指代使用不</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC-01-基础请求处理</title>
    <link href="https://xorex.space/2021/06/05/28d8300ff21a/"/>
    <id>https://xorex.space/2021/06/05/28d8300ff21a/</id>
    <published>2021-06-05T08:49:25.000Z</published>
    <updated>2021-06-11T06:05:10.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先拿张图，这里面就是 Spring 可以胜任的功能，其中 Web 模块其实就是我们接下来要学习的 SpringMVC，使用 Spring 来控制 Web 项目里面的 Model View Controller 三层模型。</p><p><img src="https://xorex.space/image/298.jpg" alt="298.jpg"></p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>首先需要导入 Spring 的核心包，也就是支持 Spring 运作的 Beans Core Context SpEL 和用于测试 Spring 的 Test 包。</p><p>而对于 SpringMVC 来说，实现基础的功能只需要导入 Web 和 Servlet 两个包即可。</p><p>SpringMVC 的模式和传统的 MVC 有一点点不同，那就是多了一个前端控制器，这个控制器也是 SpringMVC 控制整个 Web MVC 流程的实现基础。而这个前端控制器本身是一个 Servlet，交给 Tomcat 控制。然后 Tomcat 会拦截所有的 Servlet 请求，全都交给前端控制器这个 Servlet，前端控制器则根据 SpringMVC 的框架标准，控制处于 Spring 容器中的各种对象来完成业务的实现。</p><p><img src="https://xorex.space/image/299.jpg" alt="299.jpg"></p><p>所以先在 web.xml 中配置 DispatcherServlet ，初始化参数给 spring 配置文件的地址，也就是 applicationContext.xml 用来控制 IOC 容器（如果不配置的话会默认去 WEB-INF/springDispathcherServlet-servlet.xml 读配置文件，其中文件前缀就是配置的 DispathcerServlet 的 servlet-name），并配置拦截 / 下的所有 Serlvet 请求（/* 会拦截所有资源的请求，包括 jsp， / 不会拦截 jsp），当然除了拦截 Servlet 请求，静态资源的请求也从 Tomcat 手里抢了过来，这个问题以后回补充解决方案。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispathcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispathcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>搞好了前端控制器之后，就可以写 Controller 层的控制器了，只需要随便写一个类，然后标注 @Controller ，就可以被 IOC 容器标注为控制层了，等到 DispathcerServlet 调用自己即可。</p><p>而对于这个伪装的 Servlet 如何有选择的处理不同的请求呢，这就依靠 @RequestMapping 注解，也就是请求映射，将请求和处理方法建立映射。</p><p>因为我们将请求映射配置为 /，所以 Spring MVC 将捕获 WEB 容器的所有请求，包括静态资源的请求， SpringMVC 会将他们当成一个普通请求处理，因找不到对应处理器将导致错误。解决方案就是在 SpringMVC 的配置文件中配置 <code>&lt;mvc:default-servlet-handler/&gt;</code> 的方式解决静态资源的问题：<br><code>&lt;mvc:default-servlet-handler/&gt;</code> 将在 SpringMVC 上下文中定义一个 DefaultServletHttpRequestHandler，它会对进入 DispatcherServlet 的请求进行筛查，如果发现是没有经过映射的请求，就将该请求交由 WEB 应用服务器默认的 Servlet 处理，如果不是静态资源的请求，才由 DispatcherServlet 继续处理。</p><h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&#123;&quot;/index.jsp&quot;,&quot;/index&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;WEB-INF/pages/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是将 <code>/index.jsp</code> 和 <code>/index</code> 两处的请求，转发到 return 里面填写的地址上面，这里使用的是请求转发。</p><h3 id="RequestMapping-相关"><a href="#RequestMapping-相关" class="headerlink" title="RequestMapping 相关"></a>RequestMapping 相关</h3><p>RequestMapping 定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;path&quot;)</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="标注位置"><a href="#标注位置" class="headerlink" title="标注位置"></a>标注位置</h4><p>RequestMapping 可以被标注到 TYPE 也就是 Class 上和方法上，标注到 Class 上面是为了更大范围的前置约束，比如可以写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/fisrt&quot;,method=&quot;post&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/one&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;one&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/two&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">two</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;two&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样首先访问为 <code>/first/XXX</code> 的 POST 请求都会被定位到 FirstController 这个类中，然后根据 <code>/XXX</code> 的值精细化定位处理方法。</p><h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><ol><li><p>value/path 设置处理此方法映射的访问地址。详情请看：<a href="https://xorex.space/2021/06/05/28d8300ff21a/#%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84">请求路径</a></p></li><li><p>method 设置映射的访问方法，可以设置 <code>public enum RequestMethod</code> 里面设定的几种访问方法。</p></li><li><p>params 设置请求中的参数要求，必须包含某参数或者某参数为 XXX 值等。详情请看：<a href="https://xorex.space/2021/06/05/28d8300ff21a/#%E5%8F%82%E6%95%B0%E9%99%90%E5%88%B6">参数限制</a></p></li><li><p>headers 设置请求头包含 “请求头：设置” 的请求被本方法处理。</p></li><li><p>consumes 设置消费类型，是根据 Content-Type 请求头里面进行比对的，比如设置 application/json 就限制了请求里面的数据必须是 application/json 类型的请求才会被此方法处理</p></li><li><p>produces 设置要求生产类型，是根据 Accept 请求头进行比对的。根据请求想要获得的数据类型来决定本方法是否处理此请求。</p></li></ol><h4 id="请求路径"><a href="#请求路径" class="headerlink" title="请求路径"></a>请求路径</h4><p>其中可以使用 <code>&#123;VariableName&#125;</code> 的方式从 URI 中截取数据，保存到 VariableName 的变量中，然后下面通过注解 <code>@PathVariable</code> 将保存的截取数据送入方法参数中，如果参数名和截取数据所保存的变量名相等，就可以不在注解里面填写数据。如果注解标注的位置是 Map 类型，则会将<strong>所有</strong>截取的数据放入 Map 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/index/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toIndex</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> </span>&#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对截取的数据加以正则限制，则可以使用：<code>&#123;varName:regex&#125;</code> 来对某部分进行正则表达式限制。或者比较粗暴的使用 <code>*</code> 来省略被限制的部分路径。</p><hr><p>当一个请求被多个方法映射成功之后，遵循的原则是映射匹配精确度越高，方法处理的优先级越高。</p><h4 id="参数限制"><a href="#参数限制" class="headerlink" title="参数限制"></a>参数限制</h4><p>在 params 上设置只有用户名为 Xorex 的用户才会被处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(params=&quot;username=Xorex&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toAdmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Admin] Xorex login.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <code>username!=XXX</code> 表示参数 username 不等于某个值即可（包括没有 username 参数），<code>!username</code> 表示必须没有 username 参数。<code>password</code> 表示必须要有密码参数。</p><h3 id="return-地址"><a href="#return-地址" class="headerlink" title="return 地址"></a>return 地址</h3><p>请求映射方法的 return 值（为 String）就是此方法处理完请求之后会被转发到的地址（一般是 View 层）。</p><p>而转发地址里面有很多都是重复的，如 <code>WEB-INF/pages/</code> 和 <code>.jsp</code> 所以就可以再搞一个内部资源视图控制器，也就是 jsp 的一个小的控制器，只需要将其放入 IOC 容器中，这个控制器就可以设置对视图资源的访问，设置一个前缀和后缀即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 放入 IOC 容器之后，这个实例会在转发 return 后面的地址之前自动被调用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先拿张图，这里面就是 Spring 可以胜任的功能，其中 Web 模块其实就是我们接下来要学习的 SpringMVC，使用 Spring </summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SpringMVC" scheme="https://xorex.space/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>《一课经济学》读书笔记</title>
    <link href="https://xorex.space/2021/06/03/85d5c9bb45a9/"/>
    <id>https://xorex.space/2021/06/03/85d5c9bb45a9/</id>
    <published>2021-06-03T12:29:50.000Z</published>
    <updated>2021-06-05T16:47:59.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本书内容"><a href="#本书内容" class="headerlink" title="本书内容"></a>本书内容</h2><p>由于在一段时间内的生产力综合是不变的，那么对一个群体的经济政策作用代价是所有人承受的，经济政策需要考虑所有的影响者。</p><p>换句话说：经济政策既需要考虑短时影响，也需要考虑长远影响，不能只关注任意一方。不仅要想行为的好处，也要想事实行为的代价承担着。</p><h2 id="破窗谬论"><a href="#破窗谬论" class="headerlink" title="破窗谬论"></a>破窗谬论</h2><p>破窗谬论：“打碎窗户虽然损失了钱，但是玻璃工人拿到了这份钱，提供了其他消费，刺激了生产。所以这是有好处的。”</p><p>原理：这份钱的消费可以由窗户所有者提供，但社会的所有财产综合损失了一扇窗户，原有的消费不变的情况，总财产损失，反而不利。这是因为忽视了金钱原本持有者的消费能力。</p><h2 id="战祸之福"><a href="#战祸之福" class="headerlink" title="战祸之福"></a>战祸之福</h2><p>战祸之福：“经过战争的国家战后经济会高速发展，因为战后带来了巨大的需要，重建不但贡献了经济，也有后来居上的作用（最新的工厂和大楼），因此也带来了更加先进的社会生产力。”</p><p>原理：战争摧毁了很多东西，带来了某方面的巨大需要，这些需要改变了人战后的努力方向，改变了工业结构。这些被需要工业结构拿到了大量的投资，人们因为迫切的生存需要而贡献了大量的生产力，使得造成了某些被迫切需要的产业的高速发展，但焦点被转移的产业生产力是大幅度下降的。总的来说由于战争破坏，社会的总体生产力下降，整体财富下降，只是因为努力方向的转移造成了部分被迫切需要的产业的快速发展，造成了战祸之福的假象。</p><p>此外，需求和需要时不相等的。需要是客观的，比如需要房子，需要汽车。而需求是一种意愿，必须需求居住能力更高的住所，需求更快的交通工具。需求=购买力（生产力）+ 购买欲望（需要），一个没有支付能力的购买意愿并不构成需求。印度比美国有更多的需要，但是需求并没有美国多。</p><p>也可以将国家经历放到个人身上，个人的财产被毁掉之后，开始拼命工作建造房子。你可以看到它的房子每天都在快速建成，但他只是在恢复到以前的状态，本身还是很贫穷。并且由于努力方向的转移，导致了生产其他东西的能力下降。</p><h2 id="公共工程建设"><a href="#公共工程建设" class="headerlink" title="公共工程建设"></a>公共工程建设</h2><p>公共工程建设：“工程建设增加了工作机会，如果没有工程建设，工作机会也会变少”</p><p>原理：不仅仅要考虑工程的直接影响者：被雇佣者，工程对当地的积极作用等，还要考虑其他影响者，也就是付出代价的人，全体纳税者人。这些代价在原本纳税人手里会产生其他的需求，而政府则是将这些需求转移到了工程的直接影响者。这种转移意味着没创造一个公共工作机会，就会破坏掉一个私人就业机会。而如果这些直接影响者带来的收益低于付出代价，那么工程就是不值得的，这也是因为只看到了直接影响者，而没有看到更广泛的影响者（那些出钱的全体纳税人）</p><h2 id="税收与生产"><a href="#税收与生产" class="headerlink" title="税收与生产"></a>税收与生产</h2><p>税收的作用就是拿出一部分社会整体的生产力，去生产一些个人和公司无法生产的东西，比如基础设施建设，全民医保等。</p><p>适量的税收去生产这些在一定程度上是有利于整体的社会生产力的发展的。但过量的税收会导致个人和公司在相同的投入下，有大量的生产力被政府抽走，自己剩余的生产力就会过低，整体会抑制社会对扩大生产的投资，从而影响生产力的发展。实际中需要寻找一个合适的平衡点。</p><h2 id="诅咒机器"><a href="#诅咒机器" class="headerlink" title="诅咒机器"></a>诅咒机器</h2><p>诅咒机器：“人们认为使用机器带来的生产力提升使得人们失去了工作机会，所以拒绝使用机器是保住就业的好方法。”</p><p>原理：更先进的生产力破坏了原有的生产关系，导致了一部分人失去工作机会。但更加先进的生产力意味着更加强大的购买力，这部分购买力会随着购买欲望一起变成新的需求，而新的需求就意味着工作机会。在这个过程之中，因为更加先进的生产力使得整个社会的财富变得更多了，意味着能够养活的人口变多了。按照原有的工作机会水平（生产力-需求）来看，社会的工作机会不减反增。</p><p>失去的工作机会是被关注的短期和局部影响，背后带来的社会生产力提高是长远的影响，两者都应该被同等的重视，而不是过分的关注一方。</p><h2 id="关税保护"><a href="#关税保护" class="headerlink" title="关税保护"></a>关税保护</h2><p>关税是对购买国外商品的国人进行征税。对国家内部来说，关税的好处只有提高本国某行业在全世界的生产力分配额度。</p><p>如日本高得离谱的农业进口税，作用仅仅只是维持本国的部分农业供给，保证一定程度的粮食安全。而为此付出的代价就是日本国内的一部分生产力需要被消耗在低效的日本农业上面，如果取消关税，那么国外农业优势国家（相同的投入获取更多的收益）的农业生产力将会更加发达，而日本本国的消费者可以将投入本国农业的低效生产力以消费的形式转移到其他的优势产业，如制造业。从全世界来看，国外的农业和日本的制造业生产力都得到了提升，创造出来了更多的财富，所有人都收益（当然收益程度是不同的，关税的本质就是通过抑制优势生产力的流动来调整国际生产力发展带来的收益）</p><p>长远来看并不利于全世界的整体生产力的提升，因此也制约了本国的整体生产力。但在全世界并没有出现一个统一的，以全人类发展为最终目标的，拥有最高权力的全球政府之前，人类还需要忍受关税带来的内耗。<br>但上面说的只是理想的情况啦，实际即使所有国家都开放市场，因为地理，国界，文化，发展水平等等因素限制，虽然整体上是利于全世界的发展，但开放市场带来的收益会很不平衡，可能会发达国家吃肉，强发展中国家喝汤，弱发展中国家吐血。</p><h2 id="进出口"><a href="#进出口" class="headerlink" title="进出口"></a>进出口</h2><p>最好的对外贸易状态就是进口等于出口，过多的贸易顺差会造成国内资源不断外流，抑制国内需求，带来本国货币升值压力。而过多的贸易逆差会造成本国货币贬值，国内生产力不足。</p><p>所以最好是出口等于进口，是当前经济最好的状态。但因为当前最好状态不太表最终最好状态，中国靠着贸易顺差积累了原始资本，大幅度的提高了生产力，为未来获取高附加值产业奠定了基础等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本书内容&quot;&gt;&lt;a href=&quot;#本书内容&quot; class=&quot;headerlink&quot; title=&quot;本书内容&quot;&gt;&lt;/a&gt;本书内容&lt;/h2&gt;&lt;p&gt;由于在一段时间内的生产力综合是不变的，那么对一个群体的经济政策作用代价是所有人承受的，经济政策需要考虑所有的影响者。&lt;/p&gt;</summary>
      
    
    
    
    <category term="杂七杂八" scheme="https://xorex.space/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="读书笔记" scheme="https://xorex.space/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>计组-IO系统</title>
    <link href="https://xorex.space/2021/06/01/ac17795a00ed/"/>
    <id>https://xorex.space/2021/06/01/ac17795a00ed/</id>
    <published>2021-06-01T09:54:49.000Z</published>
    <updated>2021-06-05T16:47:39.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO-基本概念"><a href="#IO-基本概念" class="headerlink" title="IO 基本概念"></a>IO 基本概念</h2><p>I/O 即输入／输出，通常指数据在存储器（内部和外部）或其他周边设备之间的输入和输出，输入是系统接收的信号或数据，输出则是从其发送的信号或数据。</p><h3 id="IO-系统的发展"><a href="#IO-系统的发展" class="headerlink" title="IO 系统的发展"></a>IO 系统的发展</h3><p>早期的 IO 系统是直接和 CPU 连接，由 CPU 直接控制 IO 系统，极大的降低了 CPU 的性能。</p><p>后来将一些和内存数据交换比较频繁的外设单独建立了 DMA （Direct Memory Access 直接存储访问） 总线。</p><p>再后来发展出了 IO 通道结构，主机只需要和 IO 上面的通道部件进行数据交换即可，再次加快了速度。</p><p>现在一般开始采用 IO 处理机，承担主机的功能来管理各种外设，基本拥有和 CPU 一样的结构。</p><p><img src="https://xorex.space/image/293.jpg" alt="293.jpg"></p><h3 id="IO-系统工作方式"><a href="#IO-系统工作方式" class="headerlink" title="IO 系统工作方式"></a>IO 系统工作方式</h3><p>IO 系统一般来说有三种工作方式，分别是：程序查询方式，程序中断方式，DMA 方式。三种方式的不同的地方就是使用了不同的设计来分担了一部分 CPU 对 IO 设备的控制，使得 IO 系统对 CPU 越来越简单，从而提升性能。</p><p><img src="https://xorex.space/image/294.jpg" alt="294.jpg"></p><h2 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h2><p>关于外设的各种信息，因为和生活比较接近，所以就不写了。</p><h2 id="IO-接口"><a href="#IO-接口" class="headerlink" title="IO 接口"></a>IO 接口</h2><p>IO 接口的相关结构，主要的作用就是建立起一个 CPU 和外设之间通讯的桥梁，来提高整个设备的性能和可拓展性，让各个部件都专注与自己本身的工作：</p><p><img src="https://xorex.space/image/295.jpg" alt="295.jpg"></p><p>以及 IO 接口结构的工作流程，CPU 只和接口进行交互，并且相关数据的获取都是从绿色的数据缓冲寄存器和设备状态标记寄存器，这也是为了减少 CPU 实际读取数据的时间，和通过主控芯片来提高外接设备的性能。</p><p><img src="https://xorex.space/image/296.jpg" alt="296.jpg"></p><p>这里需要注意一个概念，我们将上面绿色部分的寄存器称为端口 Prot，分为 数据端口，控制端口，状态端口。剩下的蓝色部分和控制逻辑电路作为控制逻辑。</p><p><img src="https://xorex.space/image/297.jpg" alt="297.jpg"></p><p>也就是说，CPU 实际上和外设进行数据交换的时候，本质上是和接口里面的端口进行数据交换，所以获取数据只需要知道数据所在的端口的地址即可。统一端口设计模式之后，CPU 就完全不需要关心实际外部设备的内部设计了，这些交给端口的控制逻辑解决即可。</p><hr><p>对不起，实在不想学了，以后学了操作系统，之后再来看看 IO 系统这一章吧！</p><p>一定会补完的，QAQ</p><p>滚去学 Spring 了……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IO-基本概念&quot;&gt;&lt;a href=&quot;#IO-基本概念&quot; class=&quot;headerlink&quot; title=&quot;IO 基本概念&quot;&gt;&lt;/a&gt;IO 基本概念&lt;/h2&gt;&lt;p&gt;I/O 即输入／输出，通常指数据在存储器（内部和外部）或其他周边设备之间的输入和输出，输入是系统接收</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-总线设计</title>
    <link href="https://xorex.space/2021/05/31/1b7d3a309aca/"/>
    <id>https://xorex.space/2021/05/31/1b7d3a309aca/</id>
    <published>2021-05-31T12:43:50.000Z</published>
    <updated>2021-06-05T16:47:20.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总线（Bus）概念"><a href="#总线（Bus）概念" class="headerlink" title="总线（Bus）概念"></a>总线（Bus）概念</h2><p>总线是主机为了解决不同可更换设备之间的通信问题而产生的，计算机各种功能部件之间传送信息的公共通信干线。</p><h3 id="总线分类"><a href="#总线分类" class="headerlink" title="总线分类"></a>总线分类</h3><p>总线可以根据不同的特征进行不同的分类：</p><ol><li><p>机械特性：尺寸，形状，管脚数量，排列顺序。</p></li><li><p>电气特性：传输方向（单向 or 双向）和有效的电平范围（0 - 0.5 低电平 0.5 - 1 V 高电平）</p></li><li><p>功能特性：地址总线，数据总线，控制总线。</p></li><li><p>时间特性：信号和时序的关系。</p></li></ol><p>以及下图：</p><p><img src="https://xorex.space/image/284.jpg" alt="284.jpg"></p><p>数据传输格式：里面串行总线和并行总线的区别就是同时传输数据的位数，串行总线一次传输一位数，并行总线一次可以传输多位数。</p><p>总线的功能：主要内容看下图。</p><p><img src="https://xorex.space/image/285.jpg" alt="285.jpg"></p><h3 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h3><p>总线的结构：总线的结构设计分为单总线设计，双总线设计，三总线设计。当然这里的单总线指的是每种总线（数据总线，控制总线，地址总线）只有一根。</p><p>单总线结构，就是最基本的总线：</p><p><img src="https://xorex.space/image/286.jpg" alt="286.jpg"></p><p>双总线结构，将 CPU 与主存的总线和 IO 总线分离开来，高速的用一根，低速的用一根，从而提高整体的效率。</p><p>注意里面的通道是一个小控制器，它有自己的控制系统，负责控制 IO 和内存之间的交互。</p><p><img src="https://xorex.space/image/287.jpg" alt="287.jpg"></p><p>三总线结构，思路还是将不同的速度分级，从而提高整体的速度。这里多出来的就是 DMA 总线，也就是 Direct Memory Access 直接内存访问总线。将 IO 里面速度较快的部分（硬盘）单独和内存使用总线连接，提高硬盘速度。</p><p><img src="https://xorex.space/image/288.jpg" alt="288.jpg"></p><h2 id="总线性能指标"><a href="#总线性能指标" class="headerlink" title="总线性能指标"></a>总线性能指标</h2><p>总线带宽：也就是总线的数据传输速率，单位时间内总线上可传送数据的速率。</p><p>总线复用：有些总线是将地址总线和数据总线放在一起复用。</p><h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><p>因为在同一时间之内只能由一个设备控制总线发出信号，同一时间内只能由一个或多个设备接收总线的信号。</p><p>所以当多个设备想要向总线发送信号的时候，就需要决定哪个设备来使用总线，这便是总线仲裁。</p><h3 id="集中仲裁"><a href="#集中仲裁" class="headerlink" title="集中仲裁"></a>集中仲裁</h3><p>指的是使用一个单独的仲裁器，用它来决定谁获取总线的使用权限。当一个设备正在使用总线的时候，发出 BS 总线忙信号，仲裁器停止分配总线。当没有总线忙信号并且有设备正在请求总线的时候，发出 BG 总线允许信号，需要总线的设备接收到 BG 信号之后，开始使用总线并发出 BS 总线忙信号。这就是集中仲裁的基本原型。</p><p><img src="https://xorex.space/image/289.jpg" alt="289.jpg"></p><h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2><p>总线标准就是国际上公布过推荐的一种模块设计标准，设计设备和总线的通信的时候，只需要遵守相关的模块设计标准，就可以接入任何一条总线。</p><p>PCI 总线，局部总线：</p><p><img src="https://xorex.space/image/290.jpg" alt="290.jpg"></p><p>PCI-E 总线，</p><p><img src="https://xorex.space/image/291.jpg" alt="291.jpg"></p><p>最后用一个奔腾3的主板设计模式，来大概感受一下总线：</p><p><img src="https://xorex.space/image/292.jpg" alt="292.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;总线（Bus）概念&quot;&gt;&lt;a href=&quot;#总线（Bus）概念&quot; class=&quot;headerlink&quot; title=&quot;总线（Bus）概念&quot;&gt;&lt;/a&gt;总线（Bus）概念&lt;/h2&gt;&lt;p&gt;总线是主机为了解决不同可更换设备之间的通信问题而产生的，计算机各种功能部件之间传送信</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
