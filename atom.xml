<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xorex</title>
  
  <subtitle>要去热爱每一天的生活啊！</subtitle>
  <link href="https://xorex.space/atom.xml" rel="self"/>
  
  <link href="https://xorex.space/"/>
  <updated>2021-03-02T14:50:56.842Z</updated>
  <id>https://xorex.space/</id>
  
  <author>
    <name>Xorex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDBC思维导图</title>
    <link href="https://xorex.space/2021/03/02/9a53fb3643d5/"/>
    <id>https://xorex.space/2021/03/02/9a53fb3643d5/</id>
    <published>2021-03-02T14:43:19.000Z</published>
    <updated>2021-03-02T14:50:56.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDBC-思维导图"><a href="#JDBC-思维导图" class="headerlink" title="JDBC 思维导图"></a>JDBC 思维导图</h2><blockquote><p>在 JAVA 中，如何用代码和数据库进行交互呢？JDBC 告诉你答案！</p></blockquote><iframe src="https://www.xmind.net/embed/y3kVuZ" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JDBC-思维导图&quot;&gt;&lt;a href=&quot;#JDBC-思维导图&quot; class=&quot;headerlink&quot; title=&quot;JDBC 思维导图&quot;&gt;&lt;/a&gt;JDBC 思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在 JAVA 中，如何用代码和数据库进行交互呢？JDBC </summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SQL" scheme="https://xorex.space/tags/SQL/"/>
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="JDBC" scheme="https://xorex.space/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>SQL基本语句思维导图</title>
    <link href="https://xorex.space/2021/03/02/726651d44320/"/>
    <id>https://xorex.space/2021/03/02/726651d44320/</id>
    <published>2021-03-02T14:40:32.000Z</published>
    <updated>2021-03-02T14:50:59.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL-基本语句思维导图"><a href="#SQL-基本语句思维导图" class="headerlink" title="SQL 基本语句思维导图"></a>SQL 基本语句思维导图</h2><blockquote><p>其实暑假学习安全的时候，就学过一部分 SQL 的相关语句，但是都忘了，好在有了前面的基础，很快就复习好了，并且完成了这个思维导图，感觉更清晰了一点。</p></blockquote><iframe src="https://www.xmind.net/embed/wB36P6" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL-基本语句思维导图&quot;&gt;&lt;a href=&quot;#SQL-基本语句思维导图&quot; class=&quot;headerlink&quot; title=&quot;SQL 基本语句思维导图&quot;&gt;&lt;/a&gt;SQL 基本语句思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;其实暑假学习安全的时候，就学过一部</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SQL" scheme="https://xorex.space/tags/SQL/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库概念思维导图</title>
    <link href="https://xorex.space/2021/03/02/8adb5d7ef601/"/>
    <id>https://xorex.space/2021/03/02/8adb5d7ef601/</id>
    <published>2021-03-02T14:36:52.000Z</published>
    <updated>2021-03-02T14:51:38.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL-数据库概念思维导图"><a href="#MySQL-数据库概念思维导图" class="headerlink" title="MySQL 数据库概念思维导图"></a>MySQL 数据库概念思维导图</h2><blockquote><p>还是要了解一下什么是数据库才好啊！！！</p></blockquote><iframe src="https://www.xmind.net/embed/eZ6P3x" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL-数据库概念思维导图&quot;&gt;&lt;a href=&quot;#MySQL-数据库概念思维导图&quot; class=&quot;headerlink&quot; title=&quot;MySQL 数据库概念思维导图&quot;&gt;&lt;/a&gt;MySQL 数据库概念思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;还是要了解</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="SQL" scheme="https://xorex.space/tags/SQL/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>TodoList:2021-03</title>
    <link href="https://xorex.space/2021/02/23/e301ee97b31a/"/>
    <id>https://xorex.space/2021/02/23/e301ee97b31a/</id>
    <published>2021-02-23T13:34:24.000Z</published>
    <updated>2021-03-03T08:07:16.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于我寒假里面学习效率过低的问题"><a href="#关于我寒假里面学习效率过低的问题" class="headerlink" title="关于我寒假里面学习效率过低的问题"></a>关于我寒假里面学习效率过低的问题</h2><blockquote><p>因为想了想自己好像年后基本上就没怎么学东西了，即使看上去学习时间很长，但是效率真的是有些惨不忍睹，所以想了想还是需要努力提高自己的效率问题。那么大概总结了以后在学习的过程中，一些需要注意的方面。而每天结束的时候，都要看一看自己是否做到了下面的注意事项，最后将一天的学习内容和完成度记录下来，不断的提高自己的学习能力。加油，要成为一名优秀的软件工程师啊！</p></blockquote><ol><li><p>保证清醒的时间</p><ul><li>寒假光睡觉估计快把自己给睡傻了。所以以后作息必须严格要求自己，晚上 12:00 必须准时睡觉，寝室里小伙伴们在打游戏的话那可以适当的推迟睡觉的时间，然后按照保证大概 7.5 小时的晚上睡眠时间来规划早上起床的时间，保证不赖床！！！</li></ul></li><li><p>要有足够的休息。</p><ul><li>因为常常因为在出现问题的时候，会忍不住尝试一口气解决它，然后就会盯着屏幕看好几个小时，眼睛感到酸涩，头晕脑胀也舍不得停下来。但这实际上是降低了解决问题的效率的，还会有损身体健康，所以必须在软件绿屏的时候，停下来自己手头正在做的事情，去休息一小段时间。(刚刚在写下这段文字的时候就做到了，好耶！)</li></ul></li><li><p>要真正学懂里面的内容</p><ul><li>其实就是对于自己要学的东西，不是光看一边文档就行了（光看不思考怎么可能学会呢）。需要在看的同时使用思维导图来做笔记，从而达到强迫自己思考，最终加深理解。（自己学习的所有的东西都需要，注意是所有！）</li></ul></li><li><p>减少摸鱼的时间</p><ul><li>完全封禁 <code>weibo.com</code> <code>bilibili.com</code> <code>zhihu.com</code> 三个网站，只要坐在电脑面前，需要保证<strong>只能学习</strong>，绝对<strong>不做摸鱼</strong>的事情，而拿到手机，也不要漫无目的的刷新信息流，去看 bilibili 里面缓存的各种技术教程啊。以及 <a href="http://www.ruanyifeng.com/blog/">阮一峰</a> 博客上面的一些技术文章，闲暇的时候多看看嘛！</li></ul></li><li><p>每天一定量的运动</p><ul><li>运动是必不可少的，在学校规划到晚自习下课和 rfy 一起去操场跑步运动,要记住身体是革命的本钱哇。</li></ul></li><li><p>和道格的小伙伴们搞好关系</p><ul><li>虽说在一个实验室里面学习，但是到头来两个月都没有怎么说过话，想想还是要和道格的小伙伴们多交流，不然光和 IOTU 交流的话也太孤独了吧。（这个东西也要每天记录进度）</li></ul></li></ol><h2 id="关于我接下来学习方向的问题"><a href="#关于我接下来学习方向的问题" class="headerlink" title="关于我接下来学习方向的问题"></a>关于我接下来学习方向的问题</h2><blockquote><p>将接下来需要学习的知识点列一下，完成了就划掉。</p></blockquote><h3 id="大型阶段性目标"><a href="#大型阶段性目标" class="headerlink" title="大型阶段性目标"></a>大型阶段性目标</h3><ul><li><p><del>SQL 数据库的各种命令复习</del></p></li><li><p><del>JDBC 内容的学习</del></p></li><li><p>函数式编程</p></li><li><p>Java 设计模式</p></li><li><p>Java Web 开发</p></li><li><p>Spring Boot 开发</p></li><li><p>Spring Cloud 开发</p></li></ul><h3 id="小型随意目标"><a href="#小型随意目标" class="headerlink" title="小型随意目标"></a>小型随意目标</h3><ul><li><p><del>Windows10 C盘目录</del></p></li><li><p><del>Windows 开机流程</del></p></li></ul><h2 id="每日进度记录"><a href="#每日进度记录" class="headerlink" title="每日进度记录"></a>每日进度记录</h2><h3 id="03-01"><a href="#03-01" class="headerlink" title="03-01"></a>03-01</h3><ul><li><p>今天第一天开学，开心的是终于回到了校园里面，学习效率可以提高了，不开心的是，上课真的是太无聊了。早上因为没有课起床比较晚，明天要 7 点半起床，起来之后直接去实验室！摸鱼的时间还是有一点，不过时间利用还是挺高的，空闲时间看了几篇技术博客。因为没有晚自习就没有运动……，还是没有和道格的小伙伴们交流QAQ。</p></li><li><p>今天主要学习了 SQL 的一些拓展命令，还有 JDBC 的一些基础用法，感觉效率同样不是特别高的样子，还需要提高啊。明天要学 SQL 事务和 JDBC 事务，加油啊！！！</p></li></ul><h3 id="03-02"><a href="#03-02" class="headerlink" title="03-02"></a>03-02</h3><ul><li><p>今天主要学了 JDBC 的大部分内容，总算把数据库相关的内容给搞结束了，好耶！早上同样因为没有课程，所以起床比较晚，运动的话，晚自习是有的，但是因为下雨了，所以就没有去跑步，明天一定！！！</p></li><li><p>学习效率仍然不是非常高，明天仍然要加油啊，函数式编程，冲啊！！！</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于我寒假里面学习效率过低的问题&quot;&gt;&lt;a href=&quot;#关于我寒假里面学习效率过低的问题&quot; class=&quot;headerlink&quot; title=&quot;关于我寒假里面学习效率过低的问题&quot;&gt;&lt;/a&gt;关于我寒假里面学习效率过低的问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;因</summary>
      
    
    
    
    <category term="阶段性总结" scheme="https://xorex.space/categories/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="规划" scheme="https://xorex.space/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础思维导图【一】</title>
    <link href="https://xorex.space/2021/02/21/ffb6e1744ad2/"/>
    <id>https://xorex.space/2021/02/21/ffb6e1744ad2/</id>
    <published>2021-02-21T09:14:18.000Z</published>
    <updated>2021-02-21T09:18:02.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络基础思维导图"><a href="#计算机网络基础思维导图" class="headerlink" title="计算机网络基础思维导图"></a>计算机网络基础思维导图</h2><blockquote><p>思维导图主要介绍了和计算机网络相关的一些基本概念，以及介绍了一些非常基础的计算机通信的过程。</p></blockquote><iframe src="http://www.xmind.net/embed/ccBMp4" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机网络基础思维导图&quot;&gt;&lt;a href=&quot;#计算机网络基础思维导图&quot; class=&quot;headerlink&quot; title=&quot;计算机网络基础思维导图&quot;&gt;&lt;/a&gt;计算机网络基础思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思维导图主要介绍了和计算机网络相关的一些基</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="计算机网络" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="基础知识" scheme="https://xorex.space/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java的XML和JSON思维导图</title>
    <link href="https://xorex.space/2021/02/21/ea621b64d07c/"/>
    <id>https://xorex.space/2021/02/21/ea621b64d07c/</id>
    <published>2021-02-20T18:06:18.000Z</published>
    <updated>2021-02-21T16:25:51.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据文档思维导图"><a href="#数据文档思维导图" class="headerlink" title="数据文档思维导图"></a>数据文档思维导图</h2><blockquote><p>思维导图主要介绍了两种数据文档 XML 和 JSON 在 Java 中的数据解析方法。</p></blockquote><iframe src="https://www.xmind.net/embed/rc4VPM" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据文档思维导图&quot;&gt;&lt;a href=&quot;#数据文档思维导图&quot; class=&quot;headerlink&quot; title=&quot;数据文档思维导图&quot;&gt;&lt;/a&gt;数据文档思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思维导图主要介绍了两种数据文档 XML 和 JSON 在 Java</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="XML" scheme="https://xorex.space/tags/XML/"/>
    
    <category term="JSON" scheme="https://xorex.space/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>Java网络编程思维导图</title>
    <link href="https://xorex.space/2021/02/21/4766679f53f7/"/>
    <id>https://xorex.space/2021/02/21/4766679f53f7/</id>
    <published>2021-02-20T18:02:42.000Z</published>
    <updated>2021-02-21T16:25:47.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络编程思维导图"><a href="#网络编程思维导图" class="headerlink" title="网络编程思维导图"></a>网络编程思维导图</h2><blockquote><p>主要记录了使用 Java 实现服务端和客户端之间进行 TCP 协议和 UDP 协议之间通信的方法。</p></blockquote><iframe src="https://www.xmind.net/embed/QXFXMQ" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网络编程思维导图&quot;&gt;&lt;a href=&quot;#网络编程思维导图&quot; class=&quot;headerlink&quot; title=&quot;网络编程思维导图&quot;&gt;&lt;/a&gt;网络编程思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;主要记录了使用 Java 实现服务端和客户端之间进行 TCP 协议</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="计算机网络" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java的Maven基础思维导图</title>
    <link href="https://xorex.space/2021/02/21/21924715f1a8/"/>
    <id>https://xorex.space/2021/02/21/21924715f1a8/</id>
    <published>2021-02-20T18:02:24.000Z</published>
    <updated>2021-02-21T16:25:54.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven基础思维导图"><a href="#Maven基础思维导图" class="headerlink" title="Maven基础思维导图"></a>Maven基础思维导图</h2><blockquote><p>思维导图主要介绍了 Maven 的一些基本使用方法。</p></blockquote><iframe src="https://www.xmind.net/embed/eyFDrU" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Maven基础思维导图&quot;&gt;&lt;a href=&quot;#Maven基础思维导图&quot; class=&quot;headerlink&quot; title=&quot;Maven基础思维导图&quot;&gt;&lt;/a&gt;Maven基础思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思维导图主要介绍了 Maven 的一些基本</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="Maven" scheme="https://xorex.space/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Java加密与安全思维导图</title>
    <link href="https://xorex.space/2021/02/21/1b4cc7a4e155/"/>
    <id>https://xorex.space/2021/02/21/1b4cc7a4e155/</id>
    <published>2021-02-20T18:02:01.000Z</published>
    <updated>2021-02-21T16:23:56.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加密与安全思维导图"><a href="#加密与安全思维导图" class="headerlink" title="加密与安全思维导图"></a>加密与安全思维导图</h2><blockquote><p>思维导图主要记录了使用 Java 对数据进行各种加密解密的方法。</p></blockquote><iframe src="https://www.xmind.net/embed/yVNPMU" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;加密与安全思维导图&quot;&gt;&lt;a href=&quot;#加密与安全思维导图&quot; class=&quot;headerlink&quot; title=&quot;加密与安全思维导图&quot;&gt;&lt;/a&gt;加密与安全思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思维导图主要记录了使用 Java 对数据进行各种加密解密的</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="加密与安全" scheme="https://xorex.space/tags/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java正则表达式思维导图</title>
    <link href="https://xorex.space/2021/02/21/1521f5df53d5/"/>
    <id>https://xorex.space/2021/02/21/1521f5df53d5/</id>
    <published>2021-02-20T18:01:19.000Z</published>
    <updated>2021-02-21T16:26:10.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式思维导图"><a href="#正则表达式思维导图" class="headerlink" title="正则表达式思维导图"></a>正则表达式思维导图</h2><blockquote><p>思维导图主要记录了一下正则表达式的一些简单的使用方法。</p></blockquote><iframe src="https://www.xmind.net/embed/cFDKCv" width="900px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;正则表达式思维导图&quot;&gt;&lt;a href=&quot;#正则表达式思维导图&quot; class=&quot;headerlink&quot; title=&quot;正则表达式思维导图&quot;&gt;&lt;/a&gt;正则表达式思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思维导图主要记录了一下正则表达式的一些简单的使用方法。&lt;/</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="正则表达式" scheme="https://xorex.space/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java单元测试思维导图</title>
    <link href="https://xorex.space/2021/02/21/4555c3a37b23/"/>
    <id>https://xorex.space/2021/02/21/4555c3a37b23/</id>
    <published>2021-02-20T18:00:53.000Z</published>
    <updated>2021-02-21T16:26:44.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单元测试思维导图"><a href="#单元测试思维导图" class="headerlink" title="单元测试思维导图"></a>单元测试思维导图</h2><blockquote><p>思维导图主要介绍了如何使用 Junit 测试框架对代码进行测试。大概和 OI 中的测评差不多。</p></blockquote><iframe src="https://www.xmind.net/embed/9sFrRD" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单元测试思维导图&quot;&gt;&lt;a href=&quot;#单元测试思维导图&quot; class=&quot;headerlink&quot; title=&quot;单元测试思维导图&quot;&gt;&lt;/a&gt;单元测试思维导图&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思维导图主要介绍了如何使用 Junit 测试框架对代码进行测试。大</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="测试" scheme="https://xorex.space/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java日期与时间思维导图</title>
    <link href="https://xorex.space/2021/02/21/7e7fe64348b1/"/>
    <id>https://xorex.space/2021/02/21/7e7fe64348b1/</id>
    <published>2021-02-20T18:00:24.000Z</published>
    <updated>2021-02-21T16:26:20.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><blockquote><p>emmmm，因为自己是一只老懒狗了，发现完整的写博客真的是非常消耗时间的行为，所以想了想就改为只完成知识点的思维导图。这样的话花在记录的时间能减少很多，而且效果也非常接近，以后各种知识点大概都会以这样的方式来记录了！</p></blockquote><h2 id="旧版本的日期和时间思维导图"><a href="#旧版本的日期和时间思维导图" class="headerlink" title="旧版本的日期和时间思维导图"></a>旧版本的日期和时间思维导图</h2><blockquote><p>此思维导图记录了早期 Java 使用的日期和时间类，现在部分地方仍在使用，所以需要学习。</p></blockquote><iframe src="https://www.xmind.net/embed/KfjibH" width="800px" height="540px" frameborder="0" scrolling="no"></iframe><h2 id="新版本的日期和时间思维导图："><a href="#新版本的日期和时间思维导图：" class="headerlink" title="新版本的日期和时间思维导图："></a>新版本的日期和时间思维导图：</h2><blockquote><p>此思维导图是新版本的日期和时间类，相较于过去的类更加好用了。</p></blockquote><iframe src="https://www.xmind.net/embed/isNRTN" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;emmmm，因为自己是一只老懒狗了，发现完整的写博客真的是非常消耗时间的行为，所以想了想就改为只完</summary>
      
    
    
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="日期与时间" scheme="https://xorex.space/tags/%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程学习笔记</title>
    <link href="https://xorex.space/2021/02/21/575347381561/"/>
    <id>https://xorex.space/2021/02/21/575347381561/</id>
    <published>2021-02-20T17:59:38.000Z</published>
    <updated>2021-02-21T16:26:34.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p><strong>线程</strong>：<code>Thread</code>，是操作系统中能够进行任务调度的最小单位，一般来说是一条单独的任务，比如 bilibili 的视频解码器是一个线程，音频解码器是一条线程，弹幕显示器是一条线程，它们被一起包装在 bilibili 这个进程中，作为正在运行的应用程序。因此线程指的是进程中的一个单一顺序的控制流，一个进程中可以有多条线程，每条线程执行不同的任务。</p><p><strong>进程</strong>：<code>Process</code>， 是指计算机中运行的程序，直观体现是任务管理器中的一个个进程，进程本身不是基本运行单位，而是线程的容器，多个运行不同的线程组成了一个进程。而一个 Java 程序就是一个 JVM 进程，这个 JVM 进程中，主线程执行 main() 方法，而在 main() 线程中，又可以调用其他的线程实现多线程。</p><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p><strong>并发</strong>：<code>Concurrent</code>，是指计算机能够具备处理多个任务的能力，反义词是顺序。顺序执行时只能在执行完一个任务之后才能执行第二个任务，而并发可以“同时”执行多个任务，无论这个是通过将多个大任务分为一个个小任务，然后快速切换执行不同大任务的小任务运行实现的“同时”执行，还是真正的用两个处理器核心，不同核心专注执行不同任务实现的同时执行。两种方法都被成为并发。</p><p><strong>并行</strong>：<code>parallel</code> ，是指计算机真正意义上的同时处理两个任务，这在物理基础上需要 CPU 的两个单独的核心，然后使得两个任务的不同执行在同一时间在不同的核心上面被执行。并行是并发的一种情况（上面实现并发的第二种方法就是并行）。</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p><strong>分时调度</strong>：所有的线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p><p><strong>抢占式调度</strong>：根据优先度来分配线程的使用时间，优先度高的占用时间长，Java 采用此机制。</p><h3 id="两者的特点"><a href="#两者的特点" class="headerlink" title="两者的特点"></a>两者的特点</h3><p>对于一个复杂的应用程序，肯定是需要实现并发，也就是不同的小任务同时执行，比如 bilibili 的弹幕任务，视频解码任务和音频解码任务等。这些小任务的同时运行实现方法就是多个进程或者线程之间并发，亦或者两者一起。</p><p>创建一个进程的开销要比创建一个线程开销大很多，而且一个进程内部的多个线程之间的通信 开销很小（因为访问的是同一个变量），进程与进程之间的的通信开销就要大很多。</p><p>正是因为进程之间有一定的隔离，所以稳定性比多线程好很多。多个进程之间崩溃是互不影响的，而一个进程里面的线程一旦崩溃，这个进程中的所有线程都要受到影响。</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="main-线程"><a href="#main-线程" class="headerlink" title="main 线程"></a>main 线程</h3><p>在一个 Java 程序被执行的时候，是从 main 函数开始执行的，而 main 函数被执行的时候就是一个单独的线程，它的名字就叫做 main 线程。</p><p>首先 main 函数的代码会被放到内存的栈空间中，然后将这个空间和 CPU 建立一个桥梁，CPU 可以通过此桥梁读取此内存空间中的数据和指令，然后执行它。而这个桥梁就是线程，名字为 main 线程。</p><p>在执行 main 线程的时候，main 函数可能有创建一个新的线程的代码，当 CPU 运行 main 线程到此部分的时候，就会按照线程指令执行，开辟一个新的内存空间，放入数据和指令，然后建立一个自己到这个空间的桥梁命名为 func1 线程，用来读取数据和执行放入的指令。这就成功的在 JVM 进程的 main 线程中新建了第二个线程 func1 到此进程中，实现了多线程。</p><p>这个两个线程组成的多线程是可以实现并发的，也就是两个线程 main 和 func1 的任务可以“同时”运行。这是单独一个线程无法实现的，单独一个线程只能顺序执行里面的指令。</p><h3 id="线程建立过程"><a href="#线程建立过程" class="headerlink" title="线程建立过程"></a>线程建立过程</h3><h4 id="方法一：继承Thread"><a href="#方法一：继承Thread" class="headerlink" title="方法一：继承Thread"></a>方法一：继承Thread</h4><p>建立一个新的线程的方法就是新建一个类，继承于 Thread 类。然后在子类中重写 Thread 类里的 run() 方法，这个方法里面是需要新线程同步执行的代码。然后调用子类实例的 start() 方法，就成功的建立了一个新的线程，此线程和 main 线程并发执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread Xorex=<span class="keyword">new</span> WorkTogether(<span class="string">&quot;The Second Thread.&quot;</span>);</span><br><span class="line">        Xorex.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkTogether</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkTogether</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Tempest&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是新建了一个继承于 <code>Thread</code> 的线程类 <code>WorkTogether</code>，然后建立一个名为 <code>The Second Thread.</code> 的线程，通过 <code>start()</code> 的调用开始并发执行此线程的 <code>run()</code> 方法和 main 线程 后面的代码 。</p><p>程序运行的结果就是 Tempest 和 Xorex 两个字符串随机被打印出来，因为是并发，所以可以看作两个循环在“同时”运行，至于某一个细小的时间段具体是在运行谁，则完全由 CPU 随机决定。两个线程的运行是互不干扰的，因为建立一个新的线程的时候，就会开辟一块新的栈空间，因为内存空间不同，则运行相互独立。</p><p>如果我们不调用新线程类实例的 <code>start()</code> 方法而是直接调用 <code>run()</code> 方法，则不会启动新线程，而是把 <code>run()</code> 方法代码压栈到 main 线程的栈空间中，在 main 线程中顺序执行 <code>run()</code> 方法，执行完毕之后，再执行后面的代码而不是一起并发运行。</p><h4 id="方法二：传入Runnable"><a href="#方法二：传入Runnable" class="headerlink" title="方法二：传入Runnable"></a>方法二：传入Runnable</h4><p>Runnable 是一个接口，实现这个 Runnable 接口只需要重写一个 run() 类，和继承 Thread 的重写 run() 几乎相同，不同的是 ，这里实现了线程和执行内容的分离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span></span>;</span><br></pre></td></tr></table></figure><p>直接在 Thread 的构造方法中，传入一个实现了 Runnable 的类的实例即可，然后调用 Thread 实例的 start() 方法启动并运行线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread Xorex=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;This is an another thread!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Xorex.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面方法传入的 Runnable 实现类就是一个匿名类，传入 Thread 的构造方法之后创建线程，再用实例 Xorex 的 start() 方法启动线程。</p><h4 id="方法三：使用-Lambda-表达式"><a href="#方法三：使用-Lambda-表达式" class="headerlink" title="方法三：使用 Lambda 表达式"></a>方法三：使用 Lambda 表达式</h4><p>其实方法三和上面的方法二本质上是一样，唯一的不同就是使用了 Java8 新加入的 Lambda 表达式简化了代码。</p><p>首先忽略 λ Lambda 这个奇奇怪怪的名字，这个代码简化其实贼简单，就是个<strong>实例化匿名类</strong>的语法糖，它可以将所有能够逻辑推断出来的东西全部省略，但只有一个限制，就是这个类里面<strong>只能有一个方法</strong>，下面是使用 Lambda 表达式简化的线程建立：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread Xorex=<span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;This is an another thread&quot;</span>)); <span class="comment">//</span></span><br><span class="line">        Xorex.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是最简状态的实例化匿名类的代码，少了 <code>new Runnable()</code> 因为编译器可以通过 Thread 构造方法接收 Runnable 接口对象来推断出来这个类实现了 Runnable 接口。少了重写方法的签名 <code>public void run()</code> 是因为这个接口只有一个抽象方法等待重写，肯定是它。少了<code>&#123;;&#125;</code> 大括号和分号是因为里面只有一句语句，当然如果有多语句的话，还是需要 <code>&#123;&#125;</code> 来确定语句范围，需要 <code>;</code> 来将多个语句分隔开来。至于剩下的 Lambda 表达式标志 <code>() -&gt;</code> 其中 <code>()</code> 表示是一个方法，里面用来填写参数（可省略类型，因为可以根据抽象方法推断出来），没有参数就空着。而 <code>-&gt;</code> 则是 Lambda 的根本标志符号，必不可少。</p><p>如果需要返回参数呢，有两种方式，一种是单表达式语句，这种就按照最简写即可，而会自动返回表达式计算的结果，如果是多语句，则需要自己写 return 返回值。</p><p>下面是对 Lambda 表达式的三种情况总结：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">( params ) -&gt; expression</span><br><span class="line">( params ) -&gt; statement</span><br><span class="line">( params ) -&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure><p>第一种举个例子：<code>(int e) -&gt; e*e</code> 因为是一个 expression 直接返回这个表达式计算值。</p><p>第二种举个例子：<code>(int e) -&gt; e=e*e</code> 是一个单语句 statement 则返回空 void 。</p><p>第三种举个例子：只要有大括号，就必须手写 return 语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> e) -&gt; &#123;<span class="keyword">return</span> e*e;&#125;</span><br><span class="line">(<span class="keyword">int</span> e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> e2=e*e;</span><br><span class="line">    <span class="keyword">return</span> e2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda 表达式里面的各种特性还有很多，以后遇到了会好好总结一下的！</p><h3 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a>Thread 类</h3><p>上面只是利用 Thread 类新建了一个线程，而 Thread 类中还有很多好用的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span></span>; <span class="comment">//构造方法，设置线程名称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>; <span class="comment">//设置线程名称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span></span>; <span class="comment">//构造方法，设置线程运行代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span></span>; <span class="comment">//设置线程优先级，1-10，默认5</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>; <span class="comment">//运行此进程，并执行run()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="comment">//静态方法，正在执行的线程以毫秒数暂停</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span> <span class="comment">//返回对当前正在执行的线程对象的引用</span></span></span><br></pre></td></tr></table></figure><ul><li>首先对于 <code>setPriority</code> 方法并不能保真正优先执行此线程，而是增加了此线程被执行的概率，总体来说被执行次数会高于优先级低的线程。</li><li>其次是 <code>sleep</code> 方法是一个静态方法，在被当前线程执行的时候，当前线程就会暂停执行对应毫秒，因为此方法被执行肯定是在某个线程中被执行的，所以暂停的线程也肯定是它所在的线程。</li><li>最后 <code>currentThread</code>  方法会返回当前执行的线程对象的引用，需要用 Thread 来接收，本质上和正在运行的线程是一个实例。</li></ul><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>对于一个线程来说，它也有自己的声明周期，在 Java 中，一个线程的声明周期有以下几种：</p><ul><li><code>New</code> 新建状态：线程处于正在被生成的过程。</li><li><code>Runnable</code> 就绪状态：线程处于可以被执行状态。</li><li><code>Timeed Waiting</code> 等待时间状态：线程处于基于时间的等待状态。</li><li><code>Waiting</code> 等待状态：线程处于等待唤醒状态。</li><li><code>Blocked</code> 阻塞状态：线程处于无法被执行状态。</li><li><code>Terminated</code> 死亡状态：线程处于被终止的状态。</li></ul><p><img src="https://xorex.space/image/157.jpg" alt="preview"></p><h3 id="Runnable-状态"><a href="#Runnable-状态" class="headerlink" title="Runnable 状态"></a>Runnable 状态</h3><p>其实 Runnable 是两种子状态的一个概括，总的来说是可被执行状态分为就绪状态和被执行状态，也就是上图对应的 Ready 和 Running 状态。</p><p>我们不需要关心程序处于 Runnable 的时候，具体是在等待 CPU 调度还是正在 CPU 上运行，因为这是我们无法控制的，分配计算资源完全是操作系统干的，作为上层的应用程序我们无法干涉，所以就统称为 Runnable 可运行状态。</p><h3 id="Waiting-和-Timed-Waiting-状态"><a href="#Waiting-和-Timed-Waiting-状态" class="headerlink" title="Waiting 和 Timed Waiting 状态"></a>Waiting 和 Timed Waiting 状态</h3><p>这两个状态基本相同，都是主动的放弃 CPU 被执行权，主动进入了等待状态。不同的是，Waiting 是无限期等待，需要被另外一个线程唤醒才能进入 Runnable 状态，而 Timed  Waiting 是主动放弃我们设定的一定时间的 CPU 被执行权，过了这段时间，它会自己醒来，进入 Runnable 状态。</p><h3 id="Blocked-状态"><a href="#Blocked-状态" class="headerlink" title="Blocked 状态"></a>Blocked 状态</h3><p>这个状态被称为阻塞状态，无法进入 Runnable 并不是因为主动放弃，而是无法获得执行权，或者说此线程被锁上了并且钥匙不在自己的手上。一旦此线程拿到钥匙，就会解锁进入 Runnable 状态。</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>多线程虽然很棒，不仅仅能通过 CPU 的快速切换实现“同时”执行多个连续任务，还能利用 CPU 本身硬件支持的多核多线程来真正同时执行多个线程，大幅度提高计算效率。比如 R5 4500U 就拥有六个核心，对于一个任务开六个线程可以让这六个核心同时去处理它，从而获得六倍的运行速度。</p><p>但是要知道对于处理器在运行语句的时候，不知道快速切换或者多核心实际运行位置所在之处。当多个线程需要同时对统一数据进行写入的时候，就会导致线程安全的问题。硬核一点，看一个语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n=n+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//对应了下面三个指令：</span></span><br><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure><p>如果有两个线程同时对 n 变量进行上述语句的运行，因为不知道啥时候就丧失了 CPU 运行权，由另外一个线程运行，所以就可能出现下面的运行情况，在 Thread1 执行完 ILOAD 指令之后，丧失 CPU 执行权，由 Thread2 执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌───────┐    ┌───────┐</span><br><span class="line">│Thread1│    │Thread2│</span><br><span class="line">└───┬───┘    └───┬───┘</span><br><span class="line">    │            │</span><br><span class="line">    │ILOAD (100) │</span><br><span class="line">    │            │ILOAD (100)</span><br><span class="line">    │            │IADD</span><br><span class="line">    │            │ISTORE (101)</span><br><span class="line">    │IADD        │</span><br><span class="line">    │ISTORE (101)│</span><br><span class="line">    ▼            ▼</span><br></pre></td></tr></table></figure><p>两个线程两次执行 <code>n=n+1</code> ，但是 n 的值只加了 1 ，这就是因为线程在读取写入数据的不同步导致的，这可是个大问题。我们再看一个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Runnable RunCode=()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(Tempest.count!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Tempest.count--;</span><br><span class="line">                System.out.println(Tempest.count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Thread Th1=<span class="keyword">new</span> Thread(RunCode);</span><br><span class="line">        Thread Th2=<span class="keyword">new</span> Thread(RunCode);</span><br><span class="line"></span><br><span class="line">        Th1.start();</span><br><span class="line">        Th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码在同时执行  Th1 和 Th2 两个线程的时候，都会对同一个数据 count 进行读写操作，因为线程执行权切换可能发生在 count– 和输出 count 之间发生，所以看输出结果就会发现顺序是乱的，这就是因为线程代码不同步造成的，</p><p>线程同步，也就是一个线程中，某个过程应该连续同步完成，不允许中断。而实现线程同步，就需要将同步代码上锁，保证只有一个线程有钥匙打开并执行它，其它线程无法打开执行。</p><h3 id="1-同步代码块"><a href="#1-同步代码块" class="headerlink" title="1. 同步代码块"></a>1. 同步代码块</h3><p>一种是使用同步代码块这种语法将需要同步执行的一些代码框到里面，然后加上一个锁，只有拿到钥匙才能执行里面的内容，只需要保证钥匙的唯一性，就可以保证在同一时间，因为只有一个线程拥有钥匙，所以只有一个线程会执行锁里面的代码。当里面代码执行完毕之后，会将钥匙随机传给下一个线程，这个线程打开自己的锁，执行锁里面的代码。在这里，锁就是 <code>synchronized</code> 关键词，它锁住了代码块里面的代码，钥匙就是参数 <code>key</code> ，它需要是一个唯一的实例，用来解锁并执行内部代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object key) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Runnable RunCode=()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="string">&quot;Xorex&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(Tempest.count!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Tempest.count--;</span><br><span class="line">                    System.out.println(Tempest.count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread Th1=<span class="keyword">new</span> Thread(RunCode);</span><br><span class="line">        Thread Th2=<span class="keyword">new</span> Thread(RunCode);</span><br><span class="line"></span><br><span class="line">        Th1.start();</span><br><span class="line">        Th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就将同步代码使用 <code>synchronized</code> 语句上锁，然后设置字符串实例 <code>&quot;Xorex&quot;</code> 作为钥匙。在代码执行的时候，只有拥有钥匙的线程才能打开锁执行代码，锁代码执行完毕之后，会释放钥匙，释放的钥匙会随机传给下一个线程，注意可能会出现自己传给自己的情况，毕竟是随机传。</p><h3 id="2-同步方法"><a href="#2-同步方法" class="headerlink" title="2. 同步方法"></a>2. 同步方法</h3><p>同步方法和同步代码块的使用原理是一模一样的，但是不同的是这里将 <code>synchronized</code> 修饰词词用于某个方法的签名，这样在调用这个方法的时候，默认为这个方法里面的代码上了锁，只有此线程有钥匙才能解锁执行，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">Eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tempest.count--;</span><br><span class="line">    System.out.println(<span class="string">&quot;The rest count:&quot;</span>Tempest.count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为不能传 key 参数，所以这里面的钥匙是不能自定义的，是固定的。</p><p>对于像上面一样的普通方法，key 为拥有此方法的实例 <code>this</code> 。</p><p>而对于静态方法，因为和实例无关，只和类有关，所以 key 为此类的 Class 实例。</p><h3 id="3-同步锁-Lock"><a href="#3-同步锁-Lock" class="headerlink" title="3. 同步锁 Lock"></a>3. 同步锁 Lock</h3><p>同步锁是一个接口，它的作用和 <code>synchronized</code> 有一样的地方，但是 Lock 的功能更强大，至于强大的功能以后再说，先看 Lock 接口的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>; <span class="comment">//开始获取锁，如果其他线程已经占用，则等待</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>; <span class="comment">//尝试获取锁，如果成功返回 true，如果锁被占用返回 false 并等待锁。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>; <span class="comment">//解锁</span></span><br></pre></td></tr></table></figure><p>大概就先了解这几个就可以了，需要注意的是这个是不会自动返还锁的，所以一旦在获取锁之后的代码里面，遇到了异常，就会中断代码，后面的释放锁操作就无法执行，所以在使用 Lock 的时候，需要配合这 try-catch 语句，将 unlock() 放到 finally 里面。</p><p>实现 Lock 接口的唯一类为：<code>ReentrantLock</code>，使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">        Runnable RunCode=()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(Tempest.count&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Tempest.count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        Tempest.count--;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  &quot;</span>+Tempest.count);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread Th1=<span class="keyword">new</span> Thread(RunCode,<span class="string">&quot;Thread01&quot;</span>);</span><br><span class="line">        Thread Th2=<span class="keyword">new</span> Thread(RunCode,<span class="string">&quot;Thread02&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Th1.start();</span><br><span class="line">        Th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>在 <code>synchronized</code> 同步代码块或者同步方法的地方，只要这个线程获取了唯一的钥匙，那么遇到相同的锁，都可以打开，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="string">&quot;Xorex&quot;</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="string">&quot;Xorex&quot;</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码，最内层的代码一定是可以执行的，因为两个锁的钥匙相同，只要获取了第一个锁的钥匙 <code>&quot;Xorex&quot;</code>  String 实例，那么第二个锁也因为有了钥匙可以打开。这样的锁叫作可重入锁。</p><h3 id="产生死锁"><a href="#产生死锁" class="headerlink" title="产生死锁"></a>产生死锁</h3><p>死锁是因为两个线程在等待钥匙的时候，资源获取进入僵局，使得无法结束等待的情况称为死锁。</p><p>比如：两个线程，分别持有钥匙1和钥匙2，有钥匙1的同时在请求钥匙2，有钥匙2的同时在请求钥匙1。两个线程都进入了等待钥匙的状态，而自己持有的钥匙无法释放，导致了对方也陷入僵局。</p><p>一旦出现了死锁，只能停止执行代码，所以一定要尽力避免出现死锁的情况。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="普通线程池"><a href="#普通线程池" class="headerlink" title="普通线程池"></a>普通线程池</h3><p>线程池就是线程的集合体，通过将线程保存在线程池中来反复利用已经有的线程。因为单独的一个线程的新建和销毁都需要消耗很多资源，所以这样将线程集合在一起，需要了就给他分配任务执行的方式能很好的管理线程。</p><p>新建线程池是通过 Executors 类的三个静态方法来返回一个 ExecutorService 接口的实现实例，一共有三种线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newFixedThreadPool(<span class="keyword">int</span> nThreads) <span class="comment">// 固定数量线程池需要输入参数线程数量</span></span><br><span class="line">newCachedThreadPool() <span class="comment">// 可变数量线程池，会自己根据任务调整</span></span><br><span class="line">newSingleThreadExecutor() <span class="comment">// 单线程线程执行器</span></span><br></pre></td></tr></table></figure><p>通过静态方法得到一个 ExecutorService 接口实现类的实例之后，调用 submit(Runnable) 并传入一个 Runnable 实现实例之后线程会自动运行。</p><p>最后需要调用线程池的方法 shutdown() 来关闭线程池，不然 Java 程序不会结束运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService Xorex=Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        Runnable task=() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Xorex.submit(task);</span><br><span class="line">        Xorex.submit(task);</span><br><span class="line">        Xorex.submit(task);</span><br><span class="line">        Xorex.submit(task);</span><br><span class="line"></span><br><span class="line">        Xorex.shutdown();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反复线程池"><a href="#反复线程池" class="headerlink" title="反复线程池"></a>反复线程池</h3><p>当线程任务需要不断地重复执行的时候，就需要反复线程池了，接口为 ScheduledExecutorService ，而获取线程池的实例还是依靠 Executors 类的静态方法，不过这里只需要找名字里带有 Scheduled 的即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService Xorex=Executors.newScheduledThreadPool(<span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>拿到了一个反复线程池之后，自然要分配任务并且设定反复执行的时间之类的参数。这里 ScheduledExecutorService 接口启动线程方法变成了好几个，对应不同的反复模式：</p><p>延迟执行设定，delayTime 之后开始运行，执行 Runnable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schedule(Runnable,<span class="keyword">int</span> delayTime, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>固定速率执行设定，delayTime 之后开始运行，每次执行完任务每隔 RepeatDelayTime 之后再次重复执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduleAtFixedRate(Runnable,<span class="keyword">int</span> delayTime,<span class="keyword">int</span> RepeatDelayTime, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>固定时间执行设定，delayTime 之后开始运行，每隔 RepeatStartTime 重启线程任务，不管此线程是否执行完任务，都会重启线程，重新执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ses.scheduleWithFixedDelay(Runnable,<span class="keyword">int</span> delayTime,<span class="keyword">int</span> RepeatStartTime, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><iframe src="https://www.xmind.net/embed/uW3Rg8" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;h3 id=&quot;线程和进程&quot;&gt;&lt;a href=&quot;#线程和进程&quot; class=&quot;headerlink&quot; title=&quot;线程和进程&quot;&gt;&lt;/a&gt;线程和进</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="笔记" scheme="https://xorex.space/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="多线程" scheme="https://xorex.space/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java输入输出流学习笔记</title>
    <link href="https://xorex.space/2021/02/21/6b113700fd3d/"/>
    <id>https://xorex.space/2021/02/21/6b113700fd3d/</id>
    <published>2021-02-20T17:58:59.000Z</published>
    <updated>2021-02-21T16:25:43.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件-File-类"><a href="#文件-File-类" class="headerlink" title="文件 File 类"></a>文件 File 类</h2><h3 id="创建-File-实例"><a href="#创建-File-实例" class="headerlink" title="创建 File 实例"></a>创建 File 实例</h3><p>首先在进行输入输出处理之前，我们来看看数据的载体——文件。</p><p>因为我们在内存中存储的数据都是暂时的，一旦断电，都会消失，所以通常我们会把数据以文件的形式存储到永久存储的硬盘中，可以说，数据的操作单位就是文件。而 Java 中的 File 类就是专门对文件进行概括的一个类，它能很好的控制一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File file=<span class="keyword">new</span> File(<span class="string">&quot;Xorex.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面我们通过给构造方法传入一个文件的路径，成功实例化了 File 类。这个实例就是 <code>Xorex.txt</code> 这个文件，上面我们传入了 <code>Xorex.txt</code>  这个文件的相对路径，可以唯一确定这个文件，当然绝对路径也是可以的：<code>E:\\Java\\Xorex.txt</code> 。</p><p>需要注意的是，在不同的操作系统中，路径的表示是不同的，Windows 里面使用 <code>\</code> 表示路径分隔符，而 Linux 里面使用 <code>/</code> 表示路径分隔符。又因为在字符串中 <code>\</code> 表示转义，所以在写绝对路径或者相对路径的时候，需要用 <code>\\</code> 来分隔路径。</p><h3 id="得到文件路径"><a href="#得到文件路径" class="headerlink" title="得到文件路径"></a>得到文件路径</h3><p>得到文件路径中，File 类里面有三种不同的方法，分别是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getPath(); <span class="comment">// 返回构造方法传入的的路径</span></span><br><span class="line">getAbsolutePath(); <span class="comment">// 若构造方法为相对路径，则和当前路径拼接成绝对路径之后返回。若为绝对路径，则直接返回构造方法传入的绝对路径。</span></span><br><span class="line">getCanonicalPath(); <span class="comment">// 返回标准的绝对路径，会将 .// ..// 这些转化。</span></span><br></pre></td></tr></table></figure><h3 id="获取-File-实例的信息"><a href="#获取-File-实例的信息" class="headerlink" title="获取 File 实例的信息"></a>获取 File 实例的信息</h3><p>对于一个通过路径得到的 File 实例，如果路径结尾是一个文件名，那么 File 实例就是这个文件，如果是一个文件夹的名字，那么 File 实例就是这个文件夹。两者都可以被 File 类表示。</p><p>对于确定了一个文件/文件夹的 File 实例，我们可以通过方法获取一些这个文件/文件夹的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> 是否为文件</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span> 是否为文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span> 是否可读</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span> 是否可写</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canExecute</span><span class="params">()</span> 是否可执行/可列出来（可执行指 JVM 是否有权限读取、修改它）</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> 文件大小</span></span><br></pre></td></tr></table></figure><p>如果确定了这个实例是一个文件夹，那么还可以使用下面的方法来获取文件夹里面的东西。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] list() <span class="comment">// 以字符串列出所有内容 </span></span><br><span class="line">String[] list(FileNameFilter) <span class="comment">// 传入 FilenameFilter 接口的实例过滤列出内容</span></span><br><span class="line">File[] listFiles() <span class="comment">// 以 File 文件列出所有内容 </span></span><br><span class="line">File[] listFiles(FileFilter) <span class="comment">// 传入 FileFilter 接口的实例过滤列出内容</span></span><br><span class="line">File[] listFiles(FileNameFilter) <span class="comment">// 传入 FilenameFilter 接口的实例过滤列出内容</span></span><br></pre></td></tr></table></figure><h3 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h3><p>如果我们给的路径源文件不存在，可以直接创建，如果存在了，可以直接删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="comment">// 文件路径的所有文件夹必须全部都存在才能创建成功</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span> <span class="comment">// 删除文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">deleteOnExit</span><span class="params">()</span> <span class="comment">// JVM 结束运行时删除此文件</span></span></span><br></pre></td></tr></table></figure><p>我们还可以用 File 的静态方法创建一个临时文件，这个临时文件默认保存在 C 盘用户文件夹下面等等等的一个叫作 Temp 的文件夹。我们可以自定义这个临时文件的前缀和后缀，甚至是保存地点，这个临时文件的名字会在前缀和后缀之间加上一串随机数，且不会自动删除，所以最好获得临时文件的实例之后直接调用 <code>deleteOnExit()</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">File <span class="keyword">static</span> <span class="title">createTempFile</span><span class="params">(prefix,suffix,[File])</span> </span></span><br></pre></td></tr></table></figure><p>可选参数 File ，为是否改变默认的保存地址为 File 的地址（需要传入的 File 实例是一个文件夹，然后临时文件创建到这个文件夹中）。</p><h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span> <span class="comment">//创建文件夹，必须前面路径的文件夹存在才能创建成功。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> <span class="comment">//创建全路径文件夹，若前面路径不存在则自动创建。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span> <span class="comment">// 文件夹目录为空才能删除。</span></span></span><br></pre></td></tr></table></figure><h2 id="字节-IO-流"><a href="#字节-IO-流" class="headerlink" title="字节 IO 流"></a>字节 IO 流</h2><h3 id="try-resource-catch-语句"><a href="#try-resource-catch-语句" class="headerlink" title="try(resource)-catch 语句"></a>try(resource)-catch 语句</h3><p>InputStrean 和 OutputStream 这种流 IO 在运行的时候会占用各种资源，所以在结束流之后关闭流来释放资源是很有必要的。但是对于这种操作，往往可能关闭的不太顺利，可能出现流正在被使用无法关闭的情景，所以 <code>try-catch</code> 语句也就常常伴随着 close() 的调用而出现，来解决流关闭失败后的处理。</p><p>但是用一次 close() 就写一个  <code>try-catch</code> 有点麻烦了，Java 就给了一个小语法糖：<code>try(resource)-catch</code> 语句。这个语句和 <code>try-catch</code> 的区别就是对于在<code>(resource)</code> 这里开启的资源，结束运行之后，会自动调用资源的 close() 方法。因此能使用 <code>try(resource)-catch</code> 的语句必须拥有 close() 方法，也就是实现 closeable 接口。</p><p>正巧 IOStream 都实现了这个接口，就可以使用上面的语句是申请 IO 流资源而不用写关闭代码，因为编译器会自动帮忙写，所以也是一个语法糖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="keyword">new</span> InputStream(File)) &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">&#125; <span class="comment">// 结束运行之后会自动调用 close() 来关闭流</span></span><br></pre></td></tr></table></figure><p>看源代码发现，这个 InputStream 和 OutputStream 抽象类实现了 Closeable 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span></span></span><br></pre></td></tr></table></figure><p>而这个 Colseable 接口只有一个方法，就是 close() 方法， 也是我们对 IOStream 类操作的时候，最后需要释放资源时使用的 close() 方法。只要这个类实现了 Closeable 接口，那么就可以应用在 <code>try(resource)-catch</code> 语句里面，运行结束之后自动关闭流。</p><h3 id="InputStream：FileInputStream"><a href="#InputStream：FileInputStream" class="headerlink" title="InputStream：FileInputStream"></a>InputStream：FileInputStream</h3><p>对于从文件中读取，使用 InputStream 的子类 FileInputStream，在构造方法传入 File 实例或者一个文件路径的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="comment">//自己根据路径找文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="comment">//借助File实例找文件</span></span></span><br></pre></td></tr></table></figure><p>确认文件之后就可以使用内置的 read() 方法读取文件内容了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="comment">//一次读取一个字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="comment">//一次读取b数组大小的字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//off是指读取的内容写入b数组中的起始位置，len表示写入的字节长度</span></span></span><br></pre></td></tr></table></figure><h3 id="OutputStream：FileOutputStram"><a href="#OutputStream：FileOutputStram" class="headerlink" title="OutputStream：FileOutputStram"></a>OutputStream：FileOutputStram</h3><p>对于向文件写入，使用 OutputStream 的子类 FileOutputStream，在构造方法传入 File 实例或者一个文件路径的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name)</span> <span class="comment">//传入文件路径覆盖写入</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name, <span class="keyword">boolean</span> append)</span> <span class="comment">//append为true时往文件末尾写入</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file)</span> <span class="comment">//传入File实例获取路径</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span> <span class="comment">//append为true时往文件末尾写入</span></span></span><br></pre></td></tr></table></figure><p>确认文件之后就可以使用内置的 write() 方法向文件中写入内容了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="comment">//读取一个字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="comment">//读取一个字节数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//设置写入文件的数据中，在b数组的起始位置off以及总长度len</span></span></span><br></pre></td></tr></table></figure><p>在 Java 中为了效率，有了输入输出的缓冲区，只有缓冲区内数据到达一定程度，才会真正的写入到文件中，但是有些情况我们需要即使写入，那么就可以调用 flush() 来将缓冲区的数据直接写入到文件中。</p><h3 id="Filter-设计模式"><a href="#Filter-设计模式" class="headerlink" title="Filter 设计模式"></a>Filter 设计模式</h3><p>因为对于 IO 的输入输出来说，有的时候我们想要在输入输出的同时添加一些额外的工作，比如加密，解码等等。在通常情况下，解决方法就是单独写一个类继承于 IOStream 然后添加新功能，但当各种小功能需要排列组合使用的时候，就会引起功能类数量爆炸的情况，所以这里引入了 Filter 的设计模式，来对功能类进行排列组合。</p><p>首先要实现的功能需要继承于 FilterInputStream/FilterOutputStream ，然后功能类的构造方法参数为 IOStream 并用 super() 传给 Filter 类的构造方法，最后就可以重写 read() 和 write() 方法，使用原输入输出就用 in.read() 或者 out.write() ，只需要前后添加新功能即可，类似于普通代理。</p><p>有了功能类之后，就可以利用在构造方法中不停套娃其他的功能类，实现功能的排列组合，一个简单的对输出数据进心 base64 加密的功能类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FilterOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file=<span class="keyword">new</span> File(<span class="string">&quot;Xorex.Tempest&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>(Base64OutputString BaseOut=<span class="keyword">new</span> Base64OutputString(<span class="keyword">new</span> FileOutputStream(file))) &#123; </span><br><span class="line">            BaseOut.write(<span class="string">&quot;I like coding!&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base64OutputString</span> <span class="keyword">extends</span> <span class="title">FilterOutputStream</span> </span>&#123;</span><br><span class="line">    Base64OutputString(OutputStream out) &#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.write(Base64.getEncoder().encode(b));       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Filter 父类里面的构造方法其实就是将传入的输入流实例赋值给 in 或者 out，然后这个可以被子类重写方法的时候调用，从而实现功能的组合。</p><p>剩下的东西不太想写了，鸽了。以后直接上传思维导图好了。</p><p>主要 IO 框架的思维导图：</p><iframe src="https://www.xmind.net/embed/kSC5hQ" width="800px" height="540px" frameborder="0" scrolling="no"></iframe><p>IO 相关类的继承关系的思维导图：</p><iframe src="https://www.xmind.net/embed/wLEzaX" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件-File-类&quot;&gt;&lt;a href=&quot;#文件-File-类&quot; class=&quot;headerlink&quot; title=&quot;文件 File 类&quot;&gt;&lt;/a&gt;文件 File 类&lt;/h2&gt;&lt;h3 id=&quot;创建-File-实例&quot;&gt;&lt;a href=&quot;#创建-File-实例&quot; cla</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="思维导图" scheme="https://xorex.space/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
    <category term="笔记" scheme="https://xorex.space/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="IO" scheme="https://xorex.space/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习笔记【二】</title>
    <link href="https://xorex.space/2021/02/21/3fb2b83273fd/"/>
    <id>https://xorex.space/2021/02/21/3fb2b83273fd/</id>
    <published>2021-02-20T17:58:13.000Z</published>
    <updated>2021-02-21T08:02:24.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>因为这个和 IO 的流输入流输出有关，所以日后再来补坑。</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>首先来看看 Queue 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里可以看到是和 List 同级别的接口，都继承了 collection，顾名思义啊，这个 Queue 就是一个实现了队列功能的集合，First In First Out 先进先出。</p><p>而在 Java 中，实现 Queue 接口的类是：LinkedList，虽说它叫作  LinkedList ，但是它实际上是实现了 List 和 Queue 两个接口。我们可以向上转型为 Queue，然后把它当作队列的实例使用。</p><p>看一看 Queue 里面封装的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">//向队列尾部加入元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>; <span class="comment">//向队列尾部加入元素</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>; <span class="comment">//返回队头元素，并删除</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>; <span class="comment">//返回队头元素，并删除</span></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>; <span class="comment">//返回队头元素，但不删除</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>; <span class="comment">//返回队头元素，但不删除</span></span><br></pre></td></tr></table></figure><p>上面相同的功能有两种不同的方法实现，一个是常用词（add，remove，element），另一个是非常用词（offer，poll，peek），两者的区别就是前者出错时直接抛出异常，后者时返回 null。</p><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>优先队列，在 Java 中使用堆结构实现。为 PriorityQueue 类，并实现了 Queue 接口。其所拥有的的方法和 Queue 差不多，唯一的不同是队列开头的元素是按照自己要求排出来的第一。</p><p>因为涉及到了比较，所以和 TreeMap 以及 Collections.sort() 一样，要么在元素的类中实现 Comparable 接口中的 compareTo() 方法，要么在建立 PriorityQueue 实例的时候传入一个 Comparator 的匿名类进去。</p><h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>Deuqe 是个双端队列，双端队列故名思意就是可以在队列头和队列尾都添加元素的队列，同样是实现了FIFO先进先出的特性。ArrayDeque 和 LinkedList 两者实现了 Deque 接口（好家伙 LinkedList 也太全能了吧），而 Deque 接口规定了必须要实现的方法：</p><table><thead><tr><th align="left">功能</th><th align="left">Deque</th></tr></thead><tbody><tr><td align="left">添加元素到队尾</td><td align="left">addLast(E e) / offerLast(E e)</td></tr><tr><td align="left">取队首元素并删除</td><td align="left">E removeFirst() / E pollFirst()</td></tr><tr><td align="left">取队首元素但不删除</td><td align="left">E getFirst() / E peekFirst()</td></tr><tr><td align="left">添加元素到队首</td><td align="left">addFirst(E e) / offerFirst(E e)</td></tr><tr><td align="left">取队尾元素并删除</td><td align="left">E removeLast() / E pollLast()</td></tr><tr><td align="left">取队尾元素但不删除</td><td align="left">E getLast() / E peekLast()</td></tr></tbody></table><p>用法和优先队列的 Queue 完全相同，而且 Deque 也是继承于 Queue 接口的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以 Deque 也可以使用 offer() 添加元素到队尾，但是并不推荐这样写，对于这种双端队列，还是写成 offerLast() 这样更明确一些。</p><p>因为像 LinkedList 这样实现了很多不同接口的类，我们具体要把它当作某一个接口使用的时候，因该让它向上转型为对应的接口，然后按照接口拥有的功能进行操作，这种尽量持有接口的方法才是面向对象的思想。</p><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>众所周知，栈是一个先进后出的数据结构，和叠碗筷差不多。在 Java 中并没有单独搞一个叫作 Stack 的接口，这是因为历史遗留问题，有一个单独叫作 Stack 的类，因为这个 Stack 类所拓展的 Vector 类是一个早期 Java 写的一个不太行的类，里面很多方法都是线程安全的，速度很慢，所以就直接废弃不用了。</p><p>那如何实现栈结构呢？当然是使用万能的双端队列 Deque 啦，Deque 接口就封装了栈所需要的一些方法，如：</p><ul><li>把元素压入栈中： push(E)/addFirst(E)</li><li>把元素弹出栈：pop(E)/removeFirst(E)</li><li>取栈顶元素但不弹出： peek(E)/peekFirst(E)</li></ul><p>如果将 Deque 当作 Stack 使用的时候，尽量用 push pop peek 这样的方法，更直接清晰。</p><p>栈数据结构的用途非常多，以后会慢慢学的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Properties&quot;&gt;&lt;a href=&quot;#Properties&quot; class=&quot;headerlink&quot; title=&quot;Properties&quot;&gt;&lt;/a&gt;Properties&lt;/h2&gt;&lt;p&gt;因为这个和 IO 的流输入流输出有关，所以日后再来补坑。&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="笔记" scheme="https://xorex.space/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="集合" scheme="https://xorex.space/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java集合学习笔记【一】</title>
    <link href="https://xorex.space/2021/02/21/ea646ab3cd00/"/>
    <id>https://xorex.space/2021/02/21/ea646ab3cd00/</id>
    <published>2021-02-20T17:58:12.000Z</published>
    <updated>2021-02-21T09:32:32.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合导论"><a href="#集合导论" class="headerlink" title="集合导论"></a>集合导论</h2><p>集合 Collection</p><p>用来存储数据使用，对应着不同类型的需求，拥有着不同的集合来处理它。Collection 是一个顶层接口，下面继承他的还有两个接口，分别是 List 接口和 Set 接口，其中 List 接口实现的是有序可重复的列表，Set 接口实现的是无序不可重复的列表。剩下的就是实现 List 和 Set 接口的各种类了，这些类五花八门，可以根据需要选择使用。</p><p><img src="https://xorex.space/image/156.jpg" alt="img"></p><h2 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h2><h3 id="Collection-的定义"><a href="#Collection-的定义" class="headerlink" title="Collection 的定义"></a>Collection 的定义</h3><p>首先我们看 Collection 接口的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span></span><br></pre></td></tr></table></figure><p>继承了一个 Iterable 的接口，并使用了泛型，泛型用于定义此集合存储的数据类型，而继承的接口 Iterable 可以先不管，一会再看它。接口里面定义了所有实现这个接口的类所必须要有的方法，因为 Collection 接口是所有集合都要实现的接口，因此所有的集合都有 Collection  接口里面的方法，下面是一些主要的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 返回集合元素数量</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">// 返回集合是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>; <span class="comment">// 返回是否包含某个元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">// 加入某个元素并返回是否加入成功</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>; <span class="comment">// 删除某个元素并判断是否删除成功</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 删除所有的元素</span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>; <span class="comment">// 返回此集合的一个迭代器</span></span><br></pre></td></tr></table></figure><p>研究 Collection 接口里面的方法是因为这些方法在所有集合里面都是通用的，无论我们拿到一个什么样的集合，都可以使用 Collection 接口里面定义的方法来对此集合进行操作，而 Collection 接口的存在，除了方便规定集合以外，还可以用来玩多态，无论是啥集合，统一向上转型，然后当作 Collection 实例处理。</p><h3 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h3><p>仔细观察 Collection 接口的主要方法，里面是没有用来返回元素的，这是因为有些集合，是没有索引的，比如 <code>set</code> 接口下面实现的几种集合。他们不能通过对下标的遍历来遍历整个集合。面对千万种不同的集合，一种统一的用于集合的迭代接口就必不可少了，把具体的迭代细节封装起来，留下统一的方法接口，只管调用即可。</p><p>而 Iteratior 接口就是这种标准的迭代接口，在 Collection 接口种就规定了一个方法用来返回用于此集合遍历的迭代器 <code>Iterator&lt;E&gt; iterator();</code>。而 Iteratior 接口规定了实现迭代统一而必不可少的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>; <span class="comment">// 返回是否还有下一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>; <span class="comment">// 返回下一个元素并移动指针指向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，只有这两个方法就够了，判断还有下一个元素没有了，如果有就取出来，如果没有那就迭代完成！我们不需要关心集合是啥，只要 hasNext 和 next ，闭着眼都能遍历它。</p><h3 id="增强-For-循环"><a href="#增强-For-循环" class="headerlink" title="增强 For 循环"></a>增强 For 循环</h3><p>对于数组和集合来说，可以使用普通 for 循环和迭代器来迭代它，首先建立一个集合并添加元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; Tempest=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Tempest.add(<span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">Tempest.add(<span class="string">&quot;Asuna&quot;</span>);</span><br><span class="line">Tempest.add(<span class="string">&quot;Yukino&quot;</span>);</span><br><span class="line">Tempest.add(<span class="string">&quot;Megumi&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后对集合进行遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; Ti =Tempest.iterator();Ti.hasNext();) &#123;</span><br><span class="line">    String i=Ti.next();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是利用了普通 for 循环和迭代器实现了集合的遍历。</p><p>那么这样的写法一般是比较固定的，于是 Java 就加入了一个语法糖，增强 for 循环。使用格式就是 <code>for(集合元素类型 变量名 : 集合实例名);</code> ，然后遍历代码就可以简化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String i:Tempest) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上还是用了迭代器，只不过这部分代码是编译器帮助我们生成的，我们只写语法糖部分即可。</p><h2 id="List-接口及其实现"><a href="#List-接口及其实现" class="headerlink" title="List 接口及其实现"></a>List 接口及其实现</h2><h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><p>上面说了 Collection 接口被 List 和 Set 两个接口继承，从而将集合分为了两大结构，这里我们就开始讨论一下这个 List 接口，以及 List 接口的一些实现。首先我们看一下官方给 List 的介绍：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* An ordered collection (also known as a &lt;i&gt;sequence&lt;/i&gt;).  The user of this</span><br><span class="line">* interface has precise control over where in the list each element is</span><br><span class="line">* inserted.  The user can access elements by their integer index (position in</span><br><span class="line">* the list), and search for elements in the list.&lt;p&gt;</span><br></pre></td></tr></table></figure><p>首先 List 是一个 ordered collection 即<strong>有序列表</strong>，这意味着元素的取出顺序和放入顺序是相同的。并且可以 precise control over where 精确的控制元素的插入位置，使用元素 integer index <strong>坐标</strong>来访问和搜索。</p><p>然后我们来看看 List 区别与 Collection 的主要方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 获取在某坐标的元素</span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; <span class="comment">// 在某坐标替换元素（删除原元素），并返回原元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;<span class="comment">// 在某坐标插入元素，原元素后移一位</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 移除某坐标的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;<span class="comment">// 获取某元素第一次出现的坐标值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;<span class="comment">// 获取某元素最后一次出现的坐标值</span></span><br></pre></td></tr></table></figure><p>不同的地方自然是有序列表和坐标的引入了，那么就会有上面针对于坐标的操作。</p><h3 id="List-和-Array-互换"><a href="#List-和-Array-互换" class="headerlink" title="List 和 Array 互换"></a>List 和 Array 互换</h3><p>第一种是从 List 转换为 Array，方法自然是使用 List 接口里面的 <code>toArray(T[])</code> 传入一个和元素类型相同的数组，然后返回一个将 List 元素转化过的数组。当然如果我们传入的数组大小和 List 元素数量不一样的话，它也会自动处理的，小的话它会新建一个刚刚好的数组复制之后返回回来，大的话它会把没有容纳 List 元素的位置填成 null。当然我们可以直接写个大小刚刚好的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] array = Tempest.toArray(<span class="keyword">new</span> String[Tempest.size()]);</span><br></pre></td></tr></table></figure><h3 id="ArrayList-集合"><a href="#ArrayList-集合" class="headerlink" title="ArrayList 集合"></a>ArrayList 集合</h3><p>ArrayList 是对 List 接口的一个实现类，而它的实现方法是使用数组，数组的缺点就是在插入元素的时候，后面的元素都要全部后移，造成了性能消耗比较大：</p><table><thead><tr><th align="left">执行请求</th><th align="left">资源消耗</th></tr></thead><tbody><tr><td align="left">获取指定元素</td><td align="left">速度很快</td></tr><tr><td align="left">添加元素到末尾</td><td align="left">速度很快</td></tr><tr><td align="left">在指定位置添加/删除</td><td align="left">需要移动元素</td></tr><tr><td align="left">内存占用</td><td align="left">少</td></tr></tbody></table><h3 id="LinkedList-集合"><a href="#LinkedList-集合" class="headerlink" title="LinkedList 集合"></a>LinkedList 集合</h3><p>LinkedList 也同样是对 List 接口的一个实现类，而它的实现方法是使用链表，链表的缺点就是查询的时候，需要遍历一边链表才能查到，造成了性能消耗比较大：</p><table><thead><tr><th align="left">执行请求</th><th align="left">资源消耗</th></tr></thead><tbody><tr><td align="left">获取指定元素</td><td align="left">需要从头开始查找元素</td></tr><tr><td align="left">添加元素到末尾</td><td align="left">速度很快</td></tr><tr><td align="left">在指定位置添加/删除</td><td align="left">不需要移动元素</td></tr><tr><td align="left">内存占用</td><td align="left">较大</td></tr></tbody></table><h2 id="Set-接口及其实现"><a href="#Set-接口及其实现" class="headerlink" title="Set 接口及其实现"></a>Set 接口及其实现</h2><h3 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h3><p>讨论完 List 接口之后来看看 Set 接口，同样作为继承于 Collection 的好孩子，Set 接口有什么特点呢，看看官方文档吧：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* A collection that contains no duplicate elements.  More formally, sets</span><br><span class="line">* contain no pair of elements &#123;@code e1&#125; and &#123;@code e2&#125; such that</span><br><span class="line">* &#123;@code e1.equals(e2)&#125;, and at most one null element.  As implied by</span><br><span class="line">* its name, this interface models the mathematical &lt;i&gt;set&lt;/i&gt; abstraction.</span><br></pre></td></tr></table></figure><p>no duplicate elements 表示 Set 里面<strong>没有重复</strong>的元素，也就是两个 equals() 能判断相等的两个元素，null 也只能有一个。并且此集合没有索引，也就不存在了各种有关索引操作的方法了。</p><p>至于这个接口规定的一些方法，其实没啥好讲的，和 Collection 差不多，下面直接研究实现 Set 接口的两个重要的类，分别是 HashSet 和 LinkedHashSet 。</p><h3 id="HashSet-集合"><a href="#HashSet-集合" class="headerlink" title="HashSet 集合"></a>HashSet 集合</h3><h4 id="HashSet内部实现"><a href="#HashSet内部实现" class="headerlink" title="HashSet内部实现"></a>HashSet内部实现</h4><p>HashSet 是 Set 的一个实现类，故名思意，实现 Set 的方法就是用了 Hash，确切的说，使用了 Hash 实现的 Map，即 HashMap。这可是个好东西，通过 Map 构建了键值对映射之后，就意味着我们对于 List 的查询和添加效率不可得兼的问题就得到了解决。使用 HashMap 可以高效的完成添加和查询，但是牺牲就是里面无法存储重复的元素。</p><p>这里对上面的名词进行解释一下， Hash，哈希表，又叫做散列表，是用来计算唯一特征值的一种算法，每一个实例都可以计算出来自己独一无二的 Hash 值，我们将这个 Hash 值作为键，将实例作为值，然后用 Map 结构来存储两者，通过 Map 结构可以用 Hash 值作为键值快速获得实例。</p><p>因此我们总结出来了，使用 HashSet 有两个必须要的条件：</p><ol><li>可以计算一个实例的 Hash 值，并且尽可能地独一无二。</li><li>拥有判断两个实例是否相等地算法，保证集合元素不会重复。</li></ol><p>第一个在 Java 里面，需要自己在写类的时候就重写继承于 Object 的方法 hashCode()，第二个则需要重写 Object 的 equals() 方法。</p><h4 id="重写-hashCode"><a href="#重写-hashCode" class="headerlink" title="重写 hashCode()"></a>重写 hashCode()</h4><p>首先我们看看 Object 里面的 hashCode() 是怎么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>使用了 native 关键词，说明是调用了系统来返回一个十进制整数，作为这个实例的 Hash 值。</p><p>而我们的重写就需要自己计算 Hash 值了，这个算法需要保证两点</p><ul><li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li><li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li></ul><p>Java 为我们提供了一个利器来实现 Hash 的计算，因为不同的实例本质上是字段的值不同，所以我们就根据字段来计算 Hash 值，而计算的方法则是利用 Objects.hash()，它使用是可变参数，往里面把所有的字段都填进去即可返回一个合适的 Hash 值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object... values)</span></span>;</span><br></pre></td></tr></table></figure><p>简单的重写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(age,name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重写-equals"><a href="#重写-equals" class="headerlink" title="重写 equals()"></a>重写 equals()</h4><p>编写 equals() 当然也有一些原则，不过我认为这些原则都没啥用，只要能合理的重写 equals 方法即可。我们比较 两个实例是否相等的方式就是依次比较它的字段值，如果每个字段值都相等，那么就认为这两个实例是相等的，字段值有两种，一种是基本类型，一种是引用类型。对于基本类型，我们可以直接用 <code>==</code> 进行判断，但是引用类型就不可以了。</p><p>引用类型使用 <code>==</code> 判断比较的是引用地址是否相同，假使两个实例的所有字段都相同，但是由两个 new 语句建立的，那么引用地址就肯定不相同，导致使用 <code>==</code> 判断也不相同。所以对于引用类型的字段来说，我们使用它自带的 equals() 进行比对，但是，如果比对 equals() 的一方的引用类型字段为 null，那么调用它的 equals() 就会抛出异常，所以我们还需要单独判断是否为 null，这就太麻烦了。</p><p>麻烦的东西自然有人帮助我们处理，直接使用 Objects 类种的静态方法 equals() 传入两个引用类型，它会自动返回是否相等。因此我们就可以得到重写 equals() 的步骤了。</p><ol><li>首先判断传入的  <code>Object</code> 是不是此类的实例，如果是则开始下一步。</li><li>然后将传入的 <code>Object</code> 向下转型为当前类的实例，方便比较字段。</li><li>然后比较字段，引用类型使用 <code>Objects.equals(Object a,Object b)</code>，基本类型直接使用 <code>==</code> 。</li></ol><p>简单的重写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Tempest) &#123;</span><br><span class="line">            Tempest P=(Tempest)o;</span><br><span class="line">            <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name,P.name)&amp;&amp;<span class="keyword">this</span>.age==P.age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-HashSet-集合"><a href="#使用-HashSet-集合" class="headerlink" title="使用 HashSet 集合"></a>使用 HashSet 集合</h4><p>这里就可以看出来 Set 和 List 的使用区别了，如果需要存储重复的元素，那么只能使用 List ，如果没必要存储重复元素，则使用 Set 。 Set 虽然有着无序和无法通过下标访问的缺点，但是因为使用了映射机制，实现了 List 的无法全部获得的优点：同时实现插入和查询的高效。</p><p>因此如果没有必须要重复存储一些元素，那我们直接使用 Set 类。</p><h3 id="LinkedHashSet-集合"><a href="#LinkedHashSet-集合" class="headerlink" title="LinkedHashSet 集合"></a>LinkedHashSet 集合</h3><p>LinkedHashSet 集合和 HashSet 集合之间的区别仅仅就是在前者比后者内部多了一个链表用来记录存储元素的先后顺序，这个链表仅仅只在迭代器工作的时候使用，它可以保证迭代的顺序和插入元素的顺序是相同的。而 HashSet 因为只有一个哈希表，所以迭代顺序可能会随着插入了元素而变化。</p><h2 id="Collections-集合工具"><a href="#Collections-集合工具" class="headerlink" title="Collections 集合工具"></a>Collections 集合工具</h2><p>集合工具，故名思意，就是用于操作集合的工具，这个类里面拥有很多直接操作集合的方法，帮助我们更好使用集合。</p><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1. 排序"></a>1. 排序</h3><p>对一个集合进行排序的时候，如果集合里面拥有排序方法，那么就可以调用集合里面的排序方法对集合进行排序。如果没有的话，则可以利用 Collections 类的静态方法 sort() 对集合进行排序操作，需要注意的是，这里的排序只能用于列表 List ，而不能用于 Set 。</p><p>实现排序最根本的要求就是知道如何比较集合里面两个元素的大小，对于 Collections 类里面有两种排序方法，一种是 <code>sort(List&lt;T&gt; list)</code> ，直接传入一个列表既可，但需要列表的元素类实现 <code>interface Comparable&lt;T&gt;</code> 接口并重写 <code>compareTo()</code> 方法。另外一种则是使用 <code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> 里面传入列表和对应元素类型需要的比较器 Comparator 。</p><ul><li>首先我们介绍第一种，在类中实现 <code>interface Comparable&lt;T&gt;</code> 接口，并重写里面的 <code>compareTo()</code> 方法。<code>public int compareTo(T o);</code>  ，如果返回<strong>零</strong>则表示两者相等，返回<strong>正数</strong>表示自己大于比较对象 o ，返回<strong>负数</strong>表示自己小于比较对象。</li><li>第二种的优势在于可以定义临时的比较方法，不在类中将比较方法写死了，使用匿名类传入参数 <code>Comparator&lt;? super T&gt; c</code>  ，只需要重写 <code>public int compare(T o1, T o2);</code> 方法即可。下面展示一下：</li></ul><p>这里代码的主要思路就是对一个元素类型是 Tempest 类的列表进行排序，而我们的类 Tempest 考虑到不同的用途有不同的比较方法，就没有实现 <code>compareTo()</code> ，因此这里使用 Collections 里面的 <code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> ，其中第二个参数就是我们临时生成的匿名类，里面实现了 compare 方法。这个比较规则是首先按照年龄排序，如果年龄相同，则按照姓名排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Tempest&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Xorex&quot;</span>,<span class="number">19</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Asuna&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Yukino&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Megumi&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Origami&quot;</span>,<span class="number">17</span>));</span><br><span class="line">        Collections.sort(list,<span class="keyword">new</span> Comparator&lt;Tempest&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Tempest o1,Tempest o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1.getAge()==o2.getAge()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    Tempest(String name,<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&#x27;:&#x27;</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洗牌-shuffle"><a href="#洗牌-shuffle" class="headerlink" title="洗牌 shuffle"></a>洗牌 shuffle</h3><p>洗牌故名思意，就是将列表里面的元素顺序打乱，这种打乱是随机的，每次都不同的打乱。这种方法则是使用 Collections 中的静态方法：<code>Collections.shuffle(List&lt;?&gt; list)</code> 。</p><h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p>再 Collections 中，可以封装三种类型非不可变集合：</p><ul><li>封装成不可变 List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li><li>封装成不可变 Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li><li>封装成不可变 Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li></ul><p>调用这些方法，传入集合，然后返回一个不可变集合。需要注意的是，原来的集合实例还是可以修改的，而且修改之后，也同样会会修改返回的不可变实例。因此我们如果想要把一个集合变成不可变的，那么应该直接扔掉可变实例的引用，只留下来返回的不可变实例。</p><h2 id="Map-容器"><a href="#Map-容器" class="headerlink" title="Map 容器"></a>Map 容器</h2><h3 id="基本-Map-的概念"><a href="#基本-Map-的概念" class="headerlink" title="基本 Map 的概念"></a>基本 Map 的概念</h3><p>需要注意的是，这里的 Map 并不是地图的意思，而是<strong>映射</strong>。我们看看 Map 的定义：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里接口 Map 并没有继承与 Collection 或者 Iterator，而是作为默认继承了 Object，说明它并不是 “集合” 的一个下属，而是和 Collection 同级别的存在。我们一般的集合指的都是 Collection 实现的子类，而 Map，我认为被叫做容器更为合适一点，但是大家都叫做它集合。</p><p>Map 映射，从它的定义就能看出来，拥有两个泛型 <code>&lt;K, V&gt;</code> 表示 key 和 value 的一个键值对的映射。这种映射是拥有一定要求的，最重要的一点就是 Key 是不允许重复的，我们通过键访问值，键因此不能重复。</p><p>Map 集合里面拥有一些方法可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回Map中拥有的映射数量</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">//返回Map是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>; <span class="comment">//返回是否存在键key</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>; <span class="comment">//返回是否存在值value</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>; <span class="comment">//输入key返回value</span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>; <span class="comment">//输入一个键值对，建立一个null,如果key不存在返回null,存在返回原来value</span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>; <span class="comment">//输入键，移除此键值对映射</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>; <span class="comment">//将一个现成Map存入当前Map</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">//清空Map</span></span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>; <span class="comment">//返回一个Set集合，里面为Map的键</span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>; <span class="comment">//返回一个集合，里面为Map的值</span></span><br><span class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); <span class="comment">//返回一个Set集合，里面元素为Map.Entry&lt;K,V&gt;实例，每个实例保存了一个键值对映射。</span></span><br></pre></td></tr></table></figure><p>上面的方法中，需要注意的是 <code>V put(K key, V value);</code> ，因为 key 的唯一性，当我们使用 put 方法传入一个 key 已经存在 Map 里面的 key-value2 映射的时候，这个 key 映射的 value1 会被新的 value2 覆盖，并且 put 方法会把这个 value1 给返回回来。如果 key 不存在与 Map 的时候，新添加一个 key-value 只会返回 null。</p><h3 id="迭代-Map"><a href="#迭代-Map" class="headerlink" title="迭代 Map"></a>迭代 Map</h3><p>因为 Map 没有继承 Iterator 接口，所以自然不存在 iterator() 来返回迭代器，所以如果想要迭代 Map 的话，有两种方法可以实现：</p><ul><li>第一种是使用 <code>Set&lt;K&gt; keySet();</code> 方法，获取一个 装满 key 的 Set 集合，用 Set 的迭代器迭代出来 Map 所有的 key ，再通过 key 和 <code>V get(Object key);</code> 方法获取 value。</li><li>第二种是使用 <code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</code> 返回一个装满 <code>Map.Entry&lt;K,V&gt;</code> 实例的 Set 集合，然后迭代这个集合，对于集合中的每个 <code>Map.Entry&lt;K,V&gt;</code> 实例，使用它的 <code>K getKey();</code> 和 <code>V getValue();</code> 来获取键值对信息即可。</li></ul><h3 id="Map-接口实现-HashMap"><a href="#Map-接口实现-HashMap" class="headerlink" title="Map 接口实现 HashMap"></a>Map 接口实现 HashMap</h3><p>HashMap 是使用哈希算法来实现 Map 接口的一种集合，这里 HashMap 和 HashSet 使用的技术是一模一样的，都为哈希，不同之处就是 Map 为存储键值对的映射容器，而 Set 为存储单一元素的集合，Map 对于单个元素的访问可以通过键或者值，而 Set 对于单个元素的访问只能通过值。</p><p>我们使用 Map 的时候都是通过 HashMap 来实现的，不过因为采用了 Hash 技术，和前面的 HashSet 一样，想要存储自定义数据类型，必须实现 key 类自己的 equals() 和 hashCode() ，两者的实现方法在上面已经写过了。而 value 无需实现两者，因为其实现是针对 key 进行计算位置的以及是否哈希冲突的。</p><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>首先观察此类的定义，发现它是继承于 HashMap 的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这意味着这个类拥有 HashMap 所有的方法，他们之间的不同之处就是 LinkedHashMap 自己内部通过链表实现了一个加入顺序的记录，也就是说，我们如果直接输出 LinkedHashMap 的实例，发现里面的元素顺序和我们添加的顺序是相同的，这就是 Linked 的意义所在。而且这个输出顺序同样体现在： <code>Set&lt;K&gt; keySet();</code> 方法和<code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</code> 方法返回的 Set 集合里元素的顺序，同样是按照输入的顺序保留下来的。（其实返回来的本质上是 LinkedHashSet 来保证顺序的）</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>我们来看看 TreeMap 在 Map 家族里面的关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">       │Map│</span><br><span class="line">       └───┘</span><br><span class="line">         ▲</span><br><span class="line">    ┌────┴─────┐</span><br><span class="line">    │          │</span><br><span class="line">┌───────┐ ┌─────────┐</span><br><span class="line">│HashMap│ │SortedMap│</span><br><span class="line">└───────┘ └─────────┘</span><br><span class="line">               ▲</span><br><span class="line">               │</span><br><span class="line">          ┌─────────┐</span><br><span class="line">          │ TreeMap │</span><br><span class="line">          └─────────┘</span><br></pre></td></tr></table></figure><p>这里 TreeMap 是实现了 SortedMap 接口里面的内容，表示它通过了树结构，实现了可排序的 Map。因为本身 HashMap 这样的类一是不像 ArrayList 一样内置了 sort() 方法，二是不像 Collection 大家族拥有 Collections 类来对其进行排序操作。因此 Map 家族就直接搞了一个 TreeMap 来实现 Map 的排序。</p><p>TreeMap 内部实现是利用红黑树实现查询和排序的，因此相对于 HashMap，他获得了 Key 排好顺序的同时，失去了 O(1) 复杂度的查询，变成了O(Logn) 。因此，如果没有必须的排序要求，还是建议使用 HashMap。因为实现方法不是哈希算法，所以自然不需要对 key 类进行实现 hashCode() 和 equals() 。</p><p>使用 TreeMap 的时候，因为要排序，所以需要 key 类实现接口 comparable 的 compareTo()，或者在建立 TreeMap 实例的时候，直接给构造方法传入一个比较器 Comparator ，这里原理都和 Collections 排序集合一样。</p><hr><p>集合的内容好多啊，所以就又拆分出来了一篇文章，第二篇的内容就比较少了，而且体系化相对来说比较弱一点，都是一些零零散散的工具集合，加油吧少年！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;集合导论&quot;&gt;&lt;a href=&quot;#集合导论&quot; class=&quot;headerlink&quot; title=&quot;集合导论&quot;&gt;&lt;/a&gt;集合导论&lt;/h2&gt;&lt;p&gt;集合 Collection&lt;/p&gt;
&lt;p&gt;用来存储数据使用，对应着不同类型的需求，拥有着不同的集合来处理它。Collecti</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="笔记" scheme="https://xorex.space/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="集合" scheme="https://xorex.space/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型学习笔记</title>
    <link href="https://xorex.space/2021/01/10/6303f95aef53/"/>
    <id>https://xorex.space/2021/01/10/6303f95aef53/</id>
    <published>2021-01-10T03:43:47.000Z</published>
    <updated>2021-02-20T13:44:45.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为泛型"><a href="#何为泛型" class="headerlink" title="何为泛型"></a>何为泛型</h2><h3 id="泛型概念"><a href="#泛型概念" class="headerlink" title="泛型概念"></a>泛型概念</h3><p>泛型故名思意，就是广泛的类型，其本质就是参数化类型。在各种资料里面，泛型的概念都是通过 ArrayList 这个类来引入的，那么这里也用它来引入泛型的概念。</p><p>ArrayList 我没有使用过，但是它是一个变长数组，可以通过方法 <code>.add()</code> 来不断增加元素，而不用担心空间大小不够的问题。这个类可以实现任意类型的可变数组，而实现的方法就是通过泛型来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; // <span class="title">ArrayList</span> 类的声明</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">add</span>(<span class="title">int</span> <span class="title">index</span>, <span class="title">E</span> <span class="title">element</span>) // <span class="title">add</span>方法的一个重载</span></span><br></pre></td></tr></table></figure><p>首先可能就注意到了，这个类名是 <code>ArrayList&lt;E&gt;</code> 并且在 add 方法的参数里面，element 的类型是 E ，这个 E 就是一个类型的代称，取什么名字都行，这个 E 表示什么类型，完全取决于在实例化 ArrayList 的时候，给它指定的类型。</p><p>比如我们想要一个 String 类型的可变数组，那么声明方法就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strs=<span class="keyword">new</span> ArrayList&lt;String&gt;;</span><br></pre></td></tr></table></figure><p>这样，上面的 <code>&lt;E&gt;</code> 被声明的时候填充成了 <code>&lt;String&gt;</code> 那么这个 E 就变成了 String ，下面的 element 的类型就变成了 String，这个 ArrayList 类，就变成了一个专门实现字符串数组的类。</p><h3 id="泛型的优势"><a href="#泛型的优势" class="headerlink" title="泛型的优势"></a>泛型的优势</h3><p>当然，由于向上转型的存在，我们可以用 Object 类来代替实现泛型，由于数据的载体是 Object[] ，所以这样实现还能让一个数组里面存储不同的类，第一个元素可以是 String 类型，第二个可以是 Integer 类型。但是这样就会带来一个问题，针对数据操作的时候，不但要将 Object 向下转型为对应类型，还要防止出现误转型，也就是把 String 转成了 Integer ，会抛出 ClassCastException 。</p><p>所以使用泛型来来编写一个数据模板是非常合适的，它可以通过指定类型来实现所有类的可变数组，而不需要为不同的类编写不同的可变数组，大大减少了代码量。</p><h3 id="泛型的向上转型"><a href="#泛型的向上转型" class="headerlink" title="泛型的向上转型"></a>泛型的向上转型</h3><p>从 ArrayList 的定义来看，它是实现了一个接口  <code>List&lt;T&gt;</code>  也就是说，他们是一个类继承关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span></span><br></pre></td></tr></table></figure><p>那么我们就可以对它进行向上转型，需要注意的是，这里的向上转型是<strong>对携带了 泛型&lt;T&gt; 标志的类的继承关系</strong>的向上转型。转型过程中，泛型&lt;T&gt; 表示的类型需要一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; a=ArrayList&lt;String&gt;;</span><br></pre></td></tr></table></figure><hr><p>这是一种转型，还有一种转型是<strong>对泛型的</strong>向上转型，也就是对 &lt;T&gt; 这里面的类 T 的向上转型。</p><p>对于这种向上转型，Java 是不支持的，原因和上面泛型的优势是一样的，可能会出现 ClassCastException ，也就是误类转型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Number&gt; a=ArrayList&lt;Integer&gt;;</span><br><span class="line">a.add(<span class="number">1</span>); <span class="comment">// 1 Integer 属于 Number</span></span><br><span class="line">a.add(<span class="number">1.0</span>); <span class="comment">//1.0 Float 属于 Number</span></span><br><span class="line">Integer b=a.get(<span class="number">1</span>); <span class="comment">//获取索引一的元素也就是 1.0，会抛出ClassCastException</span></span><br></pre></td></tr></table></figure><p>所以编译器为了避免出现这样的情况，就根本不允许你对泛型进行向上转型，也就是不让你玩泛型的多态。</p><h2 id="泛型的本质"><a href="#泛型的本质" class="headerlink" title="泛型的本质"></a>泛型的本质</h2><h3 id="实现泛型"><a href="#实现泛型" class="headerlink" title="实现泛型"></a>实现泛型</h3><p>众所周知，JVM 虚拟机是一个很笨的东西，像泛型这样灵活的东西，它不太好实现。</p><p>怎么办呢，交给编译器实现吧，而 Java 的编译器实现泛型的方法，就是编译器代替人完成安全的强制转型。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T son;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSon</span><span class="params">(T son)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.son=son;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> son;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Tempest&lt;String&gt; Xorex=<span class="keyword">new</span> Tempest&lt;&gt;();</span><br><span class="line">Xorex.setSon(<span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">String Name=Xorex.getSon();</span><br></pre></td></tr></table></figure><p>上面的代码会被编译器自动转化为下面的代码（泛型 &lt;T&gt; 被全部替换为 Object，同时自动帮我们根据输入泛型的类型，将 Object 强制转型为我们输入的类型）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object son;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSon</span><span class="params">(Object son)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.son=son;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> son;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Tempest Xorex=<span class="keyword">new</span> Tempest();</span><br><span class="line">Xorex.setSon(<span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">String Name=(String)Xorex.getSon();</span><br></pre></td></tr></table></figure><p>所以，所谓的泛型本质上就是编译器帮我们完成了安全的强制转型，无论是 <code>Tempest&lt;String&gt;</code> 还是 <code>Tempest&lt;Integer&gt;</code> ，都为同一个类（操作的时候编译器会自动帮我们加上强制转型为不同的类型，看起来像是不同的类），<code>Tempest&lt;Object&gt;</code> 最后编译也只会出现一个文件：<code>Tempest.class</code> 。</p><p>&lt;T&gt; 本质上就是告诉编译器，操作完之后记得把 Object 强制转型为 T 类型，如果不加 &lt;T&gt; ，那么默认就不执行强制转型，直接返回 Object 类型。比如如果使用 Class 的实例的 newInstance() 获取某个类的实例的话，返回的是 Object 类型，而使用 Class&lt;String&gt; 的实例的 newInstance() 获取某个类的实力的话，返回的则是 String 类型。</p><h3 id="泛型的局限性"><a href="#泛型的局限性" class="headerlink" title="泛型的局限性"></a>泛型的局限性</h3><p>因而，由于泛型的实现并不是我们所想象的那样：编译器帮我们写一个对应类型的类出来，而是用 Object 的强制转型来骗我们，因而就有了一些和前者不同的局限性:</p><h4 id="1-lt-T-gt-不能是基本类型"><a href="#1-lt-T-gt-不能是基本类型" class="headerlink" title="1. &lt;T&gt; 不能是基本类型"></a>1. &lt;T&gt; 不能是基本类型</h4><p>因为实际上 &lt;T&gt; 可以是各种类始由于 Object 来存储接收并实现的，所以 &lt;T&gt; 就只能是引用类型——类，而对于基本类型 int、float 这些则无法使用泛型。</p><h4 id="2-无法获得泛型的-Class-实例"><a href="#2-无法获得泛型的-Class-实例" class="headerlink" title="2. 无法获得泛型的 Class 实例"></a>2. 无法获得泛型的 Class 实例</h4><p>其实前面已经提过了，我们无论是对  <code>Tempest&lt;String&gt;</code> 还是 <code>Tempest&lt;Integer&gt;</code> 对于它们的实例，使用 <code>.getClass()</code> 获得的是本质上都是 <code>Tempest&lt;Object&gt;</code> 的 Class，也就是 <code>Tempest.class</code> 文件中的信息。</p><p>同样编译器也只有 <code>Tempest.class</code> 这种操作。</p><h4 id="3-无法判断带泛型类实例的类型"><a href="#3-无法判断带泛型类实例的类型" class="headerlink" title="3. 无法判断带泛型类实例的类型"></a>3. 无法判断带泛型类实例的类型</h4><p>也就是说 <code>Tempest&lt;String&gt;</code> 和<code>Tempest&lt;Integer&gt;</code> 两者的实例，是没有办法判断是属于二者的，他们只能判断出来都属于 <code>Tempest&lt;Object&gt;</code> 。</p><h4 id="4-无法实例化-T-类型"><a href="#4-无法实例化-T-类型" class="headerlink" title="4. 无法实例化 T 类型"></a>4. 无法实例化 T 类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T One=<span class="keyword">new</span> T(); <span class="comment">//不可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为上面的代码会被转化为 <code>Object One=new Object()</code> 然后就没有任何意义。想要实现实例化 T，那么就必须借助传入的 Class 类型的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toInstance</span><span class="params">(Class&lt;T&gt; Tclass)</span> </span>&#123;</span><br><span class="line">    T One=Tclass.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是一定要用 <code>Class&lt;T&gt;</code> 这样在调用 Class 的 newInstance() 的时候，会直接返回 T 类型的实例，否则编译器不会给你自动强制转型为 T 类型，而是返回实际的类型 Object 的实例。</p><h3 id="实质带来的可能性问题"><a href="#实质带来的可能性问题" class="headerlink" title="实质带来的可能性问题"></a>实质带来的可能性问题</h3><p>还需要小心一个关于泛型本质的潜在问题，由于泛型的 &lt;T&gt; 骗着我们，实际上这个东西是 Object，就会导致潜在的覆写问题。</p><p>对于所有类都会继承的 Object 类，他有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们这样自定义一个方法的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T another)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于它的 T 实际上会被编译器搞成 Object ，所以导致了这个方法的签名和 Object 类的 equals 的方法签名相同，导致了意外的覆写父类的方法，由于看起来 T 和 Object 不一样，所以可能不太在意，但是实际上经过编译器处理过后，两者是一样的！</p><h2 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h2><h3 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用"></a>普通使用</h3><p>对于最普通的泛型使用，就是代替 Object 来接受各种不同的类。其实最开始引入泛型概念的时候就已经讲述过了。</p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>可以在接口中使用泛型，在实现接口的时候，可以选择固定接口的 &lt;T&gt; 为特定类型，或者直接沿用接口的 &lt;T&gt; 。</p><h3 id="继承泛型"><a href="#继承泛型" class="headerlink" title="继承泛型"></a>继承泛型</h3><p>前面说了，因为本质上泛型实现是 Object 实现的，只不过是编译器记住了所属于的类型，给它加了一个强制转型，我们无法通过一个实例来得到泛型的具体类型。但是凡事都有例外，我们可以用特殊的方法来实现这样的需求。</p><p>答案就是用一个子类去继承父类，然后我们就可以通过子类的实例来获取父类的泛型的具体类型。这是因为子类的 <code>.class</code> 文件是包含了父类的所有信息的，自然也包括父类的泛型。但是获取的方法有点麻烦，就不研究了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xorex</span> <span class="keyword">extends</span> <span class="title">Tempest</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就可以通过 Xorex 的实例来获得父类 Tempest 的泛型类型为 String。</p><h3 id="静态方法使用泛型"><a href="#静态方法使用泛型" class="headerlink" title="静态方法使用泛型"></a>静态方法使用泛型</h3><p>首先说明：在静态方法中使用泛型的方法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Xorex(T Info) </span><br></pre></td></tr></table></figure><p>与普通的方法不同的是在 static 后面多了一个 &lt;T&gt; 就像在 class 名字后面多了一个 &lt;T&gt; 是一样的，表示声明一个要使用的泛型。因为静态方法是脱离类的实例使用的，所以无论它的类 class 名字后面声明了几个泛型，都和静态方法无关，那些泛型都是在实例化的时候才会被编译器确定类型，静态方法的使用和实例化无关。</p><p>于是，静态方法需要自己定义自己需要的泛型，上面的 static 后面的 &lt;T&gt; 就是 Xorex 方法自己定义的泛型，通过传入的参数 Info 的类型来确定 &lt;T&gt; 的具体类型，如果无法通过传入参数来确定的话，则默认为 Object 类型。如果静态方法所在类也拥有泛型的话，建议静态方法的泛型命名避开类的命名，毕竟两者是不同的东西。</p><h3 id="多泛型类型"><a href="#多泛型类型" class="headerlink" title="多泛型类型"></a>多泛型类型</h3><p>只需要在 &lt;&gt; 里面用逗号分隔开多个泛型即可，比如 &lt;T,K&gt; 就成功声明了两个泛型，使用的时候：&lt;String,Integer&gt; 即可。</p><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符 ?"></a>通配符 ?</h3><p>对于一个含有泛型的类来说，如果不确定具体的泛型是谁，尤其是当它要作为参数传入一个方法的时候，我们现在的认知来说，有两种方法实现：</p><p>第一种是在本方法所在的类名后定义一个泛型，然后再方法参数中加入这个泛型，在实例化的时候就把类型确定下来。但是在一个本来就是有泛型的类中的话，会影响其他方法中的泛型，而且如果使用者不会使用这个方法，还要白白在实例化的时候加上类型限制。</p><p>第二种是将这个方法改成静态方法，和类的实例脱节，自创一套泛型系统来使用。但是这可能会破坏封装性和完整性，自创泛型系统也有点小麻烦。</p><p>这里可以引入第三种解决方法，使用 <code>?</code> 通配符，表示不确定的泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Xorex</span><span class="params">(Tempest&lt;?&gt; a)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样这个方法就可以接收所有 Tempest 的任意具体泛型。</p><h3 id="泛型的上限限定"><a href="#泛型的上限限定" class="headerlink" title="泛型的上限限定"></a>泛型的上限限定</h3><p>上限限定使用 extends 表示，可以用在类名后声明泛型： <code>class Tempest&lt;T extends Number&gt;</code> 和方法接收参数：<code>public void Xorex(&lt;? extends Number&gt;)</code>。</p><p>两者都表示接收的类型必须是 Number 及其子类，相当于给泛型一个上限限定，类在抽象不能超过 Number 的范围，这样里面的代码可以专注于只处理数字，不用担心有其他奇奇怪怪的类型。</p><h3 id="泛型的下限限定"><a href="#泛型的下限限定" class="headerlink" title="泛型的下限限定"></a>泛型的下限限定</h3><p>下限限定使用 super 表示，使用方法和上面的 extends 相同，其实这两种上限和下限以及泛型与反射有更加巧妙地用途，可惜现在的我暂时能力有限，看的不是太懂，先建立起整个 Java 知识体系。具体的这些，以后一定会再次详细的，透彻的研究一遍的。</p>]]></content>
    
    
    <summary type="html">泛型程序设计（generic programming）是程序设计语言的一种风格或范式。泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。各种程序设计语言和其编译器、运行环境对泛型的支持均不一样。Ada、Delphi、Eiffel、Java、C#、F#、Swift 和 Visual Basic .NET 称之为泛型（generics）；ML、Scala 和 Haskell 称之为参数多态（parametric polymorphism）；C++ 和 D称之为模板。具有广泛影响的1994年版的《Design Patterns》一书称之为参数化类型（parameterized type）。</summary>
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="笔记" scheme="https://xorex.space/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="泛型" scheme="https://xorex.space/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java注解学习笔记</title>
    <link href="https://xorex.space/2021/01/10/ea03bffbefdc/"/>
    <id>https://xorex.space/2021/01/10/ea03bffbefdc/</id>
    <published>2021-01-10T03:43:38.000Z</published>
    <updated>2021-02-20T13:45:01.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-注解"><a href="#Java-注解" class="headerlink" title="Java 注解"></a>Java 注解</h2><p>对于 Java 的注解，其实前面我们已经接触过了，在对接口或者抽象类的方法进行重写的时候，我们会在重写的方法的前面加上 <code>@Override</code> 这个注解，注意这个是注解不是注释，注释是完全被编译器忽略的东西，而注解并不会被忽视，是会被编译器处理的。这个注解的作用就是让编译器帮我们检查我们重写的方法是否正确。</p><p>按照 Java 中一切皆为对象来看，注解也自然是对象了（其实准确的说，<strong>注解本质上是一个接口</strong>，继承于 java.lang.annotation.Annotation ），下面的代码就是 <code>@Override</code> 注解的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><p>注解在 Java 中一般拥有三个用途：</p><ol><li><p>用来编写文档</p></li><li><p>用来编译检查</p></li><li><p>用来代码分析</p></li></ol><p>这些用途我们一点一点的说：</p><h3 id="用来编写文档"><a href="#用来编写文档" class="headerlink" title="用来编写文档"></a>用来编写文档</h3><p>记得我最开始在写 Java 的基础笔记里面，提到了 JDK 里面是拥有一个叫作 <code>javadoc.exe</code> 的程序，这个程序的作用就是从 Java 代码中提取注释，然后整合成文档。我们同样可以在我们自己的代码中对这些进行尝试，用注解标识自己的代码，然后使用 <code>javadoc.exe</code> 程序将这些注解进行提取，生成自己代码的一个功能文档。</p><p>首先是利用注解对代码进行标注，下面代码写了一个类中，一个 main 方法和一个将字符串自身累加一次的 PlusOnce 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Java.test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class is discribe the test.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;First of all, this class is the best class in the world.</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;&lt;li&gt;The</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;best</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;class!&lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xorex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is the main method.</span></span><br><span class="line"><span class="comment">     * And it only output a number 10000;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Xorex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args Parameter is the orders.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">10000</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is the PlusOnce method:</span></span><br><span class="line"><span class="comment">     * So what is the best of the String plus String?</span></span><br><span class="line"><span class="comment">     * Just plus it!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Xorex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a Input a String a.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The double lenght of the a,to be a+a .</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span> IOException It will throw IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> IOException </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> It is not good yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PlusOnce</span><span class="params">(String a)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Java 中自带的一些注解对类和方法进行了一个比较基本的描述，需要注意的是，Java 中使用的注释为单行注释  <code>//</code> 多行注释 <code>/**/</code> ，但是注解与他们不同，使用的是这样： <code>/** */</code>  要比多行注释多了一个星。我们的注解就写在里面。里面的注解描述的都是很基本的信息，然后使用命令 <code>javadoc test.java</code> 成功生成了一堆网页文件，打开 <code>index.html</code> 就可以看到生成的文档了。</p><p><img src="https://xorex.space/image/155.jpg"></p><p>点开之后里面就有很多东西了，我们所有的标注都被提取出来，变成了一个文档。</p><h3 id="用来编译检查"><a href="#用来编译检查" class="headerlink" title="用来编译检查"></a>用来编译检查</h3><p>比如以前使用的的 <code>@Override</code> 来检查是否重写方法正确，使用 <code>@SuppressWarnings</code>  来让编译器忽略此处代码产生的警告信息。</p><p>注解也是拥有参数的，比如 <code>@SuppressWarnings</code>  就拥有一个类型为 String 的参数，用来接收数据，从而命令编译器忽略哪一种类型的警告，下面是输入参数对应的各种效果：</p><ul><li>all 压制所有的警告</li><li>deprecation 压制使用不赞成类和方法警告</li><li>unused 压制未使用变量警告</li><li>unchecked 压制未检查转化警告</li><li>path 压制路径不存在警告</li></ul><p>使用方法就是在语句前加上  <code>@SuppressWarnings(&quot;all&quot;);</code></p><h3 id="用来代码分析"><a href="#用来代码分析" class="headerlink" title="用来代码分析"></a>用来代码分析</h3><p>这是对于我们一个普通的开发者来说，注解的用途就是来帮助我们进行分析代码。我们可以自己写一个用来处理代码的工具比如一个测试代码是否有运行错误的工具。那么这个工具是如何知道应该运行哪些代码，应该以什么方式运行代码呢？这就用到了注解，我们利用注解对代码进行标注，然后代码分析工具读取我们的标注，按照标注的注解来决定如何处置这些代码，这是我们一般自定义注解的用途。</p><h2 id="注解的组成"><a href="#注解的组成" class="headerlink" title="注解的组成"></a>注解的组成</h2><h3 id="注解的声明"><a href="#注解的声明" class="headerlink" title="注解的声明"></a>注解的声明</h3><p>Java 的注解组成来看，先看看上面我们介绍过的注解 <code>@SuppressWarnings</code> 的定义代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value(); <span class="comment">//这东西看起来像一个抽象方法，但是实际上是个属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先声明使用方法自然是 public 类型的 <code>@interface</code> + 注解名 来声明出来一个拥有名字的注解，注解内部用来声明注解需要输入的参数，比如上面的参数输入就是一个字符串数组，参数名为后面设置的 value，可以在参数声明后面加上默认值，作用就是在使用这个注解的时候，没有输入此参数的时候，这个参数会接受默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;Xorex&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 100</span>;</span><br></pre></td></tr></table></figure><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>上面除了像声明了一个接口一样声明了一个注解的代码，还有一些注解与注解定义的注解，比如上面的 <code>@Target</code> 和 <code>@Retention</code>  ，他们被叫作元注解，下面是在 Java 中内置的一些元注解</p><h4 id="1-Target"><a href="#1-Target" class="headerlink" title="1. @Target"></a>1. @Target</h4><p>Target 注解用来定义声明的这个 Annotation 能够被作用的位置，是定义注解时必须加上的元注解。</p><p>Target 接受的参数是一个枚举类型的数组，叫作 <code>ElementType[]</code> 这个枚举类型里面拥有定义好的元素，分别对应不同的作用位置：</p><ul><li>类或接口：<code>ElementType.TYPE</code>；</li><li>字段：<code>ElementType.FIELD</code>；</li><li>方法：<code>ElementType.METHOD</code>；</li><li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li><li>方法参数：<code>ElementType.PARAMETER</code>。</li></ul><p>如果需要定义多个可作用位置，只需要把他们构造成一个数组即可。</p><h4 id="2-Retention"><a href="#2-Retention" class="headerlink" title="2. @Retention"></a>2. @Retention</h4><p>Retention n. 保留，扣留，记忆力。这个元注解用来定义 Annotation 的生命周期。</p><p>Retention 接受的参数同样也是一个枚举类型的单个常量，叫作 <code>RetentionPolicy</code> ，这个枚举类有一下的选项：</p><ul><li><code>RetentionPolicy.SOURCE</code> 表示此注解的生命周期可以维持到源码中存在，编译完就会被丢掉。</li><li><code>RetentionPolicy.CLASS</code>  表示此注解的生命周期可以维持到编译文件 .class 中存在，会被留在编译文件里。</li><li><code>RetentionPolicy.RUNTIME</code> 表示此注解的生命周期可以维持到运行时，会被 JVM 读取并处理。</li></ul><p>如果不加入这条注解，那么默认生命周期为 <code>RetentionPolicy.CLASS</code> 级别，但是考虑到一般来说，我们自定义的注解作用的生命周期都是运行时，所以需要加上  <code>RetentionPolicy.RUNTIME</code> 这一条设置。</p><h4 id="3-Repeatable"><a href="#3-Repeatable" class="headerlink" title="3. @Repeatable"></a>3. @Repeatable</h4><p>用于表示我们自定义的 Annotation 是否被允许重复注解一个元素。</p><p>使用方法就是在定义 Annotation 的时候，用此 Annotation 经过编译之后的文件名作为元注解 @Repeatable 的参数，就可以设置此 Annotation 在使用的时候，可以重复作用与同一个元素了。</p><p>不过感觉这个东西用处不大啊，如果要传入多条参数的话，直接修改注解定义的参数即可了。</p><h4 id="4-Inherited"><a href="#4-Inherited" class="headerlink" title="4. @Inherited"></a>4. @Inherited</h4><p>Inherited adj. 遗传的，继承的。 这个用来表示对于某 Annotation，注解了父类之后，子类是否会继承这个注解。需要注意的是这个元注解只能作用与同时拥有 <code>Target(ElementType.TYPE)</code>  元注解的 Annotation，因为有 @Inherited 的前提是有继承关系，因为只有类和接口能被继承，所以才有这样的硬性规定。</p><p>如果某 Annotation 允许子类从父类或接口那里继承与自己的话，只需要在定义 Annotation 的前面加上元注解 <code>@Inherited;</code>  即可，不需要填写任何参数。</p><h4 id="5-Documented"><a href="#5-Documented" class="headerlink" title="5. @Documented"></a>5. @Documented</h4><p>在使用 javadoc.exe 进行抽取一个 java 文件里面的类的信息的时候，自定义的注解一般不会被提取并显示在生成的文档中，也就是说，我们在 javadoc.exe 看一个类的信息的时候，如果使用了自定义的注解，那么默认这些是在类信息里面看不到的，我们不知道这个类有没有使用某种特定的注解。</p><p>如何让使用某个我们自定义注解的类，它提取文档里面有此类使用了我们定义的注解的信息呢？</p><p>答案就是在定义这个注解的时候，在这个注解前面加上元注解 @Documented 即可。这样凡是使用了这个注解的了类，在自己的文档里面就会有体现使用我们定义注解的信息了。</p><h3 id="定义-Annotation"><a href="#定义-Annotation" class="headerlink" title="定义 Annotation"></a>定义 Annotation</h3><p>综上，我们可以总结出来定义一个 Annotation 的方法：</p><p>首先使用 @interface 定义一个拥有名字的注解，然后往此注解中添加参数，建议所有的参数就加上默认值，最后使用元注解对自己定义的 Annotation 进行修饰。</p><h2 id="利用自定义的注解"><a href="#利用自定义的注解" class="headerlink" title="利用自定义的注解"></a>利用自定义的注解</h2><h3 id="获取被标注的注解的实例"><a href="#获取被标注的注解的实例" class="headerlink" title="获取被标注的注解的实例"></a>获取被标注的注解的实例</h3><p>实际上利用自定义的注解主要是利用 RUNTIME 类型的注解，而要按照标注的注解处理程序，就需要读取到这些注解，并分析注解里面的属性值。注解是依托于被标注物存在的，所以我们读取这些标注的方法就是依靠被标注物的反射机制获取的。</p><p>对于一个类来说，可以通过使用反射获取一个保存了它 <strong>所有信息</strong> 的 Class 类的实例，既然是所有信息，那么也包括它的注解，而获取注解的方法就是使用 Class 类中的方法。同理，对于方法，字段，构造器的反射出来的实例也有用来处理注解的方法，比如判断某个注解是否标注（参数里的 Class 为注解的 Class 类实例（本质是接口嘛））：</p><ul><li>Class.isAnnotationPresent(Class)</li><li>Field.isAnnotationPresent(Class)</li><li>Method.isAnnotationPresent(Class)</li><li>Constructor.isAnnotationPresent(Class)</li></ul><p>举个例子，判断类 Tempest 中的方法 Xorex() 中是否有注解 <code>@Override</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tempest.class.getMethod(<span class="string">&quot;Xorex&quot;</span>).isAnnotationPresent(Override.class);</span><br></pre></td></tr></table></figure><p>当然还可以直接获取注解的 Class 实例，使用的是下面，返回的是标记此元素注解的实例（包括具体的属性的）：</p><ul><li>Class.getAnnotation(Class)</li><li>Field.getAnnotation(Class)</li><li>Method.getAnnotation(Class)</li><li>Constructor.getAnnotation(Class)</li></ul><p>或者直接返回所有的注解，返回类型是 Annotation[]：</p><ul><li>Class.getAnnotations()</li><li>Field.getAnnotations()</li><li>Method.getAnnotations()</li><li>Constructor.getAnnotations()</li></ul><p>所以利用反射机制获取注解实例的方法有两种，一种是先判断有没有，然后再获取，另外一种是直接获取，如果没有就会返回 null 注意处理这种返回情况就可以了。</p><hr><p>这里有一个比较特殊的注解获取，因为能被注解标注的，除了上面几个意外，还有方法的参数们。而参数们又对应着不止一个注解，所以 Method.getParameterAnnotations() 返回的是一个 Annotation[][] 的二维数组，第一维对应的是不同的参数，第二维对应的是参数的不同注解。</p><h3 id="利用注解信息处理代码"><a href="#利用注解信息处理代码" class="headerlink" title="利用注解信息处理代码"></a>利用注解信息处理代码</h3><p>现在我们知道了如何获取被标注代码中的注解信息，那么我们就可以根据这些注解信息的不同，采用不同的方式处理这些代码，比如我们可以写一个测试框架，对于输入的一个类，获取所有的方法，然后对于每一个方法，判断是否存在注解 <code>@Test</code> ，若存在，则利用反射执行这个方法，判断是否抛出异常从而记录日志。如果没有注解 <code>@Test</code> ，那么就不测试，最后输出测试日志。</p><p>这就是注解的一个用途，帮助程序分析程序。</p>]]></content>
    
    
    <summary type="html">在计算机语言中，注释是计算机语言的一个重要组成部分，用于在源代码中解释代码的功用，可以增强程序的可读性，可维护性，或者用于在源代码中处理不需运行的代码段，来调试程序的功能执行。注释在随源代码进入预处理器或编译器处理后会被移除，不会在目标代码中保留其相关信息</summary>
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="笔记" scheme="https://xorex.space/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="注解" scheme="https://xorex.space/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>我的2020年</title>
    <link href="https://xorex.space/2021/01/10/be626d8ced18/"/>
    <id>https://xorex.space/2021/01/10/be626d8ced18/</id>
    <published>2021-01-10T03:06:27.000Z</published>
    <updated>2021-02-20T14:18:42.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这神奇的一年"><a href="#这神奇的一年" class="headerlink" title="这神奇的一年"></a>这神奇的一年</h2><p>2020 年一直对于我来说都是一个很神奇的年份，可能是因为这是 21 世纪第二个十年的最后一年吧，各种宏伟的计划的实现时间都定在了 2020 年。出于对美好未来的向往，自然十分期待 2020 年的到来，而当我开始写下这篇回忆录的时候，2020 已经接近尾声了，站在年末，不得不说，2020 真的是一个很神奇的年份，无论是对于世界还是我。</p><p>本来作为懒狗的我是不太想写这些东西的，但是想到自己差到爆炸的记忆力，觉得还是有必要把这些经历都记录下来，因为今年发生的事情还都是非常有纪念意义的，无论是好的方面还是差的方面，2020 年真的是让人又爱又恨啊。</p><h2 id="绝不松懈的复习"><a href="#绝不松懈的复习" class="headerlink" title="绝不松懈的复习"></a>绝不松懈的复习</h2><p>在 2020 的开头，最深的记忆还是和丹阳同学一起学习的时候的情景，有一个能一同努力的伙伴真的是非常棒的体验。那个时候的我学习状态处于最巅峰的时候，每天的学习任务都安排的满满的，和丹阳同学讨论题目，一起进步，最后在寝室锁门前的 5 分钟冲刺回去，路上还要记忆一两个知识点。也正是和他坐在一起的时间里面，我学到了他的一些高效的学习方法，印象最深的是用一个总结本去记录所有重要 知识点/易错点，然后早读的时候拿出来进行记忆，这个习惯一直陪伴到了我高考结束，也帮助了我很多。</p><blockquote><p>我们两个人的座位：</p></blockquote><p><img src="https://xorex.space/image/143.jpg" alt="我们两个人的座位"></p><p>紧张的学习生活中也有一些令人放松的事情，比如拍一拍的美景：</p><blockquote><p>寝室6楼阳台眺望市区：</p></blockquote><p><img src="https://xorex.space/image/144.jpg"></p><blockquote><p>早上联考开始之前的天空：</p></blockquote><p><img src="https://xorex.space/image/145.jpg"></p><blockquote><p>晚自习下课测试刚更新 Flyme 的超级夜景：</p></blockquote><p><img src="https://xorex.space/image/146.jpg"></p><p>除了拍照片来放松，研究微积分也成为了那个时候我的乐趣之一。当时一边在 bilibili 上看 3b1b 的微积分视频，一边在下面证明各种课本上的求导公式，差点走火入魔。也正这有些不务正业的学习研究，让我对原理有了非常执着的追求和欲望。后来由于复习到了解析结合，复杂的运算才让我缓了缓学习方向，开始面向高考学习的刷题生涯之中（因为解析几何让我计算的非常痛苦，我甚至还买了好几本质量非常棒的纸来算题）。</p><p>由于一轮复习的进度飞快，导致我一些知识点根本来不及学习，只能不断的追求老师的进度，所以就给自己定下了寒假用来查漏补缺的任务，计划美好的让我不禁对寒假期待满满。期间还有了两条新闻，一条就是晚自习前的新闻播报了武汉华南海鲜市场出现了不明病毒，另外一条是教育部发布的取消自主招生的信息。在当时，我显然只主要到了后者，研究着它对我升学的影响。当时的我认为中国的医疗水平已经很厉害了，即使遇到过去的非典那样的病毒，也能很快的解决，抱着对社会主义的无比优越性的信念，我根本没有把它放在心上，更别说关心后续发展了。</p><h2 id="寒假要查漏补缺"><a href="#寒假要查漏补缺" class="headerlink" title="寒假要查漏补缺"></a>寒假要查漏补缺</h2><p>美好的寒假也如期到来，我和丹阳一起选择了放弃过春节返校学习，虽说当时病毒已经感染了好几百人，但一是武汉已经封城，对国家力量的非常信任，二是觉得那是发生在武汉的事情，距离几千公里之外的小城市应该不会受到什么影响。所以，还是满脑子想的是寒假的各种学习安排，根本没有把病毒放在心上。</p><p>留校学习的时光非常快乐，我带来了寝室的台灯，丹阳搬到窗户旁边，有了光，学习就没有阻力了。一天主要就是在学习的沉默中度过的，当然偶尔也会在一起交流一下一些习题。第一天中午我们跑去河南理工大学的门口解决了午饭，虽说吃的挺不错的，但是还是觉得跑那么远太麻烦了，索性就买了七八桶泡面，作为后面时间的存粮。</p><p>留在学校里面学习的，除了我们两个男生，还有路sir。不过身为一个女生，她自然对安全问题比较在意，面对病例不断增加的疫情，她在除夕之前就收一堆教材跑回家学习了。丹阳因为过年要在老家呆两天，临走前也带走了一堆书，只有我仗着不回老家，而且想要给自己在新年第一天放个假，就什么都没带回家过年去了。</p><p>万万没想到，大年初二，全国戒严了……</p><p>当我带着口罩骑着电动车开开心心到学校门口之后，保安叔叔给我来了个赶快离开的手势，然后说，学校封校了，赶快回家。我傻了，只能骑着电动车回去了。到家之后，因为自己的寒假计划完全被打乱了，也不知道该干什么，只能背背单词看看错题划划水，等待着寒假结束。</p><p>但是全国的疫情已经越来越严重了，武汉病例随着大规模检测的铺开开始飞升，全国其他地方也开始不断新增病例。这个时候，我就知道开学已经没有希望了，寒假必然延期。果然在初六的时候，老师宣布假期延长了10天，剩余时间的学习转为线上学习。老师给我们发了一个课程表，每科老师会在课程表对应的时间给我们发一些电子版本的学习资料，让我们去写。虽说每天写的都很水，但是还是跟着老师开始了线上的学习。</p><h2 id="本质还是老懒狗"><a href="#本质还是老懒狗" class="headerlink" title="本质还是老懒狗"></a>本质还是老懒狗</h2><p>线上学习的前几天我还跟着认真的学习一下，到了后面厌学情绪飞涨，坐在电脑面前让我来学习？于是我的摸鱼时间越来越长，作业也开始复制粘贴，各种东西都开始应付起来了。每天我的日常就是早上 6:30 起床，然后趴在床上旁边放一本书装作在学习知识点，实则趴在抱枕上睡大觉。睡到了早晨 9 点，起床打开电脑，查看新更新地疫情数据，然后打开知乎开始看热榜，看完热榜打开 bilibili 看视频，看到中午之后就去吃午饭，下午到晚上重复上述状态。</p><p>大概就是这样一直在假装学习，因为真的是学不进去，这是我很小很小的时候就有的习惯了，在家里只想玩，一点学习的欲望都没有。强制自己去认真学习也效果不大，因为根本没有任何效果，该怎么样还是怎么样，于是就破罐子破摔了。</p><p>疫情也随着时间的流逝不断地发展着，湖北每天数千例地增加，病毒在全国开始蔓延，每个人都忧心忡忡，医疗队援助湖北，火神山雷神山医院飞速搭建。这是中国的至暗时刻，那种恐惧和无力的感觉，笼罩着每一个人。</p><p>大概就是这样经过了一个月的时间，吃喝玩乐然后再后悔，后悔完再吃喝玩乐。看动漫逛知乎写代码，除了学习啥都干了。全国的疫情还没有看到停止的希望，我一度认为我的高四要白给了，每天看着高考倒计时越来越短，有种绝望的感觉，于是开始安慰自己二本学校也不错，只要能学计算机就行。</p><p>后来国内疫情开始慢慢好转了起来，国外开始爆发了。英国搞全体免疫，意大利猛超中国，美国穷追不舍，各种神奇的骚操作看呆了。然后国内病例开始慢慢减少，似乎有了开学的希望？终于到了 3 初，河南病例清零，焦作也 15 天没有新增，老师通知我们，做好 3 月 15 日开学的准备。</p><p>在家里划水了一个多月的我开心极了，如果 3 月 15 号能开学的话，自己的高四还能拯救一下。然而盆冷水很快泼了下来，开学时间又延长了。我只能在家继续划水，等待着新的消息进展。这个时候郑州突然冒出来了一例新增，此人趁着放假跑去了意大利看球赛，意大利因为疫情爆发取消了球赛，他在意大利玩了几天之后就绕路回国了，然后隐瞒行踪，继续上班，结果被查出了新冠阳性，被网友骂了个狗血淋头。</p><p>原本看到了开学曙光的我直接绝望，如果郑州出现了疫情，那么开学继续遥遥无期，我开始学习也遥遥无期。虽说中间老师有从学校给我们带来过一些学习资料，但是在家的我根本没有办法进入学习状态，想要认真的学习只能回到学校里面。</p><h2 id="好像还有得救啊"><a href="#好像还有得救啊" class="headerlink" title="好像还有得救啊"></a>好像还有得救啊</h2><p>后来有两个消息，一个是河南教育厅公布了河南省初高三的返校时间是四月七号，另外一个是国家教育局公布了 2020 年的高考时间延长一个月，改为七月七日。这两个消息在同一天公布，知道了这些的我开心到爆炸，还是有机会的，还剩下三个月的时间，还是能拯救一下我的文化课的。</p><p>开学的时间如期而至，学校的防疫措施也非常完善，寝室被分隔开来来，所有学生错峰吃饭，餐厅的桌子全部使用隔板隔开，每个人有自己固定的座位。但是唯一的槽点就是统一的饭真的是太难吃了，无法想象的难吃，于是到了后期就是泡面的天下了。</p><p>开学自然要开始测试来检测自己的学习成果，于是开学考就来了，然而奇怪的是，在家里完全没有学习的我反而考了最好的名次，好迷啊。为了修补自己在家里欠下的二轮复习，就开始疯狂的刷起来教材，发现做题越来越顺，各种题型也都开始通晓了它们的套路，成为了做题能力疯狂增长的做题家。</p><p>我的高考有救了！</p><h2 id="去应对一切可能"><a href="#去应对一切可能" class="headerlink" title="去应对一切可能"></a>去应对一切可能</h2><p>快速进入学习状态的我开始了快速的复习，到了最后一个月，我已经将二轮复习完全补完了，做题能力大幅度上升，但是因为不细心却导致了很多错误，尤其是理综，有的时候甚至能错上七八到题目，比如下面图片的考试，理综就因为不细心雪崩了，我就把成绩贴到桌角来激励自己。后面开始专门刻意的去训练自己的准确度，经过了一段时间之后有了很大的好转。</p><p><img src="https://xorex.space/image/147.jpg"></p><p>其次就是空调问题，随着进入六月，天气也开始越来越热了，但是因为防疫的要求学校不给开空调。然后在一次数学考试中，因为天气炎热加上我做题不顺，一直流汗，注意力根本无法集中到考试上，心态大崩，只考了 70 多分。后面我一度很害怕，害怕高考的时候出现这样的情况，如果真的有了，那我直接完蛋。</p><p>后来有了一个新的同桌宝宝，和他坐一块也挺有意思。我们两个本质上是比较相似的，但是因为一些原因最后才熟悉起来。我们两个中间交流的话题挺多，而且都在周末不回家，呆在学校里面。到了周六晚上，其他同学回家，我们就呆在班里面开始我们一周一次的娱乐活动，下面就是我们用投影仪一起看辉夜大小姐的时候：</p><p><img src="https://xorex.space/image/148.jpg"></p><p>学校当时三轮复习结束之后的策略就是以考代练，让我们疯狂的写卷纸，写了好几个星期。但是写着写着感觉自己不知道学什么了，每天都在一套一套的刷卷纸，刷完总结错题，那个时候的我一度非常泄气。于是将策略开始转向了背书，尤其是生物。由于自己的记忆力真的是非常差，就提前搞了一个生物知识点的总结，写了足足一本，背了好几轮。每天中午就到实验楼四楼我专属地盘背书，非常爽。</p><p><img src="https://xorex.space/image/149.jpg"></p><h2 id="结束了高中生活"><a href="#结束了高中生活" class="headerlink" title="结束了高中生活"></a>结束了高中生活</h2><p>高考的最后倒计时，没有想想的那么紧张，感觉自己该学的都学过了，就是不断地巩固复习，做题保持手感。我也开始尝试了一些新的东西，比如早上跑步。每天早上跑完步之后真的是非常清醒，也让我爱上了这种感觉（虽说到了大学已经丢掉了） ，中午吃饭的时候也开始挑战最短时间，我还专门用手表开始计时。我记得从放学跑到餐厅，吃完午饭之后跑回回班里最短用了 7 分钟。</p><p>距离高考只有10天之前我感染了普通的流感病毒，成功感冒发烧，当时的我一度非常高兴，因为现在到高考的时间足够我痊愈了。这样到了高考，我就一定不会生病（对此流感病毒免疫），可以用最好的状态迎接考试了。同时考试之前我也开始在意各种身体的状态，尽可能地保证自己的考试状态。</p><p>最后几天我开始逃课到四楼复习，因为老师的安排就是一套一套写卷纸，实在是写吐了，就开始全面的过知识点，做最后的巩固。时间不断流逝，高考也最终来了。这是对我来说真正意义上的高考，是我真的给予了非常大的期望的考试，虽说已经考过一次了，但是却比第一次紧张多了。</p><p>复读生被安排到了一个单独的学校，实验小学，虽说有点担心考试场地对我的影响，但是好在其实并没有什么影响，空调凉度适中，桌椅大小合适，也就钟表看的不太舒服，到了第二场考试这个问题也被解决了。就像是换了个地方考了一次模拟一样，我的第二次高考结束了，没有任何意外，一切顺利！</p><h2 id="毫无压力的暑假"><a href="#毫无压力的暑假" class="headerlink" title="毫无压力的暑假"></a>毫无压力的暑假</h2><p>考完试之后，第一件事情就是买电脑了，我高考前心水了很久 小新Pro13锐龙版 在拼多多的百亿补贴上面降价到了 4199，考试结束当天下午就买了下来。至于手机我并不着急，手里的魅族X8还能使用，而且今年发布的手机没有一个令我满意的，就先没有购买手机。</p><p>考试结束的晚上是在睡不着，就找网上的答案对了一下，感觉还行，不好不坏的样子，算了一下分数乐观估计大概在 600 分左右，就安心去睡觉了。之后的暑假，报名了驾校，开始了代码能力恢复计划，写起了《我的高中生活》（虽然太监了）。剩下的时间就是看看动漫玩玩游戏，然后就是仔细挑选大学。</p><p>大概是用了两天左右的时间，将好几个分数段的学校都开始了筛选，根据我的需求，筛选出来不少学校，把他们汇总成 Microsoft Todo 里面的任务，什么分数，什么排名，对应什么学校，当时的我统计的一清二楚，只要成绩出来，就马上可以锁定一选过的院校。</p><p>之后就是打工生活了，林泽音小姐姐介绍了我一份比较摸鱼的工作，由于这个工作可以用来学习的时间比较多，于是我就欣然接受了。是争鸣学堂的班导工作，主要负责处理班级里面的各种杂事，比如收发作业，打印卷纸，批改听写，打扫卫生，和老师对接等等。虽说要从早上8点工作到下午7点，但是实际工作时间很短，大部分都是上课时间，我只需要坐在最后面，时不时关注一下学生们的动态，记录一下大致情况，拍一些照片即可。剩下的大把时间都可以用来学习，比如刚开始的一个星期我都用来看 CSAPP 的英文版了。</p><p>到了 26 号，就是公布高考成绩的时候了，说不紧张那是假的，我比去年紧张多了。去年我还能安心睡觉，等到人少的时候再起床查成绩，今年就完全做不到了。坐在电脑面前开始刷新网页，刷到了凌晨三点左右才出来成绩。613 分，省排 3.2w ，对我来说还不错。</p><p>报考志愿主要在 成都信息工程大学 和 郑州大学 之间犹豫。中间经历了几次修改之后，最后为了计算机类的专业，选了成信。但是宝宝因为自己考的比较差，所以没啥心情报考志愿，我就给他解决了，冲了成都的几个学校，留了 华北水利水电大学 保底，最后保底了进了软工。</p><h2 id="绝不停止的学习"><a href="#绝不停止的学习" class="headerlink" title="绝不停止的学习"></a>绝不停止的学习</h2><p>结束了打工之后，理所当然的去考科目一了，毕竟已经拖了快半个月了。考科目一的时候遇到了同样来学车的初中数学老师（当时感觉没有脸面见她，毕竟复读了还是感觉丢人），中间在开始考试之前交流了一些近况之类的。科目一当时理所当然的一次就过了，虽说自己记忆力不太强，但是区区科目一还是很简单的。</p><p>然后就是科目二的学习，刚开始不知道去预约啥的，就在上车模拟那里花了很长的时间，导致整个科目二整整学了将近一个月。</p><p>后来从又林泽音小姐姐那里又搞了一个活，去 JZYZ 机房做助教，来帮助高一萌新们快速入门信息学奥赛。当然这个我当时并不知道有工资，只是单纯的想要帮学弟学妹们学习，因为自己当年在学习竞赛的时候也受到了学长们的帮助，于是就想要把这种一代帮一代的精神延续下去。</p><p>然后就多了一个学习的地方，也见到了帆神刘神尧神，得知刘老师从浙江回来了，认识了新来的张文军教练。中午有免费的咪小多吃，培训最后还有学妹送奶茶喝（送给Hvcime了）。最后一天我们 2019 届的 OIer 们和刘老师一起出去吃了晚饭，大家在一起畅所欲言，回忆过往的趣事，也了解了刘老师在浙江的这三年的工作，大家都很开心。总之整个打工过程真的是非常快乐啊！</p><p><img src="https://xorex.space/image/150.jpg"></p><p>后来大家的高考录取结果就都出来了，我被成信的信安专业录取，林泽音小姐姐录了郑大的管科，帆神录了哈工程的计算机，结果都还不错。虽说我没有被我最想去的软工和计科录取，但是在网上查询了成信的信安之后，发现了新世界，说是成信的三叶草安全技术小组实力非常强大（<del>脚踩川大，拳打电科</del>），而且还附上了招新群。于是一无所知的我就加入了这个招新群，跳进了一个新的大坑。</p><p>在这个招新群中混了几天，到了一天晚上，群里突然有人开始刷：师傅我想学web，我就也开始跟风刷了一句（当时还不知道 Web 和 二进制 两个方向是做什么的），突然一个学长就申请添加我为好友，然后大概给我说了说如何入门 web 安全，让我去看看 HTTP 协议和 HTML 相关的东西。大概过了几天之后，他把我拉到了一个 Web 的学习群里面，并利用语雀平台给我们布置了第一个任务：学会基本的 SQL 语法，并使用自己搭建的 MySQL 环境进行练习，时限大概三天左右。</p><p>这个任务对于我来说还好，但是对于计算机新手来说一点也不简单，我在浪爷给的练习网站里面练了不少 SQL 的语法，虽说练习的这些和安全关系不大。不过也是见到了一些超级大佬，比如即使是新手任务也能按照地狱级难度完成的 <code>FeverKing</code> 大佬。第二次的任务就有点难得离谱了（对于新手来说），直接让搭建本地服务器，然后实现 SQL-Labs 的环境，然后打通他。</p><p>这让我这个完全没有接触过除了竞赛以外的计算机相关来说，直接蒙了，前两天都花时间在手动搭建服务器上面了，Apache MySQL PHP 三者的联动手动配置起来真的是非常的麻烦，我对于网络这些完全一窍不通。虽说学长给了 PHPStudy 这种一键部署的工具，但是因为这个工具没有适配高分辨率屏幕，在我本来看起来就非常小的笔记本屏幕上看起来根本没有办法使用。配置了一天也没有成功的我只能放弃，开始贴着屏幕使用 PHPStudy 完成了环境的搭建。</p><p>后面的 SQL-Labs 的学习更加艰苦，因为根本不了解内部的原理，所以只能在网上找教程，但是教程里的每一个字我都认识，组合在一起就看不懂了。大概花了好几天，才慢慢熟悉什么是 SQL 注入，以及整个 SQL 注入的攻击流程，虽说有点延期，但是还是顺利完成了这个任务。当时和林泽音小姐姐一起呆在一中学习，我完成 Web 小组的任务，她在一旁学习高数（因为要转专业），每天大概 10 点多一起回家（有个能学习的地方和学习的伙伴真不错！）</p><p>就这样，在每天持续学习的过程中过完了暑假，一个很充实的暑假，接下来，就是大学生活啦！</p><h2 id="开始了大学生活"><a href="#开始了大学生活" class="headerlink" title="开始了大学生活"></a>开始了大学生活</h2><p>临出发去成都之前，研究了怎么买机票，登机，订酒店，购置了一些必需品，然后怀揣着对未来的期望，与凌晨三点从家里出发前往郑州机场，开车前往郑州的路程中，看到了漆黑一片的龙源湖公园门口有着唯一的灯光，那是一个小吃车，旁边有个中年妇女，在凌晨三点半的时候就已经开始了自己一天的辛劳，这个时候突然感觉自己好幸运啊，能够去读大学，去学习自己挺喜欢的计算机，然后以后能找一份体面的工作，不用这样辛劳，应该学会满足和感恩啊！</p><p><img src="https://xorex.space/image/151.jpg"></p><p>到了郑州机场时间还比较早，就在机场吃了早饭（好贵贵贵啊！）但是不知道需要提前好久去安检登机，就差点迟到了。想着以后自己坐飞机的机会还多，就把靠窗的位置给了父母，在伴随着巨大噪音的加速中，我前往了这个未来我要居住四年的城市——成都。</p><p>到了成都之后，和父母一起去逛了几个比较著名的景点，吃了成都的火锅（感觉一点也不辣啊），最后去超市买了各种生活必需品。其实逛了大半个成都之后感觉还是很失望的，在我的印象里面，成都应该是发展很棒的新一线大城市啊，但是大部分的城区也就十八线小城市焦作的级别，大概只有市中心（春熙路）和地铁（超方便）看着才有大城市的感觉，好在成都的物价比我想象的低，吃喝没花多少钱。</p><p>开学之后感觉成信的校园就是加强版本的焦作一中，四改六的寝室看着比想象的好一些，餐厅比较一般（一中餐厅永远的神！）。不过好在寝室里的同学还都不错（除了旁边打游戏用青轴开外放的那个），16 栋 5034，条件比一中的八人间好很多，有了自己的小桌子，有了独立卫生间，有了自己控制的空调。寝室里的同学们也是来自天南地北，比如来自江浙沪发达地区江苏苏州的唐震，看着像南方人实际来自东北辽宁的税奕铭，还有来自和焦作距离很近的山西长治的吕子韬，剩下两个则是四川绵阳和四川都江堰的胥宇杰和饶飞杨。</p><p>大学的课程也是直接给我喝了一壶，高等数学和线性代数直接变成定义朗诵课，除了C语言真的能学到知识以外（然而我已经掌握了），剩下的就全部都是大水课了。定义朗诵课的结果就是我根本听不懂，只能上课自己看书，但不讲人话的教材看的也是一头雾水。</p><p>后来和另外一个在 Web 学习小组的同学一起去三叶草安全实验室参观了一下，学长们都在显示器面前钻研技术，实验室的各种获奖证书叠了快有人高，最前面的是近几天刚刚拿到强网杯的全国第七，被邀请到线下决赛。三叶草的学长们也都很友好，和我们交流了一下各自的情况，还欢迎我们常来实验室玩，氛围真的是非常棒！</p><p><img src="https://xorex.space/image/152.jpg"></p><p>由于我有编程的基础，所以在寝室里面可以指点其他同学学习C语言，他们就因此以为我是大佬，纷纷给我取了源老的代称，想想我只不过是比他们多了编程的基础而已，并没有什么了不起的。</p><h2 id="信息安全好难啊"><a href="#信息安全好难啊" class="headerlink" title="信息安全好难啊"></a>信息安全好难啊</h2><p>过了大概半个月之后，看着这课程我就完全听讲不下去了，因为完全听不懂老师们朗诵的内容，于是就开始在课堂上各种划水。安全的知识继续跟着 Web 小组的进度学习，不过已经没有刚开始的时候那么困难了。就这样，一个月的大学生活就这样过去了。按照三叶草安全小组的传统，会有一个安全比赛——极客大挑战，来帮助成信的学生们入门信息安全，从而方便自己选拔实验室成员。这个比赛如期而至，不过需要两个人组成一个队伍，一个人解决 Web 方向的题目，另外一个人解决二进制方向的题目。就这样，我认识了在寻找队友的二进制大佬 77，和他组成了一支队伍，队伍名字为：桃李春风一杯酒。因为他想要一个有诗意的名字，所以就按照他的意思定了。77 是我们这一届中最早接触安全的人，暑假被令则带着学习了两个月，大概是当时成信 20 届二进制第一人，所以他很想拿第一名。由于我当时还没有清晰的认清楚我和其他大佬的差距，就答应他会好好打比赛，努力实现这个目标，现在想想真的是给自己挖了个大坑。（我和各位大佬都在完成 Web 小组任务，比较面向新手，自然大大限制了大佬们的上限，让我以为和大佬们都能完成小组任务就说明我能跟上大佬们的进度了）</p><p>然后就是去参加三叶草的宣讲会，去的人很多，场面很热闹。现场演示的各种破解也很有趣，爆破了教室摄像头，学校门禁，共享单车，CSGO游戏，QQ空间等等，酷到爆炸。很难不让人对三叶草充满了向往：“去成为一名 Hacker 吧，少年！” 宣讲会结束之后就是一面，拿到了两个最高的 P 评价，剩下的就是等待明天开始的极客大挑战了。</p><p>于是，接下来的两个月，我的漫长的噩梦开始了。</p><p>在此之前，因为周围人大多都没有计算机相关的基础，所以刚开始我的自我感觉还算良好。无论是为数不多的坚持下来跟着 Web 小组的进度学习，还是在零基础同学们面前的 “大佬风范” ，都让我感觉自己学习能力还可以，但这不过是因为大家都是零基础造成的假象罢了，不过是没有站在同一起跑线上的比赛。</p><p>极客大挑战开始的当天，我和 77 一起去图书馆解题。早上 9 点，第一波题目被放了出来，我负责的 Web 一共有五道。一个小时之后，我顺利的把五道的三道解决了，都是比较简单的题目，跟着提示就可以完成了。剩下的两道中，有一道是卡在了不知道去哪里找 Flag，另外一道是完全不知道思路。</p><p>剩下的时间就是不停的在看这两道题目，在网上搜索相关的内容，想办法找到这些题目的思路。然而过了一上午也想不出来，当然想不出来了，这可是第一次做 CTF 的萌新，怎么可能想出来呢。这个时候旁边的 77 已经把除了 pwn 以外的其他所有题目都解决了，我们队伍的排名也上升到了前列。吃完中午饭之后，77 开始学习 pwn 的知识，而我继续搜索这两道题目的相关内容。这真的是一个非常痛苦的过程，因为完全什么都不知道，只能生硬的在网上漫无目的的搜索，而且这个搜索已经进行了三个小时了，我都想放弃了，但是旁边的队友很兴奋，时不时刷新着排行榜。我只能硬着头皮继续在互联网上毫无方向的搜索着，看着各种专业名词的文章，想办法找出和题目相似的地方。</p><p>这个时候 77 已经完成了除了 Web 方向的所有题目，在旁边给我加油。然而我已经一无所获 5 个小时了，处于接近崩溃的边缘，满脑子想着，我为什么要和他组队呢，这实力差距好大啊，自己这么菜肯定回让他失望了吧！好在这个时候一道 Web 的题目放出了提示：Do you know CSRF ? 我赶快去搜索了这个名词，好像这就是这道题目的题型。</p><p>花了半个小时大概明白了什么是 CSRF，然后开始摸索如何解决题目，经过漫长的思考和各种尝试，大概摸索出来了一条道路，花了 4 个小时解决了它。拿到 Flag 的那种释然简直爽到爆炸。但是第一题 Welcome 怎么都不知道去哪里获取 Flag，一天过去了也没有解决。这道题目更加让人崩溃，我已经将 PHP 配置文件看了数十遍，一点思路都没有（因为是萌新，当然没有思路了），最后是十几天之后，77 从其他人那里问到的方法，才找到 Flag 在哪里。</p><p>后面的题目就更加难的离谱了，为了不辜负 77 的期待，不拖他的后腿，开始了和 77 一样每天晚上熬夜，白天上课补觉，睡醒了继续做题的打工生活。但还是太难了，对于我来所，这些根本没有见过的题目根本没有办法凭空想出来思路。绝大部分都是在毫无进展的情况下，看着没有回显的页面发呆，然后不停的绝望和怀疑人生。最可怕的是我不能停下脚步，我不能放弃，因为我还有队友 77 ，他实力那么强大，他想要个好排名，我也要和他一起努力才行。</p><p>但着毕竟是努力无法解决的，不会就是不会，想不出来就是想不出来。再多的努力也是徒劳的，只会把耐心一点点消磨殆尽，然后陷入绝望。每天吃饭难以下咽，睡觉都在想着题目如何解决，但太无力，留给自己的只有无尽的绝望。于是我开始尝试逃避 77 ，逃避他期待的眼神，开始尝试停下毫无进展的解题过程，开始第一次早早上床睡觉，但是满脑子仍然亲不自禁的想着题目。然后在有一天，将这些告诉了他。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">感谢你啊</span><br><span class="line"></span><br><span class="line">说实话，前几天真的是有些自闭了，可能是学习的方法不对，也有可能给自己的压力有点大了（本质还是我菜）</span><br><span class="line"></span><br><span class="line">那时候我觉得我很后悔和你组队，你二进制那么厉害，除了re，pwn，还做完了杂项和密码学，我连自己的web都搞不定，我基本全程拖后腿。</span><br><span class="line"></span><br><span class="line">看着 fever_king 每天熬夜肝题，一道接一道，最后 AK，感受到了实力差距的绝望。</span><br><span class="line"></span><br><span class="line">暑假的时候学了几种语言打了几个靶场就以为自己比其他新生厉害很多，极客大挑战应该问题不大，现在看来问题大了</span><br><span class="line"></span><br><span class="line">即使和我一样同时学习安全的 f1ve 都能坚持下去肝题，一直忘不了他给我发好友申请时候的备注：喜欢web </span><br><span class="line"></span><br><span class="line">看着一道题目，有时候都不知道要干什么，去查各种资料还是不知道如何解题。</span><br><span class="line"></span><br><span class="line">但是有时候这道题设置的waf是什么都不清楚，看着空白的回显页面发呆，就这样毫无进展的几个小时过去了。</span><br><span class="line"></span><br><span class="line">安全是什么都不懂就入了web的坑，跟着小组做了几次任务就觉得自己水平还可以，太Native了。</span><br><span class="line"></span><br><span class="line">真正开始比赛之后就露馅了，我还是菜鸡一个，就像一个小学生做高考压轴题，要干什么都不知道。</span><br><span class="line"></span><br><span class="line">想要放弃但是不能放弃，这不是单人赛，我放弃了你怎么办。</span><br><span class="line"></span><br><span class="line">开始不想碰那些毫无头绪的题目，开始想要躲避你的期待。</span><br><span class="line"></span><br><span class="line">想要躺平，但是每天一闭眼都会情不自禁的想 web 题目，一整夜都睡不好，吃不进东西。</span><br><span class="line"></span><br><span class="line">如果当初方向没选web，没去了解三叶草，没报全省只招2个计科的成信，就不会变成这样的情况吧。</span><br><span class="line"></span><br><span class="line">但这些都已经成为定局了，必须去面对问题，解决问题，逃避只会让它越来越糟糕。</span><br><span class="line"></span><br><span class="line">所以才会问你，你喜欢安全吗，所以才会告诉你这些内容。</span><br><span class="line"></span><br><span class="line">我实话说，我骗不了自己，至少现在没有办法欺骗自己，比起找漏洞做安全，我更想成为软件工程师。</span><br><span class="line"></span><br><span class="line">我觉得创造一样东西的时候，其本身就是一个很值得享受的过程。</span><br><span class="line"></span><br><span class="line">我很羡慕 fever_king 整夜不睡肝题目，羡慕他能说出来：虽然有点累但是做喜欢的事情就很快乐。</span><br><span class="line"></span><br><span class="line">就像我高考完去学 Python 做小游戏的时候，肝到凌晨四点但是很快乐（除了修bug不快乐）</span><br><span class="line"></span><br><span class="line">我没什么天赋，没什么毅力，只是觉得计算机挺有意思，学习它很快乐。</span><br><span class="line"></span><br><span class="line">未来要走什么路：安全/开发，或者两者一起；</span><br><span class="line"></span><br><span class="line">这些我还不太确定，但是唯一确定的是：</span><br><span class="line"></span><br><span class="line">我会继续坚持下去极客大挑战，会去学习更多的知识，尽可能的解决更多的题目，和你一起完成比赛。</span><br><span class="line"></span><br><span class="line">但可能还是会很大程度的拖你的后腿，这里向你说声抱歉了。</span><br></pre></td></tr></table></figure><p>所有话说出来之后，得到了他的理解，两个人也进行了非常坦诚的交流，这件问题也终于让我得到了一些释怀。但极客大挑战仍在继续，我还是需要去尝试解决这些问题，总的来说还是需要去面对绝望，但是压力没有那么大了。极客刚开始的第一周的压力是很难描述清楚的，没有经历过的人是很难感同身受的，以我的单薄的语言描述是根本无法体现的。他人的期待，题目难度的绝望，进退两难。可以很确定的说，那是我目前人生中最绝望的时刻，没有之一。</p><h2 id="绝望被大佬乱杀"><a href="#绝望被大佬乱杀" class="headerlink" title="绝望被大佬乱杀"></a>绝望被大佬乱杀</h2><p>随着极客大挑战的进行，三叶草的二面开始了。二面的 Web 有三个方向，第一个是代码审计一个购物网站，要求多个漏洞组合利用实现任意文件读取。第二个是两道 CTF 题目，第一道 SSTI，第二道 SQL 注入。第三个是拿 Src，直接过面试。由于被极客的 CTF 题目给狠狠暴打了一顿，所以我理所当然的选择了第一个任务，看了好几天的 PHP 代码，然而除了一个反向加钱的，一个有用的漏洞都没找到。</p><p>还有一件事情就是在上思修课的的时候，在抽屉里捡到了一台 iPad，然后在万能墙上发布了出去。第二天 zwh 找我说是他的 iPad 丢了，事情非常巧。可能是因为帮他找到了 iPad，他在报名 Connected Junction 黑客马拉松的时候，拉我组了一队，一起抱着无名神的大腿，前往了天府新区。</p><p>在这个比赛我全程都在做三叶草二面的第二个任务，其他都基本上是 zwh 和无名神在做。这次和新生实力比较强劲的小伙伴们接触了不少，最大的感觉就是难以融入他们。可能是觉得自己和他们的技术水平差距太大了吧，自己也不太愿意融入他们。比赛最后我们队非常意外的拿到了最具潜力奖，8000 块的奖金，我全程只做了一些数据处理，差不多算是白嫖了 1600 块。</p><p><img src="https://xorex.space/image/153.jpg"></p><p>比赛回来之后的生活就比较随意了，极客没怎么打，学了一些更广泛的东西。这个时候我的室友们正在完成道格实验室的二面任务，他们的学习进度飞快，把我吓了一大跳，甚至比我当时学习的速度还要快很多。于是不得不承认了自己学习能力并不出众的事实。各种因素结合起来并认真思考之后，我决定更换学习方向，从安全转为开发，成为一名码农搬砖工。</p><p>于是三叶草的三面任务我就完全放弃了，除了极客的影响以外，还有 Junction 的，大一参赛的基本都是三叶草候选人员，接触这几天感觉自己实力差距大到难以融入他们，我很害怕加入三叶草之后我的现状会延续下去，无论是并不喜欢安全，还是难以融入集体。最终决定放弃了加入三叶草，并和一直帮助我的浪浪学长讲了讲我转开发的事情，得到了他的鼓励。退圈安全之后把目光放到了一个开发实验室，IOTU 上面。其实开发实验室还有一个更好的选择——易控实验室，但是一是我错过了易控实验室的宣讲会，二是被室友和极客大挑战给弄的觉得自己很菜，单独面试也不太好，三是我迫切想要加入实验室用来学习，于是就去了比较好进入的 IOTU。</p><p>这一个多月我过的是非常痛苦的，简直是我人生低得不能再低的低谷了，每天都很失落，基本上就靠着单曲循环 Hiiro 的 潮汐，来改善一下自己失落的心情，这首歌真的是给了我很大的帮助去熬过那段时间。</p><p><img src="https://xorex.space/image/154.jpeg"></p><h2 id="迷茫的失去梦想"><a href="#迷茫的失去梦想" class="headerlink" title="迷茫的失去梦想"></a>迷茫的失去梦想</h2><p>接下来就是准备 IOTU 的各种考核任务，主要是深入学习了 C 语言，然后剩下的时间全部用来颓废了。可能是学习安全被打击的太狠了，之后的一个月我都没怎么好好学过技术了，在寝室里看了不少电影和动画。除了颓废看动画，为了拯救接近禁考的线性代数（因为极客前后一个半月没听过课了），也认真学了学它，真正感受到了线性代数的魅力，也更加坚定了以后不跟着老师，全部自学的决心。</p><p>虽说远远离开了三叶草和信息安全，也能稳稳的加入 IOTU，但之后的时间仍然处于一个比较低沉的状态。来到成信之后，我已经很久没有感受到快乐了，甚至用来治愈自己的好天气都没有。（垃圾成都天气，我毕业一定跑路！）对于放弃加入三叶草，内心还是有点可惜的，因为这毕竟是一个强的离谱的平台，拥有全成信最棒的资源，未来出路也都是 BAT 级别的大厂，自己在信安专业学习软件工程的内容，出路肯定回差不少。</p><p>再后来因为辅导员的管理松懈，我的逃课也越来越熟练了起来。对于即将到来的四级考试，我的内心也毫无波动，甚至因为题目过于困难想要去逃避它。感觉自己已经变成了一条挂在商店的咸鱼，完全接受了自己垃圾的现实，然后开始自暴自弃。中途想过要转专业去软工的，但是和班导交流过后，权衡了利弊放弃了转专业，现在想想的确是一个比较正确的决定，如果转专业去了软工，就没人上课帮我喊到来逃课了，作业完成和考试信息获取也会麻烦不少。</p><p>那段时间的每一天我都感觉不到我正在活着，仿佛自己就想一具行尸走肉一般。每天早上醒了之后，能逃课就逃了呆在寝室里，不能逃就去上课玩手机，然后是吃饭和看动画，最后一天结束之后躺床上睡觉。每天都是这样过下去的，很迷茫，很痛苦，很无助。</p><h2 id="没前途的打工人"><a href="#没前途的打工人" class="headerlink" title="没前途的打工人"></a>没前途的打工人</h2><p>不过好在很快就通过了 IOTU 实验室的选拔，并且拥有了自己的位置用来学习，实验室是和道格在一间教室里面的，实验室经过装修之后，两者没有隔开了。我最开始选择了第一排靠近讲桌的位置，并在双 12 在京东上购买了一台攀升的28 英寸 4k 显示器，不过由于多种原因：拓展坞的 hdmi 接口最大支持 4k30hz，显示器颜色过于偏黄，尺寸过大看着费力。在京东上又退掉换了一个 sanc 的 23.8 英寸 2k 显示器，无奈因为便宜货的背光太差，屏幕油腻感很严重，于是又退掉了（京东别拉黑我啊！）</p><p> 然后就是从零开始学起了高数，毕竟总不能等到快考试再去学吧，到时候可能就有点晚了。不得不说蜂考的课程是真的棒，用来快速入门高数真的是太爽了。有了一个学习的位置自然就要学习计算机了，我开发选择的方向是 Java 后端开发，因为觉得前端需要按照设计师给的图写代码，现在各个公司的 app 设计的都和 <code>*</code> 一样，让我写 <code>*</code> 一样的代码我肯定不太想做，还是去做后端的数据处理吧！</p><p>于是大概就一直学习起来了 Java ，学了很多面对对象的东西，不得不说 Java 的确很适合用来处理业务逻辑。不过因为是和道格在一间教室，所以经常能听到他们在讨论关于安全比赛的事情。比如全国各地到处旅游打比赛啦，大把大把的拿比赛奖金啦，去哪个大公司实习啦。真的让人非常羡慕啊，在成信最好的出路就是学习安全了吧，但是自己已经放弃了，放弃了一个更好的机会，以后要搞内卷严重的开发了，去当一名搬砖打工人。</p><p>同时也很羡慕在打 ACM 的林泽音小姐姐，她也志向将来读研，搞人工智能，以后也应该稳去大厂吧。花了一小段时间才接受自己将来要出苦力赚钱的现实（可能是在学习安全的时候，三叶草给自己对未来的憧憬拉的高度太高了吧，毕竟是人均 20k 的实验室），自己果然就是一条咸鱼啊。</p><h2 id="我的未来在何方"><a href="#我的未来在何方" class="headerlink" title="我的未来在何方"></a>我的未来在何方</h2><p>2020年的最后就要进入考试密集区了，已经考了两门，线性代数和大学计算机基础，大计基是靠着老师画的重点速成的，线性代数是自己真正认真研究学会的。想想果然在大学老师真的教不了什么真正给自己，当初报考志愿的时候还是太在意专业了（应该忽略专业去杭州师范的！），果然学习还是靠自己啊。</p><p>自己也想清楚了以后要做什么了，虽说这个过程有点坎坷，但是好在最终还是走上了正轨，走上了当初自己所期待的样子。不过对于未来的迷茫和不确定性仍然感到有点恐惧，2020 好好的给我上了一课，希望 2021 能温柔一点啊！</p><p>冲啊！要成为一名优秀的软件工程师啊！</p>]]></content>
    
    
    <summary type="html">年终总结是人们对一年来的工作学习进行回顾和分析，从中找出经验和教训，引出规律性认识，以指导今后工作和实践活动的一种应用文体。年终总结的内容包括一年来的情况概述、成绩和经验教训及今后努力的方向。</summary>
    
    
    
    <category term="阶段性总结" scheme="https://xorex.space/categories/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="总结" scheme="https://xorex.space/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="感想" scheme="https://xorex.space/tags/%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Java反射学习笔记</title>
    <link href="https://xorex.space/2020/12/28/1dd949f5ac1b/"/>
    <id>https://xorex.space/2020/12/28/1dd949f5ac1b/</id>
    <published>2020-12-28T05:41:58.000Z</published>
    <updated>2021-02-20T13:43:25.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><h3 id="JVM中保存类的Class"><a href="#JVM中保存类的Class" class="headerlink" title="JVM中保存类的Class"></a>JVM中保存类的Class</h3><p>在理解反射这个概念之前，我们要先理解一下 Class，Class 是一个 Java 自己带的类，注意这里的 Class 首字母是大写的，说明它是一个类的名字，而不是 类 的英文翻译，就像我们自己定义的一个类一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Xorex</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这叫作 Class 的类（这个名字容易误解成这个叫类的类，但实际上 Class 只是它的名字），也有自己的定义，虽然有点长：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">GenericDeclaration</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">Type</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">AnnotatedElement</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">TypeDescriptor</span>.<span class="title">OfField</span>&lt;<span class="title">Class</span>&lt;?&gt;&gt;,</span></span><br><span class="line"><span class="class">                              <span class="title">Constable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">                              &#125;</span><br></pre></td></tr></table></figure><p>那么这个叫作 Class 类有什么用呢？答案是用来保存其他的类。</p><p>在 JVM 运行的时候，它一边运行，一边会把自己需要执行的类放入自己的内存中，叫作<strong>动态加载</strong> （不会一次性全部加载，而是需要的时候再去找），比如一个程序我们需要 <code>Xorex</code> 和 <code>Tempest</code> 两个类并在程序中创建 N 个它们的实例。那么 JVM 运行的时候，会在第一次实例化的时候，查看自己的内存中有没有这个类的信息，如果内存中没有这个类，那么就会把这个类加载到自己的内存中，然后根据内存中的这个类的信息，创建一个实例（开辟一块内存空间存放这个实例的数据。），内存中有了这个类的信息之后，第二次创建实例就简单多了，只需要再开辟一块内存空间存放这个类的数据就算实例化了（实例是类的数据）。</p><p>那么我们放在内存中的类，是以什么形式的保存的呢？没错，就是用 Class 类的实例来保存，每一个保存在内存中的类，都是 Class 类的一个实例！这个类的所有信息都被保存在 Class 类的实例中。</p><h3 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h3><p>这里我们就可以引入反射的概念了，反射 Reflection ，就是利用一些能确定某个类的信息，映射出这个类，然后反射出整个类的所有结构。这个确定某个类的信息需要有确定性，比如某个类的完整名称（方法三），某个类的实例（方法二），或者某个类的 Class 包含的所有信息（方法一），只要有这些确定性信息就能映射到一个确定的类身上，然后反射出来整个类的所有信息。</p><p>既然我们可以通过 Class 获得一个类的所有信息，那么我们就可以不通过 new 运算符，来创建一个实例了。你可能想问，为什么要不通过 new 运算符来创建实例呢？</p><p>因为在框架编写中，并不知道使用这个框架的人要传入什么类来完成某个功能，但是我们仍然需要实例化使用者传入的类，完成框架需要执行的任务。这里就需要在不知道一个类的情况下实例化一个类，因而 new 运算符就失效了。但是 Class 的出现可以让我们先将一个类转化为 Class 类型，然后利用 Class 实例化这个类，最后对其进行各种操作。</p><p>将一个类转化为 Class 的方法有三种：</p><ol><li>使用一些类的静态变量 <code>Class str=String.class;</code></li><li>使用一些类的实例提供的 <code>getClass()</code> 方法 <code>Class str=&quot;Xorex&quot;.getClass();</code></li><li>使用一个类的完整类名来得到 <code>Class str=Class.forName(&quot;java.lang.String&quot;);</code></li></ol><h3 id="一个类一个Class"><a href="#一个类一个Class" class="headerlink" title="一个类一个Class"></a>一个类一个Class</h3><p>我们用上面的方法，能获取一个类的 Class 实例，这个实例包含着这个类的所有信息。回想上面 JVM 执行的过程，就可以发现每个类在 JVM 中只有一个 Class 实例（因为实例是根据类的构成创建的，类是唯一的，数据也自然是唯一的），那么我们无论通过什么方法获得某个类的 Class 实例，它们都应该是引用了同一个实例，所以就可以使用 <code>==</code> 来验证我们获得的 Class 实例是否为同一个实例，如果是，那么两种获得 Class 实例的唯一性信息所映射出来的类是同一个类。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class One=<span class="string">&quot;Xorex&quot;</span>.getClass();</span><br><span class="line">CLass Two=<span class="string">&quot;Tempest&quot;</span>.getClass();</span><br><span class="line"><span class="keyword">if</span>(One==Two) System.out.println(<span class="string">&quot;They a from a same class.&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> System.out.println(<span class="string">&quot;They a from a different class.&quot;</span>)</span><br></pre></td></tr></table></figure><p>其实这个特性是很理所当然的，对于一个类的信息，只保存一次，实例化的时候重复使用，节省内存。</p><h3 id="用类的Class实例来获得类的实例"><a href="#用类的Class实例来获得类的实例" class="headerlink" title="用类的Class实例来获得类的实例"></a>用类的Class实例来获得类的实例</h3><p>当我们反射出来一个 Class 实例之后，我们相当于掌握了一个完整的类，那么我们自然能够将建这个类的实例，方法也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class str=String.class;</span><br><span class="line">String s=(String)str.newInstance();</span><br></pre></td></tr></table></figure><p>这里 <code>(String)str.newInstance()</code> 就等价与 <code>new String()</code> 只不过这个创建实例的过程是由 Class 类的 <code>newInstance()</code> 方法实现的。利用这个方法创建实例是有很大的局限性的，在使用 <code>new String()</code> 的时候，会直接调用 String 的构造方法，在加上重载机制，可以在创建实例的时候给构造方法传入参数来初始化。但是 <code>newInstance()</code> 方法不可能对于一个未知的类的构造方法进行重载，所以就导致了使用反射机制创建的实例没有办法往对应类的构造方法里面传入参数。</p><h2 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h2><h3 id="获取字段"><a href="#获取字段" class="headerlink" title="获取字段"></a>获取字段</h3><p>在 <code>java.lang.reflect</code> 里面由一个类叫作 Field ，专门用来存储字段的信息，Class 类中存储类字段的数据类型就是 Field ，当然我们可以通过这个东西来存储我们从 Class 实例中得到的字段信息。</p><p>获得字段的方法有这些：</p><ol><li><code>getField(String name)</code> 返回 Field 数据，为名字为 name 的字段（包括父类）。</li><li><code>getDeclaredField(String name)</code> 作用同上，但不包括父类的字段。</li><li><code>getFields()</code> 返回 Field[] 数据，为该 Class 实例中所有的字段（包括父类）。</li><li><code>getDeclaredFields()</code> 同上，但不包括父类字段。</li></ol><p>前两个在使用的时候，需要处理可能抛出的异常 <code>NoSuchFieldException</code> 。</p><p>得到了一个字段 Field，而类 Field 里面包含了一些方法可以查看这个字段的详情信息，比如 <code>getName()</code> 和 <code>getType()</code> 获取字段的名字和类型。</p><h3 id="获取-修改-字段值"><a href="#获取-修改-字段值" class="headerlink" title="获取/修改 字段值"></a>获取/修改 字段值</h3><p>Field 类中有一个方法为 <code>get(Object)</code> ，将该类的实例作为参数传入可以得到这个字段在实例中的值，同样可以通过方法 <code>set(Object1,Object2)</code> ，来修改这个字段在实例 Object1 中的值为 object2，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Tempest Xorex=<span class="keyword">new</span> Tempest();</span><br><span class="line">        System.out.println(Tempest.class.getField(<span class="string">&quot;Blessing&quot;</span>).get(Xorex));</span><br><span class="line"></span><br><span class="line">        Tempest.class.getField(<span class="string">&quot;Blessing&quot;</span>).set(Xorex,<span class="string">&quot;The World&quot;</span>);</span><br><span class="line">        System.out.println(Tempest.class.getField(<span class="string">&quot;Blessing&quot;</span>).get(Xorex));</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String Blessing;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tempest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Blessing=<span class="string">&quot;Software&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码通过 <code>Tempest</code> 的实例 <code>Xorex</code> 映射出来 <code>Tempest</code> 类，并反射出来对应的 <code>Class</code> 实例，然后使用 <code>Class</code> 类中的 <code>getField()</code> 方法获得了类型为 <code>Field</code> 的 <code>Tempest</code> 类的字段 <code>Blessing</code> 。最后使用 Field 类自带的 <code>get()</code> / <code>set()</code> 方法 获得/修改 了 <code>Tempest</code> 类对应实例 <code>Xorex</code> 的字段  <code>Blessing</code> 。</p><p>上面的话可能有点绕，但这就是整个调用的逻辑原理。</p><h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>同样的，就像字段拥有自己的类 Field，方法也有属于自己的类 Method：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li></ul><p>上面的参数里面有一条是 <code>Class...</code> ，这是因为有着重载的存在，对于一个名字的方法可能有多种签名，所以为了区分不同的方法需要把完整的方法签名传入进去，而 <code>Class...</code> 就是需要传入签名中的形参列表，只需要按照对应顺序传入对应数据类型的 Class 实例即可。如果对应的方法的形参为 <code>int x,String y</code> ，那么就需要将 <code>Class...</code> 写为 <code>int.class,String.class</code> 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Tempest Xorex=<span class="keyword">new</span> Tempest();</span><br><span class="line">        System.out.println(Tempest.class.getMethod(<span class="string">&quot;GetAns&quot;</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String Blessing;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tempest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Blessing=<span class="string">&quot;Software&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAns</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.Blessing);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的就是一个 Method 类型数据，<code>public void Tempest.GetAns(int,int)</code> 。</p><p>还可以利用的 Method 类的一些方法来输出实例的固定信息：</p><ul><li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li></ul><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><ol><li><strong>调用普通方法</strong></li></ol><p>调用方法使用 Method 类的 <code>invoke(Object,MethodParameter...)</code>  方法，其中 Object 参数传入一个方法所在类的实例，<code>MethodParameter...</code> 传入对应方法需要的参数。需要注意的是，这个 Method 实例在获得的时候就已经确定了是具体的某个方法了，所以参数方法要严格按照对应的方法签名传进去，不要妄想在 Method 里面玩方法重载。</p><p>比如上面代码获得的 Method 就可以这样调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tempest.class.getMethod(<span class="string">&quot;GetAns&quot;</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class).invoke(Xorex,<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>调用静态方法</strong></li></ol><p>调用静态方法的话，方式和前面都是一样的，唯一的不同的是，最后使用 <code>invoke()</code> 方法的时候就不必须传入一个实例了，可以传入一个 null 来补位，比如把上面的方法 <code>GetAns()</code> 修改成静态方法之后，就可以不单独搞一个实例作为参数传进入了（当然你想传入实例的话也可以，没什么影响），直接用 null 补位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tempest.class.getMethod(<span class="string">&quot;GetAns&quot;</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class).invoke(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>调用多态方法</strong></li></ol><p>当我们用反射出来的父类 Class 得到的一个父类的方法 Method 之后，传入一个子类的实例调用此 Method ，会发现这个 Method 实际执行的方法是子类的方法而不是父类的。</p><p>说明 Method 没有保存方法的代码，而只是保留了方法签名，还是利用引用的关系进行方法调用。所以调用一个实现了多态的方法的时候，是遵循多态原则的（实际运行的是子类重写过的方法）</p><p>具体内部的原理虽然能强行推出来一个还算合理的解释，但是无法验证真伪，这些东西牵扯到的知识面比较广，和 JVM 以及这些类的底层实现代码有关，暂且放一放，以后会好好研究一下它们到底是如何运作起来的。</p><p>暂且记住：使用 <strong>反射调用方法</strong> 时，仍然 <strong>遵循多态原则</strong> ：即总是调用实际类型的覆写方法。</p><h2 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h2><p>在前面我们利用反射出来的 Class 来创建对应类的实例的时候，Class 的 <code>newInstance()</code> 拥有着无法调用有参数的构造方法的问题，那么 Reflect 就提供了一个 Constructor 类，专门用来解决这个问题。</p><p>首先导入 Constructor 类之后，需要使用方法 <code>getConstructor(Parameter...)</code>从 Class 里面获得构造方法的信息，因为构造方法的名字和类名相同，所以就不需要方法名作为参数，按照去掉方法名的 <code>getMethod()</code> 一样，直接填充对应构造方法的实参即可。</p><p>得到 Constructor 的实例之后，就可以利用里面的方法 <code>newInstance()</code> 来构造一个实例，不过这次，可以往里面填对应构造方法的实参了，算是解决了 Class 自己的 <code>newInstance()</code> 的一个小缺陷。</p><p>下面是代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Constructor con=Integer.class.getConstructor(<span class="keyword">int</span>.class);<span class="comment">//选择构造方法</span></span><br><span class="line">        Integer Xorex=(Integer)con.newInstance(<span class="number">10</span>);</span><br><span class="line">        System.out.println(Xorex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们利用 Constructor 获得了 Integer 类中的构造方法 <code>Integer(int)</code> 的信息，然后用它的实例的 <code>newInstance(int)</code> 方法成功调用 Integer 类中的构造方法 <code>Integer(int)</code> ，并实例化出来一个 Integer 对象。</p><h2 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h2><h3 id="获取父类"><a href="#获取父类" class="headerlink" title="获取父类"></a>获取父类</h3><p>使用 Class 类中的 <code>getSuperClass()</code> 可以获取这个 Class 实例表示的类的父类，返回的是父类的 Class 实例。我们就可以利用它来看一些类的继承关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class Xorex=NullPointerException.class;</span><br><span class="line"><span class="keyword">while</span>(Xorex!=<span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(Xorex);</span><br><span class="line">    Xorex=Xorex.getSuperclass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会一路打印继承关系，到了 Object 类，因为没有父类，所以返回的是 null，结束循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">NullPointerException</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">RuntimeException</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Exception</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Throwable</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br></pre></td></tr></table></figure><h3 id="获取实现接口"><a href="#获取实现接口" class="headerlink" title="获取实现接口"></a>获取实现接口</h3><p>这里是使用 <code>getInterfaces()</code> 返回一个 Class 的数组，遍历就能得到实现的所有接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class Xorex=Integer.class;</span><br><span class="line">Class[] Tempest=Xorex.getInterfaces();</span><br><span class="line"><span class="keyword">for</span>(Class i:Tempest) System.out.println(i);</span><br></pre></td></tr></table></figure><p>输出 Integer 类实现的所有接口（不包括父类实现的接口）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span></span></span><br><span class="line"><span class="class"><span class="title">interface</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">constant</span>.<span class="title">Constable</span></span></span><br><span class="line"><span class="class"><span class="title">interface</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">constant</span>.<span class="title">ConstantDesc</span></span></span><br></pre></td></tr></table></figure><h3 id="判断向上转型"><a href="#判断向上转型" class="headerlink" title="判断向上转型"></a>判断向上转型</h3><p>判断一个实例的类是不是另外一个类的子类的时候，可以使用 instanceof 操作符，如果是，那么这个实例就可向上转型为另外一个类的实例。那么两个 Class 如何判断是否有继承关系呢？</p><p>可以使用 Class 类的方法 <code>Class1.isAssignableFrom(Class2)</code> 来确定 Class1 是否继承了 Class2 ，返回一个布尔值。</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>当我们调用一个第三方的类完成一些任务的时候，发现这个第三方的类没有办法满足我们的需求，需要添加一些功能，但是我们又不能修改人家第三方类的代码，在调用库的类里面添加功能则会打乱我们的业务实现逻辑。这个时候，我们就可以再新建一个类，作为代理类，在这个类里面添加新业务实现的代码，然后用第三方的类完成补充。最后我们再通过对这个代理类的调用实现整个业务需求。</p><p>这样我们就通过代理操作，新建了一个类对第三方类进行 “修改” 以满足业务需求，同时原有的代码结构不变，不过是从直接操作第三方类变成了直接操作代理类。</p><p>这就是静态代理： <strong>代理类 = 原类 + 增强代码</strong></p><p><img src="https://pic2.zhimg.com/v2-e302487f952bdf8e284afc0d8d6a770b_r.jpg?source=1940ef5c" alt="preview"></p><p>我们直接对代理类的操作即可，代理类会完成对原类的完善。以后修改代码只需要修改代理类，原调用地方是不需要修改代码的。</p><p>我们来看一段静态代理的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">        Helloimplements hello = <span class="keyword">new</span> Helloimplements(); <span class="comment">//第三方类</span></span><br><span class="line">        StaticProxy proxy = <span class="keyword">new</span> StaticProxy(); <span class="comment">// 新建代理类</span></span><br><span class="line">        proxy.setImpl(hello); <span class="comment">// 代理类绑定第三方类</span></span><br><span class="line">        proxy.sayHello(<span class="string">&quot;Jerry&quot;</span>); <span class="comment">// 用操作代理类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayGoogBye</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helloimplements</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123; <span class="comment">//需要被代理的类</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayGoogBye</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; GoodBye!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123; <span class="comment">// 自己写的静态代理类</span></span><br><span class="line">    <span class="keyword">private</span> IHello iHello;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImpl</span><span class="params">(IHello impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iHello = impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The new codes...&quot;</span>); <span class="comment">// 需要补充的新代码</span></span><br><span class="line">        iHello.sayHello(name); <span class="comment">//调用第三方类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayGoogBye</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The new codes...&quot;</span>); <span class="comment">// 需要补充的代码</span></span><br><span class="line">        iHello.sayGoogBye(name); <span class="comment">// 调用第三方类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>前面说类静态代理，说是静态代理是因为这些过程在运行的时候都是不变的，编译生成 <code>.class</code> 文件是在 JVM <strong>运行之前</strong>完成的。但是动态代理的代理类，是在 JVM <strong>运行中</strong>生成的 <code>.class</code> 的。</p><p>动态代理有什么好处吗，为什么在 JVM 运行中生成有什么用啊？</p><p>当然有用，它最大的用处就是在运行中生成。在静态代理中，如果我们需要对大量的原类进行编写增强代码相似的代理类，重复的工作就太多了。于是我们想要在程序运行的时候，根据实际所对应的原类能自动生成需要的代理类，我们只用写一次代理类模板，就能直接代理所有的原类，那就太方便了。想到动态代理可以在程序运行中生成代理类，这不就是我们想要的嘛，写一个代理类模板，运行的时候依次生成所有原类的代理类，这样以后修改增强代码只需要在代理类模板修改即可。</p><p>看下图，这里静态代理和动态代理最大的区别就是多了一个中间处理方法 invoke() ，这个invoke() 里面就是用来写增强代码的地方，里面对原类的各种调用利用反射来完成。只需要将原类传进代理生成器，就能利用反射生成一个原类对应的代理类，最后只要操作这个生成的代理类即可。修改代码只修改 invoke()</p><p><img src="https://pic2.zhimg.com/v2-b5fc8b279a6152889afdfedbb0f611cc_r.jpg?source=1940ef5c" alt="preview"></p><p>为了能生成代理类，就需要有模板 <code>InvocationHandler.invoke()</code> ，这个是我们自己通过重写实现的，然后需要一个代理类生成器：<code>Proxy.newProxyInstance()</code> ，最后，只需要将模板和数据塞入代理类生成器，就能量产代理类了。</p><p>下面就是代码的具体实现上面的需求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个集成了生成器和模板的 动态代理生成工厂</span></span><br><span class="line">        DynamicProxyHello helloproxy = <span class="keyword">new</span> DynamicProxyHello();</span><br><span class="line">        <span class="comment">// 新建一个需要被代理的类的实例hello</span></span><br><span class="line">        Helloimplements hello = <span class="keyword">new</span> Helloimplements();</span><br><span class="line">        <span class="comment">// 调用动态代理生成工厂的 生成方法 让其返回生成的代理类实例</span></span><br><span class="line">        IHello ihello = (IHello) helloproxy.bind(hello); </span><br><span class="line">        <span class="comment">// 调用被生成的代理类实例</span></span><br><span class="line">        ihello.sayHello(<span class="string">&quot;Jerry&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集成了 代理类生成器+代理类生成模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHello</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object delegate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里调用代理类生成器，传入需要的数据，然后返回生成的代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object delegate)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 借助此方法生成动态代理类</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance( </span><br><span class="line">        <span class="keyword">this</span>.delegate.getClass().getClassLoader(), <span class="keyword">this</span>.delegate</span><br><span class="line">        .getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 生成的代理类中，所有的方法里面都只会调用这个方法，为模板</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The Adding Code...&quot;</span>); </span><br><span class="line">            <span class="comment">// JVM通过这条语句执行原类的方法(反射机制)</span></span><br><span class="line">            result = method.invoke(<span class="keyword">this</span>.delegate, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要被代理的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helloimplements</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayGoogBye</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; GoodBye!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统一操作接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayGoogBye</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先写一个代理类模板 ，来规定生成的代理类都有哪些对应的功能，这就是 <code>InvocationHandler</code> 接口的 <code>invoke()</code> 需要实现功能。而我们上面代码定义这个 <code>invoke()</code>  为多输出了一段字符串，然后调用被代理实例的某个方法。然后又定义了启动代理类生成器 <code>Proxy.newProxyInstance()</code>  的方法 <code>bind()</code> ，用来将被代理实例和模板通过代理类生成器绑定，从而生成被代理实例需要的代理类。</p><p>对于 <code>InvocationHandler</code> 接口需要被实现的 <code>invoke()</code> 方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span></span><br></pre></td></tr></table></figure><ul><li><p>proxy 为被代理的实例</p></li><li><p>method 为需要调用实例的方法</p></li><li><p>args 为调用的时候接受的参数</p></li></ul><p>上面三个参数的如何传递并不需要关心，这些 <code>Proxy.newProxyInstance()</code> 对自动生成填写合适参数的代理类。</p><p>然后就是  <code>Proxy.newProxyInstance()</code> 的定义了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)</span>  <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure><ul><li>loader 需要传入被代理实例的类加载器，使用 <code>Instance.getClass().getClassLoader()</code> 获得名字为 Instance 的被代理实例的类加载器，共给生成的代理类使用。</li><li>ingerfaces 按照被代理类实现的接口来对应生成代理类，使用 <code>Instance.getClass().getInterfaces()</code> 就可以获得名字为 Instance 的被代理实例实现的接口了。</li><li>h 一个 <code>InvocationHandler</code> 接口实现的类，需要实现其 <code>invoke()</code> 方法，里面为实现需求的所有代码，在被调用的代理类的方法就是通过 <code>invoke()</code> 作为模板生成的。</li></ul><p>这样实现的好处：将数据和功能分离了，一些需要被增加的类变成了数据。我们只要关心如何实现增加的功能，不需要关心谁需要增加功能，里面的 “谁” 就变成了数据，只要在参数里面传入它，就能自动增加它的功能。</p><p>而实现这一切的核心就是反射机制让我们不用关心具体的对象是谁也可以操作它。</p>]]></content>
    
    
    <summary type="html">在计算机学中，反射（英语：reflection）是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。要注意术语“反射”和“内省”（type introspection）的关系。内省（或称“自省”）机制仅指程序在运行时对自身信息（称为元数据）的检测；反射机制不仅包括要能在运行时对程序自身信息进行检测，还要求程序能进一步根据这些信息改变程序状态或结构。</summary>
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="笔记" scheme="https://xorex.space/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="反射" scheme="https://xorex.space/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
</feed>
