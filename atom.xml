<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xorex</title>
  
  <subtitle>要成为世界上最幸福的人啊！</subtitle>
  <link href="https://xorex.space/atom.xml" rel="self"/>
  
  <link href="https://xorex.space/"/>
  <updated>2022-09-03T11:36:33.576Z</updated>
  <id>https://xorex.space/</id>
  
  <author>
    <name>Xorex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Car-01-</title>
    <link href="https://xorex.space/2022/09/03/d64b2d671eff/"/>
    <id>https://xorex.space/2022/09/03/d64b2d671eff/</id>
    <published>2022-09-03T11:36:33.000Z</published>
    <updated>2022-09-03T11:36:33.576Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL-02-运算符</title>
    <link href="https://xorex.space/2022/08/25/9b2b03fc6a18/"/>
    <id>https://xorex.space/2022/08/25/9b2b03fc6a18/</id>
    <published>2022-08-25T08:35:06.000Z</published>
    <updated>2022-09-06T13:09:03.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://xorex.space/images/355.jpg" alt="355.jpg"></p><p><img src="https://xorex.space/images/365.jpg" alt="365.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;算术运算符&quot;&gt;&lt;a href=&quot;#算术运算符&quot; class=&quot;headerlink&quot; title=&quot;算术运算符&quot;&gt;&lt;/a&gt;算术运算符&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://xorex.space/images/355.jpg&quot; alt=&quot;355.jpg</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-01-</title>
    <link href="https://xorex.space/2022/08/25/175860cd6b1a/"/>
    <id>https://xorex.space/2022/08/25/175860cd6b1a/</id>
    <published>2022-08-25T08:18:32.000Z</published>
    <updated>2022-09-05T12:22:15.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关系型数据库-RDBMS"><a href="#关系型数据库-RDBMS" class="headerlink" title="关系型数据库 RDBMS"></a>关系型数据库 RDBMS</h2><p>RDBMS Related DataBase Management System，关系型数据库。</p><p>MySQL 的关系型，体现的就是不同的表之间，是有数据关系的，一个表将学号和姓名绑定，其他表将班级和姓名绑定，通过这样的方式，表和表之间就建立了关系，可以进行复杂的查询。</p><p>对应的非关系型数据库，就是数据之间彼此独立的，比如 Redis。</p><h2 id="表与表的关系"><a href="#表与表的关系" class="headerlink" title="表与表的关系"></a>表与表的关系</h2><ul><li>有四种：一对一关联、一对多关联、多对多关联、自我引用</li></ul><h3 id="一对一关联"><a href="#一对一关联" class="headerlink" title="一对一关联"></a>一对一关联</h3><ul><li><p>在实际的开发中应用不多，因为一对一可以创建成一张表。</p></li><li><p>举例：设计<code>学生表</code>：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、…</p><ul><li>拆为两个表：两个表的记录是一一对应关系。</li><li><code>基础信息表</code>（常用信息）：学号、姓名、手机号码、班级、系别</li><li><code>档案信息表</code>（不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、…</li></ul></li><li><p>两种建表原则： </p><ul><li>外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。 </li><li>外键是主键：主表的主键和从表的主键，形成主外键关系。</li></ul></li></ul><h3 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h3><ul><li>常见实例场景：<code>客户表和订单表</code>，<code>分类表和商品表</code>，<code>部门表和员工表</code>。</li><li>举例：<ul><li>员工表：编号、姓名、…、所属部门（多）</li><li>部门表：编号、名称、简介（一）</li><li>部门表的一条记录，对应员工表的多条记录。</li></ul></li></ul><ul><li>一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键</li></ul><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>要表示多对多关系，必须创建第三个表，该表通常称为<code>联接表</code>，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。</p><p><img src="https://xorex.space/image/353.jpg" alt="353.jpg"></p><ul><li><strong>举例：学生-课程</strong></li></ul><ol><li><p><code>学生信息表</code>：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别…）和 3 是一对多关系。</p></li><li><p><code>课程信息表</code>：一行代表一个课程的信息（课程编号、授课老师、简介…）和 3 是一对多关系。</p></li><li><p><code>选课信息表</code>：一个学生可以选多门课，一门课可以被多个学生选择。（在这个表中，体现了 1 和 2 的多对多关系）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">学号     课程编号  </span><br><span class="line">1        1001</span><br><span class="line">2        1001</span><br><span class="line">1        1002</span><br></pre></td></tr></table></figure></li></ol><h3 id="自我引用"><a href="#自我引用" class="headerlink" title="自我引用"></a>自我引用</h3><p>一个表的某一列数据，成为这个表的另外一列数据的引用。比如下面的员工的主管编号就是引用本表的员工编号，是表内的自我引用。</p><p><img src="https://xorex.space/image/354.jpg" alt="354.jpg"></p><h2 id="MySQL-目录结构"><a href="#MySQL-目录结构" class="headerlink" title="MySQL 目录结构"></a>MySQL 目录结构</h2><p>重点目录结构有三个：</p><ol><li><code>/etc/mysql/conf.d</code> 存放配置文件。</li><li><code>/logs</code> 存放 MySQL 的执行日志文件。</li><li><code>/var/lib/mysql</code> 存储数据库的数据。</li></ol><h2 id="语言分类"><a href="#语言分类" class="headerlink" title="语言分类"></a>语言分类</h2><p>SQL语言在功能上主要分为如下3大类，定义、操作和控制：</p><ul><li><p><strong>DDL（Data Definition Languages、数据定义语言）</strong>，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。</p><ul><li>主要的语句关键字包括<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code>等。</li></ul></li><li><p><strong>DML（Data Manipulation Language、数据操作语言）</strong>，用于添加、删除、更新和查询数据库记录，并检查数据完整性。</p><ul><li>主要的语句关键字包括<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>、<code>SELECT</code>等。</li><li><strong>SELECT是SQL语言的基础，最为重要。</strong></li></ul></li><li><p><strong>DCL（Data Control Language、数据控制语言）</strong>，用于定义数据库、表、字段、用户的访问权限和安全级别。</p></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单行注释：# 注释文字(MySQL特有的方式)</span><br><span class="line">单行注释：-- 注释文字(--后面必须包含一个空格。)</span><br><span class="line">多行注释：&#x2F;* 注释文字  *&#x2F;</span><br></pre></td></tr></table></figure><h2 id="关键词冲突"><a href="#关键词冲突" class="headerlink" title="关键词冲突"></a>关键词冲突</h2><p>当名字、数据和 Mysql 关键词冲突的时候，可以使用 `` 来包裹它（着重号），比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &#96;user&#96; # user 是关键词 </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关系型数据库-RDBMS&quot;&gt;&lt;a href=&quot;#关系型数据库-RDBMS&quot; class=&quot;headerlink&quot; title=&quot;关系型数据库 RDBMS&quot;&gt;&lt;/a&gt;关系型数据库 RDBMS&lt;/h2&gt;&lt;p&gt;RDBMS Related DataBase Managem</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MySQL" scheme="https://xorex.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux-04-磁盘进程软件定时任务</title>
    <link href="https://xorex.space/2022/08/17/f4d82e031af3/"/>
    <id>https://xorex.space/2022/08/17/f4d82e031af3/</id>
    <published>2022-08-17T09:36:22.000Z</published>
    <updated>2022-08-25T03:42:53.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="目录结构-tree"><a href="#目录结构-tree" class="headerlink" title="目录结构 tree"></a>目录结构 tree</h3><p><code>tree /xxx</code> 查看 xxx 目录下递归子目录的所有内容，需要 yum 下载。</p><h3 id="文件大小-du"><a href="#文件大小-du" class="headerlink" title="文件大小 du"></a>文件大小 du</h3><p>du disk usage，可以查看磁盘使用情况。</p><p><code>du -ah /xxx</code> 查看目录下所有文件大小情况。</p><p><code>du -sh /xxx</code> 查看目录下文件总大小</p><p><code>du -ah --max-depth=n</code> 查看目录下 n 层的文件大小情况</p><h3 id="磁盘空间-df"><a href="#磁盘空间-df" class="headerlink" title="磁盘空间 df"></a>磁盘空间 df</h3><p>df disk free 查看当前机器的磁盘空间，剩余量，挂载位置等等。</p><p><code>df -h</code> -h 是 human 的意思，可以让数据方便易懂。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs        909M     0  909M   0% &#x2F;dev</span><br><span class="line">tmpfs           919M   32K  919M   1% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs           919M   17M  903M   2% &#x2F;run</span><br><span class="line">tmpfs           919M     0  919M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;vda1        50G  4.1G   43G   9% &#x2F;</span><br><span class="line">tmpfs           184M     0  184M   0% &#x2F;run&#x2F;user&#x2F;0</span><br><span class="line">tmpfs           184M     0  184M   0% &#x2F;run&#x2F;user&#x2F;1001</span><br></pre></td></tr></table></figure><p>这里的 <code>/dev.vdal</code> 是挂载的硬盘。 <code>tmpfs</code> 是 temporary file system 的缩写，指的是 内存 和 虚拟内存。<code>devtmpfs</code> 指的是基于内存的文件系统，用来加快系统速度。</p><h3 id="内存空间-free"><a href="#内存空间-free" class="headerlink" title="内存空间 free"></a>内存空间 free</h3><p><code>free -h</code> 查看内存和虚拟内存空间使用情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:           1.8G        357M        233M         24M        1.2G        1.2G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure><h3 id="设备挂载查看-lsblk"><a href="#设备挂载查看-lsblk" class="headerlink" title="设备挂载查看 lsblk"></a>设备挂载查看 lsblk</h3><p>lsblk list block 表示展示块设备，也就是挂载的设备。</p><p><code>lsblk -f</code> 详细展示信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0     11:0    1 16.5M  0 rom  </span><br><span class="line">vda    253:0    0   50G  0 disk </span><br><span class="line">└─vda1 253:1    0   50G  0 part &#x2F; </span><br><span class="line"># 硬盘 vda 的第一个也是唯一一个分区，vda1，挂载到 &#x2F; 目录。</span><br></pre></td></tr></table></figure><p>sr0 指的是 scsi rom 0，是设备中存在的一块光盘。</p><p>vda 表示 visual disk A 第一块虚拟硬盘，B 表示第二块。也可能会遇到 sda ，s 表示 sata 接口。</p><h3 id="设备挂载-卸载-mount-umount"><a href="#设备挂载-卸载-mount-umount" class="headerlink" title="设备挂载/卸载 mount/umount"></a>设备挂载/卸载 mount/umount</h3><p>挂在之前需要查看 lsblk 看看是否存在为挂载设备，如果有可以挂载。</p><p><code>mount 设备地址 挂载地址</code> 选项有很多，设备地址一般在 <code>/dev</code> 下面，挂在地址一般设置再 <code>/mnt</code> 目录下。</p><p><code>mount 设备地址/挂载地址</code> 取消挂载。</p><p>比如 <code>mount /dev/cdrom /mnt/cdrom</code> 就是将设备 cdrom 挂载到 mnt 文件夹下面，然后就可以访问设备了。然后 <code>umount /mnt/cdrom</code> 解除挂载。</p><hr><p>如果要实现设备开机自动挂载，在 <code>/etc/fstab</code> file system table 中添加设备即可。</p><h3 id="磁盘分区-fdisk"><a href="#磁盘分区-fdisk" class="headerlink" title="磁盘分区 fdisk"></a>磁盘分区 fdisk</h3><p><code>fdisk -l</code> list 展示磁盘分区信息，内容非常详细。</p><p>当插入一块新的硬盘的时候，需要重启计算机，然后才能看到此硬盘。第一块硬盘结尾是 a，第二块是 b …。硬盘不能够直接被挂载，能够被挂载访问的是硬盘的分区。</p><p>分区过程：</p><ol><li><p><code>fdisk /dev/sdb</code> 对 sdb 新硬盘进行分区管理</p></li><li><p>输入 m 查看帮助。输入 n 进行分区，没有特殊要求一路回车，有特殊要求就研究一下。默认新的分区为 sdb1 设备，表示第一个分区。</p></li><li><p>分完之后输入 w 保存修改。然后就能在 fdisk 中看到分区，但是看不到文件系统信息。</p></li><li><p>然后对新的硬盘分区进行格式化，赋予文件系统。使用 mkfs  make file system 命令： <code>mksf /dev/sdb1</code> 使用的是默认的 ext2 系统，我们可以用 <code>-t ext4</code> 指定最新的文件系统类型。</p></li><li><p>分区完之后就可以被 Linux 识别访问了，这个时候将硬盘分区挂载到想要挂载的目录即可。</p></li></ol><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="查看进程-ps"><a href="#查看进程-ps" class="headerlink" title="查看进程 ps"></a>查看进程 ps</h3><p>ps process status，查看进程状态。<code>ps aux</code> 显示所有进程详细信息，<code>ps -ef</code> 显示进程的父子关系。</p><p>命令返回内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.2 125664  3956 ?        Ss   Jul19   2:42 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd --switched-root --system --desroot         2  0.0  0.0      0     0 ?        S    Jul19   0:00 [kthreadd]</span><br><span class="line">root         4  0.0  0.0      0     0 ?        S&lt;   Jul19   0:00 [kworker&#x2F;0:0H]</span><br><span class="line">root         6  0.0  0.0      0     0 ?        S    Jul19   1:41 [ksoftirqd&#x2F;0]</span><br></pre></td></tr></table></figure><p>USER：该进程是由哪个用户产生的；<br>PID：进程的 ID 号；<br>%CPU：该进程占用 CPU 资源的百分比，占用越高，进程越耗费资源；<br>%MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源；<br>VSZ：该进程占用虚拟内存的大小，单位 KB；<br>RSS：该进程占用实际物理内存的大小，单位 KB；<br>TTY：该进程是在哪个终端中运行的。对于 CentOS 来说，tty1 是图形化终端，tty2-tty6 是本地的字符界面终端。pts/0-255 代表虚拟终端。<br>STAT：进程状态。常见的状态有：R：运行状态、S：睡眠状态、T：暂停状态、Z：僵尸状态、s：包含子进程、l：多线程、+：前台显示、&lt; 高优先级、N 低优先级。<br>START：该进程的启动时间；<br>TIME：该进程占用 CPU 的运算时间，注意不是系统时间；<br>COMMAND：产生此进程的命令名；</p><h3 id="杀掉进程-kill"><a href="#杀掉进程-kill" class="headerlink" title="杀掉进程 kill"></a>杀掉进程 kill</h3><p><code>kill 进程号</code> 终止进程。<code>kill -9 进程号</code> 强行终止进程。</p><h3 id="进程启动树-pstree"><a href="#进程启动树-pstree" class="headerlink" title="进程启动树 pstree"></a>进程启动树 pstree</h3><p><code>pstree -pu</code> p 是 PID，u 是 user。表示 pstree 额外显示进程的 PID 和 User。</p><p>如果进程的所有者 User 和父进程相同，则不会显示 User ，不同才会显示。</p><h3 id="监控进程状态-top"><a href="#监控进程状态-top" class="headerlink" title="监控进程状态 top"></a>监控进程状态 top</h3><p><code>top [选项]</code> 返回实时的进程状态。</p><hr><p>参数：</p><ol><li><code>-d 秒数</code> 指定 top 命令每隔几秒更新。默认是 3 秒在 top 命令的交互模式当<br>中可以执行的命令：</li><li><code>-i</code> 使 top 不显示任何闲置或者僵死进程。</li><li><code>-p</code> 通过指定监控进程 ID 来仅仅监控某个进程的状态。</li></ol><hr><p>操作：（直接摁字母）</p><ol><li>P 以 CPU 使用率排序，默认就是此项</li><li>M 以内存的使用率排序</li><li>N 以 PID 排序</li><li>q 退出 top</li><li>u 显示输入用户的进程</li><li>k 杀掉指定进程，并发送信号 9（等效于 -9）</li></ol><h4 id="网络端口和进程-netstat"><a href="#网络端口和进程-netstat" class="headerlink" title="网络端口和进程 netstat"></a>网络端口和进程 netstat</h4><p><code>netstat -anp | grep 进程号</code> 查看和进程使用的相关端口。</p><p><code>netstat -lnp | grep 端口号</code> 查看端口占用情况。</p><p>参数里面 a 表示 all，所有的端口都显示，无论是否处于监听状态。l 表示 listen，只显示处于监听状态的端口，如果有返回值则被占用。np 是为了更好的显示，不显示别名，显示网路端口占用进程。</p><h2 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h2><p>借助于 crontab 命令，使用之前需要检查负责执行此命令的服务是否在运行：<code>systemctl restart crond</code>。</p><p>-e 编辑 crontab 定时任务<br>-l 查询 crontab 任务<br>-r 删除当前用户所有的 crontab 任务</p><p>剩下的具体设置方法，建议看一些更加详细的博文。</p><h2 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h2><h3 id="管理工具-RPM"><a href="#管理工具-RPM" class="headerlink" title="管理工具 RPM"></a>管理工具 RPM</h3><p>RPM（RedHat Package Manager），RedHat软件包管理工具。这是一个 RPM 包的名称：<code>Apache-1.3.23-11.i386.rpm</code></p><ul><li>“apache” 软件名称</li><li>“1.3.23-11”软件的版本号，主版本和此版本</li><li>“i386”是软件所运行的硬件平台，Intel 32位处理器的统称</li><li>“rpm”文件扩展名，代表RPM包</li></ul><p>此管理工具对应的命令是 <code>rpm</code>。 </p><h4 id="查询-q"><a href="#查询-q" class="headerlink" title="查询 -q"></a>查询 -q</h4><p><code>rpm -qa</code> query all，查询所有安装的应用。</p><p><code>rpm -qi 应用名</code> query information，查询应用的具体安装信息。</p><p>推荐使用 <code>rpm -qa | grep 应用名</code> 来判断是否安装某应用。</p><h4 id="卸载-e"><a href="#卸载-e" class="headerlink" title="卸载 -e"></a>卸载 -e</h4><p><code>rpm -e 应用名</code>  erase，检查应用依赖后再卸载。</p><p><code>rpm -e --nodeps</code> erase with no dependence，不检查依赖，直接卸载应用。</p><h4 id="安装-i"><a href="#安装-i" class="headerlink" title="安装 -i"></a>安装 -i</h4><p>需要有一个完整的 RPM 包，才可以安装。</p><p><code>rpm -ivh 安装包路径</code> install 安装，vh 表示显示详细过程。</p><h3 id="应用商店-yum"><a href="#应用商店-yum" class="headerlink" title="应用商店 yum"></a>应用商店 yum</h3><p>基于 rpm 的一个 下载安装 管理程序，会从默认的服务器下载对应的安装包。</p><ol><li><code>install 软件名</code> 下载安装软件</li><li><code>update 软件名</code> 更新软件</li><li><code>check-update 软件名</code> 查询更新 </li></ol><h3 id="指定连接下载-wget"><a href="#指定连接下载-wget" class="headerlink" title="指定连接下载 wget"></a>指定连接下载 wget</h3><p>全称是 web get，直接输入 <code>wget 资源URL</code> 就会下载到当前目录里面。如果要重命名下载好的文件，则：<code>wget -O 新名字 资源URL</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;磁盘管理&quot;&gt;&lt;a href=&quot;#磁盘管理&quot; class=&quot;headerlink&quot; title=&quot;磁盘管理&quot;&gt;&lt;/a&gt;磁盘管理&lt;/h2&gt;&lt;h3 id=&quot;目录结构-tree&quot;&gt;&lt;a href=&quot;#目录结构-tree&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Linux" scheme="https://xorex.space/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-03-控制符权限用户搜索压缩</title>
    <link href="https://xorex.space/2022/08/16/1a6344401e29/"/>
    <id>https://xorex.space/2022/08/16/1a6344401e29/</id>
    <published>2022-08-16T08:41:45.000Z</published>
    <updated>2022-08-17T09:36:31.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="控制符"><a href="#控制符" class="headerlink" title="控制符"></a>控制符</h2><h3 id="输出重定向-gt-gt-gt"><a href="#输出重定向-gt-gt-gt" class="headerlink" title="输出重定向 &gt; &gt;&gt;"></a>输出重定向 &gt; &gt;&gt;</h3><p><code>order1 &gt; file1</code> 将 order1 返回的内容覆盖写入 file1 中。</p><p><code>order1 &gt;&gt; file1</code> 将 order1 返回的内容追加写入 file1 中。</p><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符 |"></a>管道符 |</h3><p><code>order1 | order2</code> 将 命令1 执行的结果返回给 命令2 作为输入。</p><p>常用和 grep 一起用。</p><h2 id="权限概念"><a href="#权限概念" class="headerlink" title="权限概念"></a>权限概念</h2><h3 id="权限表示"><a href="#权限表示" class="headerlink" title="权限表示"></a>权限表示</h3><p>文件或者目录的权限表示： <code>r-xr-xr-x</code> 每三位一组，分别表示 user group others 所属的权限。 </p><p>u (user) 表示该文件的拥有者，g (group) 表示与该文件的拥有者属于同一个群体者，o (others) 表示其他以外的人，a (all) 表示这三者皆是。</p><p>一组的三位表示权限的意思分别是：r (read) 读取，w (write) 写入，x (executable) 执行，- 表示没有此项权限。文件和目录对于权限的解释是不同的。</p><hr><p>文件：注意拥有文件的 w 权限不代表可以删除文件。要删除文件需要有当前目录的 w 权限才可以。</p><p>目录：r 表示可以 ls 查看目录内容。w 表示可以删除新增重命名新目录或文件。x 表示可以进入当前目录。</p><h3 id="chmod-改变权限"><a href="#chmod-改变权限" class="headerlink" title="chmod 改变权限"></a>chmod 改变权限</h3><p>change mode 改变模式，用来改变文件的权限。</p><ul><li><p>权限作用人 <code>[who]</code> 分为：u (user) 表示该文件的拥有者，g (group) 表示与该文件的拥有者属于同一个群体者，o (others) 表示其他以外的人，a (all) 表示这三者皆是。</p></li><li><p>权限 <code>[mode]</code> 分为：r (read) 读取，w (write) 写入，x (executable) 执行。</p></li></ul><ul><li>权限操作 <code>[operator]</code> 分为：+ 增加权限，- 取消权限， = 表示唯一设定权限（也就是清除所有权限之后再增加设定权限）</li></ul><ol><li>对指定的用户组进行修改</li></ol><p>格式：<code>chmod [who][operator][mode] file</code> 。</p><p>例：<code>chmod u=rw waifu.jpg</code> 命令表示将 waifu.jpg 文件所有者的权限重新设定为只有读写权限。</p><ol start="2"><li>对所有用户组进行修改</li></ol><p>格式：<code>chmod [OperatorNumber][OperatorNumber][OperatorNumber] file</code>。</p><p>上面每一个都表示某一个用户组的权限：第一位表示 user 第二位表示 group 第三位表示 others。</p><p><code>[OperatorNumber]</code> 表示将权限符号用数字替代，没有权限用 - 代表，r 4、w 2、x 1，然后相加就是代表的权限。如 7 表示同时拥有读写执行权限。</p><p>例：<code>chmod 764 waifu.jpg</code>.</p><ol start="3"><li>对文件夹下面的所有文件/目录一起修改权限</li></ol><p><code>chomd -R [OperatorNumber][OperatorNumber][OperatorNumber]</code> -R 递归改变，包括子目录。要慎用此命令。</p><h3 id="改变所属用户和组"><a href="#改变所属用户和组" class="headerlink" title="改变所属用户和组"></a>改变所属用户和组</h3><p>可以将文件绑定的用户和组进行更改，使用 chown 和 chgrp 命令。</p><p><code>chown 用户 文件/目录</code> 更改绑定用户，加上 -R 则是目录递归修改。</p><p><code>chgrp 组名 文件/目录</code> 更改绑定组，加上 -R 则是目录递归修改。</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="添加切换删除修改查看用户"><a href="#添加切换删除修改查看用户" class="headerlink" title="添加切换删除修改查看用户"></a>添加切换删除修改查看用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd 用户名 （功能描述：添加新用户）</span><br><span class="line">useradd -g 组名 用户名 （功能描述：添加新用户到某个组）</span><br></pre></td></tr></table></figure><p>添加完用户之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd 用户名 （功能描述：设置用户的密码）</span><br></pre></td></tr></table></figure><hr><p>可以使用 <code>su 用户名</code> 来切换当前登录的用户 switch user。</p><hr><p><code>userdel 用户名</code> 删除用户</p><hr><ul><li><code>usermod -g 用户组 用户名</code> modify 修改用户所在的用户组</li></ul><hr><ul><li><code>cat /etc/passwd</code> 查看所有用户信息。</li></ul><h3 id="sudo-管理员权限"><a href="#sudo-管理员权限" class="headerlink" title="sudo 管理员权限"></a>sudo 管理员权限</h3><p>一般我们禁止使用 root 账号，给一些重要的普通账号执行管理员命令的权限。这些普通账号想要执行管理员命令的时候，要加上 <code>sudo</code> 关键字。</p><p>首先我们需要用 root 账号下发权限给其他账号：修改 <code>/etc/sudoers</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root ALL&#x3D;(ALL) ALL</span><br><span class="line">Xorex ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><p>这样就给普通账户 Xorex 了执行 sudo 的权限，如果想用 root 权限执行命令，则在前面加上 sudo 前缀即可，比如 <code>sudo shutdown</code>。</p><hr><p>需要注意的是，sudo 不能作用在内嵌命令中（cd、history等），因为 sudo 也是外部程序，只能作用与外部程序，而不是自己所在的 bash。那么这个时候就需要想办法绕过这些内嵌命令（用外部命令实现类似的效果）。或者直接开一个 <code>sudo bash</code> 在里面调用内嵌命令，用完 exit 即可。</p><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><blockquote><p>用户组是拥有相同特征的一组用户集合，这里的特征主要指的是 权限。也就是在一个组里面的用户，拥有相同权限。</p></blockquote><ul><li><p><code>groupadd xxxx</code> 创建用户组</p></li><li><p><code>groupdel xxxx</code> 删除用户组</p></li><li><p><code>groupmod -n oldName newName</code> 修改用户组的名字</p></li><li><p><code>cat /etc/group</code> 查看所有用户组信息。</p></li></ul><h3 id="用户组权限管理"><a href="#用户组权限管理" class="headerlink" title="用户组权限管理"></a>用户组权限管理</h3><p>同样可以给用户组 Admin 里面的所有用户授权 sudo 权限：</p><p>就是多了一个 <code>%</code> 表示组名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## Allows people in group wheel to run all commands</span><br><span class="line">%wheel  ALL&#x3D;(ALL) ALL</span><br><span class="line">%Admin  ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><h2 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h2><h3 id="find-文件查找"><a href="#find-文件查找" class="headerlink" title="find 文件查找"></a>find 文件查找</h3><p>find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件显示在终端。</p><p><code>find [搜索范围] [选项]</code> </p><ul><li><p>搜索范围：不写就是从当前目录开始，写了就是从指定目录开始递归查找。</p></li><li><p>选项： <code>-xxx xxx</code> 的形式，前面是选项类别，后面是选项参数。比如 <code>find -name &quot;*.txt&quot;</code>。</p></li></ul><ol><li><code>-name &quot;Regex&quot;</code> 按照指定的文件名查找模式查找文件，如果是正则表达式，一定要加双引号 <code>find -name &quot;*.txt&quot;</code>。</li><li><code>-user 用户名</code> 查找属于指定用户名所有文件 <code>find -user Xorex</code>。</li><li><code>-size +大小 -size -大小</code> 按照指定的文件大小查找文件，单位为: </li></ol><p>b —— 块（512 字节）<br>c —— 字节<br>w —— 字（2 字节）<br>k —— 千字节<br>M —— 兆字节<br>G —— 吉字节</p><p><code>+</code> 表示文件大于此大小，<code>-</code> 表示文件小于此大小。找 10 到 15 MB 之内的文件：<code>find / -size +10M -size -15M</code> 这样。</p><h3 id="locate-路径匹配"><a href="#locate-路径匹配" class="headerlink" title="locate 路径匹配"></a>locate 路径匹配</h3><p>Linux 根据文件路径建立了一个数据库，每天自动更新一次，使用前输入 <code>updatedb</code> 手动更新， locate 命令可以从这个数据库来查找文件和路径，速度很快，但是不支持正则表达式。</p><p>命令：<code>locate 关键字</code> 从路径中找含有关键字的，然后返回。</p><h3 id="whereis-命令查找"><a href="#whereis-命令查找" class="headerlink" title="whereis 命令查找"></a>whereis 命令查找</h3><p>用于查看在环境变量中的命令的位置，<code>whereis vim</code> 就是查找 vim 的地址。</p><h3 id="grep-内容查找"><a href="#grep-内容查找" class="headerlink" title="grep 内容查找"></a>grep 内容查找</h3><p>grep：Global Regular Expression Print 全局正则匹配打印、用来对文件内容进行正则匹配并打印结果。</p><p><code>grep -n StringPattern FileName</code> -n 是显示匹配字符串行号</p><p><code>ls | grep -n &quot;Hello&quot;</code> 利用管道符去匹配命令返回结果。</p><h2 id="压缩包"><a href="#压缩包" class="headerlink" title="压缩包"></a>压缩包</h2><h3 id="zip-unzip"><a href="#zip-unzip" class="headerlink" title="zip/unzip"></a>zip/unzip</h3><ul><li><p>压缩：<code>zip 压缩文件名.zip 被压缩文件</code> 或者递归压缩目录，<code>zip -r 压缩文件名.zip 被压缩目录</code>。</p></li><li><p>解压 <code>unzip -d 文件解压目录 压缩文件名.zip</code> -d 用来指定解压位置。</p></li></ul><h3 id="tar-打包"><a href="#tar-打包" class="headerlink" title="tar 打包"></a>tar 打包</h3><p><code>tar</code> 命令用来对文件进行打包，压缩或者解压操作。需要配合各种命令进行操作，格式为：<code>tar -[选项] 压缩文件 源文件/目录</code></p><ul><li><code>-c</code> 创建压缩文件，后面需要写要创建的文件名称，一般后缀是 <code>.tar</code> 。</li><li><code>-x</code> 解压缩文件，后面需要写解压后的文件名称。</li><li><code>-t</code> 查看压缩包里都有什么文件。</li><li><code>-z</code> 使用 Gzip 压缩或者解压，后缀需要是 <code>.tar.gz</code></li><li><code>-v</code> 显示压缩或者解压的过程，强烈推荐使用。</li><li><code>-f</code> 需要被压缩或者解压的文件名，需要被放在最后。</li><li><code>-C</code> 指定解压到的目录。</li></ul><p>这些命令可以组合操作，比如:</p><ul><li><p>压缩：<code>tar -czvf Xorex.tar.gz Xorex</code> 就是将 Xorex 文件夹使用 Gzip 算法压缩成为 Xorex.tar.gz 压缩文件，如果不使用压缩算法，那么就是单纯的打包文件，不进行压缩。</p></li><li><p>解压：<code>tar -xzvf Xorex.tar.gz ./tmp</code> 将压缩文件解压到 <code>./tmp</code> 目录下面。</p></li></ul><hr><p>也可以选择文件进行压缩，只需要后面多写几个源文件即可：</p><p><code>tar -czvf Files.tar.gz file1.txt file2.txt file3.txt</code> 这样三个文件就被打成一个压缩包了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;控制符&quot;&gt;&lt;a href=&quot;#控制符&quot; class=&quot;headerlink&quot; title=&quot;控制符&quot;&gt;&lt;/a&gt;控制符&lt;/h2&gt;&lt;h3 id=&quot;输出重定向-gt-gt-gt&quot;&gt;&lt;a href=&quot;#输出重定向-gt-gt-gt&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Linux" scheme="https://xorex.space/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-02-网络系统目录文件</title>
    <link href="https://xorex.space/2022/08/03/e6fbbee5ed4f/"/>
    <id>https://xorex.space/2022/08/03/e6fbbee5ed4f/</id>
    <published>2022-08-03T08:10:16.000Z</published>
    <updated>2022-08-17T14:09:21.871Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络方面"><a href="#网络方面" class="headerlink" title="网络方面"></a>网络方面</h2><p>如果我们要修改网络配置的话，需要改相应的配置文件，配置文件在 <code>/etc</code> 目录下面，网络的话就是 <code>/etc/sysconfig/network-scripts/</code> </p><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>我们可以用 ifconfig （interfaces config）命令显示网络设备。下面是显示内容详解：</p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>eth0</td><td>网卡设备号</td></tr><tr><td>Link encap</td><td>基本描述，链接概况</td></tr><tr><td>HWaddr</td><td>硬件MAC地址</td></tr><tr><td>inet addr</td><td>网络ip地址</td></tr><tr><td>Bcast</td><td>广播ip地址</td></tr><tr><td>Mask</td><td>子网掩码</td></tr><tr><td>inet6 addr</td><td>对应的ipv6地址</td></tr><tr><td>Scope</td><td>作用域，范围</td></tr><tr><td>UP</td><td>网卡已经启用</td></tr><tr><td>BROADCAST</td><td>支持多播</td></tr><tr><td>RUNNING</td><td>网卡正在运行</td></tr><tr><td>MULTICAST</td><td>支持多播</td></tr><tr><td>MTU</td><td>最大传输单元</td></tr><tr><td>Metric</td><td>度量值，用于估算路由成本</td></tr><tr><td>RX packets:</td><td>接收正确的数据包数</td></tr><tr><td>errors:</td><td>错误的数据包数</td></tr><tr><td>dropped</td><td>接收丢弃的数据包数</td></tr><tr><td>overruns:</td><td>接收时由于过速丢弃的数据包数</td></tr><tr><td>frame:</td><td>接收时，由于frame错误而丢弃的数据包数</td></tr><tr><td>TX packets</td><td>发送时正确的数据包数</td></tr><tr><td>errors:</td><td>接收时错误的数据包数</td></tr><tr><td>dropped:</td><td>接收时，丢弃的数据包数</td></tr><tr><td>overruns:</td><td>发送时，由于过速丢弃的数据包数</td></tr><tr><td>carrier:</td><td>发送时，由于carrier错误而丢弃的数据包数</td></tr><tr><td>collisions:</td><td>冲突信息包的数目</td></tr><tr><td>txqueuelen:</td><td>发送队列的大小，此处是1000MB</td></tr><tr><td>RX bytes:</td><td>接收的数据包数</td></tr><tr><td>TX bytes:</td><td>发送的数据包数</td></tr><tr><td>Interrupt</td><td>IRQ中断地址</td></tr><tr><td>Base address</td><td>基址</td></tr></tbody></table><p>由于使用 ifconfig 的修改都是临时修改，重启就失效，所以建议去修改 <code>/etc/sysconfig/network-scripts/</code> 下面的配置文件然后重启 network 服务，实现永久修改的效果。</p><h3 id="修改-IP-地址"><a href="#修改-IP-地址" class="headerlink" title="修改 IP 地址"></a>修改 IP 地址</h3><p><code>/etc/sysconfig/network-scripts/</code> 下面的 <code>ifcfg-eth0</code> 文件，是网卡的配置文件。</p><p>只需要将 DHCP 协议 修改为静态分配 IP 即可：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">BOOTPROTO</span>=<span class="string">&quot;dhcp&quot; -&gt; BOOTPROTO=&quot;static&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后加上下面的配置：</span></span><br><span class="line"><span class="comment">#IP 地址</span></span><br><span class="line"><span class="attr">IPADDR</span>=<span class="string">192.168.1.100</span></span><br><span class="line"><span class="comment">#网关</span></span><br><span class="line"><span class="attr">GATEWAY</span>=<span class="string">192.168.1.2</span></span><br><span class="line"><span class="comment">#域名解析器</span></span><br><span class="line"><span class="attr">DNS1</span>=<span class="string">192.168.1.2</span></span><br></pre></td></tr></table></figure><p>记得修改完一样东西，需要重启它才能生效。<code>service network restart</code></p><h3 id="修改-hosts"><a href="#修改-hosts" class="headerlink" title="修改 hosts"></a>修改 hosts</h3><p>hosts 文件就在 <code>/etc/</code> 下面，用 vim 修改此文件即可，然后重启网络服务。</p><h3 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h3><p>修改 <code>/etc/hostname</code> 文件，然后重启主机。</p><p>或者用命令 <code>hostnamectl set-hostname XXXX</code> 来修改，无需重启。</p><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><p>在 Linux 中原本是编写服务的 init.d 文件，然后来管理系统服务的，但是这样并不好用，后来引入了 Systemd 进行管理。字母 d 是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>常驻内存的进程，是 守护进程 daemon，也被叫做 服务 Service。</p><p>一个守护进程要被注册为 服务，则需要配置 <code>.service</code> 文件到 <code>/etc/systemd/system/</code> 文件夹下面，这样就被注册为了一个服务。推荐使用 Systemd 体系下面的 systemctl 命令开控制服务的启动关闭等。</p><p>可以划分一系列的 <code>.service</code> 为一个集合，称之为 <code>.target</code>。通过 target 来启动一系列的 service 从而实现某个具体的目标。</p><p>Systemd 默认从目录 <code>/etc/systemd/system/</code> 读取服务的配置文件。但是，里面存放的大部分文件都是符号链接，指向目录 <code>/usr/lib/systemd/system/</code> ，真正的配置文件存放在那个目录。</p><h3 id="Linux-启动级别"><a href="#Linux-启动级别" class="headerlink" title="Linux 启动级别"></a>Linux 启动级别</h3><p>0 halt 关机，代表系统停机状态，默认情况下，系统运行级别不能设置为0，否则电脑一开机就进入关机模式，电脑将不能正常启 动<br>1 Single user mode 单用户模式，只支持root账户，主要用于系统维护，禁止远程登陆，类似于Windows下的安全模式<br>2 Multiuser，without NFS 它是多用户模式，没有网络文件系统支持<br>3 Full Multiuser mode 完全多用户模式，有网络文件系统，用户登录后进入控制台命令行模式，在没有网络的环境下等同于运行级别2<br>4 unused 系统未使用，用作保留，一般不用，在一些特殊情况下可以用它来做一些事情，例如：在笔记本电脑的电池用尽时，可以切换到这一模式来做一些设置<br>5 X11 图形界面的多用户模式用户登录后直接进入X-Window系统<br>6 Reboot 重启，默认情况下，运行级别不能设为6，否则电脑一开机就进入重启模式会一直不停地重启，系统将不能正常的启动</p><p><code>systemctl get-default</code> 命令可以查询当前所处状态。</p><p>multi-user.target 等价于原运行级别 3（多用户有网，无图形界面）<br>graphical.target 等价于原运行级别 5（多用户有网，有图形界面）</p><p>这两个 <code>.target</code> 一系列对应运行级别的 service 的集合。</p><h3 id="服务开机自启"><a href="#服务开机自启" class="headerlink" title="服务开机自启"></a>服务开机自启</h3><p>输入命令 <code>setup</code> 进入远程登陆 GUI 页面（也就是 Linux 启动级别 5），里面可以通过空格控制服务是否开机自启。</p><h3 id="关机-重启"><a href="#关机-重启" class="headerlink" title="关机/重启"></a>关机/重启</h3><p>Linux 为了优化系统性能，对于硬盘的读写是有缓存区的。也就是不会立刻写入，只有缓存区满了，或者执行了 sync 命令，才会去写入硬盘。</p><p>（1）sync （功能描述：将数据由内存同步到硬盘中）<br>（2）halt （功能描述：停机，关闭系统，但不断电）<br>（3）poweroff （功能描述：关机，断电）<br>（3）reboot （功能描述：就是重启）<br>（4）shutdown time （功能描述：一段时间后 poweroff）</p><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="查看目录-ls"><a href="#查看目录-ls" class="headerlink" title="查看目录 ls"></a>查看目录 ls</h3><p><code>ls ./*</code> 这个符号 <code>*</code> 表示的是正则匹配，<code>file*</code> 就是匹配所有以<code>file</code> 开头的文件或者目录，如果只有 <code>*</code> 那就是匹配所有名称的文件或者目录。</p><h3 id="工作目录切换命令"><a href="#工作目录切换命令" class="headerlink" title="工作目录切换命令"></a>工作目录切换命令</h3><ol><li><p><code>pwd</code> 返回现在所处位置（Print Working Director）</p></li><li><p><code>cd</code> 切换工作目录 （change director）</p><ul><li><code>cd location</code> 打开对应的目录（文件夹）</li><li><code>cd ..</code> 返回上一级目录</li><li><code>cd ~</code> 可以快速返回当前用户的家目录里面。</li><li>如果路径里面包含有空格/问号/星号/货币符/逻辑符/括号，可以使用 <code>\</code> 来进行转义，让它变成路径名称而不是特殊字符。或者直接用双引号把路径名称名称括起来，<code>cd &quot;特殊字符的路径&quot;</code> 。</li></ul></li></ol><h3 id="文件目录管理"><a href="#文件目录管理" class="headerlink" title="文件目录管理"></a>文件目录管理</h3><ol><li><p><code>touch &lt;file&gt;</code> 可以创建一个新的空白文档。</p></li><li><p><code>mkdir &lt;director&gt;</code> 可以创建一个新的文件夹。</p><ul><li><code>mkdir -p &lt;director1/director2/directro3&gt;</code>可以创造嵌套的文件夹（parents）。</li></ul></li><li><p><code>cp &lt;file1/dire1&gt; &lt;file2/dire2&gt;</code> 复制 file1 或 dire1 到 dire2 目录或者到本地但是重命名为 file2。</p><ul><li><code>cp -r &lt;dir1&gt; &lt;dir2&gt;</code> recursive 递归，递归的复制目录过去（完全复制）</li></ul></li><li><p><code>mv &lt;file1/dire1&gt; &lt;file2/dire2&gt;</code> 移动 file1 或 dire1 到 dire2 目录或者到本地但是重命名为 file2。</p></li><li><p><code>rm &lt;file/dire&gt;</code> 命令用于删除文件或者目录。</p><ul><li><code>rm -r &lt;fire/dire&gt;</code> recursive 递归，用来递归删除目录，不适用 <code>-r</code> 没有办法删除。</li></ul></li><li><p><code>file &lt;filename&gt;</code> 命令用来查看文件的类型。</p><ul><li><code>&lt;filename&gt;</code> 可以使用 <code>*</code> 来进行正则匹配。</li></ul></li></ol><h2 id="文件查看"><a href="#文件查看" class="headerlink" title="文件查看"></a>文件查看</h2><h3 id="cat-查看小文本"><a href="#cat-查看小文本" class="headerlink" title="cat 查看小文本"></a>cat 查看小文本</h3><p>cat 是 catch 捕捉 的缩写。可以查看文件和拼接文件。</p><ul><li><p><code>cat -n &lt;file&gt;</code>在查看文本文件的同时标注行号。</p><ul><li>如果文件名用 <code>-</code> 开头，使用 <code>./-</code> 来打开</li><li>如果文件里面包含有空格/问号/星号/货币符/逻辑符/括号，可以使用 <code>cat &quot;特殊的文件名称&quot;</code> 。</li></ul></li><li><p><code>cat &gt; XXX</code> 创建一个名为 XXX 的新文件，并编辑其内容。</p><ul><li><code>cat XXX1 XXX2 &gt; XXX3</code> 将 XXX1 文件和 XXX2 文件的内容合并起来，覆盖 XXX3 文件。</li></ul></li></ul><h3 id="less-查看大文本"><a href="#less-查看大文本" class="headerlink" title="less 查看大文本"></a>less 查看大文本</h3><p>less 在查看大文件非常好用，可以一页一页显示。</p><table><thead><tr><th>语法</th><th>功能</th></tr></thead><tbody><tr><td>f</td><td>Front 向下翻一页</td></tr><tr><td>b</td><td>Back 向回翻一页</td></tr><tr><td>G</td><td>光标移动到最后一行</td></tr><tr><td>g</td><td>光标移动到第一行</td></tr><tr><td>/[Regex]</td><td>按照正则表达式匹配文本内容，n 下一个 N 上一个</td></tr><tr><td>q</td><td>退出 less</td></tr></tbody></table><h3 id="查看文件头和文件尾"><a href="#查看文件头和文件尾" class="headerlink" title="查看文件头和文件尾"></a>查看文件头和文件尾</h3><p><code>head fileName</code> 查看文件头前 5 行的内容。</p><p><code>tail fileName</code> 查看文件尾 10 行的内容。<code>tail -f fileName</code> follow 实时显示文件最后 10 行内容，vim 修改则无法追踪。</p><h3 id="ln-软连接"><a href="#ln-软连接" class="headerlink" title="ln 软连接"></a>ln 软连接</h3><p>软链接也称为符号链接，类似于 windows 里的快捷方式，是一种特殊的文件，指向其他文件。</p><p><code>ln -s [原文件或目录] [软链接名]</code> 创建一个新的软连接 link soft。</p><p><code>rm -rf 软链接名</code>，删除软连接文件，连接文件名不要加上 /，否则会访问绑定的文件夹然后删掉里面的东西。</p><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>比如我们用 ls -l 可以看到的文件信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">文件类型和权限  文件个数    所有者  所有组  大小</span><br><span class="line">lrwxrwxrwx.     1           root root     7 Mar  7  2019 bin -&gt; usr&#x2F;bin</span><br><span class="line">dr-xr-xr-x.     5           root root  4096 Feb  6  2022 boot</span><br><span class="line">drwxr-xr-x      2           root root  4096 Nov  5  2019 data</span><br><span class="line">drwxr-xr-x     19           root root  2980 Jul 19 10:14 dev</span><br><span class="line">drwxr-xr-x.    92           root root 12288 Aug 16 20:29 etc</span><br><span class="line">drwxr-xr-x.     4           root root  4096 Aug 16 20:29 home</span><br><span class="line">lrwxrwxrwx.     1           root root     7 Mar  7  2019 lib -&gt; usr&#x2F;lib</span><br><span class="line">lrwxrwxrwx.     1           root root     9 Mar  7  2019 lib64 -&gt; usr&#x2F;lib64</span><br><span class="line">drwx------.     2           root root 16384 Mar  7  2019 lost+found</span><br><span class="line">drwxr-xr-x.     2           root root  4096 Apr 11  2018 media</span><br><span class="line">drwxr-xr-x.     2           root root  4096 Apr 11  2018 mnt</span><br><span class="line">drwxr-xr-x.     4           root root  4096 Jun 27 19:30 opt</span><br><span class="line">dr-xr-xr-x    102           root root     0 Jul 19 10:14 proc</span><br><span class="line">dr-xr-x---.     8           root root  4096 Aug 16 20:48 root</span><br><span class="line">drwxr-xr-x     29           root root  1040 Aug 12 02:33 run</span><br><span class="line">lrwxrwxrwx.     1           root root     8 Mar  7  2019 sbin -&gt; usr&#x2F;sbin</span><br><span class="line">drwxr-xr-x.     2           root root  4096 Apr 11  2018 srv</span><br><span class="line">dr-xr-xr-x     13           root root     0 Aug  3 18:13 sys</span><br><span class="line">drwxrwxrwt.    10           root root  4096 Aug 16 20:56 tmp</span><br><span class="line">drwxr-xr-x.    13           root root  4096 Mar  7  2019 usr</span><br><span class="line">drwxr-xr-x.    19           root root  4096 Jan 14  2022 var</span><br><span class="line">drwxr-xr-x      7           root root  4096 Jan 14  2022 www</span><br></pre></td></tr></table></figure><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><table><thead><tr><th>文件属性</th><th>文件类型</th></tr></thead><tbody><tr><td>-</td><td>常规文件，即 file</td></tr><tr><td>d</td><td>directory 目录文件</td></tr><tr><td>b</td><td>block device 即块设备文件，如硬盘;支持以 block 为单位进行随机访问</td></tr><tr><td>c</td><td>character device 即字符设备文件，如键盘鼠标支持以 character 为单位进行线性访问</td></tr><tr><td>l</td><td>symbolic link 即符号链接文件，又称软链接文件</td></tr><tr><td>p</td><td>pipe 即命名管道文件</td></tr><tr><td>s</td><td>socket 即套接字文件，用于实现两个进程进行通信</td></tr></tbody></table><h3 id="文件个数"><a href="#文件个数" class="headerlink" title="文件个数"></a>文件个数</h3><p>对于文件夹来说是里面包括隐藏文件在内的个数，其他则都显示 <strong>指向它</strong> 的连接文件个数。</p><h3 id="文件大小"><a href="#文件大小" class="headerlink" title="文件大小"></a>文件大小</h3><p>这个大小在不同类型的文件有有不同的意义：</p><ol><li>对于普通文件，显示的是文件的大小（byte 字节数）</li><li>对于设备文件是指主设备号（第 6 列为次设备号）</li><li>对于目录，是指目录大小（目录内 inode 列表所占空间 4096 bit，而不是目录内文件所占的空间大小）</li><li>对于符号链接，是指链接文件的路径名的 byte 字节数</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网络方面&quot;&gt;&lt;a href=&quot;#网络方面&quot; class=&quot;headerlink&quot; title=&quot;网络方面&quot;&gt;&lt;/a&gt;网络方面&lt;/h2&gt;&lt;p&gt;如果我们要修改网络配置的话，需要改相应的配置文件，配置文件在 &lt;code&gt;/etc&lt;/code&gt; 目录下面，网络的话就是 &lt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Linux" scheme="https://xorex.space/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-01-基础概念</title>
    <link href="https://xorex.space/2022/08/03/9be090c95d2b/"/>
    <id>https://xorex.space/2022/08/03/9be090c95d2b/</id>
    <published>2022-08-03T08:05:09.000Z</published>
    <updated>2022-08-18T11:24:11.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h2><ul><li><p>最早的操作系统相关是 Unix 操作系统，诞生与 1970 年，是一个比较完善的分时操作系统。（分时操作系统是使一台计算机采用时间片轮转的方式同时为几个、几十个甚至几百个用户服务的一种操作系统，用来降低使用计算机的成本）</p></li><li><p>之后 C 语言诞生了，程序员们用这种高效的，可以移植性强的语言代替汇编语言重写了 Unix 系统，美国官方将 Unix，C 语言，ICP/IP 协议，当作标准开始推广。成功对后来的计算机发展产生了深远的影响。</p></li><li><p>有一天 Unix 突然宣布不开源了，因此有些程序员将 Unix 系统进行改编，于是就有了各种 Unix 的衍生版本，如：Sun Solaris、FreeBSD、IBM AIX、HP-UX 等等。</p></li><li><p>除此之外，还有一个编写 Unix 衍生版本的计划 GNU 被发起了，而 GNU 则是 GNU Not Unix 的递归缩写。自发起这个计划以来，GNU 开始大量的产生或收集各种系统所必备的组件，像是——函数库（libraries）、编译器（compilers）、调式工具（debugs）、文本编辑器（text editors）、网站服务器（web server），以及一个 Unix 的使用者接口（Unix shell）等等。但由于种种原因，GNU 一直没有开发操作系统的 kernel。正当 Richard Stallman 在为操作系统内核伤脑筋的时候，Linux 出现了。</p></li><li><p>Linus Torvalds 同学在上学时，觉得学校给用的 Unix 衍生操作系统 Minix 太难用了，于是就模仿 Unix 写了自己的操作系统 Linux，并且公开了 Linux 的源代码，允许所有程序员对 Linux 进行修改和完善，成功大火，所以其实可以说，Linux 是 Unix 的一个衍生系统（功能基本相同，但是系统开源）。而因为 Linux 因为借用了很多 GNU 的组件，所以现在 Linux 一般特指 内核层，整个系统则被称为 GNU/Linux。</p></li><li><p>根据国际公约，南极洲属于全人类的资产，任何国家都不能宣誓主权，于是 Linus 使用南极的特产——小企鹅，作为了 Linux 的 Logo，象征着 Linux 的开源精神。</p></li></ul><h2 id="Linux-的组成"><a href="#Linux-的组成" class="headerlink" title="Linux 的组成"></a>Linux 的组成</h2><ul><li><strong>内核层</strong> ：内核层是操作系统的核心，是直接依附在计算机的硬件系统上面，负责对计算机硬件资源和软件资源的调用。通过高效有序的控制，来最大化的发挥出来硬件的能力，为用户提供一个安全，可靠，高效的应用环境。</li><li><strong>Shell(壳)层</strong> ： 壳是用来区别核的，而着个 shell 的目的就是链接用户和 Core 核，因此这个 shell 也叫 命令解释器，用来接受用户的命令，然后解释给计算机执行，shell 分为图形界面和命令行界面。</li><li><strong>应用层</strong> ：应用层用来提供一个图形环境，用来支持操作系统中的各种应用，但是 Linux 不需要安装 GUI 就可以提供完整的功能。</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><blockquote><p>在 Linux 中，一切皆文件。</p></blockquote><h3 id="Linux-的分区"><a href="#Linux-的分区" class="headerlink" title="Linux 的分区"></a>Linux 的分区</h3><p>Linux 默认是进入根目录 <code>/</code> 所在的分区进行操作的。所以无论是物理扩展硬盘，还是对硬盘进行分区，都只能通过根目录 <code>/</code> 进行访问的。所以这些新的分区，都需要在根目录下面找一个 <strong>挂载点</strong>，也就是文件夹，作为访问分区的入口。</p><p>比如我们新分区一个 100G 的空间，使用了不同的文件系统格式。那么我们怎么访问这 100G 的空间呢，答案就是在根目录下给它找一个文件夹作为挂载点，挂载到主分区上面，这样就可以通过根目录下面的文件夹去访问新分区里面的数据了。</p><p>如图：</p><p><img src="https://xorex.space/image/351.jpg" alt="351.jpg"></p><p>根目录在 sda2 逻辑分区中，启动操作系统则会进入 sda2 分区的 根目录 <code>/</code> 下面，而其它的分区则挂载到根目录下面的文件夹下面。 </p><p>再来个例子：<a href="http://c.biancheng.net/view/2859.html">Linux 挂载详解</a></p><h3 id="安装-Linux"><a href="#安装-Linux" class="headerlink" title="安装 Linux"></a>安装 Linux</h3><p>Linux 系统安装必要的分区：</p><ol><li><p><strong>根目录分区</strong>：启动访问的目录，挂载到 <code>/</code>，</p></li><li><p><strong>引导分区</strong>：系统启动所需，需要挂载到 <code>/boot</code> 下面。文件系统格式可以采用 <code>ext4</code> 或者 <code>xfs</code>。</p></li><li><p><strong>交换分区</strong>：类似于 Win 的虚拟内存，不需要通过根目录访问，所以挂载到 <code>swap</code> 下面，和 <code>/</code> 级别平行。文件系统格式为 <code>swap</code> 格式。</p></li></ol><p><img src="https://xorex.space/image/352.jpg" alt="352.jpg"></p><h3 id="根目录文件结构"><a href="#根目录文件结构" class="headerlink" title="根目录文件结构"></a>根目录文件结构</h3><ul><li><p><code>/bin</code>：bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令的二进制可执行文件。是 <code>/usr/bin</code> 下面的一个链接。</p></li><li><p><code>/boot</code>：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p><code>/dev</code>：dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。比如 cpu disk core input output 等等。</p></li><li><p><code>/etc</code>：etc 是 Etcetera(等等) 的缩写，这个目录用来存放所有的系统管理所需要的配置文件和子目录，比如我们配置 Redis 加入系统服务就是增加了配置文件 <code>/etc/systemd/system/redis.service</code>。</p></li><li><p><code>/home</code>：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。Root 用户自己的目录在 <code>/root</code> 里面。一般用来放专属于某个用户的数据，比如 </p></li><li><p><code>/lib</code>：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库，是 <code>/usr/lib</code> 的链接。</p></li><li><p><code>/lib64</code>：和 lib 是一样的，不同的是里面是 64位 共享库，是 <code>/usr/lib64</code> 的链接。</p></li><li><p><code>/lost+found</code>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些关机丢失的文件。</p></li><li><p><code>/media</code>：linux 系统会自动识别一些媒体设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下，从这个目录下面去访问。</p></li><li><p><code>/mnt</code>：系统提供该目录是为了让用户临时挂载别的文件系统的，可以将外部设备挂载到 /mnt/ 上面，是一个可自己修改的 <code>/media</code></p></li><li><p><code>/opt</code>：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如 MySQL Redis 等等，默认是空的。</p></li><li><p><code>/proc</code>：proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure><ul><li><p><code>/root</code>：该目录为系统管理员，也称作超级权限者的用户主目录。用来放 Root 用户的资料的。</p></li><li><p><code>/sbin</code>：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员才能够调用的超级命令，和 <code>/bin</code> 一样，是 usr 文件夹下面的链接。</p></li><li><p><code>/srv</code>：service 所以，该目录存放一些系统服务启动所需要的数据。</p></li><li><p><code>/sys</code>：system，系统内核信息的文件夹。安装了新出现的一个文件系统 sys、fs。sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></li><li><p><code>/tmp</code>：tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。可以设置为下载目录。</p></li><li><p><code>/usr</code>：usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。除了安装应用程序之外，还有其他的共享资源，比如：<code>/usr/bin</code>、<code>/usr/sbin</code>、<code>/usr/src</code>（内核源代码）。</p></li><li><p><code>/var</code>：var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着、会变化的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li><li><p><code>/run</code>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p></li></ul><h2 id="文件编辑"><a href="#文件编辑" class="headerlink" title="文件编辑"></a>文件编辑</h2><h3 id="vim-编辑器"><a href="#vim-编辑器" class="headerlink" title="vim 编辑器"></a>vim 编辑器</h3><p>有三种模式，一般模式，编辑模式，指令模式。</p><p>一般模式：一进来就处于的模式，用于整体的操作文本。比如复制粘贴剪贴删除：段、行、词。和光标再文本中的移动。</p><p>编辑模式：按 i 进入编辑模式，可以输入内容。按 ESC 退出。</p><p>指令模式：按 <code>: /</code> 任意一个进入命令模式，后面跟着对应命令，回车执行。按 ESC 退出。</p><h4 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h4><table><thead><tr><th>语法</th><th>功能</th></tr></thead><tbody><tr><td>Ctrl f</td><td>Front 向下翻一页</td></tr><tr><td>Ctrl b</td><td>Back 向回翻一页</td></tr><tr><td>G</td><td>光标移动到最后一行</td></tr><tr><td>gg</td><td>光标移动到第一行</td></tr><tr><td>p</td><td>在光标处粘贴</td></tr><tr><td>u</td><td>撤销</td></tr><tr><td>Ctrl r</td><td>取消撤销</td></tr></tbody></table><h4 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h4><p>使用 i insert 进入编辑模式。然后直接输入内容即可。使用 ESC 退出编辑模式。</p><h4 id="指令模式"><a href="#指令模式" class="headerlink" title="指令模式"></a>指令模式</h4><p>使用  <code>: /</code> 进入命令模式，不同命令可以组合使用。</p><table><thead><tr><th>语法</th><th>功能</th></tr></thead><tbody><tr><td>:!</td><td>强制执行命令</td></tr><tr><td>:w</td><td>write 保存内容到硬盘上</td></tr><tr><td>:q</td><td>quit 退出 vim</td></tr><tr><td>:w [filename]</td><td>另存为 filename</td></tr><tr><td>:r [filename]</td><td>读取外部 file 并写入到当前光标后</td></tr><tr><td>/[Regex]</td><td>按照正则表达式匹配文本内容，n 下一个 N 上一个</td></tr><tr><td>:set nu</td><td>开启行号</td></tr><tr><td>:noh</td><td>No High 取消高亮</td></tr></tbody></table><h2 id="Linux-命令"><a href="#Linux-命令" class="headerlink" title="Linux 命令"></a>Linux 命令</h2><h3 id="bash-or-shell"><a href="#bash-or-shell" class="headerlink" title="bash or shell"></a>bash or shell</h3><p>上面说了 shell 是壳，而 shell 有很多实现，在 Unix 中叫做 Bourre Shell。而 Linux 中重写了 Unix 的 shell，所以叫做 Bourre Again Shell，取首字母变为了 Bash，特指 Linux 的 shell。</p><p>所有的 bash 命令都是 sh-&gt;bash 应用程序负责的。你甚至可以嵌套调用 bash，不过需要 exit 好几次才能退出来就是了。</p><h3 id="内嵌命令"><a href="#内嵌命令" class="headerlink" title="内嵌命令"></a>内嵌命令</h3><p>一部分基础功能的系统命令是直接内嵌在 shell 中的，系统加载启动之后会随着 shell 一起加载，常驻系统内存中。这部分命令被称为“内置（built-in）命令”，比如 cd、history、exit。</p><p>而其他的命令，则是在 <code>/usr/bin/</code> 目录下面的应用程序了。比如 cat touch vim 等。</p><h3 id="POSIX-命令"><a href="#POSIX-命令" class="headerlink" title="POSIX 命令"></a>POSIX 命令</h3><p>POSIX 指的是 Portable Operating System Interface of UNIX，可移植 Unix 操作系统接口。是为了应用程序在各个类 Unix 系统上都能运行的一套标准，这套标准也规定了一些都必须有的 shell 命令，比如 cd 这些基础命令，它们也被成为 POSIX 命令。 </p><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><p>内嵌命令使用 help xxx 查看，其他命令使用 man xxx 查看。</p><h2 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h2><ol><li><code>date</code> 显示当前的时间。</li><li><code>reboot</code> 重启计算机。</li><li><code>poweroff</code> 关闭系统关闭电源</li><li><code>halt</code> 只关闭系统不关电源。</li><li><code>shutdown</code> 有条件的关闭系统关闭电源</li><li><code>ps</code> 用来查看系统中的进程状态。</li><li><code>top</code> 强化版本的任务管理器。</li><li><code>pidof</code> 后面加某一进程的名称，然后返回这一进程的 PID 值。</li><li><code>kill</code> 后面加后一进程的 PID 值，用来杀掉该进程。<ul><li><code>killall</code> 后面加某一应用的名称，会杀掉所有该应用的进程。</li></ul></li><li><code>echo</code> 后面加想要输出的内容，可以是变量，可以是字符串。</li></ol><h2 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h2><ol><li><code>ifconfig</code> 可以获取网卡配置和网络状态信息，inet 后面是 IP 地址，ether 后面是 MAC 地址。</li><li><code>uname -a</code> 可以查看当前系统的系统内核和版本什么的信息。</li><li><code>free -h</code> 用来显示当前主机的内存使用的相关信息。</li><li><code>who</code> 用来查看当前使用这台计算机的用户信息。</li><li><code>last</code> 用来查看最近的所用用户登录记录（这是个可修改的文档）</li><li><code>history</code> 可以展示你最近执行的进 1000 条命令。<ul><li><code>history -c</code> 删除最近执行的命令记录。</li></ul></li></ol><h2 id="打包压缩与搜索命令"><a href="#打包压缩与搜索命令" class="headerlink" title="打包压缩与搜索命令"></a>打包压缩与搜索命令</h2><ol start="2"><li><p><code>grep string/expression file</code> 用来对文件的内容进行搜索，非常强大，可以是需要匹配的字符串string或者正则表达式expression，file则是需要匹配的文件或者文件夹！</p><ul><li><code>-c</code> 显示找到的行数，也就是一共有多少行成功匹配到了关键字符串。</li><li><code>-i</code> 匹配时忽略大小写。</li><li><code>-n</code> 显示行号。</li><li><code>-v</code> 反向选择。</li></ul></li><li><p><code>find</code> 用来查找文件，如果不加任何参数的话，回将当前目录下所有能找到的文件全部列出来。</p><ul><li><code>-name</code>匹配名称。</li><li><code>-perm</code> 匹配权限。</li><li><code>-user</code> 匹配所有者。</li><li><code>-group</code> 匹配所有组。</li><li><code>-mtime -n +n</code> 匹配修改内容的时间，-n 表示在 n 天以内，+n 表示 n 天以前。</li><li><code>-atime -n +n</code> 匹配访问内容的时间，-n 表示在 n 天以内，+n 表示 n 天以前。</li><li><code>-ctime -n +n</code> 匹配修改文件的权限的时间，-n 表示在 n 天以内，+n 表示 n 天以前。</li><li><code>-type b/d/c/p/l/f</code> 匹配文件类型（后面的字幕参数依次表示块设备、目录、字符设备、管道、链接文件、文本文件）</li><li><code>-size</code> 匹配文件大小（+50kb 表示文件大于，- 表示小于）</li></ul></li></ol><h3 id="路径相关"><a href="#路径相关" class="headerlink" title="路径相关"></a>路径相关</h3><p>绝对路径使用 <code>/</code> 开头，表示根目录，而相对路径不用任何字符开头。</p><p>其中 <code>./</code> 表示当前目录，而 <code>../</code> 表示上一级目录。</p><p>使用 <code>pwd</code> (print work directory) 命令可以现实当前所在目录的绝对路径。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>连接，将一个表面文件和另外一个目标文件关联，点击表面文件打开目标文件。</p><p>硬链接：在当前目录下面添加一个目标文件的目录项（索引），从始至终只有一个文件：目标文件。</p><p>软连接：真的建立了一个文件（又有文件节点），将自己文件路径名链接到了目标文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux-简介&quot;&gt;&lt;a href=&quot;#Linux-简介&quot; class=&quot;headerlink&quot; title=&quot;Linux 简介&quot;&gt;&lt;/a&gt;Linux 简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;最早的操作系统相关是 Unix 操作系统，诞生与 1970 年，是一个比较</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Linux" scheme="https://xorex.space/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis-02-整合Java</title>
    <link href="https://xorex.space/2022/08/03/095a6a7e9903/"/>
    <id>https://xorex.space/2022/08/03/095a6a7e9903/</id>
    <published>2022-08-03T02:08:41.000Z</published>
    <updated>2022-08-03T08:09:48.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven-整合-Jedis"><a href="#Maven-整合-Jedis" class="headerlink" title="Maven 整合 Jedis"></a>Maven 整合 Jedis</h2><p>在 Maven 中引入 Jedis 就可以使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span> <span class="comment">// 建立 Redis 链接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getReids</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;server.xorex.space&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        jedis.auth(<span class="string">&quot;tempestxorex&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">// 按照使用 Redis 命令名字来调用方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = jedis.set(<span class="string">&quot;tempest&quot;</span>, <span class="string">&quot;xorex&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        result = jedis.get(<span class="string">&quot;tempest&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span> <span class="comment">// 关闭 Redis 链接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis 虽然是原子性线程安全的，但是 Jedis 在获取和修改 Redis 的时候的代码，是线程不安全的。也就是如果多个 Java 线程共享一个 jedis 链接实例，就会出现线程不安全问题。为了解决这个问题，可以建立多个 jedis 的连接池，为每个 Java 线程分配不同的 jedis 连接实例。</p><p>创建连接池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisConnectionPoolFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为静态的，一被加载就创建连接池</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig(); <span class="comment">// 获取连接池配置</span></span><br><span class="line">        config.setMaxTotal(<span class="number">8</span>); <span class="comment">// 设置最大连接数量</span></span><br><span class="line">        config.setMinIdle(<span class="number">8</span>); <span class="comment">// 设置最小连接数量</span></span><br><span class="line">        config.setMaxWait(Duration.ZERO); <span class="comment">// 设置最大等待时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过 JedisPoolConfig配置信息 host地址 端口 最大连接时间 密码 来创建连接池</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(config, <span class="string">&quot;server.xorex.space&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;tempestxorex&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource(); <span class="comment">// 返回池子的 Jedis 连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用连接池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getReids</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从连接池获取 jedis 连接</span></span><br><span class="line">        jedis = JedisConnectionPoolFactory.getJedis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeRedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果存在连接池，close 的时候会将连接归还而不是关闭</span></span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot-整合-Jedis"><a href="#SpringBoot-整合-Jedis" class="headerlink" title="SpringBoot 整合 Jedis"></a>SpringBoot 整合 Jedis</h2><h3 id="前置操作"><a href="#前置操作" class="headerlink" title="前置操作"></a>前置操作</h3><p>这里是使用 Spring 全家桶中的 SpringData 系列（专注于数据处理）的 SpringDataRedis，它封装了第三方的 Redis Java 客户端，提供了统一的操作接口。</p><p>使用依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--连接池依赖 lettuce 和 jedis 都用它--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入完成之后，就是在 SpringBoot 的配置文件里面去配置 Redis 的信息。需要注意的是，SpringDataRedis 默认只下载了 lettuce 客户端，如果需要用 Jedis，那么就要引入 Jedis 的 Maven 了。版本号 SpringBoot 会仲裁。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>完成配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">xxxxxxxx</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxxxxxx</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>SpringDataRedis 中提供了 RedisTemplate 工具类，其中封装了各种对 Redis 的操作。并且将不同数据类型的操作 API 封装到了不同的类型中：</p><table><thead><tr><th><strong>API</strong></th><th><strong>返回值类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>redisTemplate</strong>.opsForValue()</td><td>ValueOperations</td><td>操作String类型数据</td></tr><tr><td><strong>redisTemplate</strong>.opsForHash()</td><td>HashOperations</td><td>操作Hash类型数据</td></tr><tr><td><strong>redisTemplate</strong>.opsForList()</td><td>ListOperations</td><td>操作List类型数据</td></tr><tr><td><strong>redisTemplate</strong>.opsForSet()</td><td>SetOperations</td><td>操作Set类型数据</td></tr><tr><td><strong>redisTemplate</strong>.opsForZSet()</td><td>ZSetOperations</td><td>操作SortedSet类型数据</td></tr><tr><td><strong>redisTemplate</strong></td><td></td><td>通用的命令</td></tr></tbody></table><p>操作 Redis：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 自动注入 RedisTemplate</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取 ValueOperations 来操作 String 类型数据</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;testKey&quot;</span>, <span class="string">&quot;testValue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象序列化存储问"><a href="#对象序列化存储问" class="headerlink" title="对象序列化存储问"></a>对象序列化存储问</h3><p>RedisTemplate 的两种序列化实践方案：</p><p>方案一：</p><ul><li>自定义 RedisTemplate</li><li>修改 RedisTemplate 的序列化器为 GenericJackson2JsonRedisSerializer    </li></ul><p>方案二：</p><ul><li>使用 StringRedisTemplate</li><li>写入 Redis 时，手动把对象序列化为 JSON</li><li>读取 Redis 时，手动把读取到的 JSON 反序列化为对象</li></ul><h4 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h4><p>需要注意的是， RedisTemplate 操作的时候，输入的 Key 和 Value 都是 Object 对象，那么就需要有专门的工具类将对象转换为 Redis 需要的 Key 和 Value 字符串。</p><p>这个专门工具类的设置，是作用在 RedisTemplate 上面的，需要我们去修改他的参数。那么在 SpringBoot 中很好解决，只需要我们自定义一个 RedisTemplate，然后注入到 Spring 的 IOC 容器就可以了。这样我们 @AutoWired 拿到的就是我们自定义的 RedisTemplate 而不是默认创建的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 向 IOC 容器中注入我们自己创建的 RedisTemplate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123; <span class="comment">// 方法参数 connectionFactory 会从 IOC 容器中自己找</span></span><br><span class="line">        <span class="comment">// 创建 RedisTemplate 对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置连接工厂，使得 RedisTemplate 可以获取连接池中的 Redis 连接</span></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Key 的序列化</span></span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        redisTemplate.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 Value 的序列化</span></span><br><span class="line">        redisTemplate.setValueSerializer(RedisSerializer.json());</span><br><span class="line">        redisTemplate.setHashValueSerializer(RedisSerializer.json());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样以后 @AutoWired 获取的 RedisTemplate 就是我们自己设置的了，中文编码也就不会出问题了。</p><ul><li>自动完成对象和 Json 字符串的序列化和反序列化：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>,<span class="keyword">new</span> User(<span class="number">100</span>,<span class="string">&quot;Xorex&quot;</span>,<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 Redis 中取出 Json 字符串，然后序列化成一个对象</span></span><br><span class="line">    User user = (User) redisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">    <span class="comment">// 反序列化过程是，先创建对象，然后使用 setter 方法进行填充</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自动反序列化的结果</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;@class&quot;</span>: <span class="string">&quot;space.xorex.boot.pojo.User&quot;</span>, <span class="comment">// 因为保存了 Class 信息，所以可以自动反序列化为对象</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="number">101</span>,</span><br><span class="line">  <span class="attr">&quot;userName&quot;</span>: <span class="string">&quot;你好&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h4><p>因为自动反序列化的结果多了一个 @Class，比较占用内存，我们可以通过将 Value 也设置为 String 序列化，这样就没有 @Class 了，但是这样做的坏处就是 get() 获取的 Redis 数据没有办法自动反序列化为对象了，需要我们手动完成。</p><p>Spring 默认提供了一个 StringRedisTemplate 类，它的 key 和 value 的序列化方式默认就是 String 方式。省去了我们自定义 RedisTemplate 的过程.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    <span class="comment">// jackson 提供的 json 字符串和对象互相转换的工具</span></span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="number">101</span>,<span class="string">&quot;你好&quot;</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 user 的 json</span></span><br><span class="line">    String json = mapper.writeValueAsString(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 key value</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:101&quot;</span>,json);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 key value</span></span><br><span class="line">    String value = stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:101&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将读取的字符串结果转换为对象</span></span><br><span class="line">    User newUser = mapper.readValue(json, User.class);</span><br><span class="line">    </span><br><span class="line">    System.out.println(newUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样的序列化结果：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;id&quot;</span>: <span class="number">101</span>,</span><br><span class="line">  <span class="attr">&quot;userName&quot;</span>: <span class="string">&quot;你好&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Maven-整合-Jedis&quot;&gt;&lt;a href=&quot;#Maven-整合-Jedis&quot; class=&quot;headerlink&quot; title=&quot;Maven 整合 Jedis&quot;&gt;&lt;/a&gt;Maven 整合 Jedis&lt;/h2&gt;&lt;p&gt;在 Maven 中引入 Jedis 就可以使</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Redis" scheme="https://xorex.space/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis-01-基础命令</title>
    <link href="https://xorex.space/2022/08/03/c124465ae885/"/>
    <id>https://xorex.space/2022/08/03/c124465ae885/</id>
    <published>2022-08-03T02:08:21.000Z</published>
    <updated>2022-08-11T19:42:59.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>Redis：Remote Dictionary server 远程词典（键值对形式）服务器。是一种 NoSQL 数据库。</p><h3 id="和-SQL-比较"><a href="#和-SQL-比较" class="headerlink" title="和 SQL 比较"></a>和 SQL 比较</h3><p><img src="https://xorex.space/image/342.jpg" alt="342.jpg"></p><h3 id="Redis-特点"><a href="#Redis-特点" class="headerlink" title="Redis 特点"></a>Redis 特点</h3><p><img src="https://xorex.space/image/343.jpg" alt="343.jpg"></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Redis 的 Key 都是字符串类型，Value 则支持五种基本类型和其他类型。</p><p>基本类型：string（字符串），hash（哈希），list（列表），set（集合）、sorted set（有序集合)</p><p>一个 Key 的 Value 只能有一个数据类型。</p><h3 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h3><h4 id="1-安装-GCC-依赖"><a href="#1-安装-GCC-依赖" class="headerlink" title="1. 安装 GCC 依赖"></a>1. 安装 GCC 依赖</h4><p>Redis 使用 C 语言编写，所以需要安装其代码所依赖的 GCC 编译器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><h4 id="2-下载-Redis-解压"><a href="#2-下载-Redis-解压" class="headerlink" title="2. 下载 Redis 解压"></a>2. 下载 Redis 解压</h4><p>我们将目录定位到 <code>usr/local/src</code> 中，并下载解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.7.tar.gz</span><br><span class="line">tar -zxvf redis-6.2.7.tar.gz</span><br></pre></td></tr></table></figure><h4 id="3-编译-Redis"><a href="#3-编译-Redis" class="headerlink" title="3. 编译 Redis"></a>3. 编译 Redis</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.7</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>编译完成之后，会在 <code>/usr/local/bin</code> 中出现编译结果，这个目录 <code>/usr/local/bin</code> 已经被添加到了默认的环境变量中，任意地方都可以运行里面的结果。</p><p>redis-cli Redis 命令执行客户端启动脚本</p><p>redis-server Redis 服务端启动脚本</p><p>redis-sentinel Redis 哨兵启动脚本</p><h2 id="二、Redis-控制"><a href="#二、Redis-控制" class="headerlink" title="二、Redis 控制"></a>二、Redis 控制</h2><h3 id="1-启动"><a href="#1-启动" class="headerlink" title="1. 启动"></a>1. 启动</h3><h4 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h4><p>在任意地方输入 redis-server 即可前台启动 Redis，此时无法退出，只能看着监控面板</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p><img src="https://xorex.space/image/344.jpg" alt="344.jpg"></p><h4 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h4><p>如果要让 Redis以 <code>后台</code> 方式启动，则必须修改 Redis 配置文件，就在我们之前解压的 Redis 安装包下（ <code>/usr/local/src/redis-6.2.6</code> ），名字叫 Redis.conf：</p><p><img src="https://xorex.space/image/345.jpg" alt="345.jpg"></p><p>我们先将这个配置文件备份一份：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure><p>然后修改 redis.conf 文件中的一些配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure><p>Redis 的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure><p>启动 Redis：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录,作为启动 redis 的工作目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure><h4 id="后台开机自启"><a href="#后台开机自启" class="headerlink" title="后台开机自启"></a>后台开机自启</h4><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;redis-server</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;src&#x2F;redis-6.2.7&#x2F;redis.conf</span><br><span class="line">PrivateTmp&#x3D;true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure><p>执行下面的命令，可以让 redis 开机自启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure><h3 id="2-链接-Redis"><a href="#2-链接-Redis" class="headerlink" title="2. 链接 Redis"></a>2. 链接 Redis</h3><h4 id="命令行客户端"><a href="#命令行客户端" class="headerlink" title="命令行客户端"></a>命令行客户端</h4><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli [options]</span><br></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a xxxxxx</code>：指定redis的访问密码 </li></ul><p>推荐先进行 redis 链接，不输入密码。链接成功之后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth [username] password</span><br></pre></td></tr></table></figure><p>来验证账号密码（没有用户名可以不填）</p><h4 id="图形化客户端"><a href="#图形化客户端" class="headerlink" title="图形化客户端"></a>图形化客户端</h4><p>在这里下载：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><p>然后链接就可以使用了</p><h2 id="三、Redis-命令"><a href="#三、Redis-命令" class="headerlink" title="三、Redis 命令"></a>三、Redis 命令</h2><p>推荐在官方的文档里面去学习 Redis 的命令：<a href="https://redis.io/commands/">https://redis.io/commands/</a></p><p>也可以在 Redis 命令行中使用 <code>help [command]</code> 来查看命令用法.</p><p><img src="https://xorex.space/image/346.jpg" alt="346.jpg"></p><h3 id="1-通用命令"><a href="#1-通用命令" class="headerlink" title="1. 通用命令"></a>1. 通用命令</h3><p><img src="https://xorex.space/image/347.jpg" alt="347.jpg"></p><p>Expire  <em>/<em>ɪkˈspaɪər</em>/</em> 到期死亡，设置的 key 有效期是以秒计算。</p><p>TTL TimeToLive 生存时间，返回 key 有效期，-1 为永久有效，-2 表示不存在。</p><h4 id="Key-的分类"><a href="#Key-的分类" class="headerlink" title="Key 的分类"></a>Key 的分类</h4><p>为了规范 Key 的命名，一般采用 <code>项目名:业务名:类型:id</code> 的形式命名 Key，然后将数据对象序列化为 Json 字符串作为存储值。</p><table><thead><tr><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr><td>xorex:blog:user:233</td><td>{“id”:233, “name”: “Xorex”, “age”: 21}</td></tr><tr><td>xorex:video:dance:123</td><td>{“id”:123, “name”: “newLand”, “time”: 4539}</td></tr></tbody></table><p>用这样的形式分类，会被 RDM 自动分层处理。</p><p><img src="https://xorex.space/image/348.jpg" alt="348.jpg"></p><h3 id="2-String"><a href="#2-String" class="headerlink" title="2. String"></a>2. String</h3><h4 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h4><p><img src="https://xorex.space/image/349.jpg" alt="349.jpg"></p><p>虽说三种调用的时候都是字符串，但是存储的时候格式不同，int 和 float 会使用对应的编码来增大存储范围。</p><h4 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h4><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对（Multiple）</li><li>MGET：根据多个key获取多个String类型的value（Multiple）</li><li>INCR：让一个整型的key自增1（Increase）</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2（可以通过它实现负增长）</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长（浮点数没有默认自增长度）</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行 （<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists）</li><li>SETEX：添加一个String类型的键值对，并且指定有效期 （Set+Expire）</li></ul><h3 id="3-Hash-类型"><a href="#3-Hash-类型" class="headerlink" title="3. Hash 类型"></a>3. Hash 类型</h3><h4 id="类型信息-1"><a href="#类型信息-1" class="headerlink" title="类型信息"></a>类型信息</h4><p>对 Json 类的 String 进行的改进，Json 部分使用 Hash 存储，可以单独定位修改里面的某个元素。</p><p><img src="https://xorex.space/image/350.jpg" alt="350.jpg"></p><h4 id="操作命令-1"><a href="#操作命令-1" class="headerlink" title="操作命令"></a>操作命令</h4><p>都是在一个 Key 下面，对不同的 field 进行 value 的修改。</p><p>Hash的常见命令有：</p><ul><li>HSET key field value：添加或者修改hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field的值</li><li>HMSET：批量添加多个hash类型key的field的值</li><li>HMGET：批量获取多个hash类型key的field的值</li><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有的field</li><li>HVALS：获取一个hash类型的key中的所有的value</li><li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><h3 id="4-List-类型"><a href="#4-List-类型" class="headerlink" title="4. List 类型"></a>4. List 类型</h3><h4 id="类型信息-2"><a href="#类型信息-2" class="headerlink" title="类型信息"></a>类型信息</h4><p>List 是有序的双向链表结构，插入删除快，查询速度慢。只能从左边或者右边插入，不支持插入中间。所以说是有序的，能保留插入顺序的数据结构。</p><h4 id="操作命令-2"><a href="#操作命令-2" class="headerlink" title="操作命令"></a>操作命令</h4><p>前缀 L 和 R 用来区分链表的 左边 和 右边，也就是 头 和 尾 。</p><p>List 的操作都是针对一个 Key，一个 Key 里面存着一个 List。</p><p>List的常见命令有：</p><ul><li>LPush key  element … ：向列表左侧插入一个或多个元素</li><li>LPop key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPush key  element … ：向列表右侧插入一个或多个元素</li><li>RPop key：移除并返回列表右侧的第一个元素</li><li>LRange key star end：返回一段角标范围内的所有元素</li><li>BLPop 和 BRPop：与 LPOP 和RPOP 类似，只不过在没有元素时等待指定时间，而不是直接返回 nil（在等待过程中只是该操作进入阻塞状态，仍可以完成其他操作命令）</li></ul><h3 id="5-Set-类型"><a href="#5-Set-类型" class="headerlink" title="5. Set 类型"></a>5. Set 类型</h3><p>Redis 的 Set 结构与 Java 中的 HashSet 类似，满足以下特性：无序，元素不可重复，查找快，支持交集、并集、差集等功能。</p><p>常见命令：</p><ul><li>SAdd key member … ：向set中添加一个或多个元素</li><li>SRem key member … : 移除set中的指定元素</li><li>SCard key： 返回set中元素的个数</li><li>SIsNumber key member：判断一个元素是否存在于set中 isMember</li><li>SMembers：获取set中的所有元素 members</li><li>SInter key1 key2 … ：求 key1 与 key2 的交集 inter</li><li>SDiff key1 key2 … ：求key1与key2的差集</li><li>SUnion key1 key2 ..：求key1和key2的并集</li></ul><h3 id="6-SortedSet（ZSet）-类型"><a href="#6-SortedSet（ZSet）-类型" class="headerlink" title="6. SortedSet（ZSet） 类型"></a>6. SortedSet（ZSet） 类型</h3><p>一个经过排序的 Set 集合（SortedSet 又名 ZSet），底层是通过跳表实现排序，Hash 实现唯一性。而排序是根据 score 属性的值进行排序的。</p><p>因为引入了排序功能，所以操作也多了关于位置和范围的操作：</p><ul><li>ZAdd key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZRem key member：删除sorted set中的一个指定元素</li><li>ZScore key member : 获取sorted set中的指定元素的score值</li><li>ZRank key member：获取sorted set 中的指定元素的排名</li><li>ZCard key：获取sorted set中的元素个数</li><li>ZCount key min max：统计score值在给定范围内的所有元素的个数</li><li>ZIncrBy key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRange key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRangeByScore key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDiff、ZInter、ZUnion：求差集、交集、并集</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、基本概念&quot;&gt;&lt;a href=&quot;#一、基本概念&quot; class=&quot;headerlink&quot; title=&quot;一、基本概念&quot;&gt;&lt;/a&gt;一、基本概念&lt;/h2&gt;&lt;p&gt;Redis：Remote Dictionary server 远程词典（键值对形式）服务器。是一种 NoSQ</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Redis" scheme="https://xorex.space/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Python-08-线程、进程和协程</title>
    <link href="https://xorex.space/2022/06/15/8bf79f16d228/"/>
    <id>https://xorex.space/2022/06/15/8bf79f16d228/</id>
    <published>2022-06-15T14:11:49.000Z</published>
    <updated>2022-07-16T13:47:09.594Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这章主要是：线程、进程和协程的介绍。</p></blockquote><p>串行、并行：关注着程序是否有同时处理多个任务的能力。<br>阻塞、非阻塞：关注着程序是否处于什么都不干的等待状态。<br>同步、异步：关注着程序的任务调用，是按照顺序完成一个调用一个，还是一直调用并等待依次完成。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="全局解释锁-GIL"><a href="#全局解释锁-GIL" class="headerlink" title="全局解释锁 GIL"></a>全局解释锁 GIL</h3><p>Global Interprator Lock 全局解释锁，因为 GIL 的存在，导致 Python 在一个时间内只有一个线程被执行。</p><p>Python虚拟机执行方式如下：</p><ol><li>设置 GIL</li><li>切换进线程</li><li>执行下面操作之一:<ul><li>运行指定数量的字节码指令</li><li>线程主动让出控制权</li><li>切换出线程（线程处于睡眠状态）</li></ul></li><li>解锁 GIL</li><li>进入 1 步骤</li></ol><p>采用 GIL 的原因是 Python 虚拟机采用引用计数法来标记垃圾回收。如果不加全局锁 GIL 的话，不同的线程在一个进程单位下，可以引用同一对象资源。那么并行访问就会可能导致引用计数的 线程不安全，所以才用 GIL 变成串行执行（引用是单个字节码）。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><strong>需要注意的是</strong>，GIL 是解决 <strong>引用计数</strong> 的线程不安全，并不会防止其他资源访问的线程不安全问题。比如下面的代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    t = threading.Thread(target=foo)</span><br><span class="line">    threads.append(t)</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.start()</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure><p>n+1 这个代码的指令是多条组成，虽然是串行，但是线程丢失执行权时间不确定，就有可能有线程安全问题。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD_GLOBAL              <span class="number">0</span> (n)</span><br><span class="line">LOAD_CONST               <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">INPLACE_ADD</span><br><span class="line">STORE_GLOBAL             <span class="number">0</span> (n)</span><br></pre></td></tr></table></figure><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>创建线程：<code>thread = Thread(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, daemon=None)</code></p><ul><li>group 为以后 Python 新特性 ThreadGroup 准备的</li><li>target 填写要运行的函数名，不带括号 callable</li><li>name 线程名 str</li><li>args 非可变参数，而是元组变量，按照函数的参数顺序依次填充被调用函数 tuple</li><li>kwargs 非可变参数，而是字典变量，按照 参数名:参数值 填充被调用函数 dic</li><li>daemon 是否为守护线程 boolean</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">name: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        print(name,i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置连个线程</span></span><br><span class="line">thread1 = Thread(target=count, args=(<span class="string">&#x27;1&#x27;</span>))</span><br><span class="line">thread2 = Thread(target=count, args=(<span class="string">&#x27;2&#x27;</span>))</span><br><span class="line"></span><br><span class="line">thread1.start() <span class="comment"># 开始执行</span></span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># join() 链接，将这个运行点链接到某线程去</span></span><br><span class="line">thread1.join() <span class="comment"># 在 thread1 线程执行完毕之后再执行本线程</span></span><br><span class="line">thread2.join() <span class="comment"># 在 thread2 线程执行完毕之后再执行本线程</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Two threads are all accomplish&quot;</span>) <span class="comment"># 两个线程执行完毕</span></span><br><span class="line"></span><br><span class="line">thread1.close() <span class="comment"># 释放线程资源</span></span><br><span class="line">thread2.close()</span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>将若干固定的操作交给若干个线程执行，非常方便。</p><p>从 concurrent.futures 里面导入 ThreadPoolExecutor</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">name: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        print(name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(<span class="number">12</span>) <span class="keyword">as</span> t: <span class="comment"># 创建拥有 12 个线程的线程池</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">120</span>):</span><br><span class="line">        t.submit(count, name=<span class="string">f&quot;Thread <span class="subst">&#123;i&#125;</span>&quot;</span>) <span class="comment"># 依次提交线程要完成的任务，一共 120 个，分配个 12 个线程完成。</span></span><br><span class="line">    <span class="comment"># 执行完所有任务之后，销毁线程池，退出 with 语句，执行下面代码</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Finish!&quot;</span>)</span><br></pre></td></tr></table></figure><p>submit() 函数会返回一个 Executor，可以从中获取线程执行结果 result()。</p><p>记得要 submit() 完所有的任务之后，再去获取结果哦。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>多进程由于 GIL 的存在，没有办法并行运行，所以为了充分利用 CPU 的多个核心，就只能采用 多进程 的方式了。</p><p>当然，一个进程中可以开启很多线程来共享内存资源。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>从 multiporcessing 中导入 Process 类。</p><p>Process <code>__init__</code> 的参数和 Thread 是一样的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">name: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>): </span><br><span class="line">        print(name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>: <span class="comment"># 想一想为什么要在 main 中执行</span></span><br><span class="line">    process1 = Process(target=count, name=<span class="string">&quot;Process 1&quot;</span>, args=(<span class="string">&quot;1&quot;</span>)) <span class="comment"># 创建新进程</span></span><br><span class="line">    process2 = Process(target=count, name=<span class="string">&quot;Process 2&quot;</span>, args=(<span class="string">&quot;2&quot;</span>))</span><br><span class="line"></span><br><span class="line">    process1.start() <span class="comment"># 启动进程</span></span><br><span class="line">    process2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    process1.join() <span class="comment"># 等待两个进程执行完之后再运行</span></span><br><span class="line">    process2.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;Finish&quot;</span>)</span><br><span class="line"></span><br><span class="line">    process1.close() <span class="comment"># 释放进程资源</span></span><br><span class="line">    process2.close()</span><br></pre></td></tr></table></figure><h3 id="无限引用问题"><a href="#无限引用问题" class="headerlink" title="无限引用问题"></a>无限引用问题</h3><p>上面有一个问题，就是为什么 Process 的启动必须在 main 中。</p><p>这是由于在开启一个新的进程的时候，需要资源是相互隔离的，所以要复制一份到新的进程中。</p><p>那么在导入本 py 文件的时候，如果线程创建不写在 main 中，导入过程就会执行线程创建，就会再次复制资源到新的进程并在导入，然后进入死循环。类似于循环引用，不过是我引用我自己。</p><p>所以写了 <code>__main__</code> 中之后，就不会在导入过程中不停开新的进程然后再导入了。</p><h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>用法和线程池差不多，下面是大体结构：</p><p><img src="https://xorex.space/image/341.jpg" alt="341.jpg"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">name: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        print(name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(<span class="number">5</span>) <span class="keyword">as</span> p:  <span class="comment"># 开一个 5 个进程的进程池</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            p.submit(count, name=<span class="string">f&quot;Process <span class="subst">&#123;i&#125;</span>&quot;</span>)  <span class="comment"># 提交任务</span></span><br><span class="line">    <span class="comment"># 结束线程池所有任务，继续执行下面代码</span></span><br></pre></td></tr></table></figure><p>submit() 函数会返回一个 Executor，可以从中获取线程执行结果 result()。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>这里的异步主要是指 Asyncio 对所有处于 IO 状态的代码进行切换异步处理，等到 IO 加载完成之后，再继续回来处理代码，减少因为等待 IO 浪费的时间，等待 IO 是可以并行等待的。</p><p>这里的 IO 有很多，比如打开文件进行文件读写，网络请求与发送等等。通过 async 进行协程任务标注，通过 await 进行协程调用。</p><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><p>async 表示此任务是异步的，在协程事件队列可以随意调用然后等待事件结果返回。在函数前面加上此前缀，函数会会变成一个协程对象。 </p><p>await 表示此处调用了可等待的任务，只有发来了等待结果才能继续往后面运行，是协程对象中的代码支持的功能。</p><p>下面的代码借助着协程的 异步非阻塞，实现了单线程 3s 的执行：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">function</span>():</span>  <span class="comment"># 一个协程函数对象</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)  <span class="comment"># 只有在协程中才能使用 await 异步等待执行结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        task = asyncio.create_task(function())  <span class="comment"># 将协程对象包装成 任务 Task 如果有参数，这里可以直接填写 function(xxx)</span></span><br><span class="line">        tasks.append(task)  <span class="comment"># 填充任务列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)  <span class="comment"># 异步调用 asyncio.wait() 负责将列表内的任务依次添加到事件循环中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())  <span class="comment"># 创建事件循环，把 协程 main() 加入事件循环中，开始执行事件循环</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是，协程不同于线程，启动一个线程之后，是不影响主线程的继续执行的。但是启动了一个协程，主协程会等待新协程执行完毕之后，再去执行后面的代码。</p><p>所以下面方式创建多个协程运行是会 阻塞 运行的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> function()</span><br><span class="line"><span class="keyword">await</span> function()</span><br><span class="line"><span class="keyword">await</span> function()</span><br><span class="line"><span class="keyword">await</span> function()</span><br><span class="line"><span class="keyword">await</span> function()</span><br></pre></td></tr></table></figure><p>应当使用将一个协程对象通过 asyncio.create_task() 转化为任务之后，组成一个任务列表 tasks[]，然后借助这 asyncio.wait(tasks) 将这些任务全部加入到事件循环中之后，再启动异步执行。这样这些任务就可以再 IO 的时候被事件循环控制跳转，实现非阻塞执行。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>协程在单线程中实现 IO 的异步非阻塞借助的是 事件循环 event_loop。</p><p>每一个协程对象都是一个事件，被添加到事件循环之后，可以被 asyncio 的控制下，遇到 IO 就切换到另外一个事件去执行，直到等待到 IO 的执行结果，再跳转回来执行。每一个对象执行的跳转，都在事件循环中。</p><p>所以我们执行一个协程的时候，需要借助着 asyncio.run() 创建一个事件循环，然后把参数：协程对象 加入到事件循环中，启动事件循环的执行。</p><p>协程对象每运行到 await，就会把它加入到事件循环中，以协程的方式执行它，当它执行完毕之后响应执行结果，然后跳转回来继续执行 await 后面的代码。</p><h3 id="async-with"><a href="#async-with" class="headerlink" title="async with"></a>async with</h3><p>异步的上下文管理器，比如异步的网络会话想要通过 with 来进行上下文管理的时候，就需要加上 async with，来保证异步资源在被管理的时候，可以执行内部的异步代码。比如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># async with 可以用 await 调用后面的资源生成，也可以用 await 调用最后的 close 实现管理过程的异步调用</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">    session.get()</span><br></pre></td></tr></table></figure><h3 id="async-for"><a href="#async-for" class="headerlink" title="async for"></a>async for</h3><p>用来迭代 异步可迭代 对象：</p><p>一个异步可迭代对象（asynchronous iterable）能够在迭代过程中调用异步代码，而异步迭代器就是能够在 next() 方法中调用异步代码。</p><p>1、一个对象必须实现 <code>__aiter__</code> 方法，该方法返回一个异步迭代器（asynchronous iterator）对象。<br>2、一个异步迭代器对象必须实现 <code>__anext__</code> 方法，该方法返回一个 awaitable 类型的值。<br>3、为了停止迭代，<code>__anext__</code> 必须抛出一个 StopAsyncIteration 异常。</p><p>上面的内容不用管，你只需要知道如果被迭代对象是一个 异步可迭代 对象，那么就用 <code>async for</code> 即可。</p><h3 id="异步协程库"><a href="#异步协程库" class="headerlink" title="异步协程库"></a>异步协程库</h3><p>要通过协程的方式 异步非阻塞 执行 IO 任务，就要要调用的 IO API 也必须是 async 类型的协程对象。如果对应的 IO API 没有异步实现的话，就只能借助多进程来完成了。</p><h4 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=Script.headers) <span class="keyword">as</span> response:</span><br><span class="line">        content = <span class="keyword">await</span> response.text(encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">        content = <span class="keyword">await</span> response.json()</span><br></pre></td></tr></table></figure><h4 id="aiofiles"><a href="#aiofiles" class="headerlink" title="aiofiles"></a>aiofiles</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(fileName, mode=<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">await</span> f.write(text)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这章主要是：线程、进程和协程的介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;串行、并行：关注着程序是否有同时处理多个任务的能力。&lt;br&gt;阻塞、非阻塞：关注着程序是否处于什么都不干的等待状态。&lt;br&gt;同步、异步：关注着程序的任务调用，是按照顺序完</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
    <category term="线程" scheme="https://xorex.space/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="进程" scheme="https://xorex.space/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="协程" scheme="https://xorex.space/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>爬虫-03-简单案例记录</title>
    <link href="https://xorex.space/2022/06/15/7c2756a86cb3/"/>
    <id>https://xorex.space/2022/06/15/7c2756a86cb3/</id>
    <published>2022-06-15T09:29:08.000Z</published>
    <updated>2022-06-17T12:41:56.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="regex-正则表达式"><a href="#regex-正则表达式" class="headerlink" title="regex 正则表达式"></a>regex 正则表达式</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取豆瓣前 250 的电影信息，包括名字，评分和电影 slogan。</span></span><br><span class="line"><span class="comment"># 主要是使用了正则表达式 .*? 进行内容忽略和 (?P&lt;group_name&gt;.*?) 将获取的 html 信息进行提取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> WebConstant</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&#x27;&lt;li&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;.*?&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(?P&lt;rate&gt;.*?)&lt;/span&gt;.*?&lt;span class=&quot;inq&quot;&gt;(?P&lt;slogan&gt;.*?)&lt;/span&gt;.*?&lt;/li&gt;&#x27;</span></span><br><span class="line">regex = re.<span class="built_in">compile</span>(pattern, re.S)</span><br><span class="line"></span><br><span class="line">movie_list = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    url = <span class="string">&quot;https://movie.douban.com/top250?start=&quot;</span>+<span class="built_in">str</span>(i*<span class="number">25</span>)</span><br><span class="line">    response = requests.get(url, headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>: WebConstant.USER_AGNET&#125;)</span><br><span class="line">    response.encoding = <span class="string">&quot;utf-8&quot;</span></span><br><span class="line">    text = response.text</span><br><span class="line">    groups = regex.finditer(text)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> groups:</span><br><span class="line">        movie_info = &#123;&#125;</span><br><span class="line">        movie_info[<span class="string">&quot;name&quot;</span>] = i.group(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        movie_info[<span class="string">&quot;rate&quot;</span>] = i.group(<span class="string">&quot;rate&quot;</span>)</span><br><span class="line">        movie_info[<span class="string">&quot;slogan&quot;</span>] = i.group(<span class="string">&quot;slogan&quot;</span>)</span><br><span class="line">        movie_list.append(movie_info)</span><br><span class="line"></span><br><span class="line">print(movie_list)</span><br></pre></td></tr></table></figure><h2 id="Xpath-路径定位"><a href="#Xpath-路径定位" class="headerlink" title="Xpath 路径定位"></a>Xpath 路径定位</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主要是记录 xpath 的使用过程。</span></span><br><span class="line"><span class="comment"># 通过 xpath 实现对八戒网的店铺、价格、地理位置信息进行提取。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> WebConstant</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://chengdu.zbj.com/search/f/?kw=logo&quot;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: WebConstant.USER_AGNET</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">response = requests.get(url, headers=headers)</span><br><span class="line">response.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line">html = etree.HTML(response.text)</span><br><span class="line">etree.parse()</span><br><span class="line"></span><br><span class="line">divs = html.xpath(<span class="string">&#x27;//*[@id=&quot;utopia_widget_76&quot;]/a[1]/div&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> div <span class="keyword">in</span> divs:</span><br><span class="line">    print(div)</span><br><span class="line">    price = div.xpath(<span class="string">&#x27;./p/text()&#x27;</span>)</span><br><span class="line">    print(price)</span><br></pre></td></tr></table></figure><h2 id="Session-登录会话"><a href="#Session-登录会话" class="headerlink" title="Session 登录会话"></a>Session 登录会话</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取  17k 小说 登录之后的书架内容</span></span><br><span class="line"><span class="comment"># 通过 Session 实现登陆后自动发送 Cookie，实现登录内容获取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> WebConstant</span><br><span class="line"></span><br><span class="line">login_url = <span class="string">&#x27;https://passport.17k.com/ck/user/login&#x27;</span> <span class="comment">#登录</span></span><br><span class="line">collected_books_url = <span class="string">&#x27;https://user.17k.com/ck/author/shelf?page=1&amp;appKey=2406394919&#x27;</span> <span class="comment"># 返回收藏书 JSON 数据的接口</span></span><br><span class="line"></span><br><span class="line">session = requests.session()</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    WebConstant.USER_AGNET_KEY: WebConstant.USER_AGNET</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;loginName&#x27;</span>: <span class="string">&#x27;BookLoverTempest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;tempest&amp;2001618&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">session.post(login_url, params=params, headers=headers)</span><br><span class="line"></span><br><span class="line">collected_books_dic = session.get(collected_books_url).json() <span class="comment"># JSON 转 dic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> collected_book <span class="keyword">in</span> collected_books_dic[<span class="string">&#x27;data&#x27;</span>]:</span><br><span class="line">    print(collected_book)</span><br></pre></td></tr></table></figure><h2 id="防盗链处理"><a href="#防盗链处理" class="headerlink" title="防盗链处理"></a>防盗链处理</h2><p>一些视频的 URL 地址并不是完全显示在 JSON 中的，可能会 JS 进行加工处理，所以需要找找 JSON 和实际地址之间的关系，进行处理。</p><h2 id="多线程-多进程"><a href="#多线程-多进程" class="headerlink" title="多线程/多进程"></a>多线程/多进程</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对 北京新发地 菜市场价格信息进行爬取</span></span><br><span class="line"><span class="comment"># 采用 进程池 进行多进程爬取加速（爬虫还是推荐 Asyncio 或者线程池）</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> WebConstant</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.xinfadi.com.cn/getPriceData.html&quot;</span></span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;current&#x27;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    WebConstant.USER_AGNET_KEY: WebConstant.USER_AGNET</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getItemPrice</span>(<span class="params">current: <span class="built_in">int</span></span>) -&gt; list:</span></span><br><span class="line">    params[<span class="string">&#x27;current&#x27;</span>] = current</span><br><span class="line">    <span class="keyword">with</span> requests.get(url, params=params, headers=headers) <span class="keyword">as</span> response:</span><br><span class="line">        <span class="keyword">return</span> response.json()[<span class="string">&#x27;list&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    items = []</span><br><span class="line">    executors = []</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(<span class="number">12</span>) <span class="keyword">as</span> p:  <span class="comment"># 开 12 个进程的进程池 6s</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):</span><br><span class="line">            executors.append(p.submit(getItemPrice, (i + <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> executor <span class="keyword">in</span> executors:  <span class="comment"># 等多进程分配执行完了，再去获取结果</span></span><br><span class="line">        items.append(executor.result().copy())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in range(101): # 顺序执行 44s</span></span><br><span class="line">    <span class="comment">#     getItemPrice(i+1)</span></span><br><span class="line"></span><br><span class="line">    print(items)</span><br><span class="line">    print(<span class="built_in">len</span>(items))</span><br><span class="line">    print(time.time() - start)</span><br></pre></td></tr></table></figure><h2 id="Asyncio-异步编程"><a href="#Asyncio-异步编程" class="headerlink" title="Asyncio 异步编程"></a>Asyncio 异步编程</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用异步的网络请求 aiohttp 完成对网络小说 斗破苍穹的爬取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> WebConstant</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Script</span>:</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.ddyueshu.com&#x27;</span></span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        WebConstant.USER_AGNET_KEY: WebConstant.USER_AGNET</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        chapters = self.getChapters()</span><br><span class="line">        loop = asyncio.get_event_loop()</span><br><span class="line">        loop.run_until_complete(self.toDownload(chapters))</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getChapters</span>(<span class="params">self</span>) -&gt; list:</span></span><br><span class="line">        chapters = []</span><br><span class="line"></span><br><span class="line">        response = requests.get(Script.url + <span class="string">&#x27;/1_1600&#x27;</span>, headers=Script.headers)</span><br><span class="line">        response.encoding = <span class="string">&quot;gbk&quot;</span></span><br><span class="line">        pattern = <span class="string">r&#x27;.*?&lt;dd&gt;&lt;a href =&quot;(?P&lt;url&gt;.*?)&quot;&gt;(?P&lt;name&gt;.*?)&lt;/a&gt;&lt;/dd&gt;.*?&#x27;</span></span><br><span class="line">        regex = re.<span class="built_in">compile</span>(pattern, re.S)</span><br><span class="line">        groups = regex.finditer(response.text)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> groups:</span><br><span class="line">            chapter = &#123;<span class="string">&#x27;name&#x27;</span>: i.group(<span class="string">&quot;name&quot;</span>), <span class="string">&#x27;url&#x27;</span>: i.group(<span class="string">&quot;url&quot;</span>)&#125;</span><br><span class="line">            chapters.append(chapter)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chapters</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">toDownload</span>(<span class="params">self, chapters: <span class="built_in">list</span></span>):</span></span><br><span class="line">        tasks = []</span><br><span class="line">        <span class="keyword">for</span> chapter <span class="keyword">in</span> chapters:</span><br><span class="line">            task = asyncio.create_task(self.download(chapter[<span class="string">&#x27;url&#x27;</span>], chapter[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line">            tasks.append(task)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">self, url: <span class="built_in">str</span>, chapterName: <span class="built_in">str</span></span>):</span></span><br><span class="line">        url = Script.url + url</span><br><span class="line"></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=Script.headers) <span class="keyword">as</span> response:</span><br><span class="line">                content = <span class="keyword">await</span> response.text(encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">                html = etree.HTML(content)</span><br><span class="line">                text = html.xpath(<span class="string">&#x27;//div[@id=&quot;content&quot;]/text()&#x27;</span>)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;./斗破苍穹/<span class="subst">&#123;chapterName&#125;</span>.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(<span class="built_in">str</span>(text))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    Script()</span><br></pre></td></tr></table></figure><h2 id="selenium-使用"><a href="#selenium-使用" class="headerlink" title="selenium 使用"></a>selenium 使用</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Edge</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">browser = Edge() <span class="comment"># 创建浏览器对象</span></span><br><span class="line">browser.get(<span class="string">&quot;https://www.lagou.com/&quot;</span>) <span class="comment"># 访问目标网站</span></span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">browser.find_element_by_xpath(<span class="string">&quot;/html/body/div[10]/div[1]/div[2]/div[2]/div[1]/div/p[1]/a&quot;</span>).click() <span class="comment"># 定位并点击</span></span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># send_keys 进行键盘输入搜索内容和回车</span></span><br><span class="line">browser.find_element_by_xpath(<span class="string">&quot;/html/body/div[7]/div[1]/div[1]/div[1]/form/input[1]&quot;</span>).send_keys(<span class="string">&quot;Java&quot;</span>,Keys.ENTER)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 定位所有搜到的结果</span></span><br><span class="line">elements = browser.find_elements_by_xpath(<span class="string">&#x27;//*[@id=&quot;s_position_list&quot;]/ul/li&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开所有搜到的元素</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">    element.find_element_by_xpath(<span class="string">&#x27;./div[1]/div[1]/div[1]/a&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 获取搜到的内容，然后关闭页面</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">    browser.switch_to.window(browser.window_handles[-<span class="number">1</span>])</span><br><span class="line">    print(browser.find_element_by_xpath(<span class="string">&quot;/html/body/div[1]/div[1]/div[4]/div[1]/dl[1]/dd[2]/div&quot;</span>).text)</span><br><span class="line">    browser.close()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;regex-正则表达式&quot;&gt;&lt;a href=&quot;#regex-正则表达式&quot; class=&quot;headerlink&quot; title=&quot;regex 正则表达式&quot;&gt;&lt;/a&gt;regex 正则表达式&lt;/h2&gt;&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
    <category term="爬虫" scheme="https://xorex.space/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>为美好的世界献上祝福</title>
    <link href="https://xorex.space/2022/05/20/567f91f8bbba/"/>
    <id>https://xorex.space/2022/05/20/567f91f8bbba/</id>
    <published>2022-05-20T11:58:03.000Z</published>
    <updated>2021-06-05T16:47:14.015Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="012291ade27e2252807099f5458dffca8691af597c47118762b56028f94a1a98">8a972074cb8fb594adf191142c932486f63d9db6a4bbbbf65eb58b44e7f3a502ca39de9d3c1e3d9c70fdc9a01ad868dc3486910eced5f4e34f64df4c5155d0e28740e7f637329c5391f9bbe6ff64e653a789e2cef71c949e21aa63f2fba5c2f8909ab81d64320e8cb4384ed74fbebab2050cb82c4a7d22b4b9fd24d8a61fc8d8029f2ecbce16d7ac4071fe5c0ae2c3425b4c421b4a82a69b6012152d7d464a3624e786c960a03a52f9cd3453ffde3f9e7f7f8db1b21b9fd158b70d49126036880e6f581475aa1c9265c50093981c7c70663d0a1e3bede2870b4a7e0a6dc0d1a1ce8dbc658189e95bd6888f0f4d48bc8d7fa179df02ce8435ed223754c508e2b86eb7748ba754993eb71d24a37e5f551d0164956aa4d5dd5f723185894b6581fdc9638900b4666fa18e9bd6f6874b22c630932f62849d260f383329527390267e1ae61d8591c4aeb352f4b29108c2465a5e074d349edb5a9af79cb59ade636bb557cc6cdecd797157def65921204d200554354bc3d381c49d4097e92d1d51fd01c2313cff9d6502cf7e7f4b2399cc1e6be251d80c7050309bf346d386a7b536645f5c4c96178bc331da5740a42b0bd02b9968ce31b992b998e972e1dd06841a9d53b1d8280616027ac636ce646b67ae2c98a4b2ce990afefc45bd9b4d068c8fde09917cd2e84b9ffdf59606a1a60816d2f994703dfbbad7039e96e0b658292bacb1858ba7d9e49eb3187431fa4a1f8363915dc73aad3d519447f7cc0ff818de1453e2ab8257e0057131b57981825fc2c9f788e75c5564eb2ad8404bab6a82c47ab0a53249beb3b2306c2e5554ac2302070a4190176ddf1f1a7c9f4e483174777de2b527a91c806a1327390ff9a7eb985697c66546afc772628cec06b528dccdd1cb1d1d13ad8f74668fa5f5d0195cde6adade74f3ee1870b9a5da2542345b0f3ccb4e45aa3e4ca19ee469c348bc52b7c915f9fd94f14a9ce369c3d58e5c0e6550c9e6944437b122bacc312d2eaf41ec6165983d4afd819eb351ba8b730ee916f9cd78fef8008dcb9c56e63761799af98a3a7f796a1fa589fb9951d440a514e59ecf489a527c3a856fb48273361bc634d065d3e1833fc4a3b59e3f44008e8a1565a63506724732b84253673b58773214fb18c6f216ce7f94a3000979160f8fbe89f7300870c0103288288d986af8c35cf489154c5116b9e29ea3806b83fb4fb5c13bf5fac94b9fbb3d4dbc0a39cf185ce78c526bc7ed204162cdae47a4d016b2d81ea2ba9fc9830fb3527f1841ccf23061c0b80b53f3ae74c11c56b01d7711482081a2fcee250f16af2cb412ec812dc57d4d1d6985a692f17764a8bda6787d62fb8612eb25c70420071fd319dbc83c5d7f8ab892ebe088697c5f2833a61978a2b3c68e6916e569324b6bba4123401b6cccf173cb6f5f16b310bd23c631794739ed100cba1697a02e0cd558489edd5b9fb774265919385617ef45af3e351137e2be1db5a0dc536cc5ab5a80897d655a4da942de4a3fc9462a7d2eb6b49a288980210c8bf4649156b1e7d1f2c6e6eb1b8cb056067a2306541b7828ad3c48713b7ddcd33bdc4c83aec20ea2f4812ad03fedb8d33e6214f83ca38ffcbb55ca3859cd0cf07b65dd04174589117adf9d5c76448c6786447889122c612fb0ba366bfd64384a5162e27375fa7747622c6cf3b1c9c09bae41d179b1ac15d3cdd3254c2498e37f38e8b43b6620a7898afadb4e74414a7783ae2ffefd6aaac8cd082f33fa0abb3c8271690175664331e3053092c2b6abbf7e66adb0530ddde01a965e6abe809db7bd6d79229a09bd7df84c25da01c92e73a035e2667a75229c48e889842fbd0a1d7dbf7c579292b8557b8f400157e95b2864450dc73474ca6520544b623d98a0445e62a98d184853b6cf236e48ffe6ede26b4ca737f3f8c2f19701125867ec08135ca682b3cedc732362def3eefbf16d0327fedf680a5dc50bbb5590feeffc83a065c7c09fee680f2395508e418e59c28bcce45dcb357e95c2590a7ef9049d04d6bdbebce82c03d09be7d60c90ff409231a5b8df0091ede2ea2abe007dce72a5565fa7792a143ea45e0f14c3eed8ac989811cb44a0cb0fa483aa5f25831ccd3124d07a5558b126178f10f3600a554228513b55f48fdc6ca3d88c9a4203c3f729197919ecaff8376f9535fd87232cb896294f9fc4fdb1c094dc5b8c13fc9c0af0f6d5d0649aceb4beec719f7032a9d68ec16a1f386654f29e0adf7ade3d6d883067a74baa45dd07ca46c074be4a2d4d3cedd9cb43aa79ea8605e4a843d693cd9a062524820c3ae94cd3ba631d7d2c844b4cfd17570d07e02bb79c647880cb8f4a0614ff595bd22cff36fae33ba66ff6b9614ce43b5e2c2e2103b2a7c36dee450c0294e61645f1ff62b02acba1a876583591a53d9995c97318865eac82e9ab2d7daaee2edc69d2f6240b9cb98c8f3cc1c140d3ccfdb1894a3a9ae4db3704f4bef50c79ed660d72c4d76ca15c7b090c3a3ec8b6a1663e8ef6b80b33a790d75a8f2cab63863cfbab878fb45829ac4b30877f4b44ebb6fb1bd3deef6d4bb492d9e8dcd8f44dfda2afc59f9957524ddc5a9d26235be96e405f99fc668073799bfc29c611f3d097c9bef8404dfd98753bd059c4ccb2dc28284fa4d26f7388f29f063c5924d5d793e65af69eea2a654c3ca088ed576cea7a496de608c7fdc8adf94e22690d642584b9d121a80980bff1d66f2dbc7abf03c7272b4bd1f74df56756a806d0e76f293912b968b023f95efc0779c20497e818842577470c33cf1f1412cea0944a4fa2cd2a145d2a4dc588712f11729cb1233d6eabd234e0556425985afe3cf2518e4f70bbf31c038d5c335f500e0125cd3429ce768886381d9bf7fa0236a3449fd423c501be99daf36e54f58f09e63462c975afb417a015bd5f4a918f66f022aa79981cb82c29087351b1afe7b5051ad3712c3150e62f9d01f429d0b1050f348592d09d22cd5dc3409e3d11e7664dc114d8c37160b9d39f7d594813fd90cd23ac43c86cce7f22a0ecc46e9c77c1a1097fab3af5c9e0bbd893630d1db32066c3aeb8544e5a3b1e9f4905a3685a041e7921c29f7eb36041f276e3de9da457c90c0a4e9b1ec38db531d7887628745c5f26194ad2c2bc892a0e62a63be8e7162540b04696ee38d1ffa3deef3f110517e9813d259eb2617581819a50a37da390650ba8a86f576db6036fe772c8f8d2b15633f5d1905f11d452d62d67121d9a7d30cf26419c7100f2f51a3f0f8597048cda90b68b1b86116671fed5953d70fa552b04bcd54001afaaa291346a9eef0cb871f350a08a2e2ad3ead37fbe7af6c5ea3fbb4e2af874efb0d4f33d149f83b525500d0d106ae12249119307c0242bcfff7425822d2f61aae575154c5499f03b06da9bdfabf4707602c20b2eb9173a7f01dd7ea77e0b44303670982c11b53a5603e22cc74ca166846ef28697572ae88504db22754792584f45a2a559813081ab34c8641550dc1259ba7cc55de0d8ea0ae7ab83afc533113272ad893f0106a087e6bd0eb90c464eca576a7a217ef654ea365834f37076cec52bb40f7c2ec76ca2fdfd93511f3132b68d5279d42422d4562ad20cba8e76ddf4570fdeb4a0b1e63f2b87edf688afd4f51ae842b14864a528c57686385e5e763d175bf04d26ffd612a90f5d5ed0d49d6dbd4e472a192665afa263e1d9c2dfafb17858b59b5957992af881daf5231757ae0a3733d0e032415f2e6147113228b4c342045de3f73e08d00f893f7c05ab15b64603ef42b1e300b879fe6a8703d130048a0ef4c43a0f5aae256cfbd422f76818720e45572b16b6aae06c7c9a8a2be60d6bc205e8a0bccfea6660196c6ccb73571d9fce6aec0dbf9a211c12769ce9f1d4d2dcaccffc5049e92fc42abc59c6b952abf55ce944bd619f23f17700a194a95daeae67c69a289b48ac154619c185012cae1d913657e9fcc2ea89ededbd49813fddef2a842336a0a62385844b872a5c648b7ab23e2015579b053780d4c2fc01e621dfdb0f169723e26e319948f6355a3d52c26774488a5f43a1d574e80c78730f8b825210e3a93d5b904cd14d74f09255b74f5e5185d35713038bfecaff6c4cbc9c3e6b3638c64ed1af85cd0746586e41377fa167c73f22a605639878844d9a73dc5c244e02e359c3ae6cb62540b36a4b5e2150898258f2f86d881fb21d0e5c1c4e3552eb48159529396d53cc96ff48320c1406acc328fe9c1cddb62363481ed658ec32273b5f6149e80d7f111cad43e8f989c6f9609f194d18319b7932ce1854265e28c93ad307ee5f638c795b49f625b6783187862743df526a3da373e9e814846ea92343d3d5979772a38dec79be44317f0c75efadac03409fc473af07b7c47adb8170959bb5d20d41362e96ff110bbecd6edb3a7fef4bab4470423113aa367d0e8a2425c87bd98550ac0e7db65c9c7d32db12cff2bcfa81cda4e41d0b308f9578b4b1e5d5794d5ce80ad0ef7eed3cf3039f85c28d6fc247f3e04e4da416c126c6a7453431952565dbd973ceb410451246d221b4c4c59bb45dc1e8f01d15456e4bc59b26feee41aa8ef0356eab5d03e4a9cced9df106708a16de62ca4bf2d9ca503747ed9f4b6b664916a7bf851b7392e1e71ded53d2576c775e15be1a4502a80dd2f5c34808e17f642d8a987ec273b5d0868a114466b331e563ac674abec48fd6783c8624a06a92dc359b3efbc0e9c28aa832f4a61417ff2859ddbda7ccc5617d1a9d17ce2843ea48c7b5bddf9e2d79aeae9d844002cae5545cceded9192bb31c3b49b7723b30da30318015acd6f16cabae11f2f2d197f0b0097fe222019bd1e82d6fb82b1b7a240b0be445cef0404adc7c55a1ff0bf296c88b6be1ce1b0083dd453c5a91cf01c0abe097a59f9f5771310187ee251f978945d21311f01ed29eb1ded81deda69d472642b543e0e8bf92781a96f9e576e3172770483f69c15fea7ec986b796d1a5c1f0a08e96b1090dd9119f840d9c016ac32b8cf483f3986934121380be1af639c7efc0ce4f4429aa99eabaf015c4f81a232aa9d030faa9c401c118532146e91ea4ccb77bbe21995fcdb4f16409a41715920a010d8adbca438d7c94852563dc36af172bd19e552fe44a45222fc43fe10e7ba6d4d857156399cd143de7caaeb001e14fcb3d03be87ea1717c748bce8c47ad170f8170c159e37f533dc7f0415eeb55dd07c7c28b7358f4cf62b257b6e3d972ee8d75e04c673e0cd267ac89badebc34fa445f6cac623c9ee9447556c5149db450291ba01c3dc62ebc7661da869d3c7f23b853f29af418a41890aab8c1093ba44d46019deb75043ee8b76f9fc9fbd149ad4b72cec822e73c8d5c7facb05c8f3a404555c216f48bfb128c0db6910ed237c0cfeeafd9bc148bcdeca9af6de8d62812f53993ddff62692c29cf224805fe835a5a7d84d12a815dc39e5b3877bb7236ee2fdb537e4660065e7d618dfcc74bed3f384389b92c7e3a1165f2f309b6b8f0048c1ba81e4c7b4031797b70d94ba8b5efddc4a7cbac0e8e1f9d86c4557ba4052e512eb33accc086d66f1fa47f8a3295bb6a795b32019d8f6b6d3f51b0fb68f4b150f2456de87e6635257797d016f5b64cdfc6f6cf2b1f4721068f71a4a0e96f233727c52d07d9e4e2e107a429fd2ede833b47069a37c0ec9f18b4c0eedb8fec64123c2c4206873890b4ecd4ae8a3b8b9b5f7abee5669d3eb00227dcb00220692ff0c1f5077608540d88029e1afa1377566a1acbac99284cb80939462da62f5b120feac6bbea8e9ebf09d60a606b0fc7b8734f94c57564dda534e6c5690f3552b201b0abd5830ead08e1f9dd7acda727080546ee410682baa35b2ebca77b0ea3611f6d3f2c045e0cda86fb67db751b2f5853f2a5758d0e7fd46001e1b13491fc9afb3d1c4ae7d6c416294b782ab4fcbacb5d031696fc2d113f7cebc4909b4587f78fa79ee23e89f67cc0cf72ee71453c268afd41c7f77187f53210b67ea8971152da7484b1ae59fa6e261ec1c6d2ec5b28e6752b2ac303e06e84cb9b900f2c94aa4b04fa26614e5c987b4eb301e417e7b17d949ebd3198e186cd5f780769224afde5b9c7f62eb274bc08e8b1d7dec13353c8188bd13ac4201b1715ac5ab3e13359d3609d8788aec892f7c2c562d7fcf32fffe7cfda4546e0f2e87d9ad5d55d3764567f2c728a963aeec901999062c0d69e04de39c2404a63256eac80129a1cc4b60ffc6cb52c68c1c7296b80a7b8cf9d271d43a2f442c6d8e87586df80fa8950aa5d9c756b44e1387b49b0eaa8fd1dc130961edf11f5ab9a2d67df0352580b417ba413199f7895948c8fef806d1f4970f8f6c855a7dfb1444914cb4f8960fefcfd3232d43c663a3fc1b5c6fd75cccc1b931fc7d3cb67ea4f86a5b2c9faae0edb0c616016561d119a3545e3c623f4e05e48d0dad9561944355ef77fabaf956d8e49b4e457fd8ccbbccc04f85e3f305e4eb5762da81ca55ade45b448423cf9113a359897c20b979c3ae9856674811c382a96eb7b2e06c5e96e533a4a5230066346617a7878b0dc5e45cbff9e337c7d684c85e3a7e9778d830835efe5ccaa0a8ca539c43f19c812aefe5ae68f3dd645486fcbe07023c6179674c8db5c3b7fa7d87841c1f89531be56c7607212d49d338295e585f460b6cadc2a847c37d6475a479fbe5840095f08b11f63d0c026dc0b2ac1ad490ff4ab72e42aa9b1d82d013a93d74f13d3dda95480ad71846f5606022eff22e7fbf7cd2225ed25cbd99a08691ce9172f2f234a4ee8b222f9d267b771fa8a03dccf1ba76ea6b88ab74175463aee9e07bf8ed86656fd619f9eae521dbfc303015bc392fd7651a66beae8995c502d76802f36db66a7fbff7c2867c8b3d2ce2962819b1422dc4af4bbd597e4d41ae9a3c7f90b0882e3034087baf9f7463f24f6a6021dc87f029b884156d52d00f22f9cf5f9f79c75a78233dc9e8fb33d4cd7988972d5f5b3e855b5a694e5b7ffc104b6f1d133c523356588dea18e05c90e5bdd1188ff79411338edd8b6a4bae775aad5b46a9b8fa225a2ee0f7e896aa002edaaff9fbaeaa4647a7cb2bd87fbce5d687c637d8301977a2446c38997317a44a20323790b4c47fc1d20d485edd8025d0e38ce428aa61217535d61eb7508beefbf44c12906dc991164aead928a76c2139d1ecc006338942fedabd88d817ed1374d9408f0d7e9c9b153b78ee8bf11c79973ab0ffdf1889ee783f772c31f22904834f017396e2fe424ed661e2d830657f1840b68823ba664b759ef870346a976d6827e055b967121e04c7155ee6d806840c07eb2fcbd5c9d3403399c391e3b6d13d4e1f040c84d968652815eb3b68b8c4ba5b5a313dfec3e23b42cba8656bb78317b29b2223c3dd8c81a43eecfadb22a761b9f525b984d3ae8d76b82eb28fd9a1c99cada7ede3d865b3426f3551ff5cf839c29046090a012c55cfd25489ea537ac6d0aea2068646fcc3e69f020a43fd55626292a858547e642f8919e92879db7f3e7f1c0e69fbef1666cff1c690931edc3814cf2f9da28a2ef5cc52ab0c5871cb032317f0cbb3a9c70743764353fdbc4f6cd2a2647bc1d7350ffa256553bebe06b231e170aeac66005b397f14404f17122e08680bf7799911fd812a86cad8efcff3dedb676c696817798601521856d8c33f3f3e70ca27b724f1e0a4ae2f69d243b5902a8809d13225b3ada15aa4330edfe1c8c61dfe0860fe15c7c5aa0f682a3cbfc327006c471592c0537a94eee757b389e298200559c5e0d49cb63e4e7ad2ea90f8d84fef2abbdfca554fa789f3623479ee3feb7866d354a51bb13df5ca4a523540cb9bd56db70d109b2d370d238f4e5cc257b3058251dc51ab982a576afaf3c0e1f192204c8dd60a9f7c630a34733417c2613788e16c65bcf1a74ac07db97231840cf6459a0c50f008a917d3129ab14d4c3f64483c2fbf43259e32cb7a7f348be87f158ed3cee9c07d57e15c57b8fac1b574248041aed7f038209d84aaa7ffc73093da0985faba9c924cff4f4dd13b407a9b700bfb5b83b0c192b38b94397ab303903975150e869baa5ccad3980c2c49f178eef4d027459384d3db04c86e112081b3ee9100f8a5537f05e825f72b2635983a07628b7c64f609bbf814effac0c8e3affabae3a184140c9ce438832995d149e5a71b830cc85b9d1a05f8c9d7d8cb1d3599b70f374401f48e311b998761f04a86ab616f568f0ba25055eeda8abc956d0994a8900abd771ec09f0173b79b114ff3942c31ae35e180fd81403a65b78bfe4f283ae3cc2314dafcf6ccfba3d4faef814282a707c7641a52c44a810dbbb2a8193dbd80acee318dc23a0bee6993c3000643c92f7047c7e568b4f513ade16c814656ffa601b0f4016fa627c651ec17a811dba7890827e830f6581383679619e0519fbbe35f539d846cb6b8b6c897507377e9a0970470a332db20d332b9b354ec1848e5af4f2f8901d0b444a02968fa1008ebcacef9f74e05466f6dad1057783d7b41b27198a5a92b85e159e62ef1788c3194ed721561343acdc28d618a21b6eef3d7039e2b424238313e18b0e9d5db7d2c33cff01019df595234f5b9a59dc48e1f78e1515a890d5bdb48b06fc2f2ecccffed24457a665ecf5ea4a4755069b35a47d4656130b1bfe2864f9a14020d2c15b3fc96b1e04086bbe58632405ae35e3496bd26b6529ae54a0213e54aceccb50b3f072482a59eea0d188891fcd450e7c3b8e06a27d2e812a04b5031972e9f2978bb9e7a5a7e8eaeecf03874142f706e89496f30303f00e2bb344eb2187744bdb623c28b7ad1e0a2f5c5de9fb8356593fa6b6ffc38f6206684784130930b4955706d9bf72a263da5b3c2ac102296a4ee22a578f756e350e7b284bbaafd2558e4aaf3c48bfb6768cff257995c603e7a42a8fb073ae19684a3d8b02a29b5336dec5ceb62075cdf4fcb4682776063ddb29675ed1220b41a79129a7e39197a05f019d789855928493b68d49da88fd3534dd14acd0b2b66059f3f95704ecb70ca0a80feaac678da4e0e8578a1eb02272ff67723be9f7d1ba4700b41a3c343b01d078b2a0d7a223f1266b7fbe9d5cab2b2d9b22d7fea0cc49d840ed634da634debcd40a678d356d6ac86cd681e8409baf069c34db2e1a62fbd944c14bb508075b50574296ebd8bd20d91a6af4c6a68e461c8a0d05ac1dd548ef9b36c9345f3e22af88a373eae0379d2c4da76cc4af320b91bfe6ef761d97d2d40c89a0f1ef26519d0a8454d1349fd6c6f8779d680c927354fa65891a00fc250e4d219a79e3bf6fbc21623d8e49b27b879c6f514347bfda33b3956104a1dfbb9ab2b4a5e8ac8abc03f0ca9cd63ded0f465d9ead7f7e70807727926206116d2a5666cd5deb2594b7dc6130db3433440c0032ba37f95a8c4915aa579d1d0805df6bae00040c6176d0ec2ea295dbc7986f2a54f17d4e5a72f24349b547573e65bdf14bbc81baab93ac1af2a01cce39e26b746e45fe51fe75ddd0e94bcae51d5a13b6fbb262c0f3f4630e23b5ad4773842191acee9ddb0860d5c06748d15fe6669e19572e5d669fd9a09d931b0da2a9319efa6297fa99818e202fb14323cf5d76ba46d28da9398a0eb08bbe6d4e7df3fdec2ae6735e3476c89041aaa1c3280ff4126d34f7bc739b7325993efaef0048972cb9e5dab994e23a436a6c76ab94bdaa7b3668a20257f953a03b78b079e2e9bb4fbc532cc9cfe70ee2c63d84f95ed224cc987bcea8c88a279f5d0ff4843bfae36bf999d6fbeabb927514ce1579855375ba305622c182bd751674ce36f1b53c2aca735216a39f6c3e1312f9150194aa35c2f34e0858e2345d0e9d5f34594a3e8bd663c33ad8b40753e5c37403364046d973b108c00c4e52223513c6a54ad262c6f9fb591c7c73bba659bfce59db1ec63bf3e9a384081d7425d39e57f2b2d830cf3a4b1d9c0bd522c6f8e74dda4b4b5193dc17ca4db9c93e27c673b590c944e02896054e33fcd0d0460d7ef164adb03290385c17b505a79693a458f53b7291d644463e0e7ca3335c624301d7296a02134e212df19565adb90298bd7faf3b9293cccda7ecb1c7af0f2d55541f1e2fd7c01195f4cf90958553f7ed45b5cca6360712277f3bbec081740d391b6c42d123b3c68613958c0b12568cdd6c07d03bb0f6d849835e308d907821d05bc91cd8ac4f60ce17133051c552b43e7fa74d1f97db2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Encrypted</summary>
    
    
    
    <category term="阶段性总结" scheme="https://xorex.space/categories/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="幸福" scheme="https://xorex.space/tags/%E5%B9%B8%E7%A6%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python-疑问记录</title>
    <link href="https://xorex.space/2022/04/15/cee8a2fa2829/"/>
    <id>https://xorex.space/2022/04/15/cee8a2fa2829/</id>
    <published>2022-04-15T09:52:36.000Z</published>
    <updated>2022-04-15T09:55:01.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述符-和-property-实现原理"><a href="#描述符-和-property-实现原理" class="headerlink" title="描述符 和 property() 实现原理"></a>描述符 和 property() 实现原理</h2><ul><li><p>不理解为什么描述符是绑定在 <code>类属性</code> 上面。</p></li><li><p>类属性最初可以激活 getter 方法，但是无法激活 setter 方法</p></li><li><p>实例属性最初都可以激活 getter 和 setter</p></li><li><p>当对类属性进行赋值之后，描述符就失效了。应该是赋的值覆盖了绑定符地址。</p></li><li><p>一个类的多个实例，使用的描述符对象竟然是同一个？？？</p></li><li><p>猜测应该是通过实例属性保存 描述符 实例，然后对实例访问和赋值就是对描述符进行访问赋值，会激活特殊方法 <code>get</code> __set__，从而通过描述符来实现对属性访问的控制。</p></li></ul><hr><ul><li>property() 是如何实现方法绑定的？</li></ul><h2 id="Python-多继承-MRO"><a href="#Python-多继承-MRO" class="headerlink" title="Python 多继承 MRO"></a>Python 多继承 MRO</h2><ul><li><p>新式类的 MRO 计算方法，以及前几代的设计缺陷。</p></li><li><p>super() 的原理，以及下面的代码，为什么会输出两个 B。</p></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;A&quot;</span>,end=<span class="string">&quot; &quot;</span>)  </span><br><span class="line">        <span class="built_in">super</span>().__init__() <span class="comment"># 这里为什么调用的是 B 的构造方法  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;B&quot;</span>,end=<span class="string">&quot; &quot;</span>)  </span><br><span class="line">        <span class="built_in">super</span>().__init__()  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A,B</span>):</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;C&quot;</span>,end=<span class="string">&quot; &quot;</span>)  </span><br><span class="line">        A.__init__(self)  </span><br><span class="line">        B.__init__(self)  </span><br><span class="line">print(<span class="string">&quot;MRO:&quot;</span>,[x.__name__ <span class="keyword">for</span> x <span class="keyword">in</span> C.__mro__])  </span><br><span class="line">C()</span><br></pre></td></tr></table></figure><blockquote><p>别碰 多继承，会变得不幸 ……</p></blockquote><h2 id="property-实现原理"><a href="#property-实现原理" class="headerlink" title="property() 实现原理"></a>property() 实现原理</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述符-和-property-实现原理&quot;&gt;&lt;a href=&quot;#描述符-和-property-实现原理&quot; class=&quot;headerlink&quot; title=&quot;描述符 和 property() 实现原理&quot;&gt;&lt;/a&gt;描述符 和 property() 实现原理&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>爬虫-02-网易云</title>
    <link href="https://xorex.space/2022/02/10/b297398cf5ef/"/>
    <id>https://xorex.space/2022/02/10/b297398cf5ef/</id>
    <published>2022-02-10T09:27:39.000Z</published>
    <updated>2022-06-15T09:29:51.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>来爬网易云音乐的所有热评，输入歌曲 id ，输出热评。（网易系的 Web 爬取好像都是这个流程）</p><h2 id="请求接口"><a href="#请求接口" class="headerlink" title="请求接口"></a>请求接口</h2><p>通过 F12 查看到了热评查询接口：<code>https://music.163com/weapi/comment/resource/comments/get</code>，请求方式 POST。</p><p>但是请求接口的参数，被加了密：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">params:   </span><br><span class="line">AZmpF0q2Xd7XkTpxUoqAKAaTsvs28bvL09Jg1X5cYKpMxIcOpa48xqeAqVjqyummoOPGHVEnRafFSmhsIriymftVHdDhyeh2v+rgLGy7W4w7nWPSHSOEzhDNXPLVLJBrgrFJzl/zWUh1f50AwC+qkKa4Z8MvvFZMHAR1/1/aCYBIvsS0i6IAV1DgVLwGitM4r6jyPNVmKua240dgLSw7tIOqjFxeRXFC/ZXLM8SNzL2b19kdQk/moaSILa87zUKPaZZ1YyQb1ulEPU+4MmqW3maGxqAX92LLA2I0voz4JA0=  </span><br><span class="line"></span><br><span class="line">encSecKey: 27f97b1ce8c6a382428151cea84d9a37cdcce637e83c7dd264b3977ab46c6065e9e226c40c8abe8fa7e1344a46c843f5140be441b87b2a423b476346a43ac996445e5b66d916c93f2d2e204a2ee61625e1ee98dea7674a3e4c16f30eaafa6afefc8f0af88e78f6ad71d07635685250091aaa7b19b41ca36a6c47ede90aeaad59</span><br></pre></td></tr></table></figure><p>所以我们要破解整套加密系统，实现手动构造请求参数并加密。过程很简单，找到加密的函数，查看加密前的参数格式，和加密的过程。</p><h2 id="定位请求发送函数"><a href="#定位请求发送函数" class="headerlink" title="定位请求发送函数"></a>定位请求发送函数</h2><p>首先从本次请求发起程序的调用栈的最顶层开始，一级一级回溯，注意看 params 是否被加密。</p><p><img src="https://xorex.space/image/340.jpg" alt="340.jpg"></p><p>在网络一栏下面的第一个调用函数，就是执行发送请求的函数，打上断点，观察局部变量，不停的放请求，直到从局部变量的 url 里面看到是我们要找的请求，再停下来开始分析本次请求的函数调用栈。</p><p><img src="https://xorex.space/image/341.jpg" alt="341.jpg"></p><p>这个时候就可以看到，这个发送函数的调用栈，已经和我们在 网络 一栏看到的请求调用栈是一样的了。</p><p>然后我们根据这个请求的调用栈，依次去找执行加密的函数。</p><h2 id="定位加密函数"><a href="#定位加密函数" class="headerlink" title="定位加密函数"></a>定位加密函数</h2><p>依次回溯调用栈，观察局部变量的 param，找到数据没加密状态的函数：</p><p><img src="https://xorex.space/image/342.jpg" alt="342.jpg"></p><p>成功找到，证明就是在 be8W() 中完成了加密。</p><p>然后在这个函数内打断点，一步一步执行，观察局部变量，继续跟踪具体执行加密的函数。</p><p>发现是一开始就将上图参数转化为了字符串，然后在 windows.asrsea() 中完成了对参数字符串的加密。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">a</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> d, e, b = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span>, c = <span class="string">&quot;&quot;</span>;  </span><br><span class="line">        <span class="keyword">for</span> (d = <span class="number">0</span>; a &gt; d; d += <span class="number">1</span>)  </span><br><span class="line">            e = <span class="built_in">Math</span>.random() * b.length,  </span><br><span class="line">            e = <span class="built_in">Math</span>.floor(e),  </span><br><span class="line">            c += b.charAt(e);  </span><br><span class="line">        <span class="keyword">return</span> c  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">a, b</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> c = CryptoJS.enc.Utf8.parse(b)  </span><br><span class="line">          , d = CryptoJS.enc.Utf8.parse(<span class="string">&quot;0102030405060708&quot;</span>)  </span><br><span class="line">          , e = CryptoJS.enc.Utf8.parse(a)  </span><br><span class="line">          , f = CryptoJS.AES.encrypt(e, c, &#123;  </span><br><span class="line">            iv: d,  </span><br><span class="line">            mode: CryptoJS.mode.CBC  </span><br><span class="line">        &#125;);  </span><br><span class="line">        <span class="keyword">return</span> f.toString()  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">a, b, c</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> d, e;  </span><br><span class="line">        <span class="keyword">return</span> setMaxDigits(<span class="number">131</span>),  </span><br><span class="line">        d = <span class="keyword">new</span> RSAKeyPair(b,<span class="string">&quot;&quot;</span>,c),  </span><br><span class="line">        e = encryptedString(d, a)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params">d, e, f, g</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> h = &#123;&#125;  </span><br><span class="line">          , i = a(<span class="number">16</span>);  </span><br><span class="line">        <span class="keyword">return</span> h.encText = b(d, g),  </span><br><span class="line">        h.encText = b(h.encText, i),  </span><br><span class="line">        h.encSecKey = c(i, e, f),  </span><br><span class="line">        h  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">a, b, d, e</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> f = &#123;&#125;;  </span><br><span class="line">        <span class="keyword">return</span> f.encText = c(a + e, b, d),  </span><br><span class="line">        f  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">window</span>.asrsea = d,  </span><br><span class="line">    <span class="built_in">window</span>.ecnonasr = e  </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>开始分析 window.asrsea() 的执行过程。</p><h2 id="解析加密函数"><a href="#解析加密函数" class="headerlink" title="解析加密函数"></a>解析加密函数</h2><p>首先需要明确 window.asrsea() 被调用的时候，填入的参数为：</p><p><code>JSON.stringify(i7b), bsR1x([&quot;流泪&quot;, &quot;强&quot;]), bsR1x(Xp4t.md), bsR1x([&quot;爱心&quot;, &quot;女孩&quot;, &quot;惊恐&quot;, &quot;大笑&quot;])</code></p><p>里面只有 i7b 是变量，是我们要加密的参数，被从 JSON 对象转化为了字符串，其他部分都是不变的常量。</p><p>然后去看 window.asrsea() 的具体代码，可以看到这个代码实际上就是函数 d （<code>window.asrsea = d,</code>）</p><p>那就从 d() 入手，先调用了 a(16) 保存为 i。经过阅读发现，a() 函数输入一个长度数字，返回一个对应长度的随机数。因此这个东西可以保留不变，因此现在不变的参数我们都能获得了，也就是 i e f g：</p><p><img src="https://xorex.space/image/343.jpg" alt="343.jpg"></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e: &quot;010001&quot;  </span><br><span class="line">f: &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot;  </span><br><span class="line">g: &quot;0CoJUm6Qyw8W8jud&quot;  </span><br><span class="line">i: &quot;xGsMkCrcKlP3OnHT&quot;</span><br></pre></td></tr></table></figure><p>上面的 g 和 i 都是 16字节，128 位的密钥。</p><p>接下来，就是获取加密 param 的过程，也就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h.encText = b(d, g)  </span><br><span class="line">h.encText = b(h.encText, i)</span><br></pre></td></tr></table></figure><p>分析 b，发现就是就是将输入的两个参数 var1 var2，执行 AES 加密，并返回结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AES.encrypt(var1, var2, &#123;  </span><br><span class="line">    iv: <span class="string">&quot;0102030405060708&quot;</span>,  </span><br><span class="line">    mode: CryptoJS.mode.CBC   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>查一查这个函数的文档， var1 是明文，var2 是密钥，后面的字典 iv 是偏移量，mode 是 CBC 加密模式。我们就可以用 Python 的 AES 加密模块模拟两次这个过程，获取请求的加密结果 encText。需要注意的是，最后加密完，调用加密结果的 toString() 的时候，使用的是 Base64 编码（这里需要看在创建 AES 对象的时候，传入的 format 对象的 stringify 指定使用 CryptoJS.enc.Base64），所以我们也要进行 base64 编码之后输出。</p><p>然后再来看 encSecKey 的获取，发现函数输入的三个数都是前面的常数字符串，并且里面没有用到随机数，这意味着我们确定了输入参数，就确定了结果。于是就也直接用现成它计算好的了，直接从内存中复制：</p><p>encSecKey = “54af20a9dcdc7522eac4be5f10fb17c534c8feb59b7117138afc3852dbcddaa4b2f54bce5b1b8a489f059be6b680a31d582f4f68c82d5ab9ebf0b6591a6c0d42718dc363daf643aa17f4aa44667a4d327402f7ec01b1d7ca1d7960aa48a5828ccb8532dbdc6ac1dd1d373a4d4b77418a1fd05377b4e0fbb34e4a772f61d1e839”</p><p>好了，现在我们 encSeckey 直接拿到了，encText 也知道了该如何加密，可以写 Python 脚本了。</p><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><h3 id="填充方式"><a href="#填充方式" class="headerlink" title="填充方式"></a>填充方式</h3><p>从里面的两次 AES 加密可以看出来，使用的是 128bit 加密。因为 AES 是对明文进行分块，所以也要求明文长度要是 128bit 的整数倍，所以需要对明文进行补齐，默认使用的是 PKCS5Padding 填充方式。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PKCS5Padding：如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。  </span><br><span class="line">比如明文：&#123;1,2,3,4,5,a,b,c,d,e&#125;,缺少6个字节，则补全为&#123;1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6&#125;</span><br></pre></td></tr></table></figure><h3 id="CBC-模式"><a href="#CBC-模式" class="headerlink" title="CBC 模式"></a>CBC 模式</h3><p>CBC模式（Cipher Block Chaining）引入了一个新的概念：初始向量IV（Initialization Vector）。</p><p>IV是做什么用的呢？它的作用和MD5的加盐有些类似，目的是防止同样的明文块始终加密成同样的密文块。</p><p><img src="https://xorex.space/image/344.jpg" alt="344.jpg"></p><p>从图中可以看出，CBC模式在每一个明文块加密前会让明文块和一个值先做异或操作。IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它前一个明文块所加密出的密文块相异或。</p><p>这样以来，相同的明文块加密出的密文块显然是不一样的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>今天太晚了，就去睡觉了，今天早上起来再把这个爬虫做一个终极版本，做一个像下面一样的网易云终极无敌操作器。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent  </span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64  </span><br><span class="line"><span class="keyword">import</span> requests, pprint,json  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WangYiYun</span>():</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        self.params = <span class="string">&quot;&quot;</span>  </span><br><span class="line">        self._i = <span class="string">&quot;l6Brr86UeZ6C3Bsw&quot;</span> <span class="comment"># 默认使用此字符串  </span></span><br><span class="line">        <span class="comment"># 使用默认_i 配套的encSecKey  </span></span><br><span class="line">        self.encSecKey = <span class="string">&quot;7ca9b5ba8b13044f47ed74c388df912ac84758122acbedc64111f2ac83232b01d3ce16f7195a39c7e064b4c0240b5c1d52624dc13c22ec820d76dfe32db43e496aeacced5be3ca9108c78a85bb389f1edf8d8c9fced02024ba9490401b4ce062cc50764d0a24294e07bb229271391b5a3640e924ee1ed15435dc6e288f1fa873&quot;</span>  </span><br><span class="line">        self.headers =  &#123;  </span><br><span class="line">            <span class="string">&#x27;authority&#x27;</span>: <span class="string">&#x27;music.163.com&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;user-agent&#x27;</span>: UserAgent().random,  </span><br><span class="line">            <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;accept&#x27;</span>: <span class="string">&#x27;*/*&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;origin&#x27;</span>: <span class="string">&#x27;https://music.163.com&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;sec-fetch-site&#x27;</span>: <span class="string">&#x27;same-origin&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;sec-fetch-mode&#x27;</span>: <span class="string">&#x27;cors&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;sec-fetch-dest&#x27;</span>: <span class="string">&#x27;empty&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;referer&#x27;</span>: <span class="string">&#x27;https://music.163.com/song?id=1426301364&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;accept-language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;cookie&#x27;</span>: <span class="string">&#x27;_iuqxldmzr_=32; _ntes_nnid=5f8ee04e745645d13d3f711c76769afe,1593048942478; _ntes_nuid=5f8ee04e745645d13d3f711c76769afe; WM_TID=XqvK2%2FtWaSBEUBRBEEN7XejGE%2FL0h6Vq; WM_NI=iN6dugAs39cIm2K2R9ox28GszTm5oRjcvJCcyIuaI1dccEVSjaHEwhc8FuERfkh3s%2FFP0zniMA5P4vqS4H3TJKdQofPqezDPP4IR5ApTjuqeNIJNZkCvHMSY6TtEkCZUS3k%3D; WM_NIKE=9ca17ae2e6ffcda170e2e6eeb2e57dbababf88b879a8b08fa2d84f869f9fbaaa50a3f599a5d650939b8dadd52af0fea7c3b92aab92fa85f86d83adfddae243afee85d3d133ada8fed9c679ba8ca3d6ee5aaabdbaabc269bb97bb82cc3ba8bdada6d559aabf88a6f664a1e88a96c85aa6b5a8d4f2258690009bed638f9ffbb1b77eb38dfca9b2608a95acb2ee6e94afab9bc75c94ec87b3b84bb48ca696f46f8e9786afd96181aa88aed253f68cbca6ea499a8b9dd4ea37e2a3; JSESSIONID-WYYY=tI8MIKMCRBuyCYnUJMCyUTlp%2Fufv5xIfCquvp7PJ4%2BuXod%5CXH%5CB0icDZw8TNlwHUHOW%2B2t%2BCuXyC4VZ%5C19OrzaDE%5Ck0F0dAZQh7KcVxUoHKpqUdiVzPu8NxCK9cJRG%5C%5CPTvtqxjFerd1%2BBa4%2F%5C8PESa4pvvRaQF6jljjsibX%5CrcPsH0I%3A1593347447142&#x27;</span>,  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 搜索歌曲接口  </span></span><br><span class="line">    API_Serch_Songs = <span class="string">&#x27;https://music.163.com/weapi/cloudsearch/get/web?csrf_token=&#x27;</span>  </span><br><span class="line">    <span class="comment"># 歌曲评论  </span></span><br><span class="line">    API_Comments_Song = <span class="string">&#x27;https://music.163.com/weapi/v1/resource/comments/R_SO_4_&#123;&#125;?csrf_token=&#x27;</span> <span class="comment"># 音乐ID可替换  </span></span><br><span class="line">    <span class="comment"># 歌曲歌词  </span></span><br><span class="line">    API_Lyric_Songs = <span class="string">&#x27;https://music.163.com/weapi/song/lyric?csrf_token=&#x27;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># crypt_js_complex python 复写cryptjs  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crypt_js_complex</span>(<span class="params">self,text</span>):</span>  </span><br><span class="line">        BS = AES.block_size  </span><br><span class="line">        pad = <span class="keyword">lambda</span> s: s + (BS - <span class="built_in">len</span>(s) % BS) * <span class="built_in">chr</span>(BS - <span class="built_in">len</span>(s) % BS).encode(<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line">        unpad = <span class="keyword">lambda</span> s: s[<span class="number">0</span>:-s[-<span class="number">1</span>]]  </span><br><span class="line"></span><br><span class="line">        key = <span class="built_in">bytes</span>(self._i, encoding=<span class="string">&quot;utf-8&quot;</span>)  </span><br><span class="line">        text = text.encode(<span class="string">&quot;utf-8&quot;</span>)  </span><br><span class="line">        IV = <span class="string">b&#x27;0102030405060708&#x27;</span>  </span><br><span class="line"></span><br><span class="line">        cipher = AES.new(key, mode=AES.MODE_CBC, IV=IV)  </span><br><span class="line">        <span class="comment"># cipher2 = AES.new(key, mode=AES.MODE_CBC, IV=IV)  # 加密和解密，cipher对象只能用一次  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(text)  </span></span><br><span class="line">        encrypted = pad(text)  </span><br><span class="line">        <span class="comment"># print(encrypted)  </span></span><br><span class="line">        encrypted = cipher.encrypt(encrypted)  </span><br><span class="line">        <span class="comment"># print(encrypted)  </span></span><br><span class="line">        encrypted = base64.b64encode(encrypted).decode(<span class="string">&quot;utf-8&quot;</span>)  </span><br><span class="line">        <span class="comment"># print(&quot;第二次加密结果&quot;, encrypted)  </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> encrypted  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># crypt_js_complex 的基础  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crypt_js_complex_base</span>(<span class="params">self,text</span>):</span>  </span><br><span class="line">        BS = AES.block_size  </span><br><span class="line">        pad = <span class="keyword">lambda</span> s: s + (BS - <span class="built_in">len</span>(s) % BS) * <span class="built_in">chr</span>(BS - <span class="built_in">len</span>(s) % BS).encode(<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line">        unpad = <span class="keyword">lambda</span> s: s[<span class="number">0</span>:-s[-<span class="number">1</span>]]  </span><br><span class="line"></span><br><span class="line">        key = <span class="string">b&#x27;0CoJUm6Qyw8W8jud&#x27;</span>  </span><br><span class="line">        text = text.encode(<span class="string">&quot;utf-8&quot;</span>)  </span><br><span class="line">        IV = <span class="string">b&#x27;0102030405060708&#x27;</span>  </span><br><span class="line"></span><br><span class="line">        cipher = AES.new(key, mode=AES.MODE_CBC, IV=IV)  </span><br><span class="line">        <span class="comment"># cipher2 = AES.new(key, mode=AES.MODE_CBC, IV=IV)  # 加密和解密，cipher对象只能用一次  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(text)  </span></span><br><span class="line">        encrypted = pad(text)  </span><br><span class="line">        <span class="comment"># print(encrypted)  </span></span><br><span class="line">        encrypted = cipher.encrypt(encrypted)  </span><br><span class="line">        <span class="comment"># print(encrypted)  </span></span><br><span class="line">        encrypted = base64.b64encode(encrypted).decode(<span class="string">&quot;utf-8&quot;</span>)  </span><br><span class="line">        <span class="comment"># print(&quot;第一次加密结果&quot;, encrypted)  </span></span><br><span class="line">        <span class="keyword">return</span> encrypted  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得parms参数值  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_params</span>(<span class="params">self,text</span>):</span>  </span><br><span class="line">        <span class="keyword">return</span> self.crypt_js_complex(  </span><br><span class="line">            self.crypt_js_complex_base(text),)  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 搜索歌曲接口  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serch_songs</span>(<span class="params">self,name,offset=<span class="number">0</span></span>):</span>  </span><br><span class="line">        <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name:str  </span></span><br><span class="line"><span class="string">        :param offset:int 偏移量 默认第一页 例如 0 30 60 90  </span></span><br><span class="line"><span class="string">        :return 接口数据  </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>  </span><br><span class="line">        text = <span class="string">&#x27;&#123;&quot;hlpretag&quot;:&quot;&lt;span class=\\&quot;s-fc7\\&quot;&gt;&quot;,&quot;hlposttag&quot;:&quot;&lt;/span&gt;&quot;,&quot;#/discover&quot;:&quot;&quot;,&quot;s&quot;:&quot;%s&quot;,&quot;type&quot;:&quot;1&quot;,&quot;offset&quot;:&quot;%s&quot;,&quot;total&quot;:&quot;false&quot;,&quot;limit&quot;:&quot;30&quot;,&quot;csrf_token&quot;:&quot;&quot;&#125;&#x27;</span>%(name,offset*<span class="number">30</span>)  </span><br><span class="line">        <span class="comment"># payload = &#x27;params=&#123;params&#125;&amp;encSecKey=&#123;encSecKey&#125;&#x27;.format(params=self.get_params(text),encSecKey=self.encSecKey)  </span></span><br><span class="line"></span><br><span class="line">        params = (  </span><br><span class="line">            (<span class="string">&#x27;csrf_token&#x27;</span>, <span class="string">&#x27;&#x27;</span>),  </span><br><span class="line">        )  </span><br><span class="line"></span><br><span class="line">        data = &#123;  </span><br><span class="line">            <span class="string">&#x27;params&#x27;</span>: self.get_params(text),  </span><br><span class="line">            <span class="string">&#x27;encSecKey&#x27;</span>: self.encSecKey  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        response = requests.post(self.API_Serch_Songs, headers=self.headers, params=params,  </span><br><span class="line">                                 data=data)  </span><br><span class="line">        self._dispose(json.loads(response.text))  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 歌曲评论抓取  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">comment_song</span>(<span class="params">self,songid:<span class="built_in">str</span>,offset:<span class="built_in">int</span>=<span class="number">0</span></span>):</span>  </span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">        :param str 歌曲ID  </span></span><br><span class="line"><span class="string">        :param int 翻页 默认第一页 0 20 40  </span></span><br><span class="line"><span class="string">        :return 接口数据  </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>  </span><br><span class="line">        text = <span class="string">&#x27;&#123;&quot;rid&quot;:&quot;R_SO_4_%s&quot;,&quot;offset&quot;:&quot;%s&quot;,&quot;total&quot;:&quot;true&quot;,&quot;limit&quot;:&quot;20&quot;,&quot;csrf_token&quot;:&quot;&quot;&#125;&#x27;</span>%(songid,offset*<span class="number">20</span>)  </span><br><span class="line"></span><br><span class="line">        params = (  </span><br><span class="line">            (<span class="string">&#x27;csrf_token&#x27;</span>, <span class="string">&#x27;&#x27;</span>),  </span><br><span class="line">        )  </span><br><span class="line"></span><br><span class="line">        data = &#123;  </span><br><span class="line">            <span class="string">&#x27;params&#x27;</span>: self.get_params(text),  </span><br><span class="line">            <span class="string">&#x27;encSecKey&#x27;</span>: self.encSecKey  </span><br><span class="line">        &#125;  </span><br><span class="line">        response = requests.post(self.API_Comments_Song.<span class="built_in">format</span>(songid), headers=self.headers,  </span><br><span class="line">                                 params=params, data=data)  </span><br><span class="line">        self._dispose(json.loads(response.text))  </span><br><span class="line">    <span class="comment"># 歌词爬取  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lyric_song</span>(<span class="params">self,songid:<span class="built_in">str</span></span>):</span>  </span><br><span class="line">        <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">        :param songid str 歌曲ID  </span></span><br><span class="line"><span class="string">        :return 接口数据  </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>  </span><br><span class="line">        <span class="comment"># 歌词接口加密参数原型  </span></span><br><span class="line">        text = <span class="string">&#x27;&#123;&quot;id&quot;:&quot;%s&quot;,&quot;lv&quot;:-1,&quot;tv&quot;:-1,&quot;csrf_token&quot;:&quot;&quot;&#125;&#x27;</span>%(songid)  </span><br><span class="line"></span><br><span class="line">        params = (  </span><br><span class="line">            (<span class="string">&#x27;csrf_token&#x27;</span>, <span class="string">&#x27;&#x27;</span>),  </span><br><span class="line">        )  </span><br><span class="line"></span><br><span class="line">        data = &#123;  </span><br><span class="line">            <span class="string">&#x27;params&#x27;</span>: self.get_params(text),  </span><br><span class="line">            <span class="string">&#x27;encSecKey&#x27;</span>: self.encSecKey  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        response = requests.post(self.API_Lyric_Songs, headers=self.headers, params=params, data=data)  </span><br><span class="line">        self._dispose(json.loads(response.text))  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理爬虫获取到的数据，这里我就输出值  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dispose</span>(<span class="params">self, data</span>):</span>  </span><br><span class="line">        pprint.pprint(data)  </span><br><span class="line">        <span class="keyword">return</span> data  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主函数 测试  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wangyi_main</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        <span class="comment"># 搜索接口  </span></span><br><span class="line">        <span class="comment"># self.serch_songs(&quot;旧账&quot;,0)  </span></span><br><span class="line">        <span class="comment">#歌曲评论接口  </span></span><br><span class="line">        self.comment_song(<span class="string">&quot;25639331&quot;</span>,<span class="number">0</span>)  </span><br><span class="line">        <span class="comment"># 歌词接口  </span></span><br><span class="line">        <span class="comment"># self.lyric_song(&quot;1351615757&quot;) # 旧账  </span></span><br><span class="line">        <span class="keyword">pass</span>  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    wangyi = WangYiYun()  </span><br><span class="line">    wangyi.wangyi_main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;p&gt;来爬网易云音乐的所有热评，输入歌曲 id ，输出热评。（网易系的 Web 爬取好像都是这个流程）&lt;/p&gt;
&lt;h2 id=&quot;请求接口&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
    <category term="爬虫" scheme="https://xorex.space/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬虫-01-基本技术</title>
    <link href="https://xorex.space/2022/01/28/0f5a6af58eaf/"/>
    <id>https://xorex.space/2022/01/28/0f5a6af58eaf/</id>
    <published>2022-01-28T09:18:27.000Z</published>
    <updated>2022-06-17T12:40:45.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="requests-请求库"><a href="#requests-请求库" class="headerlink" title="requests 请求库"></a>requests 请求库</h2><h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><p>requests 可以发起 get post put delete head options patch 这些请求。</p><p>参数可以携带：</p><ol><li> url 请求地址</li><li> params 拼接链接的请求参数 get</li><li> datas 正文的请求参数 post</li><li> headers 请求头内容</li><li> verify 是否 https 验证，有 True 和 False 两个值</li></ol><h3 id="获取返回内容"><a href="#获取返回内容" class="headerlink" title="获取返回内容"></a>获取返回内容</h3><hr><p>通过 request 提供的各种请求方法，返回一个 响应对象 response。</p><ul><li><p>response.text 返回 unicode 的 string 对象的相应内容。</p></li><li><p>response.content 返回 二进制 的相应内容。</p></li></ul><p>一定要记得根据编码格式，设置 response.encode = “XXX” 不然返回内容会解析错误。</p><hr><p>如果返回的是 json 数据，则调用响应对象的 json() 将其转化为 Python 的 dic 对象。</p><h3 id="Session-会话"><a href="#Session-会话" class="headerlink" title="Session 会话"></a>Session 会话</h3><p>这里是模拟自动处理响应和请求的 Cookie 处理，在所属于的 Session 会话中，每一次请求都会带上以前保留下来的 Cookie！</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session = requests.session()</span><br><span class="line">session.get(url)</span><br></pre></td></tr></table></figure><h3 id="Proxies-代理"><a href="#Proxies-代理" class="headerlink" title="Proxies 代理"></a>Proxies 代理</h3><p>Reqeusts 只支持 http 和 https 两个代理，访问的 url 是哪种链接，就匹配哪种代理。目前不支持代理池，需要自己找开源的。</p><p>http 访问可以用 https 的代理，反之不可以。</p><p>设置字典，然后请求的时候带上去就可以了：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxies = &#123;  </span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>:<span class="string">&quot;http://61.133.87.228:55443&quot;</span></span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>:<span class="string">&quot;https://124.64.8.50:8000&quot;</span></span><br><span class="line">&#125;  </span><br><span class="line">request.get(url,proxies=proxies)</span><br></pre></td></tr></table></figure><h2 id="re-正则"><a href="#re-正则" class="headerlink" title="re 正则"></a>re 正则</h2><h3 id="raw-string"><a href="#raw-string" class="headerlink" title="raw string"></a>raw string</h3><p>rstring 表示 raw string 原始字符串，表示这个字符串自动忽略所有的转义符号。常用在正则表达式字符串中，用来忽略 <code>\w</code> <code>\d</code> 这些匹配符号的转义。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">regex = <span class="string">r&quot;^[0-5][a-z].*?\\w+\\d+$&quot;</span>  </span><br><span class="line"></span><br><span class="line">result = re.<span class="built_in">compile</span>(regex)</span><br></pre></td></tr></table></figure><h3 id="re-常用"><a href="#re-常用" class="headerlink" title="re 常用"></a>re 常用</h3><p>注意下面所有的函数，除了输入正则字符串和被匹配字符串以外，还有一个可选参数 flags，多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：</p><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>re.I</td><td>使匹配对大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别（locale-aware）匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.S</td><td>使 . 匹配包括 <strong>换行</strong> 在内的所有字符</td></tr><tr><td>re.U</td><td>根据 Unicode 字符集解析字符。这个标志影响 \w, \W, \b, \B.</td></tr><tr><td>re.X</td><td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td></tr></tbody></table><p>一般来说，上面最常用的就是 re.S 来让 <code>.</code> 匹配更加强大。</p><ul><li><p>re.compile() 预编译正则表达式，返回的对象是编译完成对象，调用下面只需要输入被匹配字符串即可。</p></li><li><p>re.findall() 返回一个匹配的 list</p></li><li><p>re.finditer() 返回一个匹配的迭代器，迭代器内对象为 match，通过的 group() 获取实例，效率高于 list。</p></li><li><p>re.search() 检索第一个符合匹配的，以 match 对象返回。</p></li></ul><h3 id="group-分组"><a href="#group-分组" class="headerlink" title="group() 分组"></a>group() 分组</h3><p>对于 re.finditer() 的优势中，除了比 list 性能更强以外，还可以对捕获的数据进行分组操作。</p><p>正则表达式中 <code>(.*?)</code> 这样的括号用于捕获符合括号里面匹配的内容，我们也可以对捕获的内容进行分类，方法就是添加分类的 group 标签 <code>(?P&lt;name&gt;RegEx)</code> 为符合正则表达式 RegEx 的文本进行分组命名为 name ：</p><p>然后通过返回的 iter 对象的 <code>group(&#39;name&#39;)</code> 返回对应分组的数据，或者 <code>groupdict()</code> 以字典的形式返回本次匹配的所有分组数据。</p><h2 id="BS4"><a href="#BS4" class="headerlink" title="BS4"></a>BS4</h2><p>BeautifulSoup4 一种基于 html 代码分析解析的库。推荐用于定位大量标签类相同的数据获取。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先将响应的 html 页面交给 BeautifulSoup，并告诉它使用 html 解析器：  </span></span><br><span class="line">bs = BeautifulSoup(response,<span class="string">&quot;html.parser&quot;</span>) <span class="comment"># parser 解析器  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后返回的就是一个解析了 HTML 的 DOM 对象，可以通过 find() find_all() 查找更小的 DOM 对象  </span></span><br><span class="line"><span class="comment"># 第一个参数是标签名，后面可以跟着 属性名=值 来进行定位。  </span></span><br><span class="line"><span class="comment"># 注意所有和 Python 关键字重合的，后面都加上 _ 来规避  </span></span><br><span class="line">bs.find(<span class="string">&quot;div&quot;</span>,class_=<span class="string">&quot;pic&quot;</span>) <span class="comment"># 返回第一个符合的 DOM 对象  </span></span><br><span class="line">bs.find_all() <span class="comment"># 返回所有符合的 DOM list  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 精准定位 DOM 之后，可以用 get(&#x27;class&#x27;) 来获取属性值，用 .text 获取标签内容。  </span></span><br><span class="line">name = bs.text  </span><br><span class="line">class_ = bs.get(<span class="string">&#x27;class&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>这个用来定位唯一的元素非常方便，这里使用 lxml 中的 etree （element tree） 来解析：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.HTML(<span class="string">&#x27;&#x27;</span>) <span class="comment"># 输入 HTML 字符串进行解析</span></span><br><span class="line">html = etree.parse(<span class="string">&#x27;&#x27;</span>) <span class="comment"># 输入文件路径 URL，file 实例等解析为 DOM 对象</span></span><br><span class="line"></span><br><span class="line">html.xpath(<span class="string">&#x27;xxxxx&#x27;</span>) <span class="comment"># 进行进一步的 xpath 格式匹配，返回还是 DOM 对象</span></span><br></pre></td></tr></table></figure><h3 id="XPath-语法"><a href="#XPath-语法" class="headerlink" title="XPath 语法"></a>XPath 语法</h3><p>最简单的 XPath 是根据层次路径的元素名进行匹配的，如果有多个匹配的路径，就会全部被匹配，返回一个可迭代对象。</p><p>相同名称多个节点，可以用添加条件加以限制：</p><ul><li><code>div[2]</code> 来匹配第三个节点。</li><li><code>div[@class=&#39;click_to_sleep&#39;]</code> 和 <code>div[@id=&#39;catalina&#39;]</code> 来指定 div 元素的 class 和 id 属性值。</li></ul><hr><p>通过 xpath 不停的精确匹配，可以用 <code>./</code> 表示当前 DOM 节点。</p><hr><p>要获取 DOM 节点内容，匹配到节点之后，下一步用 <code>/text()</code>，返回字符串。</p><p>要获取 DOM 的属性值，匹配到节点之后，下一步用 <code>/@class</code>，返回属性 class 的字符串值。</p><h2 id="异步加速"><a href="#异步加速" class="headerlink" title="异步加速"></a>异步加速</h2><h3 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h3><p>见文章：Python-08</p><h3 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=Script.headers) <span class="keyword">as</span> response:</span><br><span class="line">        content = <span class="keyword">await</span> response.text(encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">        content = <span class="keyword">await</span> response.json()</span><br></pre></td></tr></table></figure><h3 id="aiofiles"><a href="#aiofiles" class="headerlink" title="aiofiles"></a>aiofiles</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(fileName, mode=<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">await</span> f.write(text)</span><br></pre></td></tr></table></figure><h2 id="Selenium-操作浏览器"><a href="#Selenium-操作浏览器" class="headerlink" title="Selenium 操作浏览器"></a>Selenium 操作浏览器</h2><p>下载对应浏览器的驱动，放置到脚本可以访问的 path 路径中，基本操作：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Edge</span><br><span class="line">browser = Edge() <span class="comment"># 创建浏览器对象</span></span><br><span class="line">browser.get(<span class="string">&quot;https://www.baidu.com&quot;</span>) <span class="comment"># 访问目标网站</span></span><br><span class="line"></span><br><span class="line">element = browser.find_element_by_xpath() <span class="comment"># 定位元素并返回</span></span><br><span class="line"></span><br><span class="line">element.click() <span class="comment"># 对元素执行某种操作（假设为打开新窗口）</span></span><br><span class="line"></span><br><span class="line">browser.close() <span class="comment"># 关闭当前绑定窗口</span></span><br><span class="line"></span><br><span class="line">browser.switch_to.window(browser.window_handles[-<span class="number">1</span>]) <span class="comment"># 将目前窗口切换到新的窗口上面</span></span><br><span class="line"></span><br><span class="line">brower.close() <span class="comment"># 关闭当前绑定窗口</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反爬"><a href="#反爬" class="headerlink" title="反爬"></a>反爬</h2><h3 id="验证人机"><a href="#验证人机" class="headerlink" title="验证人机"></a>验证人机</h3><ol><li> 加上 user-agent 信息，模拟浏览器。</li><li> 加上 Referer 信息，显示访问的上一级链接，模拟用户访问顺序。</li></ol><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>这里说一下代理的原理，至于使用方式在前面的 requests 模块介绍里。</p><h2 id="web-知识"><a href="#web-知识" class="headerlink" title="web 知识"></a>web 知识</h2><h3 id="新页面渲染"><a href="#新页面渲染" class="headerlink" title="新页面渲染"></a>新页面渲染</h3><p>当浏览器进行一个新页面渲染（刷新）的时候，默认会将以前的请求记录消除，所以可以点击 <code>保留日志</code> 选项，来保留以前的请求。</p><p>遇到一些关键请求隐藏在新页面渲染之前，可以通过这样的方式看到。</p><h3 id="框架源代码"><a href="#框架源代码" class="headerlink" title="框架源代码"></a>框架源代码</h3><p>网页分为 页面源代码 和 框架源代码。页面源代码就是请求获取的 父页面。而框架源码就是父页面新请求出来的 iframe 的子页面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;requests-请求库&quot;&gt;&lt;a href=&quot;#requests-请求库&quot; class=&quot;headerlink&quot; title=&quot;requests 请求库&quot;&gt;&lt;/a&gt;requests 请求库&lt;/h2&gt;&lt;h3 id=&quot;发起请求&quot;&gt;&lt;a href=&quot;#发起请求&quot; cla</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
    <category term="爬虫" scheme="https://xorex.space/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python-07-文件操作</title>
    <link href="https://xorex.space/2022/01/25/3c0e22d4330e/"/>
    <id>https://xorex.space/2022/01/25/3c0e22d4330e/</id>
    <published>2022-01-25T08:35:42.000Z</published>
    <updated>2022-06-15T14:10:55.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>这里指的是针对一个文件的基本属性，比如路径，大小，名字，类型等，所以使用 os.path 来操作。</p><h3 id="绝对和相对"><a href="#绝对和相对" class="headerlink" title="绝对和相对"></a>绝对和相对</h3><p>相对路径可以用 <code>./XXX</code> 或者 <code>XXX</code> 开头表示，是相对于 <code>.py</code> 代码文件的路径。</p><p>绝对路径可以用 <code>E:/XXX</code> 或者 <code>/XXX</code></p><h3 id="路径判断"><a href="#路径判断" class="headerlink" title="路径判断"></a>路径判断</h3><ul><li><p>判断路径是否存在 os.path.exists()</p></li><li><p>判断是否为文件 os.path.isfile()</p></li><li><p>判断是否为文件夹 os.path.isdir()</p></li><li><p>判断路径是否为绝对路径 os.path.isabs()</p></li></ul><h3 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h3><ul><li><p>分离路径和文件名 os.path.split()</p></li><li><p>分离文件名和拓展名 os.path.splitext()</p></li><li><p>将路径和文件名拼接返回绝对路径 os.path.join(path,name)</p></li><li><p>获取路径名 os.path.dirname()</p></li><li><p>获取文件名 os.path.basename()</p></li><li><p>获取文件大小 os.path.getsize()</p></li><li><p>获取文件夹下的所有文件 os.listdir()</p></li></ul><h3 id="文件属性操作"><a href="#文件属性操作" class="headerlink" title="文件属性操作"></a>文件属性操作</h3><ul><li><p>创建文件 open(“Name.txt”, “a”).close() 建议使用这个创建文件。</p></li><li><p>创建文件夹 os.mkdir() 和创建多个文件夹 os.makedirs()</p></li><li><p>重命名 os.rename(old,new)</p></li><li><p>删除文件 os.remove() 和删除多个文件 os.removedirs()</p></li><li><p>复制文件 shutil.copy()</p></li><li><p>移动文件 shutil.move()</p></li></ul><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>使用内建函数 open() 来实现文件的读写操作：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(file_name [, mode=<span class="string">&#x27;r&#x27;</span> [ , buffering=-<span class="number">1</span> [ , encoding = <span class="literal">None</span> ]]])</span><br></pre></td></tr></table></figure><p>此格式中，用 [] 括起来的部分为可选参数，即可以使用也可以省略。其中，各个参数所代表的含义如下：<br>file：表示要创建的文件对象。</p><ul><li><p>file_name：要创建或打开文件的文件名称，该名称要用引号（单引号或双引号都可以）括起来。需要注意的是，如果要打开的文件和当前执行的代码文件位于同一目录，则直接写文件名即可；否则，此参数需要指定打开文件所在的完整路径。</p></li><li><p>mode：可选参数，用于指定文件的打开模式。可选的打开模式如表 1 所示。如果不写，则默认以只读（r）模式打开文件。</p></li><li><p>buffering：可选参数，用于指定对文件做读写操作时，是否使用缓冲区（本节后续会详细介绍）。</p></li><li><p>encoding：手动设定打开文件时所使用的编码格式，不同平台的 ecoding 参数值也不同，以 Windows 为例，其默认为 cp936（实际上就是 GBK 编码）。</p></li></ul><p><img src="https://xorex.space/image/339.jpg" alt="339.jpg"></p><center>表 1 open 函数支持的文件打开模式</center><table><thead><tr><th>模式</th><th>意义</th><th>注意事项</th></tr></thead><tbody><tr><td>r</td><td>只读模式打开文件，读文件内容的指针会放在文件的开头。</td><td>操作的文件必须存在。</td></tr><tr><td>rb</td><td>以二进制格式、采用只读模式打开文件，读文件内容的指针位于文件的开头，一般用于非文本文件，如图片文件、音频文件等。</td><td>↑</td></tr><tr><td>r+</td><td>打开文件后，既可以从头读取文件内容，也可以从开头向文件中写入新的内容，写入的新内容会覆盖文件中等长度的原有内容。</td><td>↑</td></tr><tr><td>rb+</td><td>以二进制格式、采用读写模式打开文件，读写文件的指针会放在文件的开头，通常针对非文本文件（如音频文件）。</td><td>↑</td></tr><tr><td>w</td><td>以只写模式打开文件，若该文件存在，打开时会清空文件中原有的内容。</td><td>若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。</td></tr><tr><td>wb</td><td>以二进制格式、只写模式打开文件，一般用于非文本文件（如音频文件）</td><td>↑</td></tr><tr><td>w+</td><td>打开文件后，会对原有内容进行清空，并对该文件有读写权限。</td><td>↑</td></tr><tr><td>wb+</td><td>以二进制格式、读写模式打开文件，一般用于非文本文件</td><td>↑</td></tr><tr><td>a</td><td>以追加模式打开一个文件，对文件只有写入权限，如果文件已经存在，文件指针将放在文件的末尾（即新写入内容会位于已有内容之后）；反之，则会创建新文件。</td><td>-</td></tr><tr><td>ab</td><td>以二进制格式打开文件，并采用追加模式，对文件只有写权限。如果该文件已存在，文件指针位于文件末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。</td><td>-</td></tr><tr><td>a+</td><td>以读写模式打开文件；如果文件存在，文件指针放在文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。</td><td>-</td></tr><tr><td>ab+</td><td>以二进制模式打开文件，并采用追加模式，对文件具有读写权限，如果文件存在，则文件指针位于文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。</td><td>-</td></tr></tbody></table><hr><p>对于二进制模式和文本模式的区别：</p><p>在 Windows 系统中，文件中用 \r\n 作为行末标识符（即换行符），当以文本格式读取文件时，会将 \r\n 转换成 \n；反之，以文本格式将数据写入文件时，会将 \n 转换成 \r\n。这种隐式转换换行符的行为，对用文本格式打开文本文件是没有问题的，但如果用文本格式打开二进制文件，就有可能改变文本中的数据（将 \r\n 隐式转换为 \n）。</p><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>成功打开文件之后，获取的 file 对象可以完成对此文件的读写：</p><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>file 对象包含如下属性：</p><ul><li><p>file.name：返回文件的名称；</p></li><li><p>file.mode：返回打开文件时，采用的文件打开模式；</p></li><li><p>file.encoding：返回打开文件时使用的编码格式；</p></li><li><p>file.closed：判断文件是否己经关闭。</p></li></ul><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>一定要记得 open 的时候，设置的默认编码格式</p><ul><li><p>file.read([size]) 可以限制一次读取的字节 or 字符数量，不写的话默认 <strong>全部读取</strong> 返回一个字节串或者字符串。</p></li><li><p>file.readline([size]) 一次读一行（包括最后的 \n），可以限制读取一行的 size 大小。</p></li><li><p>file.readlines() 按照行一次性读取所有内容，返回一个列表。</p></li></ul><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ul><li><p>write() 往文件里面写入内容。如果要立刻看到写入效果，要么 close() 要么 flush()。</p></li><li><p>writelines()，将一个列表内容写入文件中，可以配合 readlines() 实现复制文件。</p></li><li><p>flush() 刷新缓存区，写入磁盘中。</p></li></ul><h3 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h3><p>主要靠这 file.tell() 和 file.seek() 两个函数来得到当前文件指针位置，和将文件指针移动到对应位置。如果要使用，必须是以二进制模式打开文件！！！</p><ul><li><p>file.tell() 返回当前文件指针位置。</p></li><li><p>file.seek(offset[, whence])</p></li></ul><p>其中，各个参数的含义如下：</p><ol><li><p> whence：作为可选参数，用于指定文件指针要放置的位置，该参数的参数值有 3 个选择：0 代表文件头（默认值）、1 代表当前位置、2 代表文件尾。</p></li><li><p> offset：表示相对于 whence 位置文件指针的偏移量，正数表示向后偏移，负数表示向前偏移。例如，当whence == 0 &amp;&amp;offset == 3（即 seek(3,0) ），表示文件指针移动至距离文件开头处 3 个字符的位置；当whence == 1 &amp;&amp;offset == 5（即 seek(5,1) ），表示文件指针向后移动，移动至距离当前位置 5 个字符处。</p></li></ol><p>也就是根据 whence 选定参考点，根据 offset 设定偏移量，从而重新定位文件指针位置。</p><h2 id="自动关闭"><a href="#自动关闭" class="headerlink" title="自动关闭"></a>自动关闭</h2><h3 id="with-as"><a href="#with-as" class="headerlink" title="with as"></a>with as</h3><p>Python 中也有和 Java 一样的 try(resource) 语句，用来自动控制上下文资源（文件，数据库链接等）。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> 表达式 [<span class="keyword">as</span> target]：  </span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure><p>此格式中，用 [] 括起来的部分可以使用，也可以省略。其中，target 参数用于指定一个变量，该语句会将 expression 指定的结果保存到该变量中。with as 语句中的代码块如果不想执行任何语句，可以直接使用 pass 语句代替。</p><h3 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h3><p>上下文 context，表示上文和下文…… 在编程里面，则指的是用来保存上文状态的东西。比如：</p><ol><li> 文件资源：里面就是保存各种文件信息的对象，可以叫做 上下文</li><li> 进程资源：切换进程保存在 PCB 里面的东西，也可以叫做 上下文</li><li> 数据库链接：保存数据库链接的东西，叫做 上下文</li><li> 请求数据：保存请求携带的各种信息，也叫 上下文</li></ol><p>就是要保存一下以前获得的东西，就叫上下文。而上下文管理器，就是管理上下文资源的对象，比如 Python 里面的 file。</p><p>file 对象实现了 <code>__start__() __exit__()</code> 因此就是上下文管理器，可以被 with as 语句所操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件操作&quot;&gt;&lt;a href=&quot;#文件操作&quot; class=&quot;headerlink&quot; title=&quot;文件操作&quot;&gt;&lt;/a&gt;文件操作&lt;/h2&gt;&lt;p&gt;这里指的是针对一个文件的基本属性，比如路径，大小，名字，类型等，所以使用 os.path 来操作。&lt;/p&gt;
&lt;h3 id=&quot;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-06-异常和代码管理</title>
    <link href="https://xorex.space/2022/01/22/ba1c421d07e7/"/>
    <id>https://xorex.space/2022/01/22/ba1c421d07e7/</id>
    <published>2022-01-22T08:17:37.000Z</published>
    <updated>2022-04-15T08:35:51.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><p>基本结构</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入被除数：&quot;</span>))  </span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入除数：&quot;</span>))  </span><br><span class="line">    c = a / b  </span><br><span class="line">    print(<span class="string">&quot;您输入的两个数相除的结果是：&quot;</span>, c)  </span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e: <span class="comment"># e 表示捕获的实例  </span></span><br><span class="line">    print(<span class="string">&quot;输入内容不是合法滴数字呢&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:  </span><br><span class="line">    print(<span class="string">&quot;除数不能为零呢&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> (ValueError,ZeroDivisionError) <span class="keyword">as</span> e: <span class="comment">#把两个异常结合在一起的写法  </span></span><br><span class="line">    print(<span class="string">&quot;输入数字异常呢&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e : <span class="comment"># 捕获商量捕获不了的异常  </span></span><br><span class="line">    print(<span class="string">&quot;出现未知异常呢&quot;</span>)  </span><br><span class="line">    print(e.args)  </span><br><span class="line">    print(<span class="built_in">str</span>(e))  </span><br><span class="line">    print(<span class="built_in">repr</span>(e))  </span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 没有出现异常之后，会执行 else 里面的代码  </span></span><br><span class="line">    print(<span class="string">&quot;计算成功，没有出现异常&quot;</span>)  </span><br><span class="line"><span class="keyword">finally</span>: <span class="comment"># 无论有没有异常都会执行的代码，即使异常没有被捕获  </span></span><br><span class="line">    print(<span class="string">&quot;计算结束&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="异常信息"><a href="#异常信息" class="headerlink" title="异常信息"></a>异常信息</h3><p>我们捕获到了对应的异常实例之后就需要对异常获取信息处理：</p><ul><li>e.args：返回异常的错误编号和描述字符串；</li><li>str(e)：返回异常信息，但不包括异常信息的类型；</li><li>repr(e)：返回较全的异常信息，包括异常信息的类型。</li></ul><h3 id="异常继承结构"><a href="#异常继承结构" class="headerlink" title="异常继承结构"></a>异常继承结构</h3><p><img src="https://xorex.space/image/338.jpg" alt="338.jpg"></p><p>如果要自己实现异常的时候，就一定要找对上层异常去继承。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>我们可以手动抛出异常 关键字 raise</p><p>可以在任何地方使用 raise，抛出一个异常的实例。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> e <span class="comment"># 在 except 语句里面抛出捕获的异常   </span></span><br><span class="line"><span class="keyword">raise</span> Exception <span class="comment"># 新建异常 Exception   </span></span><br><span class="line"><span class="keyword">raise</span> Exception(<span class="string">&quot;异常原因 XXX&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="查看异常信息"><a href="#查看异常信息" class="headerlink" title="查看异常信息"></a>查看异常信息</h3><p>导入 traceback 模块，调用方法：</p><ul><li><p><code>traceback.print_exc()</code> 控制台输出内容</p></li><li><p><code>traceback.print_exc(file=open(&#39;filename&#39;，&#39;a&#39;))</code> 文件 filename 中输出内容</p></li></ul><p>就直接在 except 里面调用即可。</p><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p>Python 自带 logging 模块可以使用，</p><h3 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h3><p>感觉确实没有 Java 的日志系统使用起来更方便一点。导入 logging 模块之后，需要用 baseConfig() 进行最基本的设置，常用的参数如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filename: str | PathLike[str] | None = ...,  </span><br><span class="line">filemode: str = ...,  </span><br><span class="line">format: str = ...,  </span><br><span class="line">datefmt: str | None = ...,  </span><br><span class="line">style: str = ...,  </span><br><span class="line">level: int | str | None = ...,  </span><br><span class="line">stream: SupportsWrite[str] | None = ...,  </span><br><span class="line">handlers: Iterable[Handler] | None = ...) -None</span><br></pre></td></tr></table></figure><p>主要集中在 level (日志显示最低等级)，format 输出日志格式，这两个上面。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, <span class="built_in">format</span>=<span class="string">&#x27; %(asctime)s - %(levelname)s - %(message)s&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>我们只要调用 logging 对应的日志输出函数，里面填充日志 message 内容</p><table><thead><tr><th>级别</th><th>对应的函数</th><th>描述</th></tr></thead><tbody><tr><td>DEBUG</td><td>logging.debug()</td><td>最低级别，用于小细节，通常只有在诊断问题时，才会关心这些消息。</td></tr><tr><td>INFO</td><td>logging.info()</td><td>用于记录程序中一般事件的信息，或确认一切工作正常。</td></tr><tr><td>WARNING</td><td>logging.warning()</td><td>用于表示可能的问题，它不会阻止程序的工作，但将来可能会。</td></tr><tr><td>ERROR</td><td>logging.error()</td><td>用于记录错误，它导致程序做某事失败。</td></tr><tr><td>CRITICAL</td><td>logging.critical()</td><td>最高级别，用于表示致命的错误，它导致或将要导致程序完全停止工作。</td></tr></tbody></table><p>具体的日志系统如何使用，以后写项目再研究。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>Python 一个 py 文件就是一个模块，可以通过 import 导入进来，然后通过文件名作为此文件代码的命名空间，来访问里面的变量和函数。</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>import 有两种写法：</p><ul><li><p><code>import module_name as alias</code> 将模块 module_name.py 导入，并起别名 alias（可以不起别名），然后就可以别名作为命名空间访问里面的变量和模块，就像类一样。</p></li><li><p><code>from module_name import func/var</code> 将变量或者函数单独导入，这样访问就不需要指定命名空间，用名字就可以了。</p></li></ul><p>当然如果遇到开头是空格或者数字的模块名，那就这样导入：</p><p><code>__import__(modulename:str)</code> 这是等价于 import 的内建函数。</p><h3 id="name"><a href="#name" class="headerlink" title="__name__"></a>__name__</h3><p>在运行程序的时候，会首先看所有 import 的模块，将这些模块的代码逐一经过解释器执行。但是对于模块中一些不想被导入是执行的代码，可以通过判断命名空间来决定是否执行，内建模块自带 <code>__name__</code> 变量。</p><p>在运行一个 Python 文件的时候，如果执行文件里面的代码，这个内建模块变量 <code>__name__</code> 的值为 <code>__main__</code>，当执行到 import 导入模块的时候，会改变 <code>__name__</code> 值为模块名字，然后再解释执行模块里面的内容。</p><p>所以当时直接运行模块文件的时候 <code>__name__</code> 值为 <code>__main__</code>，我们可以运行一些代码执行，当时作为模块导入另外的文件的时候，值就会变成文件名，就可以不运行这些代码。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="模块文档"><a href="#模块文档" class="headerlink" title="模块文档"></a>模块文档</h3><p>只需要用 <code>&#39;&#39;&#39;</code> 包裹在文件开始即可。然后再调用的地方可以用 <code>模块名.__doc__</code> 获取这些字符串里面的内容。</p><h3 id="模块查找"><a href="#模块查找" class="headerlink" title="模块查找"></a>模块查找</h3><p>这里的模块定位查找：</p><ul><li><p>在当前目录，即当前执行的程序文件所在目录下查找；</p></li><li><p>到 PYTHONPATH（环境变量）下的每个目录中查找；</p></li><li><p>到 Python 默认的安装目录下查找。</p></li></ul><p>这些目录都可以在 sys.path 中输出查看。</p><hr><p>当 Python 程序找不到模块的时候：</p><ul><li><p>向 sys.path 中临时添加模块文件存储位置的完整路径；</p></li><li><p>将模块放在 sys.path 变量中已包含的模块加载路径中；</p></li><li><p>设置 path 系统环境变量。</p></li></ul><h3 id="模块封装"><a href="#模块封装" class="headerlink" title="模块封装"></a>模块封装</h3><ol><li><p> 当用户通过 import 导入模块命名空间来访问模块成员的时候，如果想要限制一些方法的访问，可以使用 <code>_</code> 或者 <code>__</code> 作为开头限制访问。</p></li><li><p> 当用户通过 from xxx import * 进行全部导入的时候，可以通过内建列表 <code>__all__</code> 来设置允许被导入的成员名字。</p></li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">&#x27;fun1&#x27;</span>,<span class="string">&#x27;fun2&#x27;</span>,<span class="string">&#x27;var1&#x27;</span>,<span class="string">&#x27;var2&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="导入本质"><a href="#导入本质" class="headerlink" title="导入本质"></a>导入本质</h3><p>本质上就是创建了一个模块名的变量，类型是 <code>&lt;class &#39;module&#39;&gt;</code>， 将模块里面的代码，交给了这个变量，通过这个变量来访问模块成员。</p><h2 id="包-package"><a href="#包-package" class="headerlink" title="包 package"></a>包 package</h2><p>包是对模块的一种封装管理，是一个文件夹，文件夹的名字就是这个包的名字。这个文件夹里面可以包含另外一个包，也可以包含若干个模块。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>一般来说，一个 package 的文件夹下面都会有一个叫做 <code>__init__.py</code> 的模块，在单纯的导入包的时候，本质上就是导入了这个包的 <code>__init__.py</code> 模块。</p><p>比如我们可以新建一个文件夹叫 <code>my_package</code>，然后里面管理着两个模块 <code>module1.py</code> 和 <code>module2.py</code>，那么这个完整的 package 如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_package  </span><br><span class="line">     ┠── __init__.py  </span><br><span class="line">     ┠── module1.py  </span><br><span class="line">     ┗━━ module2.py</span><br></pre></td></tr></table></figure><h3 id="导入-package"><a href="#导入-package" class="headerlink" title="导入 package"></a>导入 package</h3><p>因为 package 相对于 module，多了一层概念，那么再导入的时候，也需要多一层 package 的名字：</p><p>有三种方式导入 package 中的 module：</p><ol><li><code>import 包名[.模块名 [as 别名]]</code></li><li><code>from 包名 import 模块名 [as 别名]</code></li><li><code>from 包名.模块名 import 成员名 [as 别名]</code></li></ol><ul><li>对于第一种，如果只导入包名的话，其实是导入了 <code>__init__.py</code> 这个模块了。并不是同时导入 package 里面的所有 module。导入 包名.模块名 之后，除非起一个别名，否则还是用 包名.模块名 这样的命名空间来访问。</li></ul><h3 id="利用-init-py"><a href="#利用-init-py" class="headerlink" title="利用 __init__.py"></a>利用 __init__.py</h3><p>实际上对与包的使用远远没有这么麻烦，比如在使用 requests 包的时候，可没对包里面的各种模块控制导入。这是因为第三方提供的包中，一般都会包的 <code>__init__.py</code> 模块中完成了整个包对外暴露的成员的控制，导入 <code>__init__.py</code> 就等于导入了整个包的功能。</p><p>因为导入包名其实就是导入了 <code>__init__.py</code>，所以只要在这个模块里面导入需要的成员，那么外界就可以借助着 <code>__init__.py</code> 也就是导入包名完成访问了。</p><hr><p>在 <code>__init__.py</code> 编写导入模块代码的时候，写法和外部导入是一样的，不同的是包名使用 <code>.</code> 来代替，比如 requests 里面：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> utils <span class="comment"># 在自己的包 request 中导入模块 utils  </span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> packages <span class="comment"># 导入 packages</span></span><br></pre></td></tr></table></figure><p>不过访问 <code>__init__.py</code> 里面导入的成员，肯定要加上包名这一层命名空间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;异常捕获&quot;&gt;&lt;a href=&quot;#异常捕获&quot; class=&quot;headerlink&quot; title=&quot;异常捕获&quot;&gt;&lt;/a&gt;异常捕获&lt;/h2&gt;&lt;p&gt;基本结构&lt;/p&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-05-类特殊成员</title>
    <link href="https://xorex.space/2022/01/21/f14e56f10092/"/>
    <id>https://xorex.space/2022/01/21/f14e56f10092/</id>
    <published>2022-01-21T08:08:04.000Z</published>
    <updated>2022-04-15T08:55:54.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>Python 提供了 enum 模块的枚举类 Enum，只需要继承这个类，里面的类属性就都变成 iterable 类型的了。</p><p>然后就可以使用循环访问了。</p><p>不同的是，枚举类无法修改成员，并且类属性名字不能重复。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xorex</span>(<span class="params">Enum</span>):</span>  </span><br><span class="line">    name = <span class="string">&quot;Xorex&quot;</span>  </span><br><span class="line">    grage = <span class="string">&quot;Tempest&quot;</span>  </span><br><span class="line">    age = <span class="number">18</span>  </span><br><span class="line">    Length = <span class="number">18</span>  </span><br><span class="line">    <span class="comment"># 上面两个 age 和 Length 因为值相同，会被看做成一个  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Xorex:  </span><br><span class="line">    print(i) <span class="comment">#只会输出前三个，Length 作为 age 的别名</span></span><br></pre></td></tr></table></figure><h2 id="特别的"><a href="#特别的" class="headerlink" title="特别的"></a>特别的</h2><h3 id="直接写代码"><a href="#直接写代码" class="headerlink" title="直接写代码"></a>直接写代码</h3><p>这里的直接写代码就是在类定义下面直接写，等价于 Java 的静态代码块，会在 <strong>加载类代码的时候运行</strong>。毕竟类下面定义的，就是这个类命名空间下面的代码嘛，自然遇到能执行的就执行，函数的话就封装起来嘛。</p><p>所以这里也不难理解，为什么直接写在类里面的变量，就等同于静态变量了……</p><p>调用 类名方法之后，解释器创建一个对象（用来保存实例属性和实例所属类的结构体），然后调用 <code>__init__</code> 方法并将这个对象（结构体）传入 self 中。执行完方法之后，self 作为返回值返回给调用处的地方。</p><p>一般来说，会在构造方法中，初始化类所需要的实例属性。</p><h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h3><p>Python 的描述符是一个特殊的类，这个类用于管理某一种属性的 getter 和 setter。举两个例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameControl</span>:</span> <span class="comment"># 用来控制名字 name 的 setter 和 setter  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name: <span class="built_in">str</span> = <span class="string">&quot;HAHA&quot;</span></span>):</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span> <span class="comment"># 规定的 getter 方法  </span></span><br><span class="line">        <span class="keyword">return</span> self.name  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span>  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">str</span>):  </span><br><span class="line">            print(<span class="string">&quot;要输入字符串哦！&quot;</span>)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            self.name = value  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span>  </span><br><span class="line">    name = NameControl() <span class="comment"># 绑定到类属性上面</span></span><br></pre></td></tr></table></figure><ul><li><p>不理解为什么描述符是绑定在 <strong>类属性</strong> 上面。</p></li><li><p>类属性最初可以激活 getter 方法，但是无法激活 setter 方法</p></li><li><p>实例属性最初都可以激活 getter 和 setter</p></li><li><p>当对类属性进行赋值之后，描述符就失效了。应该是赋的值覆盖了绑定符地址。</p></li><li><p>一个类的多个实例，使用的描述符对象竟然是同一个？？？</p></li></ul><p>猜测应该是通过实例属性保存 描述符 实例，然后对实例访问和赋值就是对描述符进行访问赋值，会激活特殊方法 <code>__get__</code> <code>__set__</code>，从而通过描述符来实现对属性访问的控制。</p><p>对描述符里面的特殊方法的调用，是在 <code>__getattribute__()</code> 中决定调用的，判断的逻辑如下：</p><ol><li> 验证该属性是否为类实例对象的数据描述符；</li><li> 如果不是，就查看该属性是否能在类实例对象的 <code>__dict__</code> 中找到；</li><li> 最后，查看该属性是否为类实例对象的非数据描述符。</li></ol><h3 id="property-函数"><a href="#property-函数" class="headerlink" title="property() 函数"></a>property() 函数</h3><p>这个函数的作用和 描述符 类似。不过它是手动绑定起到 getter 和 setter 的方法，绑定方法为： <code>属性名=property(fget=None, fset=None, fdel=None, doc=None)</code> 这样以后在对 <code>属性名</code> 进行访问和赋值的时候，都会经过 property 绑定的方法完成。</p><ul><li>fget: getterFunction</li><li>fset: setterFunction</li><li>fdel: deleteFunction</li><li>doc: 字符串，属性描述信息。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span>):</span>  </span><br><span class="line">        self.__name = name  <span class="comment"># 记得要设置成私有属性 __name，因为如果名字还是 name 的话，就会无限触发绑定的 getName 方法，进入死调用循环。  </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        <span class="keyword">return</span> self.__name  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setName</span>(<span class="params">self, name: <span class="built_in">str</span></span>):</span>  </span><br><span class="line">        self.__name = name  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">    name = <span class="built_in">property</span>(getName,setName) <span class="comment"># 绑定到类属性 name 上面</span></span><br></pre></td></tr></table></figure><p>然后就可以随心所欲的在访问实例属性的时候，全都经过指定的 getter setter 方法了！！！</p><h2 id="类特殊成员"><a href="#类特殊成员" class="headerlink" title="类特殊成员"></a>类特殊成员</h2><p>Python 类中的特殊成员名字都是用下划线包起来的，这些特殊的成员在 Python 解释器下面会有特殊的作用。</p><p>不像是 Java 的那种没有特殊标识，比如 toString() 构造方法，iterator() 方法等，Python 的特殊方法一眼都可以看出来。</p><p>下面的特殊方法，如果不需要自己声明就可以调用，那么就一定是基类 object 里面包含有的！</p><h3 id="init-构造方法"><a href="#init-构造方法" class="headerlink" title="__init__() 构造方法"></a>__init__() 构造方法</h3><p>这里的构造方法和 Java 中是一样的，不过因为 Python 支持多继承以及不支持重载，所以在继承中，不会自动调用父类的构造方法，这里需要自己手动调用。</p><p>要么用 <code>super().__init__()</code> 要么 用 <code>类名.__init__(self)</code>。</p><h3 id="repr-描述方法"><a href="#repr-描述方法" class="headerlink" title="__repr__() 描述方法"></a>__repr__() 描述方法</h3><p>represent 类描述方法，在 object 中输出的是当前对象的 <code>类名+object at+内存地址</code>。可以重写，在遇到需要转化为字符串的时候，如果没有 <code>__str__()</code> 方法，则会调用 <code>__repr__()</code>，否则优先调用 <code>__str__()</code>。</p><h3 id="str-字符串"><a href="#str-字符串" class="headerlink" title="__str__() 字符串"></a>__str__() 字符串</h3><p>需要返回一个字符串，作为对象需要被转化为字符串类型的时候的值。</p><h3 id="del-销毁对象"><a href="#del-销毁对象" class="headerlink" title="__del__() 销毁对象"></a>__del__() 销毁对象</h3><p>对于 Python 来说，使用 <code>del XXX</code> 语句可以将对象的引用计数减一，减到零的时候，就会触发 <code>__del__()</code> 方法进行善后，善后完毕后清除内存。</p><p>需要注意的是，<code>__del___()</code> 就是一个善后的，它并不负责引用计数器减一和清除内存的工作，它只是被调用的。</p><p>另外，一定要记得在子类的 <code>__del__()</code> 中调用父类的 <code>__del__()</code> 来完全完成善后工作。因为父类并不单独存在对象，所以自然只调用 <code>__del__()</code> 即可。</p><h3 id="dir-列出成员"><a href="#dir-列出成员" class="headerlink" title="__dir__() 列出成员"></a>__dir__() 列出成员</h3><p>用来列出当前实例所持有的所有成员（包括继承来的属性和方法）。</p><p>和 dir() 的作用类似，不过区别是 dir() 可以列出来类和实例的成员，而 <code>__dir__()</code> 只能列出来实例的成员。</p><h3 id="dict-字典属性"><a href="#dict-字典属性" class="headerlink" title="__dict__ 字典属性"></a>__dict__ 字典属性</h3><ul><li>对于类属性 <code>__dict__</code>：以字典的形式输出所有的类属性。</li><li>对于实例属性 <code>__dict__</code>: 以字典的形式输出所有的实例属性。</li></ul><h3 id="call-调用绑定"><a href="#call-调用绑定" class="headerlink" title="__call__() 调用绑定"></a>__call__() 调用绑定</h3><p>在类中可以定义一个名字叫做 <code>__call__()</code> 的方法，这个方法会和 <code>实例名()</code> 这样的调用方式绑定，好玩：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xorex</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, name</span>):</span> <span class="comment"># 将方法和实例名绑定，可以通过实例名调用此方法  </span></span><br><span class="line">        print(name + <span class="string">&quot; called the Xorex.&quot;</span>)  </span><br><span class="line"></span><br><span class="line">xorex = Xorex()  </span><br><span class="line">xorex.__call__(<span class="string">&quot;Yukino&quot;</span>) <span class="comment"># 手动调用  </span></span><br><span class="line">xorex(<span class="string">&quot;Asuna&quot;</span>) <span class="comment"># 绑定调用</span></span><br></pre></td></tr></table></figure><h2 id="和类相关的内建函数"><a href="#和类相关的内建函数" class="headerlink" title="和类相关的内建函数"></a>和类相关的内建函数</h2><p>对于 Python 中的各种不需要 import 就可以使用的东西，比如各种方法，以及类 object 等，都是包含在内建模块中 builtins 里面。在运行 Python 代码之前会优先加载这个内建模块。</p><h3 id="hasattr"><a href="#hasattr" class="headerlink" title="hasattr()"></a>hasattr()</h3><p><code>hasattr(obj, name)</code> 返回布尔类型，判断是否有名字为 name 的方法或者属性。</p><h3 id="getattr"><a href="#getattr" class="headerlink" title="getattr()"></a>getattr()</h3><p><code>getattr(obj, name)</code> 如果找不到 name 那就跑出来异常。如果是属性，返回属性值，如果是方法，返回方法信息。</p><h3 id="setattr"><a href="#setattr" class="headerlink" title="setattr()"></a>setattr()</h3><p><code>setattr(obj, name, value)</code> 这个就是设置属性了。适合只有字符串的那种批量建立属性。</p><h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p><code>issubclass(cls, class_or_tuple)</code> 判断是否为子类，可以跟着一个 tuple 遍历判断。</p><p><code>isinstance(obj, class_or_tuple)</code> 判断是否为实例，可以跟着一个 tuple 遍历判断。</p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载是作用与对象进行运算符计算的时候，应该调用什么方法来完成:</p><p>数值运算：</p><table><thead><tr><th>重载方法</th><th>重载运算</th><th>运算</th></tr></thead><tbody><tr><td>__add__(self,rhs)</td><td>self + rhs</td><td>加法</td></tr><tr><td>__sub__(self,rhs)</td><td>self - rhs</td><td>减法</td></tr><tr><td>__mul__(self,rhs)</td><td>self * rhs</td><td>乘法</td></tr><tr><td>__truediv__(self,rhs)</td><td>self / rhs</td><td>除法</td></tr><tr><td>__floordiv__(self,rhs)</td><td>self //rhs</td><td>地板除</td></tr><tr><td>__mod__(self,rhs)</td><td>self % rhs</td><td>取模(求余)</td></tr><tr><td>__pow__(self,rhs)</td><td>self **rhs</td><td>幂运算</td></tr></tbody></table><p>逻辑运算：</p><table><thead><tr><th>重载方法</th><th>重载运算</th><th>运算</th></tr></thead><tbody><tr><td>__lt__(self,rhs)</td><td>self &lt; rhs</td><td>Less Than</td></tr><tr><td>__gt__(self,rhs)</td><td>self &gt; rhs</td><td>Grater Than</td></tr><tr><td>__le__(self,rhs)</td><td>self &lt;= rhs</td><td>Less Equal</td></tr><tr><td>__ge__(self,rhs)</td><td>self &gt;= rhs</td><td>Grater Equal</td></tr><tr><td>__eq__(self,rhs)</td><td>self = rhs</td><td>Equal</td></tr><tr><td>__ne__(self,rhs)</td><td>self != rhs</td><td>Nagtive Equal</td></tr></tbody></table><h2 id="装饰器原理"><a href="#装饰器原理" class="headerlink" title="装饰器原理"></a>装饰器原理</h2><p>我们之前是见过装饰器的，就是 @staticmethod @classmethod 这些。而它们是什么呢，可以干什么呢。</p><p>其实就是通过设计模式——装饰器来修改原有函数的功能，变成一个加强版本的函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span>(<span class="params">Func</span>):</span> <span class="comment">#定义装饰器，会将被装饰的函数当作实参传入  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wapper</span>(<span class="params">*args,**kwargs</span>):</span> <span class="comment">#对传入的函数进行包装为新的此函数  </span></span><br><span class="line">        print(<span class="string">&quot;[logger] Invoke Func: &quot;</span>+Func.__name__)  </span><br><span class="line">        print(<span class="string">&quot;[logger] Args are &quot;</span>+args.__str__()+<span class="string">&#x27; &#x27;</span>+kwargs.__str__())  </span><br><span class="line">        <span class="keyword">return</span> Func(*args,**kwargs)  </span><br><span class="line">    <span class="keyword">return</span> wapper <span class="comment">#将包装好的函数地址返回给原函数名  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logger </span><span class="comment">#这个等价于函数后面多了一句话： hello = logger(hello)  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name</span>):</span>  </span><br><span class="line">    print(<span class="string">&quot;Ya hello! &quot;</span>+name)  </span><br><span class="line"></span><br><span class="line">hello(<span class="string">&quot;Xorex&quot;</span>) <span class="comment">#调用被包装之后的函数</span></span><br></pre></td></tr></table></figure><p>上面代码的核心就是把 <code>@logger</code> 标注在函数 <code>hello</code> 上面之后，会自动生成一句代码到 <code>hello</code> 后面：<code>hello = logger(hello)</code> 所以我们要在 logger 里面定义装饰器的代码，将 hello 函数装饰之后返回一个新的被装饰过的函数。</p><hr><p>允许标注多个装饰器，执行顺序从上到下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@funA  </span></span><br><span class="line"><span class="meta">@funB  </span></span><br><span class="line"><span class="meta">@funC  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span>  </span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>则会这样执行：<code>fun = funA( funB ( funC (fun) ) )</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;枚举类&quot;&gt;&lt;a href=&quot;#枚举类&quot; class=&quot;headerlink&quot; title=&quot;枚举类&quot;&gt;&lt;/a&gt;枚举类&lt;/h2&gt;&lt;p&gt;Python 提供了 enum 模块的枚举类 Enum，只需要继承这个类，里面的类属性就都变成 iterable 类型的了。&lt;/p&gt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>迈尔斯-布里格斯性格分类法</title>
    <link href="https://xorex.space/2022/01/20/c3863c88e613/"/>
    <id>https://xorex.space/2022/01/20/c3863c88e613/</id>
    <published>2022-01-20T07:57:01.000Z</published>
    <updated>2022-04-15T08:00:24.842Z</updated>
    
    <content type="html"><![CDATA[<p>MBTI <code>Mybers-Briggs Type Indicator</code> 迈尔斯-布里格斯性格分类法。是我目前见到的，比较适合用来描述人性格的一种科学有效的方法。</p><h2 id="性格分类："><a href="#性格分类：" class="headerlink" title="性格分类："></a>性格分类：</h2><table><thead><tr><th>维度</th><th>类型-英文</th><th>类型-英文</th></tr></thead><tbody><tr><td>精力来源</td><td>外向 E Extrovert</td><td>内向 I Introvert</td></tr><tr><td>认知方式</td><td>感觉 S Sensing</td><td>直觉 N Intuition</td></tr><tr><td>决定方式</td><td>理性 T Thinking</td><td>感性 F Feeling</td></tr><tr><td>外部世界</td><td>判断 J Judgment</td><td>知觉 Perceiving</td></tr></tbody></table><h3 id="精力来源"><a href="#精力来源" class="headerlink" title="精力来源"></a>精力来源</h3><p>这个主要是精力来源，取决于社交是提供能量还是消耗能量。</p><h3 id="认知方式"><a href="#认知方式" class="headerlink" title="认知方式"></a>认知方式</h3><p>认知方式是人们在面对世界，面对新事物的时候，是如何认知它的。</p><p>对于 S Sensing 类型来说，就是一个具体的，详细的事物，而对于 N Intuition 来说，则是一类共性，整体情况，普遍规律等。</p><h3 id="决定方式"><a href="#决定方式" class="headerlink" title="决定方式"></a>决定方式</h3><p>决定方式 主要取决于在做决定的时候，参考的依据是什么。</p><p>T Thinking 类型按照客观的立场，一视同仁的按照规则看待，必须有逻辑，倾向于批评。</p><p>F Feeling 重视人的感受，更有人情味，重视和睦的氛围并想要维护。</p><h3 id="决定方式-1"><a href="#决定方式-1" class="headerlink" title="决定方式"></a>决定方式</h3><p>J Judging 判断型 目的强 喜欢有计划，有条理</p><p>P Perceiving 自由 散漫，不受约束 etc</p><p>感觉自己在 J 和 P 反复横跳 QAQ</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MBTI &lt;code&gt;Mybers-Briggs Type Indicator&lt;/code&gt; 迈尔斯-布里格斯性格分类法。是我目前见到的，比较适合用来描述人性格的一种科学有效的方法。&lt;/p&gt;
&lt;h2 id=&quot;性格分类：&quot;&gt;&lt;a href=&quot;#性格分类：&quot; class=&quot;he</summary>
      
    
    
    
    <category term="杂七杂八" scheme="https://xorex.space/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="MBTI" scheme="https://xorex.space/tags/MBTI/"/>
    
  </entry>
  
  <entry>
    <title>Python-04-面向对象</title>
    <link href="https://xorex.space/2022/01/17/d8f77f52e836/"/>
    <id>https://xorex.space/2022/01/17/d8f77f52e836/</id>
    <published>2022-01-17T07:23:42.000Z</published>
    <updated>2022-04-15T09:00:59.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Python 中的面对对象中的概念中，和 Java 不同的只有字段，在 Python 中直接叫做 <code>属性</code> . 并且 Python 中的类其实就是一个独立的 <code>命名空间</code> 这个命名空间使用类名来调用，里面有变量，有方法（函数），像极了另外的一个 Python 文件。</p><blockquote><p>所以，类属性其实就是另外命名空间的全局变量，方法其实就是另外命名空间的函数！！！</p></blockquote><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在 Python 面对对象中使用的变量有三种类型：</p><ol><li> 类体中、所有函数之外：此范围定义的变量，称为类属性或类变量；（类命名空间的普通变量）</li><li> 类体中，所有函数内部：以“self.变量名”的方式定义的变量，称为实例属性或实例变量；（self 保存结构体地址的变量集合）</li><li> 类体中，所有函数内部：以“变量名=变量值”的方式定义的变量，称为局部变量。（类命名空间函数的局部变量）</li></ol><p>同时三者中的属性，也就是类属性和实例属性，默认都是 public 类型，如果想要设置 private 类型，则需要在属性名字前面加上 <code>__</code> 如 <code>__name</code>，外界访问就会报错。当然也可以加一个 <code>_</code> 外界虽然也能调用，但是编译器不会给提示，约定俗成为 private 类型。</p><p>并且类属性和实例属性都支持在类外面动态添加属性。</p><hr><ul><li><strong>类属性</strong> ，可以通过类名进行访问和修改。</li></ul><p>比较不同的是，Python 支持动态的为类添加类属性，直接赋值就可以了（可以理解为动态语言直接在叫做 类名 的命名空间文件中，修改了代码）：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span>  </span><br><span class="line">    name = <span class="string">&quot;People&quot;</span> <span class="comment"># 通过类名访问的静态字段 name  </span></span><br><span class="line"></span><br><span class="line">People.age = <span class="number">18</span> <span class="comment"># 动态添加类属性  </span></span><br><span class="line"></span><br><span class="line">print(People.age) <span class="comment"># 访问类属性</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>实例属性</strong> ，也就是 Java 中的普通字段，通过具体的实例进行访问。比较不同的是，Python 只能在方法中进行声明，并且需要以 <code>self.name=XXX</code> 来声明名字为 name 的实例对象。（实例就是保存实例变量的结构体地址）</li></ul><p>实例属性也支持动态的添加，但是是依托于某一个具体的实例进行属性添加，对于其他属性，没有影响。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span> <span class="comment"># 建议实例属性都放在构造器 __init__ 里面声明  </span></span><br><span class="line">        self.age = <span class="number">18</span> <span class="comment"># 以 self 开头，为实例属性  </span></span><br><span class="line"></span><br><span class="line">print(People().age) <span class="comment"># 通过新建实例来访问</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>局部变量</strong> ，这个和函数里面的概念是一样的，直接 <code>name=value</code> 的形式就创建了在当前方法内部有效的局部变量。（因为本质上就是一个类命名空间里面的函数呀）</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Python 不支持方法重载。如果有两个重名的方法，则后面的会覆盖前面的。</p><p>方法也是分为三种：类方法，实例方法和静态方法。</p><p>但是这三种方法在本质上都是一样的，都是类命名空间下面的普通函数，只不过根据必须传递的参数不同进行了划分。必须传递实例地址 self 的为实例方法，必须传递自己类命名空间的地址的方法叫做类方法，而静态方法就是什么都不用传递的普通方法。</p><p>因为类中定义的方法默认是需要 self 的实例方法，所以要定义其他两种就需要注解来标记一下。</p><hr><p>可以通过在方法名字前面加上 <code>__</code> 来将方法改成 private 类型。可以加上 <code>_</code> 变成假 private 类型。</p><hr><p>Python 同样支持对三种方法进行动态添加，只要先定义一个符合规范的方法，然后按照动态添加字段的方式，就可以动态添加方法了：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLanguage</span>:</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line"><span class="comment">#下面定义了一个实例方法  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span>  </span><br><span class="line">    print(<span class="string">&quot;正在调用实例方法&quot;</span>)  </span><br><span class="line"><span class="comment">#下面定义了一个类方法  </span></span><br><span class="line"><span class="meta">@classmethod  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info2</span>(<span class="params">cls</span>):</span>  </span><br><span class="line">    print(<span class="string">&quot;正在调用类方法&quot;</span>)  </span><br><span class="line"><span class="comment">#下面定义个静态方法  </span></span><br><span class="line"><span class="meta">@staticmethod  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info3</span>():</span>  </span><br><span class="line">    print(<span class="string">&quot;正在调用静态方法&quot;</span>)  </span><br><span class="line"><span class="comment">#类可以动态添加以上 3 种方法，会影响所有实例对象  </span></span><br><span class="line">CLanguage.info = info  </span><br><span class="line">CLanguage.info2 = info2  </span><br><span class="line">CLanguage.info3 = info3  </span><br><span class="line">clang = CLanguage()  </span><br><span class="line"></span><br><span class="line"><span class="comment">#类实例对象只能动态添加实例方法，不会影响其它实例对象  </span></span><br><span class="line">clang1 = CLanguage()  </span><br><span class="line">clanginfo = info  </span><br><span class="line"><span class="comment">#必须手动为 self 传值  </span></span><br><span class="line">clanginfo(clang1)</span><br></pre></td></tr></table></figure><p>尽量别改代码，不然维护起来，真的是，无语呀。</p><hr><ul><li><strong>实例方法</strong> ，类中定义的默认方法都是实例方法（必须有参数 self），也就是必须需要实例才可以访问的方法。</li></ul><p>有两种调用方式，一种是实例直接调用（self 自动传入），一种是类名调用，但是需要传入 self 参数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;Hello!&quot;</span>)  </span><br><span class="line"></span><br><span class="line">xorex = People()  </span><br><span class="line">xorex.say_hello() <span class="comment"># 通过实例调用实例方法  </span></span><br><span class="line"></span><br><span class="line">People.say_hello(xorex) <span class="comment"># 通过类名调用实例方法</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>静态方法</strong> ，静态方法就等同于 Java 的静态方法。需要在方法前面加上 <code>@staticmethod</code>，通过类名访问。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span>  </span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>():</span>  </span><br><span class="line">        print(<span class="string">&quot;Hello&quot;</span>)  </span><br><span class="line"></span><br><span class="line">People.Hello()</span><br></pre></td></tr></table></figure><hr><ul><li><strong>类方法</strong> ，类方法有点类似于 Java 的静态方法，需要在方法前面加上注解 <code>@classmethod</code>，但是不一样的是，这个方法绑定了类本身，将类本身作为第一个默认参数传了进去，约定俗成这个参数名字为：cls</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span>  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">what_is_classmethod</span>(<span class="params">cls</span>):</span>  </span><br><span class="line">        print(cls <span class="keyword">is</span> People) <span class="comment"># 输出内容为 True，可以看到 cls 就是类 People 的地址。  </span></span><br><span class="line"></span><br><span class="line">People.what_is_classmethod()</span><br></pre></td></tr></table></figure><h3 id="类封装性原理"><a href="#类封装性原理" class="headerlink" title="类封装性原理"></a>类封装性原理</h3><p>前面说在属性或者方法前面加 <code>_</code> 实现约定俗成的私有，但是仍然可调用的私有方法。</p><p>而名字加上 <code>__</code> 则变成真正不可调用的私有方法/属性。其实这个方法/属性调用接口还是存在的，只不过被 Python 改了名字，改成了 <code>_类名__属性名/方法名&quot;</code>，只要前面加上 <code>_类名</code> 还是可以调用这个私有方法/属性的。</p><p>只能说，Python 没有完全私有，还可以调用。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="默认继承"><a href="#默认继承" class="headerlink" title="默认继承"></a>默认继承</h3><p>在 Python 中，所有没有明面继承其他类的类，都会默认继承基类 object！</p><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>Python 支持继承和多继承，使用方法就是在定义类的时候，在类名后面加小括号，里面塞进去要继承的类名即可，就可以将父类的代码当作在同一命名空间使用了。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>:</span>  </span><br><span class="line">    fatherStatic = <span class="string">&quot;FatherStatic&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        self.fatherField = <span class="string">&quot;FatherField&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Father</span>):</span> <span class="comment"># 继承类 Father  </span></span><br><span class="line">    sonStatic = <span class="string">&quot;SonStatic&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        self.sonField = <span class="string">&quot;SonField&quot;</span></span><br></pre></td></tr></table></figure><p>上面的代码就等价于：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span>  </span><br><span class="line">    fatherStatic = <span class="string">&quot;FatherStatic&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        self.fatherField = <span class="string">&quot;FatherField&quot;</span>  </span><br><span class="line"></span><br><span class="line">    sonStatic = <span class="string">&quot;SonStatic&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        self.sonField = <span class="string">&quot;SonField&quot;</span></span><br></pre></td></tr></table></figure><p>因此在这种机制下，继承了父类的代码之后，父类定义的类属性和各种方法都得到了继承，但是一旦和子类有命名冲突，因为子类的定义在后面，所以会覆盖父类。（一定会被覆盖的就是 <strong>init</strong> 方法，所以说父类在 <strong>init</strong> 声明的实例属性无法被继承后的父类方法和子类使用）</p><p>也因此创建子对象的时候，并不会像 Java 一样调用父类的构造方法。</p><hr><p>我们知道被覆盖的方法仅仅只是因为调用顺序的原因，Java 提供 super 实例来通过定义调用偏移量实现对覆盖的父类方法和属性的访问。</p><p>Python 则可以通过 <code>父类名.方法(self)</code> 名手动绑定 self 对象的方式访问父类中的方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;Father Hello&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Father</span>):</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;Son Hello&quot;</span>)  </span><br><span class="line"></span><br><span class="line">son = Son()  </span><br><span class="line">son.Hello()  </span><br><span class="line">Father.Hello(son) <span class="comment"># 借助类访问方法，需要自己填充实例对象 self</span></span><br></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>Python 的多继承就是在类名字后面的小括号里面，多写几个父类，至于命名冲突之后的访问顺序，请参考后面介绍的 MRO 机制：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father1</span>:</span>  </span><br><span class="line">    father1Static = <span class="string">&quot;Father1Static&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(Fatherfather1Static)  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father2</span>:</span>  </span><br><span class="line">    father2Static = <span class="string">&quot;Father2Static&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(Fatherfather2Static)  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Father1,Father2</span>):</span> <span class="comment"># 多继承 Father1 和 Father2，优先级从左到右  </span></span><br><span class="line">    sonStatic = <span class="string">&quot;SonStatic&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        self.sonField = <span class="string">&quot;SonField&quot;</span>  </span><br><span class="line"></span><br><span class="line">son = Son()  </span><br><span class="line">son.Hello() <span class="comment"># 说明 Father1 优先级高于 Father2  </span></span><br><span class="line">print(Son.father1Static) <span class="comment"># 继承了 Father1  </span></span><br><span class="line">print(Son.father2Static) <span class="comment"># 继承了 Father2</span></span><br></pre></td></tr></table></figure><p>但是上面的仅仅只是很简单的多继承关系，如果遇到了更复杂的，犹如很乱的多层树结构继承的时候，就需要根据 MRO 去分析了。</p><h3 id="MRO-机制"><a href="#MRO-机制" class="headerlink" title="MRO 机制"></a>MRO 机制</h3><p>MRO 全称 Method Resolution Order，方法解析顺序。</p><p>可以通过调用类名的类属性 <code>__mro__</code> 来获取类的优先级顺序，会返回一个元组。当然聪明的我们可以自己分析复杂的 <code>__mro__</code> :</p><hr><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span>  </span><br><span class="line">      print(<span class="string">&quot;CommonA&quot;</span>)  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span>  </span><br><span class="line">      print(<span class="string">&quot;CommonC&quot;</span>)  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B, C</span>):</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">print(D().method())</span><br></pre></td></tr></table></figure><p>对于上面的程序，把各个类的 MRO 记为如下等式：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类 A：L[A] = merge(A , object)  </span><br><span class="line">类 B：L[B] = [B] + merge(L[A] , [A])  </span><br><span class="line">类 C：L[C] = [C] + merge(L[A] , [A])  </span><br><span class="line">类 D：L[D] = [D] + merge(L[B] , L[C] , [B] , [C])</span><br></pre></td></tr></table></figure><p>注意，以类 A 等式为例，其中 merge 包含的 A 称为 L[A] 的头，剩余元素（这里仅有一个 object）称为尾。</p><p>这里的关键在于 merge，它的运算方式如下：</p><ol><li> 检查第一个列表的头元素（如 L[A] 的头），记作 H。</li><li> 若 H 未出现在 merge 中其它列表的尾部，则将其输出，并将其从所有列表中删除，然后回到步骤 1；否则，取出下一个列表的头部记作 H，继续该步骤。</li><li> 重复上述步骤，直至列表为空或者不能再找出可以输出的元素。如果是前一种情况，则算法结束；如果是后一种情况，Python 会抛出异常。</li></ol><p>由此，可以计算出类 B 的 MRO，其计算过程为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L[B] = [B] + merge(L[A],[A])  </span><br><span class="line">     = [B] + merge([A,object],[A])  </span><br><span class="line">     = [B,A] + merge([object])  </span><br><span class="line">     = [B,A,object]</span><br></pre></td></tr></table></figure><p>同理，其他类的 MRO 也可以轻松计算得出。</p><h3 id="父类的初始化"><a href="#父类的初始化" class="headerlink" title="父类的初始化"></a>父类的初始化</h3><p>因为 Python 的继承不会像 Java 一样，创建子对象的时候，是不会自动调用父类的构造方法的（因为方法覆盖，只会调用最后面的那个构造方法），所以如果要调用父类的构造方法来完成初始化，就要手动调用。</p><p>有两种方法：</p><ul><li><p>通过 <code>super().__init__()</code> 调用上一个优先级的父类的构造方法。</p></li><li><p>通过 <code>父类名.__init__(self)</code> 手动绑定实例来调用父类的构造方法。</p></li></ul><p>不过建议只在单继承中使用 super() 在多继承中只用后者。</p><h3 id="多态实现"><a href="#多态实现" class="headerlink" title="多态实现"></a>多态实现</h3><p>因为 Python 是动态类型，所以多态机制简直不要太好实现，根本不需要继承！！！</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">polymorphic</span>(<span class="params">self</span>):</span>  </span><br><span class="line">    self.Hello()  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;One Hello&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;Two Hello&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">all</span> = (One(),Two())  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">all</span>: <span class="comment"># 多态实现  </span></span><br><span class="line">    polymorphic(i)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h2&gt;&lt;p&gt;Python 中的面对对象中的概念中，和 Java 不同的只有字段，在 Python 中直接叫做 &lt;code&gt;属性&lt;/code&gt; . 并且 Pyth</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
  </entry>
  
</feed>
