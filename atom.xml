<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xorex</title>
  
  <subtitle>要成为世界上最幸福的人啊！</subtitle>
  <link href="https://xorex.space/atom.xml" rel="self"/>
  
  <link href="https://xorex.space/"/>
  <updated>2022-07-16T10:56:00.687Z</updated>
  <id>https://xorex.space/</id>
  
  <author>
    <name>Xorex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python-08-线程、进程和协程</title>
    <link href="https://xorex.space/2022/06/15/8bf79f16d228/"/>
    <id>https://xorex.space/2022/06/15/8bf79f16d228/</id>
    <published>2022-06-15T14:11:49.000Z</published>
    <updated>2022-07-16T10:56:00.687Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这章主要是：线程、进程和协程的介绍。</p></blockquote><p>串行、并行：关注着程序是否有同时处理多个任务的能力。<br>阻塞、非阻塞：关注着程序是否处于什么都不干的等待状态。<br>同步、异步：关注着程序的任务调用，是按照顺序完成一个调用一个，还是一直调用并等待依次完成。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="全局解释锁-GIL"><a href="#全局解释锁-GIL" class="headerlink" title="全局解释锁 GIL"></a>全局解释锁 GIL</h3><p>Global Interprator Lock 全局解释锁，因为 GIL 的存在，导致 Python 在一个时间内只有一个线程被执行。</p><p>Python虚拟机执行方式如下：</p><ol><li>设置 GIL</li><li>切换进线程</li><li>执行下面操作之一:<ul><li>运行指定数量的字节码指令</li><li>线程主动让出控制权</li><li>切换出线程（线程处于睡眠状态）</li></ul></li><li>解锁 GIL</li><li>进入 1 步骤</li></ol><p>采用 GIL 的原因是 Python 虚拟机采用引用计数法来标记垃圾回收。如果不加全局锁 GIL 的话，不同的线程在一个进程单位下，可以引用同一对象资源。那么并行访问就会可能导致引用计数的 线程不安全，所以才用 GIL 变成串行执行（引用是单个字节码）。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><strong>需要注意的是</strong>，GIL 是解决 <strong>引用计数</strong> 的线程不安全，并不会防止其他资源访问的线程不安全问题。比如下面的代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    t = threading.Thread(target=foo)</span><br><span class="line">    threads.append(t)</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.start()</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br><span class="line">print(n)</span><br></pre></td></tr></table></figure><p>n+1 这个代码的指令是多条组成，虽然是串行，但是线程丢失执行权时间不确定，就有可能有线程安全问题。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD_GLOBAL              <span class="number">0</span> (n)</span><br><span class="line">LOAD_CONST               <span class="number">1</span> (<span class="number">1</span>)</span><br><span class="line">INPLACE_ADD</span><br><span class="line">STORE_GLOBAL             <span class="number">0</span> (n)</span><br></pre></td></tr></table></figure><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>创建线程：<code>thread = Thread(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, daemon=None)</code></p><ul><li>group 为以后 Python 新特性 ThreadGroup 准备的</li><li>target 填写要运行的函数名，不带括号 callable</li><li>name 线程名 str</li><li>args 非可变参数，而是元组变量，按照函数的参数顺序依次填充被调用函数 tuple</li><li>kwargs 非可变参数，而是字典变量，按照 参数名:参数值 填充被调用函数 dic</li><li>daemon 是否为守护线程 boolean</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">name: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        print(name,i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置连个线程</span></span><br><span class="line">thread1 = Thread(target=count, args=(<span class="string">&#x27;1&#x27;</span>))</span><br><span class="line">thread2 = Thread(target=count, args=(<span class="string">&#x27;2&#x27;</span>))</span><br><span class="line"></span><br><span class="line">thread1.start() <span class="comment"># 开始执行</span></span><br><span class="line">thread2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># join() 链接，将这个运行点链接到某线程去</span></span><br><span class="line">thread1.join() <span class="comment"># 在 thread1 线程执行完毕之后再执行本线程</span></span><br><span class="line">thread2.join() <span class="comment"># 在 thread2 线程执行完毕之后再执行本线程</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Two threads are all accomplish&quot;</span>) <span class="comment"># 两个线程执行完毕</span></span><br><span class="line"></span><br><span class="line">thread1.close() <span class="comment"># 释放线程资源</span></span><br><span class="line">thread2.close()</span><br></pre></td></tr></table></figure><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>将若干固定的操作交给若干个线程执行，非常方便。</p><p>从 concurrent.futures 里面导入 ThreadPoolExecutor</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">name: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        print(name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(<span class="number">12</span>) <span class="keyword">as</span> t: <span class="comment"># 创建拥有 12 个线程的线程池</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">120</span>):</span><br><span class="line">        t.submit(count, name=<span class="string">f&quot;Thread <span class="subst">&#123;i&#125;</span>&quot;</span>) <span class="comment"># 依次提交线程要完成的任务，一共 120 个，分配个 12 个线程完成。</span></span><br><span class="line">    <span class="comment"># 执行完所有任务之后，销毁线程池，退出 with 语句，执行下面代码</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Finish!&quot;</span>)</span><br></pre></td></tr></table></figure><p>submit() 函数会返回一个 Executor，可以从中获取线程执行结果 result()。</p><p>记得要 submit() 完所有的任务之后，再去获取结果哦。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>多进程由于 GIL 的存在，没有办法并行运行，所以为了充分利用 CPU 的多个核心，就只能采用 多进程 的方式了。</p><p>当然，一个进程中可以开启很多线程来共享内存资源。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>从 multiporcessing 中导入 Process 类。</p><p>Process <code>__init__</code> 的参数和 Thread 是一样的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">name: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        print(name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>: <span class="comment"># 想一想为什么要在 main 中执行</span></span><br><span class="line">    process1 = Process(target=count, name=<span class="string">&quot;Process 1&quot;</span>, args=(<span class="string">&quot;1&quot;</span>)) <span class="comment"># 创建新进程</span></span><br><span class="line">    process2 = Process(target=count, name=<span class="string">&quot;Process 2&quot;</span>, args=(<span class="string">&quot;2&quot;</span>))</span><br><span class="line"></span><br><span class="line">    process1.start() <span class="comment"># 启动进程</span></span><br><span class="line">    process2.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    process1.join() <span class="comment"># 等待两个进程执行完之后再运行</span></span><br><span class="line">    process2.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;Finish&quot;</span>)</span><br><span class="line"></span><br><span class="line">    process1.close() <span class="comment"># 释放进程资源</span></span><br><span class="line">    process2.close()</span><br></pre></td></tr></table></figure><h3 id="无限引用问题"><a href="#无限引用问题" class="headerlink" title="无限引用问题"></a>无限引用问题</h3><p>上面有一个问题，就是为什么 Process 的启动必须在 main 中。</p><p>这是由于在开启一个新的进程的时候，需要资源是相互隔离的，所以要复制一份到新的进程中。</p><p>那么在导入本 py 文件的时候，如果线程创建不写在 main 中，导入过程就会执行线程创建，就会再次复制资源到新的进程并在导入，然后进入死循环。类似于循环引用，不过是我引用我自己。</p><p>所以写了 <code>__main__</code> 中之后，就不会在导入过程中不停开新的进程然后再导入了。</p><h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><p>用法和线程池差不多，下面是大体结构：</p><p><img src="https://xorex.space/image/341.jpg" alt="341.jpg"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">name: <span class="built_in">str</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        print(name, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(<span class="number">5</span>) <span class="keyword">as</span> p:  <span class="comment"># 开一个 5 个进程的进程池</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            p.submit(count, name=<span class="string">f&quot;Process <span class="subst">&#123;i&#125;</span>&quot;</span>)  <span class="comment"># 提交任务</span></span><br><span class="line">    <span class="comment"># 结束线程池所有任务，继续执行下面代码</span></span><br></pre></td></tr></table></figure><p>submit() 函数会返回一个 Executor，可以从中获取线程执行结果 result()。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>这里的异步主要是指 Asyncio 对所有处于 IO 状态的代码进行切换异步处理，等到 IO 加载完成之后，再继续回来处理代码，减少因为等待 IO 浪费的时间，等待 IO 是可以并行等待的。</p><p>这里的 IO 有很多，比如打开文件进行文件读写，网络请求与发送等等。通过 async 进行协程任务标注，通过 await 进行协程调用。</p><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><p>async 表示此任务是异步的，在协程事件队列可以随意调用然后等待事件结果返回。在函数前面加上此前缀，函数会会变成一个协程对象。 </p><p>await 表示此处调用了可等待的任务，只有发来了等待结果才能继续往后面运行，是协程对象中的代码支持的功能。</p><p>下面的代码借助着协程的 异步非阻塞，实现了单线程 3s 的执行：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">function</span>():</span>  <span class="comment"># 一个协程函数对象</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)  <span class="comment"># 只有在协程中才能使用 await 异步等待执行结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        task = asyncio.create_task(function())  <span class="comment"># 将协程对象包装成 任务 Task 如果有参数，这里可以直接填写 function(xxx)</span></span><br><span class="line">        tasks.append(task)  <span class="comment"># 填充任务列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> asyncio.wait(tasks)  <span class="comment"># 异步调用 asyncio.wait() 负责将列表内的任务依次添加到事件循环中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())  <span class="comment"># 创建事件循环，把 协程 main() 加入事件循环中，开始执行事件循环</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是，协程不同于线程，启动一个线程之后，是不影响主线程的继续执行的。但是启动了一个协程，主协程会等待新协程执行完毕之后，再去执行后面的代码。</p><p>所以下面方式创建多个协程运行是会 阻塞 运行的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> function()</span><br><span class="line"><span class="keyword">await</span> function()</span><br><span class="line"><span class="keyword">await</span> function()</span><br><span class="line"><span class="keyword">await</span> function()</span><br><span class="line"><span class="keyword">await</span> function()</span><br></pre></td></tr></table></figure><p>应当使用将一个协程对象通过 asyncio.create_task() 转化为任务之后，组成一个任务列表 tasks[]，然后借助这 asyncio.wait(tasks) 将这些任务全部加入到事件循环中之后，再启动异步执行。这样这些任务就可以再 IO 的时候被事件循环控制跳转，实现非阻塞执行。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>协程在单线程中实现 IO 的异步非阻塞借助的是 事件循环 event_loop。</p><p>每一个协程对象都是一个事件，被添加到事件循环之后，可以被 asyncio 的控制下，遇到 IO 就切换到另外一个事件去执行，直到等待到 IO 的执行结果，再跳转回来执行。每一个对象执行的跳转，都在事件循环中。</p><p>所以我们执行一个协程的时候，需要借助着 asyncio.run() 创建一个事件循环，然后把参数：协程对象 加入到事件循环中，启动事件循环的执行。</p><p>协程对象每运行到 await，就会把它加入到事件循环中，以协程的方式执行它，当它执行完毕之后响应执行结果，然后跳转回来继续执行 await 后面的代码。</p><h3 id="async-with"><a href="#async-with" class="headerlink" title="async with"></a>async with</h3><p>异步的上下文管理器，比如异步的网络会话想要通过 with 来进行上下文管理的时候，就需要加上 async with，来保证异步资源在被管理的时候，可以执行内部的异步代码。比如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># async with 可以用 await 调用后面的资源生成，也可以用 await 调用最后的 close 实现管理过程的异步调用</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">    session.get()</span><br></pre></td></tr></table></figure><h3 id="async-for"><a href="#async-for" class="headerlink" title="async for"></a>async for</h3><p>用来迭代 异步可迭代 对象：</p><p>一个异步可迭代对象（asynchronous iterable）能够在迭代过程中调用异步代码，而异步迭代器就是能够在 next() 方法中调用异步代码。</p><p>1、一个对象必须实现 <code>__aiter__</code> 方法，该方法返回一个异步迭代器（asynchronous iterator）对象。<br>2、一个异步迭代器对象必须实现 <code>__anext__</code> 方法，该方法返回一个 awaitable 类型的值。<br>3、为了停止迭代，<code>__anext__</code> 必须抛出一个 StopAsyncIteration 异常。</p><p>上面的内容不用管，你只需要知道如果被迭代对象是一个 异步可迭代 对象，那么就用 <code>async for</code> 即可。</p><h3 id="异步协程库"><a href="#异步协程库" class="headerlink" title="异步协程库"></a>异步协程库</h3><p>要通过协程的方式 异步非阻塞 执行 IO 任务，就要要调用的 IO API 也必须是 async 类型的协程对象。如果对应的 IO API 没有异步实现的话，就只能借助多进程来完成了。</p><h4 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=Script.headers) <span class="keyword">as</span> response:</span><br><span class="line">        content = <span class="keyword">await</span> response.text(encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">        content = <span class="keyword">await</span> response.json()</span><br></pre></td></tr></table></figure><h4 id="aiofiles"><a href="#aiofiles" class="headerlink" title="aiofiles"></a>aiofiles</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(fileName, mode=<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">await</span> f.write(text)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这章主要是：线程、进程和协程的介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;串行、并行：关注着程序是否有同时处理多个任务的能力。&lt;br&gt;阻塞、非阻塞：关注着程序是否处于什么都不干的等待状态。&lt;br&gt;同步、异步：关注着程序的任务调用，是按照顺序完</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
    <category term="线程" scheme="https://xorex.space/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="进程" scheme="https://xorex.space/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="协程" scheme="https://xorex.space/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>爬虫-03-简单案例记录</title>
    <link href="https://xorex.space/2022/06/15/7c2756a86cb3/"/>
    <id>https://xorex.space/2022/06/15/7c2756a86cb3/</id>
    <published>2022-06-15T09:29:08.000Z</published>
    <updated>2022-06-17T12:41:56.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="regex-正则表达式"><a href="#regex-正则表达式" class="headerlink" title="regex 正则表达式"></a>regex 正则表达式</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取豆瓣前 250 的电影信息，包括名字，评分和电影 slogan。</span></span><br><span class="line"><span class="comment"># 主要是使用了正则表达式 .*? 进行内容忽略和 (?P&lt;group_name&gt;.*?) 将获取的 html 信息进行提取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> WebConstant</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pattern = <span class="string">r&#x27;&lt;li&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;.*?&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(?P&lt;rate&gt;.*?)&lt;/span&gt;.*?&lt;span class=&quot;inq&quot;&gt;(?P&lt;slogan&gt;.*?)&lt;/span&gt;.*?&lt;/li&gt;&#x27;</span></span><br><span class="line">regex = re.<span class="built_in">compile</span>(pattern, re.S)</span><br><span class="line"></span><br><span class="line">movie_list = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    url = <span class="string">&quot;https://movie.douban.com/top250?start=&quot;</span>+<span class="built_in">str</span>(i*<span class="number">25</span>)</span><br><span class="line">    response = requests.get(url, headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>: WebConstant.USER_AGNET&#125;)</span><br><span class="line">    response.encoding = <span class="string">&quot;utf-8&quot;</span></span><br><span class="line">    text = response.text</span><br><span class="line">    groups = regex.finditer(text)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> groups:</span><br><span class="line">        movie_info = &#123;&#125;</span><br><span class="line">        movie_info[<span class="string">&quot;name&quot;</span>] = i.group(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">        movie_info[<span class="string">&quot;rate&quot;</span>] = i.group(<span class="string">&quot;rate&quot;</span>)</span><br><span class="line">        movie_info[<span class="string">&quot;slogan&quot;</span>] = i.group(<span class="string">&quot;slogan&quot;</span>)</span><br><span class="line">        movie_list.append(movie_info)</span><br><span class="line"></span><br><span class="line">print(movie_list)</span><br></pre></td></tr></table></figure><h2 id="Xpath-路径定位"><a href="#Xpath-路径定位" class="headerlink" title="Xpath 路径定位"></a>Xpath 路径定位</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主要是记录 xpath 的使用过程。</span></span><br><span class="line"><span class="comment"># 通过 xpath 实现对八戒网的店铺、价格、地理位置信息进行提取。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> WebConstant</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://chengdu.zbj.com/search/f/?kw=logo&quot;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: WebConstant.USER_AGNET</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">response = requests.get(url, headers=headers)</span><br><span class="line">response.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line"></span><br><span class="line">html = etree.HTML(response.text)</span><br><span class="line">etree.parse()</span><br><span class="line"></span><br><span class="line">divs = html.xpath(<span class="string">&#x27;//*[@id=&quot;utopia_widget_76&quot;]/a[1]/div&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> div <span class="keyword">in</span> divs:</span><br><span class="line">    print(div)</span><br><span class="line">    price = div.xpath(<span class="string">&#x27;./p/text()&#x27;</span>)</span><br><span class="line">    print(price)</span><br></pre></td></tr></table></figure><h2 id="Session-登录会话"><a href="#Session-登录会话" class="headerlink" title="Session 登录会话"></a>Session 登录会话</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取  17k 小说 登录之后的书架内容</span></span><br><span class="line"><span class="comment"># 通过 Session 实现登陆后自动发送 Cookie，实现登录内容获取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> WebConstant</span><br><span class="line"></span><br><span class="line">login_url = <span class="string">&#x27;https://passport.17k.com/ck/user/login&#x27;</span> <span class="comment">#登录</span></span><br><span class="line">collected_books_url = <span class="string">&#x27;https://user.17k.com/ck/author/shelf?page=1&amp;appKey=2406394919&#x27;</span> <span class="comment"># 返回收藏书 JSON 数据的接口</span></span><br><span class="line"></span><br><span class="line">session = requests.session()</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    WebConstant.USER_AGNET_KEY: WebConstant.USER_AGNET</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;loginName&#x27;</span>: <span class="string">&#x27;BookLoverTempest&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;tempest&amp;2001618&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">session.post(login_url, params=params, headers=headers)</span><br><span class="line"></span><br><span class="line">collected_books_dic = session.get(collected_books_url).json() <span class="comment"># JSON 转 dic</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> collected_book <span class="keyword">in</span> collected_books_dic[<span class="string">&#x27;data&#x27;</span>]:</span><br><span class="line">    print(collected_book)</span><br></pre></td></tr></table></figure><h2 id="防盗链处理"><a href="#防盗链处理" class="headerlink" title="防盗链处理"></a>防盗链处理</h2><p>一些视频的 URL 地址并不是完全显示在 JSON 中的，可能会 JS 进行加工处理，所以需要找找 JSON 和实际地址之间的关系，进行处理。</p><h2 id="多线程-多进程"><a href="#多线程-多进程" class="headerlink" title="多线程/多进程"></a>多线程/多进程</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对 北京新发地 菜市场价格信息进行爬取</span></span><br><span class="line"><span class="comment"># 采用 进程池 进行多进程爬取加速（爬虫还是推荐 Asyncio 或者线程池）</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> WebConstant</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.xinfadi.com.cn/getPriceData.html&quot;</span></span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&#x27;current&#x27;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    WebConstant.USER_AGNET_KEY: WebConstant.USER_AGNET</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getItemPrice</span>(<span class="params">current: <span class="built_in">int</span></span>) -&gt; list:</span></span><br><span class="line">    params[<span class="string">&#x27;current&#x27;</span>] = current</span><br><span class="line">    <span class="keyword">with</span> requests.get(url, params=params, headers=headers) <span class="keyword">as</span> response:</span><br><span class="line">        <span class="keyword">return</span> response.json()[<span class="string">&#x27;list&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    items = []</span><br><span class="line">    executors = []</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">with</span> ProcessPoolExecutor(<span class="number">12</span>) <span class="keyword">as</span> p:  <span class="comment"># 开 12 个进程的进程池 6s</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):</span><br><span class="line">            executors.append(p.submit(getItemPrice, (i + <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> executor <span class="keyword">in</span> executors:  <span class="comment"># 等多进程分配执行完了，再去获取结果</span></span><br><span class="line">        items.append(executor.result().copy())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in range(101): # 顺序执行 44s</span></span><br><span class="line">    <span class="comment">#     getItemPrice(i+1)</span></span><br><span class="line"></span><br><span class="line">    print(items)</span><br><span class="line">    print(<span class="built_in">len</span>(items))</span><br><span class="line">    print(time.time() - start)</span><br></pre></td></tr></table></figure><h2 id="Asyncio-异步编程"><a href="#Asyncio-异步编程" class="headerlink" title="Asyncio 异步编程"></a>Asyncio 异步编程</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用异步的网络请求 aiohttp 完成对网络小说 斗破苍穹的爬取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> WebConstant</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Script</span>:</span></span><br><span class="line">    url = <span class="string">&#x27;https://www.ddyueshu.com&#x27;</span></span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        WebConstant.USER_AGNET_KEY: WebConstant.USER_AGNET</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        chapters = self.getChapters()</span><br><span class="line">        loop = asyncio.get_event_loop()</span><br><span class="line">        loop.run_until_complete(self.toDownload(chapters))</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getChapters</span>(<span class="params">self</span>) -&gt; list:</span></span><br><span class="line">        chapters = []</span><br><span class="line"></span><br><span class="line">        response = requests.get(Script.url + <span class="string">&#x27;/1_1600&#x27;</span>, headers=Script.headers)</span><br><span class="line">        response.encoding = <span class="string">&quot;gbk&quot;</span></span><br><span class="line">        pattern = <span class="string">r&#x27;.*?&lt;dd&gt;&lt;a href =&quot;(?P&lt;url&gt;.*?)&quot;&gt;(?P&lt;name&gt;.*?)&lt;/a&gt;&lt;/dd&gt;.*?&#x27;</span></span><br><span class="line">        regex = re.<span class="built_in">compile</span>(pattern, re.S)</span><br><span class="line">        groups = regex.finditer(response.text)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> groups:</span><br><span class="line">            chapter = &#123;<span class="string">&#x27;name&#x27;</span>: i.group(<span class="string">&quot;name&quot;</span>), <span class="string">&#x27;url&#x27;</span>: i.group(<span class="string">&quot;url&quot;</span>)&#125;</span><br><span class="line">            chapters.append(chapter)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chapters</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">toDownload</span>(<span class="params">self, chapters: <span class="built_in">list</span></span>):</span></span><br><span class="line">        tasks = []</span><br><span class="line">        <span class="keyword">for</span> chapter <span class="keyword">in</span> chapters:</span><br><span class="line">            task = asyncio.create_task(self.download(chapter[<span class="string">&#x27;url&#x27;</span>], chapter[<span class="string">&#x27;name&#x27;</span>]))</span><br><span class="line">            tasks.append(task)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">self, url: <span class="built_in">str</span>, chapterName: <span class="built_in">str</span></span>):</span></span><br><span class="line">        url = Script.url + url</span><br><span class="line"></span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">            <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=Script.headers) <span class="keyword">as</span> response:</span><br><span class="line">                content = <span class="keyword">await</span> response.text(encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">                html = etree.HTML(content)</span><br><span class="line">                text = html.xpath(<span class="string">&#x27;//div[@id=&quot;content&quot;]/text()&#x27;</span>)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;./斗破苍穹/<span class="subst">&#123;chapterName&#125;</span>.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(<span class="built_in">str</span>(text))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    Script()</span><br></pre></td></tr></table></figure><h2 id="selenium-使用"><a href="#selenium-使用" class="headerlink" title="selenium 使用"></a>selenium 使用</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Edge</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"></span><br><span class="line">browser = Edge() <span class="comment"># 创建浏览器对象</span></span><br><span class="line">browser.get(<span class="string">&quot;https://www.lagou.com/&quot;</span>) <span class="comment"># 访问目标网站</span></span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">browser.find_element_by_xpath(<span class="string">&quot;/html/body/div[10]/div[1]/div[2]/div[2]/div[1]/div/p[1]/a&quot;</span>).click() <span class="comment"># 定位并点击</span></span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># send_keys 进行键盘输入搜索内容和回车</span></span><br><span class="line">browser.find_element_by_xpath(<span class="string">&quot;/html/body/div[7]/div[1]/div[1]/div[1]/form/input[1]&quot;</span>).send_keys(<span class="string">&quot;Java&quot;</span>,Keys.ENTER)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 定位所有搜到的结果</span></span><br><span class="line">elements = browser.find_elements_by_xpath(<span class="string">&#x27;//*[@id=&quot;s_position_list&quot;]/ul/li&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开所有搜到的元素</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">    element.find_element_by_xpath(<span class="string">&#x27;./div[1]/div[1]/div[1]/a&#x27;</span>).click()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 获取搜到的内容，然后关闭页面</span></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">    browser.switch_to.window(browser.window_handles[-<span class="number">1</span>])</span><br><span class="line">    print(browser.find_element_by_xpath(<span class="string">&quot;/html/body/div[1]/div[1]/div[4]/div[1]/dl[1]/dd[2]/div&quot;</span>).text)</span><br><span class="line">    browser.close()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;regex-正则表达式&quot;&gt;&lt;a href=&quot;#regex-正则表达式&quot; class=&quot;headerlink&quot; title=&quot;regex 正则表达式&quot;&gt;&lt;/a&gt;regex 正则表达式&lt;/h2&gt;&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
    <category term="爬虫" scheme="https://xorex.space/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>为美好的世界献上祝福</title>
    <link href="https://xorex.space/2022/05/20/567f91f8bbba/"/>
    <id>https://xorex.space/2022/05/20/567f91f8bbba/</id>
    <published>2022-05-20T11:58:03.000Z</published>
    <updated>2021-06-05T16:47:14.015Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="012291ade27e2252807099f5458dffca8691af597c47118762b56028f94a1a98">8a972074cb8fb594adf191142c932486f63d9db6a4bbbbf65eb58b44e7f3a502ca39de9d3c1e3d9c70fdc9a01ad868dc3486910eced5f4e34f64df4c5155d0e28740e7f637329c5391f9bbe6ff64e653a789e2cef71c949e21aa63f2fba5c2f8909ab81d64320e8cb4384ed74fbebab2050cb82c4a7d22b4b9fd24d8a61fc8d8029f2ecbce16d7ac4071fe5c0ae2c3425b4c421b4a82a69b6012152d7d464a3624e786c960a03a52f9cd3453ffde3f9e7f7f8db1b21b9fd158b70d49126036880e6f581475aa1c9265c50093981c7c70663d0a1e3bede2870b4a7e0a6dc0d1a1ce8dbc658189e95bd6888f0f4d48bc8d7fa179df02ce8435ed223754c508e2b86eb7748ba754993eb71d24a37e5f551d0164956aa4d5dd5f723185894b6581fdc9638900b4666fa18e9bd6f6874b22c630932f62849d260f383329527390267e1ae61d8591c4aeb352f4b29108c2465a5e074d349edb5a9af79cb59ade636bb557cc6cdecd797157def65921204d200554354bc3d381c49d4097e92d1d51fd01c2313cff9d6502cf7e7f4b2399cc1e6be251d80c7050309bf346d386a7b536645f5c4c96178bc331da5740a42b0bd02b9968ce31b992b998e972e1dd06841a9d53b1d8280616027ac636ce646b67ae2c98a4b2ce990afefc45bd9b4d068c8fde09917cd2e84b9ffdf59606a1a60816d2f994703dfbbad7039e96e0b658292bacb1858ba7d9e49eb3187431fa4a1f8363915dc73aad3d519447f7cc0ff818de1453e2ab8257e0057131b57981825fc2c9f788e75c5564eb2ad8404bab6a82c47ab0a53249beb3b2306c2e5554ac2302070a4190176ddf1f1a7c9f4e483174777de2b527a91c806a1327390ff9a7eb985697c66546afc772628cec06b528dccdd1cb1d1d13ad8f74668fa5f5d0195cde6adade74f3ee1870b9a5da2542345b0f3ccb4e45aa3e4ca19ee469c348bc52b7c915f9fd94f14a9ce369c3d58e5c0e6550c9e6944437b122bacc312d2eaf41ec6165983d4afd819eb351ba8b730ee916f9cd78fef8008dcb9c56e63761799af98a3a7f796a1fa589fb9951d440a514e59ecf489a527c3a856fb48273361bc634d065d3e1833fc4a3b59e3f44008e8a1565a63506724732b84253673b58773214fb18c6f216ce7f94a3000979160f8fbe89f7300870c0103288288d986af8c35cf489154c5116b9e29ea3806b83fb4fb5c13bf5fac94b9fbb3d4dbc0a39cf185ce78c526bc7ed204162cdae47a4d016b2d81ea2ba9fc9830fb3527f1841ccf23061c0b80b53f3ae74c11c56b01d7711482081a2fcee250f16af2cb412ec812dc57d4d1d6985a692f17764a8bda6787d62fb8612eb25c70420071fd319dbc83c5d7f8ab892ebe088697c5f2833a61978a2b3c68e6916e569324b6bba4123401b6cccf173cb6f5f16b310bd23c631794739ed100cba1697a02e0cd558489edd5b9fb774265919385617ef45af3e351137e2be1db5a0dc536cc5ab5a80897d655a4da942de4a3fc9462a7d2eb6b49a288980210c8bf4649156b1e7d1f2c6e6eb1b8cb056067a2306541b7828ad3c48713b7ddcd33bdc4c83aec20ea2f4812ad03fedb8d33e6214f83ca38ffcbb55ca3859cd0cf07b65dd04174589117adf9d5c76448c6786447889122c612fb0ba366bfd64384a5162e27375fa7747622c6cf3b1c9c09bae41d179b1ac15d3cdd3254c2498e37f38e8b43b6620a7898afadb4e74414a7783ae2ffefd6aaac8cd082f33fa0abb3c8271690175664331e3053092c2b6abbf7e66adb0530ddde01a965e6abe809db7bd6d79229a09bd7df84c25da01c92e73a035e2667a75229c48e889842fbd0a1d7dbf7c579292b8557b8f400157e95b2864450dc73474ca6520544b623d98a0445e62a98d184853b6cf236e48ffe6ede26b4ca737f3f8c2f19701125867ec08135ca682b3cedc732362def3eefbf16d0327fedf680a5dc50bbb5590feeffc83a065c7c09fee680f2395508e418e59c28bcce45dcb357e95c2590a7ef9049d04d6bdbebce82c03d09be7d60c90ff409231a5b8df0091ede2ea2abe007dce72a5565fa7792a143ea45e0f14c3eed8ac989811cb44a0cb0fa483aa5f25831ccd3124d07a5558b126178f10f3600a554228513b55f48fdc6ca3d88c9a4203c3f729197919ecaff8376f9535fd87232cb896294f9fc4fdb1c094dc5b8c13fc9c0af0f6d5d0649aceb4beec719f7032a9d68ec16a1f386654f29e0adf7ade3d6d883067a74baa45dd07ca46c074be4a2d4d3cedd9cb43aa79ea8605e4a843d693cd9a062524820c3ae94cd3ba631d7d2c844b4cfd17570d07e02bb79c647880cb8f4a0614ff595bd22cff36fae33ba66ff6b9614ce43b5e2c2e2103b2a7c36dee450c0294e61645f1ff62b02acba1a876583591a53d9995c97318865eac82e9ab2d7daaee2edc69d2f6240b9cb98c8f3cc1c140d3ccfdb1894a3a9ae4db3704f4bef50c79ed660d72c4d76ca15c7b090c3a3ec8b6a1663e8ef6b80b33a790d75a8f2cab63863cfbab878fb45829ac4b30877f4b44ebb6fb1bd3deef6d4bb492d9e8dcd8f44dfda2afc59f9957524ddc5a9d26235be96e405f99fc668073799bfc29c611f3d097c9bef8404dfd98753bd059c4ccb2dc28284fa4d26f7388f29f063c5924d5d793e65af69eea2a654c3ca088ed576cea7a496de608c7fdc8adf94e22690d642584b9d121a80980bff1d66f2dbc7abf03c7272b4bd1f74df56756a806d0e76f293912b968b023f95efc0779c20497e818842577470c33cf1f1412cea0944a4fa2cd2a145d2a4dc588712f11729cb1233d6eabd234e0556425985afe3cf2518e4f70bbf31c038d5c335f500e0125cd3429ce768886381d9bf7fa0236a3449fd423c501be99daf36e54f58f09e63462c975afb417a015bd5f4a918f66f022aa79981cb82c29087351b1afe7b5051ad3712c3150e62f9d01f429d0b1050f348592d09d22cd5dc3409e3d11e7664dc114d8c37160b9d39f7d594813fd90cd23ac43c86cce7f22a0ecc46e9c77c1a1097fab3af5c9e0bbd893630d1db32066c3aeb8544e5a3b1e9f4905a3685a041e7921c29f7eb36041f276e3de9da457c90c0a4e9b1ec38db531d7887628745c5f26194ad2c2bc892a0e62a63be8e7162540b04696ee38d1ffa3deef3f110517e9813d259eb2617581819a50a37da390650ba8a86f576db6036fe772c8f8d2b15633f5d1905f11d452d62d67121d9a7d30cf26419c7100f2f51a3f0f8597048cda90b68b1b86116671fed5953d70fa552b04bcd54001afaaa291346a9eef0cb871f350a08a2e2ad3ead37fbe7af6c5ea3fbb4e2af874efb0d4f33d149f83b525500d0d106ae12249119307c0242bcfff7425822d2f61aae575154c5499f03b06da9bdfabf4707602c20b2eb9173a7f01dd7ea77e0b44303670982c11b53a5603e22cc74ca166846ef28697572ae88504db22754792584f45a2a559813081ab34c8641550dc1259ba7cc55de0d8ea0ae7ab83afc533113272ad893f0106a087e6bd0eb90c464eca576a7a217ef654ea365834f37076cec52bb40f7c2ec76ca2fdfd93511f3132b68d5279d42422d4562ad20cba8e76ddf4570fdeb4a0b1e63f2b87edf688afd4f51ae842b14864a528c57686385e5e763d175bf04d26ffd612a90f5d5ed0d49d6dbd4e472a192665afa263e1d9c2dfafb17858b59b5957992af881daf5231757ae0a3733d0e032415f2e6147113228b4c342045de3f73e08d00f893f7c05ab15b64603ef42b1e300b879fe6a8703d130048a0ef4c43a0f5aae256cfbd422f76818720e45572b16b6aae06c7c9a8a2be60d6bc205e8a0bccfea6660196c6ccb73571d9fce6aec0dbf9a211c12769ce9f1d4d2dcaccffc5049e92fc42abc59c6b952abf55ce944bd619f23f17700a194a95daeae67c69a289b48ac154619c185012cae1d913657e9fcc2ea89ededbd49813fddef2a842336a0a62385844b872a5c648b7ab23e2015579b053780d4c2fc01e621dfdb0f169723e26e319948f6355a3d52c26774488a5f43a1d574e80c78730f8b825210e3a93d5b904cd14d74f09255b74f5e5185d35713038bfecaff6c4cbc9c3e6b3638c64ed1af85cd0746586e41377fa167c73f22a605639878844d9a73dc5c244e02e359c3ae6cb62540b36a4b5e2150898258f2f86d881fb21d0e5c1c4e3552eb48159529396d53cc96ff48320c1406acc328fe9c1cddb62363481ed658ec32273b5f6149e80d7f111cad43e8f989c6f9609f194d18319b7932ce1854265e28c93ad307ee5f638c795b49f625b6783187862743df526a3da373e9e814846ea92343d3d5979772a38dec79be44317f0c75efadac03409fc473af07b7c47adb8170959bb5d20d41362e96ff110bbecd6edb3a7fef4bab4470423113aa367d0e8a2425c87bd98550ac0e7db65c9c7d32db12cff2bcfa81cda4e41d0b308f9578b4b1e5d5794d5ce80ad0ef7eed3cf3039f85c28d6fc247f3e04e4da416c126c6a7453431952565dbd973ceb410451246d221b4c4c59bb45dc1e8f01d15456e4bc59b26feee41aa8ef0356eab5d03e4a9cced9df106708a16de62ca4bf2d9ca503747ed9f4b6b664916a7bf851b7392e1e71ded53d2576c775e15be1a4502a80dd2f5c34808e17f642d8a987ec273b5d0868a114466b331e563ac674abec48fd6783c8624a06a92dc359b3efbc0e9c28aa832f4a61417ff2859ddbda7ccc5617d1a9d17ce2843ea48c7b5bddf9e2d79aeae9d844002cae5545cceded9192bb31c3b49b7723b30da30318015acd6f16cabae11f2f2d197f0b0097fe222019bd1e82d6fb82b1b7a240b0be445cef0404adc7c55a1ff0bf296c88b6be1ce1b0083dd453c5a91cf01c0abe097a59f9f5771310187ee251f978945d21311f01ed29eb1ded81deda69d472642b543e0e8bf92781a96f9e576e3172770483f69c15fea7ec986b796d1a5c1f0a08e96b1090dd9119f840d9c016ac32b8cf483f3986934121380be1af639c7efc0ce4f4429aa99eabaf015c4f81a232aa9d030faa9c401c118532146e91ea4ccb77bbe21995fcdb4f16409a41715920a010d8adbca438d7c94852563dc36af172bd19e552fe44a45222fc43fe10e7ba6d4d857156399cd143de7caaeb001e14fcb3d03be87ea1717c748bce8c47ad170f8170c159e37f533dc7f0415eeb55dd07c7c28b7358f4cf62b257b6e3d972ee8d75e04c673e0cd267ac89badebc34fa445f6cac623c9ee9447556c5149db450291ba01c3dc62ebc7661da869d3c7f23b853f29af418a41890aab8c1093ba44d46019deb75043ee8b76f9fc9fbd149ad4b72cec822e73c8d5c7facb05c8f3a404555c216f48bfb128c0db6910ed237c0cfeeafd9bc148bcdeca9af6de8d62812f53993ddff62692c29cf224805fe835a5a7d84d12a815dc39e5b3877bb7236ee2fdb537e4660065e7d618dfcc74bed3f384389b92c7e3a1165f2f309b6b8f0048c1ba81e4c7b4031797b70d94ba8b5efddc4a7cbac0e8e1f9d86c4557ba4052e512eb33accc086d66f1fa47f8a3295bb6a795b32019d8f6b6d3f51b0fb68f4b150f2456de87e6635257797d016f5b64cdfc6f6cf2b1f4721068f71a4a0e96f233727c52d07d9e4e2e107a429fd2ede833b47069a37c0ec9f18b4c0eedb8fec64123c2c4206873890b4ecd4ae8a3b8b9b5f7abee5669d3eb00227dcb00220692ff0c1f5077608540d88029e1afa1377566a1acbac99284cb80939462da62f5b120feac6bbea8e9ebf09d60a606b0fc7b8734f94c57564dda534e6c5690f3552b201b0abd5830ead08e1f9dd7acda727080546ee410682baa35b2ebca77b0ea3611f6d3f2c045e0cda86fb67db751b2f5853f2a5758d0e7fd46001e1b13491fc9afb3d1c4ae7d6c416294b782ab4fcbacb5d031696fc2d113f7cebc4909b4587f78fa79ee23e89f67cc0cf72ee71453c268afd41c7f77187f53210b67ea8971152da7484b1ae59fa6e261ec1c6d2ec5b28e6752b2ac303e06e84cb9b900f2c94aa4b04fa26614e5c987b4eb301e417e7b17d949ebd3198e186cd5f780769224afde5b9c7f62eb274bc08e8b1d7dec13353c8188bd13ac4201b1715ac5ab3e13359d3609d8788aec892f7c2c562d7fcf32fffe7cfda4546e0f2e87d9ad5d55d3764567f2c728a963aeec901999062c0d69e04de39c2404a63256eac80129a1cc4b60ffc6cb52c68c1c7296b80a7b8cf9d271d43a2f442c6d8e87586df80fa8950aa5d9c756b44e1387b49b0eaa8fd1dc130961edf11f5ab9a2d67df0352580b417ba413199f7895948c8fef806d1f4970f8f6c855a7dfb1444914cb4f8960fefcfd3232d43c663a3fc1b5c6fd75cccc1b931fc7d3cb67ea4f86a5b2c9faae0edb0c616016561d119a3545e3c623f4e05e48d0dad9561944355ef77fabaf956d8e49b4e457fd8ccbbccc04f85e3f305e4eb5762da81ca55ade45b448423cf9113a359897c20b979c3ae9856674811c382a96eb7b2e06c5e96e533a4a5230066346617a7878b0dc5e45cbff9e337c7d684c85e3a7e9778d830835efe5ccaa0a8ca539c43f19c812aefe5ae68f3dd645486fcbe07023c6179674c8db5c3b7fa7d87841c1f89531be56c7607212d49d338295e585f460b6cadc2a847c37d6475a479fbe5840095f08b11f63d0c026dc0b2ac1ad490ff4ab72e42aa9b1d82d013a93d74f13d3dda95480ad71846f5606022eff22e7fbf7cd2225ed25cbd99a08691ce9172f2f234a4ee8b222f9d267b771fa8a03dccf1ba76ea6b88ab74175463aee9e07bf8ed86656fd619f9eae521dbfc303015bc392fd7651a66beae8995c502d76802f36db66a7fbff7c2867c8b3d2ce2962819b1422dc4af4bbd597e4d41ae9a3c7f90b0882e3034087baf9f7463f24f6a6021dc87f029b884156d52d00f22f9cf5f9f79c75a78233dc9e8fb33d4cd7988972d5f5b3e855b5a694e5b7ffc104b6f1d133c523356588dea18e05c90e5bdd1188ff79411338edd8b6a4bae775aad5b46a9b8fa225a2ee0f7e896aa002edaaff9fbaeaa4647a7cb2bd87fbce5d687c637d8301977a2446c38997317a44a20323790b4c47fc1d20d485edd8025d0e38ce428aa61217535d61eb7508beefbf44c12906dc991164aead928a76c2139d1ecc006338942fedabd88d817ed1374d9408f0d7e9c9b153b78ee8bf11c79973ab0ffdf1889ee783f772c31f22904834f017396e2fe424ed661e2d830657f1840b68823ba664b759ef870346a976d6827e055b967121e04c7155ee6d806840c07eb2fcbd5c9d3403399c391e3b6d13d4e1f040c84d968652815eb3b68b8c4ba5b5a313dfec3e23b42cba8656bb78317b29b2223c3dd8c81a43eecfadb22a761b9f525b984d3ae8d76b82eb28fd9a1c99cada7ede3d865b3426f3551ff5cf839c29046090a012c55cfd25489ea537ac6d0aea2068646fcc3e69f020a43fd55626292a858547e642f8919e92879db7f3e7f1c0e69fbef1666cff1c690931edc3814cf2f9da28a2ef5cc52ab0c5871cb032317f0cbb3a9c70743764353fdbc4f6cd2a2647bc1d7350ffa256553bebe06b231e170aeac66005b397f14404f17122e08680bf7799911fd812a86cad8efcff3dedb676c696817798601521856d8c33f3f3e70ca27b724f1e0a4ae2f69d243b5902a8809d13225b3ada15aa4330edfe1c8c61dfe0860fe15c7c5aa0f682a3cbfc327006c471592c0537a94eee757b389e298200559c5e0d49cb63e4e7ad2ea90f8d84fef2abbdfca554fa789f3623479ee3feb7866d354a51bb13df5ca4a523540cb9bd56db70d109b2d370d238f4e5cc257b3058251dc51ab982a576afaf3c0e1f192204c8dd60a9f7c630a34733417c2613788e16c65bcf1a74ac07db97231840cf6459a0c50f008a917d3129ab14d4c3f64483c2fbf43259e32cb7a7f348be87f158ed3cee9c07d57e15c57b8fac1b574248041aed7f038209d84aaa7ffc73093da0985faba9c924cff4f4dd13b407a9b700bfb5b83b0c192b38b94397ab303903975150e869baa5ccad3980c2c49f178eef4d027459384d3db04c86e112081b3ee9100f8a5537f05e825f72b2635983a07628b7c64f609bbf814effac0c8e3affabae3a184140c9ce438832995d149e5a71b830cc85b9d1a05f8c9d7d8cb1d3599b70f374401f48e311b998761f04a86ab616f568f0ba25055eeda8abc956d0994a8900abd771ec09f0173b79b114ff3942c31ae35e180fd81403a65b78bfe4f283ae3cc2314dafcf6ccfba3d4faef814282a707c7641a52c44a810dbbb2a8193dbd80acee318dc23a0bee6993c3000643c92f7047c7e568b4f513ade16c814656ffa601b0f4016fa627c651ec17a811dba7890827e830f6581383679619e0519fbbe35f539d846cb6b8b6c897507377e9a0970470a332db20d332b9b354ec1848e5af4f2f8901d0b444a02968fa1008ebcacef9f74e05466f6dad1057783d7b41b27198a5a92b85e159e62ef1788c3194ed721561343acdc28d618a21b6eef3d7039e2b424238313e18b0e9d5db7d2c33cff01019df595234f5b9a59dc48e1f78e1515a890d5bdb48b06fc2f2ecccffed24457a665ecf5ea4a4755069b35a47d4656130b1bfe2864f9a14020d2c15b3fc96b1e04086bbe58632405ae35e3496bd26b6529ae54a0213e54aceccb50b3f072482a59eea0d188891fcd450e7c3b8e06a27d2e812a04b5031972e9f2978bb9e7a5a7e8eaeecf03874142f706e89496f30303f00e2bb344eb2187744bdb623c28b7ad1e0a2f5c5de9fb8356593fa6b6ffc38f6206684784130930b4955706d9bf72a263da5b3c2ac102296a4ee22a578f756e350e7b284bbaafd2558e4aaf3c48bfb6768cff257995c603e7a42a8fb073ae19684a3d8b02a29b5336dec5ceb62075cdf4fcb4682776063ddb29675ed1220b41a79129a7e39197a05f019d789855928493b68d49da88fd3534dd14acd0b2b66059f3f95704ecb70ca0a80feaac678da4e0e8578a1eb02272ff67723be9f7d1ba4700b41a3c343b01d078b2a0d7a223f1266b7fbe9d5cab2b2d9b22d7fea0cc49d840ed634da634debcd40a678d356d6ac86cd681e8409baf069c34db2e1a62fbd944c14bb508075b50574296ebd8bd20d91a6af4c6a68e461c8a0d05ac1dd548ef9b36c9345f3e22af88a373eae0379d2c4da76cc4af320b91bfe6ef761d97d2d40c89a0f1ef26519d0a8454d1349fd6c6f8779d680c927354fa65891a00fc250e4d219a79e3bf6fbc21623d8e49b27b879c6f514347bfda33b3956104a1dfbb9ab2b4a5e8ac8abc03f0ca9cd63ded0f465d9ead7f7e70807727926206116d2a5666cd5deb2594b7dc6130db3433440c0032ba37f95a8c4915aa579d1d0805df6bae00040c6176d0ec2ea295dbc7986f2a54f17d4e5a72f24349b547573e65bdf14bbc81baab93ac1af2a01cce39e26b746e45fe51fe75ddd0e94bcae51d5a13b6fbb262c0f3f4630e23b5ad4773842191acee9ddb0860d5c06748d15fe6669e19572e5d669fd9a09d931b0da2a9319efa6297fa99818e202fb14323cf5d76ba46d28da9398a0eb08bbe6d4e7df3fdec2ae6735e3476c89041aaa1c3280ff4126d34f7bc739b7325993efaef0048972cb9e5dab994e23a436a6c76ab94bdaa7b3668a20257f953a03b78b079e2e9bb4fbc532cc9cfe70ee2c63d84f95ed224cc987bcea8c88a279f5d0ff4843bfae36bf999d6fbeabb927514ce1579855375ba305622c182bd751674ce36f1b53c2aca735216a39f6c3e1312f9150194aa35c2f34e0858e2345d0e9d5f34594a3e8bd663c33ad8b40753e5c37403364046d973b108c00c4e52223513c6a54ad262c6f9fb591c7c73bba659bfce59db1ec63bf3e9a384081d7425d39e57f2b2d830cf3a4b1d9c0bd522c6f8e74dda4b4b5193dc17ca4db9c93e27c673b590c944e02896054e33fcd0d0460d7ef164adb03290385c17b505a79693a458f53b7291d644463e0e7ca3335c624301d7296a02134e212df19565adb90298bd7faf3b9293cccda7ecb1c7af0f2d55541f1e2fd7c01195f4cf90958553f7ed45b5cca6360712277f3bbec081740d391b6c42d123b3c68613958c0b12568cdd6c07d03bb0f6d849835e308d907821d05bc91cd8ac4f60ce17133051c552b43e7fa74d1f97db2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Encrypted</summary>
    
    
    
    <category term="阶段性总结" scheme="https://xorex.space/categories/%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="幸福" scheme="https://xorex.space/tags/%E5%B9%B8%E7%A6%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python-疑问记录</title>
    <link href="https://xorex.space/2022/04/15/cee8a2fa2829/"/>
    <id>https://xorex.space/2022/04/15/cee8a2fa2829/</id>
    <published>2022-04-15T09:52:36.000Z</published>
    <updated>2022-04-15T09:55:01.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述符-和-property-实现原理"><a href="#描述符-和-property-实现原理" class="headerlink" title="描述符 和 property() 实现原理"></a>描述符 和 property() 实现原理</h2><ul><li><p>不理解为什么描述符是绑定在 <code>类属性</code> 上面。</p></li><li><p>类属性最初可以激活 getter 方法，但是无法激活 setter 方法</p></li><li><p>实例属性最初都可以激活 getter 和 setter</p></li><li><p>当对类属性进行赋值之后，描述符就失效了。应该是赋的值覆盖了绑定符地址。</p></li><li><p>一个类的多个实例，使用的描述符对象竟然是同一个？？？</p></li><li><p>猜测应该是通过实例属性保存 描述符 实例，然后对实例访问和赋值就是对描述符进行访问赋值，会激活特殊方法 <code>get</code> __set__，从而通过描述符来实现对属性访问的控制。</p></li></ul><hr><ul><li>property() 是如何实现方法绑定的？</li></ul><h2 id="Python-多继承-MRO"><a href="#Python-多继承-MRO" class="headerlink" title="Python 多继承 MRO"></a>Python 多继承 MRO</h2><ul><li><p>新式类的 MRO 计算方法，以及前几代的设计缺陷。</p></li><li><p>super() 的原理，以及下面的代码，为什么会输出两个 B。</p></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;A&quot;</span>,end=<span class="string">&quot; &quot;</span>)  </span><br><span class="line">        <span class="built_in">super</span>().__init__() <span class="comment"># 这里为什么调用的是 B 的构造方法  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;B&quot;</span>,end=<span class="string">&quot; &quot;</span>)  </span><br><span class="line">        <span class="built_in">super</span>().__init__()  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A,B</span>):</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;C&quot;</span>,end=<span class="string">&quot; &quot;</span>)  </span><br><span class="line">        A.__init__(self)  </span><br><span class="line">        B.__init__(self)  </span><br><span class="line">print(<span class="string">&quot;MRO:&quot;</span>,[x.__name__ <span class="keyword">for</span> x <span class="keyword">in</span> C.__mro__])  </span><br><span class="line">C()</span><br></pre></td></tr></table></figure><blockquote><p>别碰 多继承，会变得不幸 ……</p></blockquote><h2 id="property-实现原理"><a href="#property-实现原理" class="headerlink" title="property() 实现原理"></a>property() 实现原理</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;描述符-和-property-实现原理&quot;&gt;&lt;a href=&quot;#描述符-和-property-实现原理&quot; class=&quot;headerlink&quot; title=&quot;描述符 和 property() 实现原理&quot;&gt;&lt;/a&gt;描述符 和 property() 实现原理&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>爬虫-02-网易云</title>
    <link href="https://xorex.space/2022/02/10/b297398cf5ef/"/>
    <id>https://xorex.space/2022/02/10/b297398cf5ef/</id>
    <published>2022-02-10T09:27:39.000Z</published>
    <updated>2022-06-15T09:29:51.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>来爬网易云音乐的所有热评，输入歌曲 id ，输出热评。（网易系的 Web 爬取好像都是这个流程）</p><h2 id="请求接口"><a href="#请求接口" class="headerlink" title="请求接口"></a>请求接口</h2><p>通过 F12 查看到了热评查询接口：<code>https://music.163com/weapi/comment/resource/comments/get</code>，请求方式 POST。</p><p>但是请求接口的参数，被加了密：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">params:   </span><br><span class="line">AZmpF0q2Xd7XkTpxUoqAKAaTsvs28bvL09Jg1X5cYKpMxIcOpa48xqeAqVjqyummoOPGHVEnRafFSmhsIriymftVHdDhyeh2v+rgLGy7W4w7nWPSHSOEzhDNXPLVLJBrgrFJzl/zWUh1f50AwC+qkKa4Z8MvvFZMHAR1/1/aCYBIvsS0i6IAV1DgVLwGitM4r6jyPNVmKua240dgLSw7tIOqjFxeRXFC/ZXLM8SNzL2b19kdQk/moaSILa87zUKPaZZ1YyQb1ulEPU+4MmqW3maGxqAX92LLA2I0voz4JA0=  </span><br><span class="line"></span><br><span class="line">encSecKey: 27f97b1ce8c6a382428151cea84d9a37cdcce637e83c7dd264b3977ab46c6065e9e226c40c8abe8fa7e1344a46c843f5140be441b87b2a423b476346a43ac996445e5b66d916c93f2d2e204a2ee61625e1ee98dea7674a3e4c16f30eaafa6afefc8f0af88e78f6ad71d07635685250091aaa7b19b41ca36a6c47ede90aeaad59</span><br></pre></td></tr></table></figure><p>所以我们要破解整套加密系统，实现手动构造请求参数并加密。过程很简单，找到加密的函数，查看加密前的参数格式，和加密的过程。</p><h2 id="定位请求发送函数"><a href="#定位请求发送函数" class="headerlink" title="定位请求发送函数"></a>定位请求发送函数</h2><p>首先从本次请求发起程序的调用栈的最顶层开始，一级一级回溯，注意看 params 是否被加密。</p><p><img src="https://xorex.space/image/340.jpg" alt="340.jpg"></p><p>在网络一栏下面的第一个调用函数，就是执行发送请求的函数，打上断点，观察局部变量，不停的放请求，直到从局部变量的 url 里面看到是我们要找的请求，再停下来开始分析本次请求的函数调用栈。</p><p><img src="https://xorex.space/image/341.jpg" alt="341.jpg"></p><p>这个时候就可以看到，这个发送函数的调用栈，已经和我们在 网络 一栏看到的请求调用栈是一样的了。</p><p>然后我们根据这个请求的调用栈，依次去找执行加密的函数。</p><h2 id="定位加密函数"><a href="#定位加密函数" class="headerlink" title="定位加密函数"></a>定位加密函数</h2><p>依次回溯调用栈，观察局部变量的 param，找到数据没加密状态的函数：</p><p><img src="https://xorex.space/image/342.jpg" alt="342.jpg"></p><p>成功找到，证明就是在 be8W() 中完成了加密。</p><p>然后在这个函数内打断点，一步一步执行，观察局部变量，继续跟踪具体执行加密的函数。</p><p>发现是一开始就将上图参数转化为了字符串，然后在 windows.asrsea() 中完成了对参数字符串的加密。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">a</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> d, e, b = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span>, c = <span class="string">&quot;&quot;</span>;  </span><br><span class="line">        <span class="keyword">for</span> (d = <span class="number">0</span>; a &gt; d; d += <span class="number">1</span>)  </span><br><span class="line">            e = <span class="built_in">Math</span>.random() * b.length,  </span><br><span class="line">            e = <span class="built_in">Math</span>.floor(e),  </span><br><span class="line">            c += b.charAt(e);  </span><br><span class="line">        <span class="keyword">return</span> c  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">a, b</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> c = CryptoJS.enc.Utf8.parse(b)  </span><br><span class="line">          , d = CryptoJS.enc.Utf8.parse(<span class="string">&quot;0102030405060708&quot;</span>)  </span><br><span class="line">          , e = CryptoJS.enc.Utf8.parse(a)  </span><br><span class="line">          , f = CryptoJS.AES.encrypt(e, c, &#123;  </span><br><span class="line">            iv: d,  </span><br><span class="line">            mode: CryptoJS.mode.CBC  </span><br><span class="line">        &#125;);  </span><br><span class="line">        <span class="keyword">return</span> f.toString()  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">a, b, c</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> d, e;  </span><br><span class="line">        <span class="keyword">return</span> setMaxDigits(<span class="number">131</span>),  </span><br><span class="line">        d = <span class="keyword">new</span> RSAKeyPair(b,<span class="string">&quot;&quot;</span>,c),  </span><br><span class="line">        e = encryptedString(d, a)  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params">d, e, f, g</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> h = &#123;&#125;  </span><br><span class="line">          , i = a(<span class="number">16</span>);  </span><br><span class="line">        <span class="keyword">return</span> h.encText = b(d, g),  </span><br><span class="line">        h.encText = b(h.encText, i),  </span><br><span class="line">        h.encSecKey = c(i, e, f),  </span><br><span class="line">        h  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">a, b, d, e</span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">var</span> f = &#123;&#125;;  </span><br><span class="line">        <span class="keyword">return</span> f.encText = c(a + e, b, d),  </span><br><span class="line">        f  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">window</span>.asrsea = d,  </span><br><span class="line">    <span class="built_in">window</span>.ecnonasr = e  </span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>开始分析 window.asrsea() 的执行过程。</p><h2 id="解析加密函数"><a href="#解析加密函数" class="headerlink" title="解析加密函数"></a>解析加密函数</h2><p>首先需要明确 window.asrsea() 被调用的时候，填入的参数为：</p><p><code>JSON.stringify(i7b), bsR1x([&quot;流泪&quot;, &quot;强&quot;]), bsR1x(Xp4t.md), bsR1x([&quot;爱心&quot;, &quot;女孩&quot;, &quot;惊恐&quot;, &quot;大笑&quot;])</code></p><p>里面只有 i7b 是变量，是我们要加密的参数，被从 JSON 对象转化为了字符串，其他部分都是不变的常量。</p><p>然后去看 window.asrsea() 的具体代码，可以看到这个代码实际上就是函数 d （<code>window.asrsea = d,</code>）</p><p>那就从 d() 入手，先调用了 a(16) 保存为 i。经过阅读发现，a() 函数输入一个长度数字，返回一个对应长度的随机数。因此这个东西可以保留不变，因此现在不变的参数我们都能获得了，也就是 i e f g：</p><p><img src="https://xorex.space/image/343.jpg" alt="343.jpg"></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e: &quot;010001&quot;  </span><br><span class="line">f: &quot;00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b3ece0462db0a22b8e7&quot;  </span><br><span class="line">g: &quot;0CoJUm6Qyw8W8jud&quot;  </span><br><span class="line">i: &quot;xGsMkCrcKlP3OnHT&quot;</span><br></pre></td></tr></table></figure><p>上面的 g 和 i 都是 16字节，128 位的密钥。</p><p>接下来，就是获取加密 param 的过程，也就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h.encText = b(d, g)  </span><br><span class="line">h.encText = b(h.encText, i)</span><br></pre></td></tr></table></figure><p>分析 b，发现就是就是将输入的两个参数 var1 var2，执行 AES 加密，并返回结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AES.encrypt(var1, var2, &#123;  </span><br><span class="line">    iv: <span class="string">&quot;0102030405060708&quot;</span>,  </span><br><span class="line">    mode: CryptoJS.mode.CBC   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>查一查这个函数的文档， var1 是明文，var2 是密钥，后面的字典 iv 是偏移量，mode 是 CBC 加密模式。我们就可以用 Python 的 AES 加密模块模拟两次这个过程，获取请求的加密结果 encText。需要注意的是，最后加密完，调用加密结果的 toString() 的时候，使用的是 Base64 编码（这里需要看在创建 AES 对象的时候，传入的 format 对象的 stringify 指定使用 CryptoJS.enc.Base64），所以我们也要进行 base64 编码之后输出。</p><p>然后再来看 encSecKey 的获取，发现函数输入的三个数都是前面的常数字符串，并且里面没有用到随机数，这意味着我们确定了输入参数，就确定了结果。于是就也直接用现成它计算好的了，直接从内存中复制：</p><p>encSecKey = “54af20a9dcdc7522eac4be5f10fb17c534c8feb59b7117138afc3852dbcddaa4b2f54bce5b1b8a489f059be6b680a31d582f4f68c82d5ab9ebf0b6591a6c0d42718dc363daf643aa17f4aa44667a4d327402f7ec01b1d7ca1d7960aa48a5828ccb8532dbdc6ac1dd1d373a4d4b77418a1fd05377b4e0fbb34e4a772f61d1e839”</p><p>好了，现在我们 encSeckey 直接拿到了，encText 也知道了该如何加密，可以写 Python 脚本了。</p><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><h3 id="填充方式"><a href="#填充方式" class="headerlink" title="填充方式"></a>填充方式</h3><p>从里面的两次 AES 加密可以看出来，使用的是 128bit 加密。因为 AES 是对明文进行分块，所以也要求明文长度要是 128bit 的整数倍，所以需要对明文进行补齐，默认使用的是 PKCS5Padding 填充方式。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PKCS5Padding：如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。  </span><br><span class="line">比如明文：&#123;1,2,3,4,5,a,b,c,d,e&#125;,缺少6个字节，则补全为&#123;1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6&#125;</span><br></pre></td></tr></table></figure><h3 id="CBC-模式"><a href="#CBC-模式" class="headerlink" title="CBC 模式"></a>CBC 模式</h3><p>CBC模式（Cipher Block Chaining）引入了一个新的概念：初始向量IV（Initialization Vector）。</p><p>IV是做什么用的呢？它的作用和MD5的加盐有些类似，目的是防止同样的明文块始终加密成同样的密文块。</p><p><img src="https://xorex.space/image/344.jpg" alt="344.jpg"></p><p>从图中可以看出，CBC模式在每一个明文块加密前会让明文块和一个值先做异或操作。IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它前一个明文块所加密出的密文块相异或。</p><p>这样以来，相同的明文块加密出的密文块显然是不一样的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>今天太晚了，就去睡觉了，今天早上起来再把这个爬虫做一个终极版本，做一个像下面一样的网易云终极无敌操作器。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent  </span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64  </span><br><span class="line"><span class="keyword">import</span> requests, pprint,json  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WangYiYun</span>():</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        self.params = <span class="string">&quot;&quot;</span>  </span><br><span class="line">        self._i = <span class="string">&quot;l6Brr86UeZ6C3Bsw&quot;</span> <span class="comment"># 默认使用此字符串  </span></span><br><span class="line">        <span class="comment"># 使用默认_i 配套的encSecKey  </span></span><br><span class="line">        self.encSecKey = <span class="string">&quot;7ca9b5ba8b13044f47ed74c388df912ac84758122acbedc64111f2ac83232b01d3ce16f7195a39c7e064b4c0240b5c1d52624dc13c22ec820d76dfe32db43e496aeacced5be3ca9108c78a85bb389f1edf8d8c9fced02024ba9490401b4ce062cc50764d0a24294e07bb229271391b5a3640e924ee1ed15435dc6e288f1fa873&quot;</span>  </span><br><span class="line">        self.headers =  &#123;  </span><br><span class="line">            <span class="string">&#x27;authority&#x27;</span>: <span class="string">&#x27;music.163.com&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;user-agent&#x27;</span>: UserAgent().random,  </span><br><span class="line">            <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;accept&#x27;</span>: <span class="string">&#x27;*/*&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;origin&#x27;</span>: <span class="string">&#x27;https://music.163.com&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;sec-fetch-site&#x27;</span>: <span class="string">&#x27;same-origin&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;sec-fetch-mode&#x27;</span>: <span class="string">&#x27;cors&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;sec-fetch-dest&#x27;</span>: <span class="string">&#x27;empty&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;referer&#x27;</span>: <span class="string">&#x27;https://music.163.com/song?id=1426301364&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;accept-language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,  </span><br><span class="line">            <span class="string">&#x27;cookie&#x27;</span>: <span class="string">&#x27;_iuqxldmzr_=32; _ntes_nnid=5f8ee04e745645d13d3f711c76769afe,1593048942478; _ntes_nuid=5f8ee04e745645d13d3f711c76769afe; WM_TID=XqvK2%2FtWaSBEUBRBEEN7XejGE%2FL0h6Vq; WM_NI=iN6dugAs39cIm2K2R9ox28GszTm5oRjcvJCcyIuaI1dccEVSjaHEwhc8FuERfkh3s%2FFP0zniMA5P4vqS4H3TJKdQofPqezDPP4IR5ApTjuqeNIJNZkCvHMSY6TtEkCZUS3k%3D; WM_NIKE=9ca17ae2e6ffcda170e2e6eeb2e57dbababf88b879a8b08fa2d84f869f9fbaaa50a3f599a5d650939b8dadd52af0fea7c3b92aab92fa85f86d83adfddae243afee85d3d133ada8fed9c679ba8ca3d6ee5aaabdbaabc269bb97bb82cc3ba8bdada6d559aabf88a6f664a1e88a96c85aa6b5a8d4f2258690009bed638f9ffbb1b77eb38dfca9b2608a95acb2ee6e94afab9bc75c94ec87b3b84bb48ca696f46f8e9786afd96181aa88aed253f68cbca6ea499a8b9dd4ea37e2a3; JSESSIONID-WYYY=tI8MIKMCRBuyCYnUJMCyUTlp%2Fufv5xIfCquvp7PJ4%2BuXod%5CXH%5CB0icDZw8TNlwHUHOW%2B2t%2BCuXyC4VZ%5C19OrzaDE%5Ck0F0dAZQh7KcVxUoHKpqUdiVzPu8NxCK9cJRG%5C%5CPTvtqxjFerd1%2BBa4%2F%5C8PESa4pvvRaQF6jljjsibX%5CrcPsH0I%3A1593347447142&#x27;</span>,  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 搜索歌曲接口  </span></span><br><span class="line">    API_Serch_Songs = <span class="string">&#x27;https://music.163.com/weapi/cloudsearch/get/web?csrf_token=&#x27;</span>  </span><br><span class="line">    <span class="comment"># 歌曲评论  </span></span><br><span class="line">    API_Comments_Song = <span class="string">&#x27;https://music.163.com/weapi/v1/resource/comments/R_SO_4_&#123;&#125;?csrf_token=&#x27;</span> <span class="comment"># 音乐ID可替换  </span></span><br><span class="line">    <span class="comment"># 歌曲歌词  </span></span><br><span class="line">    API_Lyric_Songs = <span class="string">&#x27;https://music.163.com/weapi/song/lyric?csrf_token=&#x27;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># crypt_js_complex python 复写cryptjs  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crypt_js_complex</span>(<span class="params">self,text</span>):</span>  </span><br><span class="line">        BS = AES.block_size  </span><br><span class="line">        pad = <span class="keyword">lambda</span> s: s + (BS - <span class="built_in">len</span>(s) % BS) * <span class="built_in">chr</span>(BS - <span class="built_in">len</span>(s) % BS).encode(<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line">        unpad = <span class="keyword">lambda</span> s: s[<span class="number">0</span>:-s[-<span class="number">1</span>]]  </span><br><span class="line"></span><br><span class="line">        key = <span class="built_in">bytes</span>(self._i, encoding=<span class="string">&quot;utf-8&quot;</span>)  </span><br><span class="line">        text = text.encode(<span class="string">&quot;utf-8&quot;</span>)  </span><br><span class="line">        IV = <span class="string">b&#x27;0102030405060708&#x27;</span>  </span><br><span class="line"></span><br><span class="line">        cipher = AES.new(key, mode=AES.MODE_CBC, IV=IV)  </span><br><span class="line">        <span class="comment"># cipher2 = AES.new(key, mode=AES.MODE_CBC, IV=IV)  # 加密和解密，cipher对象只能用一次  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(text)  </span></span><br><span class="line">        encrypted = pad(text)  </span><br><span class="line">        <span class="comment"># print(encrypted)  </span></span><br><span class="line">        encrypted = cipher.encrypt(encrypted)  </span><br><span class="line">        <span class="comment"># print(encrypted)  </span></span><br><span class="line">        encrypted = base64.b64encode(encrypted).decode(<span class="string">&quot;utf-8&quot;</span>)  </span><br><span class="line">        <span class="comment"># print(&quot;第二次加密结果&quot;, encrypted)  </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> encrypted  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># crypt_js_complex 的基础  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crypt_js_complex_base</span>(<span class="params">self,text</span>):</span>  </span><br><span class="line">        BS = AES.block_size  </span><br><span class="line">        pad = <span class="keyword">lambda</span> s: s + (BS - <span class="built_in">len</span>(s) % BS) * <span class="built_in">chr</span>(BS - <span class="built_in">len</span>(s) % BS).encode(<span class="string">&#x27;utf-8&#x27;</span>)  </span><br><span class="line">        unpad = <span class="keyword">lambda</span> s: s[<span class="number">0</span>:-s[-<span class="number">1</span>]]  </span><br><span class="line"></span><br><span class="line">        key = <span class="string">b&#x27;0CoJUm6Qyw8W8jud&#x27;</span>  </span><br><span class="line">        text = text.encode(<span class="string">&quot;utf-8&quot;</span>)  </span><br><span class="line">        IV = <span class="string">b&#x27;0102030405060708&#x27;</span>  </span><br><span class="line"></span><br><span class="line">        cipher = AES.new(key, mode=AES.MODE_CBC, IV=IV)  </span><br><span class="line">        <span class="comment"># cipher2 = AES.new(key, mode=AES.MODE_CBC, IV=IV)  # 加密和解密，cipher对象只能用一次  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(text)  </span></span><br><span class="line">        encrypted = pad(text)  </span><br><span class="line">        <span class="comment"># print(encrypted)  </span></span><br><span class="line">        encrypted = cipher.encrypt(encrypted)  </span><br><span class="line">        <span class="comment"># print(encrypted)  </span></span><br><span class="line">        encrypted = base64.b64encode(encrypted).decode(<span class="string">&quot;utf-8&quot;</span>)  </span><br><span class="line">        <span class="comment"># print(&quot;第一次加密结果&quot;, encrypted)  </span></span><br><span class="line">        <span class="keyword">return</span> encrypted  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得parms参数值  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_params</span>(<span class="params">self,text</span>):</span>  </span><br><span class="line">        <span class="keyword">return</span> self.crypt_js_complex(  </span><br><span class="line">            self.crypt_js_complex_base(text),)  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 搜索歌曲接口  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serch_songs</span>(<span class="params">self,name,offset=<span class="number">0</span></span>):</span>  </span><br><span class="line">        <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name:str  </span></span><br><span class="line"><span class="string">        :param offset:int 偏移量 默认第一页 例如 0 30 60 90  </span></span><br><span class="line"><span class="string">        :return 接口数据  </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>  </span><br><span class="line">        text = <span class="string">&#x27;&#123;&quot;hlpretag&quot;:&quot;&lt;span class=\\&quot;s-fc7\\&quot;&gt;&quot;,&quot;hlposttag&quot;:&quot;&lt;/span&gt;&quot;,&quot;#/discover&quot;:&quot;&quot;,&quot;s&quot;:&quot;%s&quot;,&quot;type&quot;:&quot;1&quot;,&quot;offset&quot;:&quot;%s&quot;,&quot;total&quot;:&quot;false&quot;,&quot;limit&quot;:&quot;30&quot;,&quot;csrf_token&quot;:&quot;&quot;&#125;&#x27;</span>%(name,offset*<span class="number">30</span>)  </span><br><span class="line">        <span class="comment"># payload = &#x27;params=&#123;params&#125;&amp;encSecKey=&#123;encSecKey&#125;&#x27;.format(params=self.get_params(text),encSecKey=self.encSecKey)  </span></span><br><span class="line"></span><br><span class="line">        params = (  </span><br><span class="line">            (<span class="string">&#x27;csrf_token&#x27;</span>, <span class="string">&#x27;&#x27;</span>),  </span><br><span class="line">        )  </span><br><span class="line"></span><br><span class="line">        data = &#123;  </span><br><span class="line">            <span class="string">&#x27;params&#x27;</span>: self.get_params(text),  </span><br><span class="line">            <span class="string">&#x27;encSecKey&#x27;</span>: self.encSecKey  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        response = requests.post(self.API_Serch_Songs, headers=self.headers, params=params,  </span><br><span class="line">                                 data=data)  </span><br><span class="line">        self._dispose(json.loads(response.text))  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 歌曲评论抓取  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">comment_song</span>(<span class="params">self,songid:<span class="built_in">str</span>,offset:<span class="built_in">int</span>=<span class="number">0</span></span>):</span>  </span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">        :param str 歌曲ID  </span></span><br><span class="line"><span class="string">        :param int 翻页 默认第一页 0 20 40  </span></span><br><span class="line"><span class="string">        :return 接口数据  </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>  </span><br><span class="line">        text = <span class="string">&#x27;&#123;&quot;rid&quot;:&quot;R_SO_4_%s&quot;,&quot;offset&quot;:&quot;%s&quot;,&quot;total&quot;:&quot;true&quot;,&quot;limit&quot;:&quot;20&quot;,&quot;csrf_token&quot;:&quot;&quot;&#125;&#x27;</span>%(songid,offset*<span class="number">20</span>)  </span><br><span class="line"></span><br><span class="line">        params = (  </span><br><span class="line">            (<span class="string">&#x27;csrf_token&#x27;</span>, <span class="string">&#x27;&#x27;</span>),  </span><br><span class="line">        )  </span><br><span class="line"></span><br><span class="line">        data = &#123;  </span><br><span class="line">            <span class="string">&#x27;params&#x27;</span>: self.get_params(text),  </span><br><span class="line">            <span class="string">&#x27;encSecKey&#x27;</span>: self.encSecKey  </span><br><span class="line">        &#125;  </span><br><span class="line">        response = requests.post(self.API_Comments_Song.<span class="built_in">format</span>(songid), headers=self.headers,  </span><br><span class="line">                                 params=params, data=data)  </span><br><span class="line">        self._dispose(json.loads(response.text))  </span><br><span class="line">    <span class="comment"># 歌词爬取  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lyric_song</span>(<span class="params">self,songid:<span class="built_in">str</span></span>):</span>  </span><br><span class="line">        <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">        :param songid str 歌曲ID  </span></span><br><span class="line"><span class="string">        :return 接口数据  </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>  </span><br><span class="line">        <span class="comment"># 歌词接口加密参数原型  </span></span><br><span class="line">        text = <span class="string">&#x27;&#123;&quot;id&quot;:&quot;%s&quot;,&quot;lv&quot;:-1,&quot;tv&quot;:-1,&quot;csrf_token&quot;:&quot;&quot;&#125;&#x27;</span>%(songid)  </span><br><span class="line"></span><br><span class="line">        params = (  </span><br><span class="line">            (<span class="string">&#x27;csrf_token&#x27;</span>, <span class="string">&#x27;&#x27;</span>),  </span><br><span class="line">        )  </span><br><span class="line"></span><br><span class="line">        data = &#123;  </span><br><span class="line">            <span class="string">&#x27;params&#x27;</span>: self.get_params(text),  </span><br><span class="line">            <span class="string">&#x27;encSecKey&#x27;</span>: self.encSecKey  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        response = requests.post(self.API_Lyric_Songs, headers=self.headers, params=params, data=data)  </span><br><span class="line">        self._dispose(json.loads(response.text))  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理爬虫获取到的数据，这里我就输出值  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_dispose</span>(<span class="params">self, data</span>):</span>  </span><br><span class="line">        pprint.pprint(data)  </span><br><span class="line">        <span class="keyword">return</span> data  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主函数 测试  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wangyi_main</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        <span class="comment"># 搜索接口  </span></span><br><span class="line">        <span class="comment"># self.serch_songs(&quot;旧账&quot;,0)  </span></span><br><span class="line">        <span class="comment">#歌曲评论接口  </span></span><br><span class="line">        self.comment_song(<span class="string">&quot;25639331&quot;</span>,<span class="number">0</span>)  </span><br><span class="line">        <span class="comment"># 歌词接口  </span></span><br><span class="line">        <span class="comment"># self.lyric_song(&quot;1351615757&quot;) # 旧账  </span></span><br><span class="line">        <span class="keyword">pass</span>  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    wangyi = WangYiYun()  </span><br><span class="line">    wangyi.wangyi_main()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;p&gt;来爬网易云音乐的所有热评，输入歌曲 id ，输出热评。（网易系的 Web 爬取好像都是这个流程）&lt;/p&gt;
&lt;h2 id=&quot;请求接口&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
    <category term="爬虫" scheme="https://xorex.space/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>爬虫-01-基本技术</title>
    <link href="https://xorex.space/2022/01/28/0f5a6af58eaf/"/>
    <id>https://xorex.space/2022/01/28/0f5a6af58eaf/</id>
    <published>2022-01-28T09:18:27.000Z</published>
    <updated>2022-06-17T12:40:45.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="requests-请求库"><a href="#requests-请求库" class="headerlink" title="requests 请求库"></a>requests 请求库</h2><h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><p>requests 可以发起 get post put delete head options patch 这些请求。</p><p>参数可以携带：</p><ol><li> url 请求地址</li><li> params 拼接链接的请求参数 get</li><li> datas 正文的请求参数 post</li><li> headers 请求头内容</li><li> verify 是否 https 验证，有 True 和 False 两个值</li></ol><h3 id="获取返回内容"><a href="#获取返回内容" class="headerlink" title="获取返回内容"></a>获取返回内容</h3><hr><p>通过 request 提供的各种请求方法，返回一个 响应对象 response。</p><ul><li><p>response.text 返回 unicode 的 string 对象的相应内容。</p></li><li><p>response.content 返回 二进制 的相应内容。</p></li></ul><p>一定要记得根据编码格式，设置 response.encode = “XXX” 不然返回内容会解析错误。</p><hr><p>如果返回的是 json 数据，则调用响应对象的 json() 将其转化为 Python 的 dic 对象。</p><h3 id="Session-会话"><a href="#Session-会话" class="headerlink" title="Session 会话"></a>Session 会话</h3><p>这里是模拟自动处理响应和请求的 Cookie 处理，在所属于的 Session 会话中，每一次请求都会带上以前保留下来的 Cookie！</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">session = requests.session()</span><br><span class="line">session.get(url)</span><br></pre></td></tr></table></figure><h3 id="Proxies-代理"><a href="#Proxies-代理" class="headerlink" title="Proxies 代理"></a>Proxies 代理</h3><p>Reqeusts 只支持 http 和 https 两个代理，访问的 url 是哪种链接，就匹配哪种代理。目前不支持代理池，需要自己找开源的。</p><p>http 访问可以用 https 的代理，反之不可以。</p><p>设置字典，然后请求的时候带上去就可以了：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxies = &#123;  </span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>:<span class="string">&quot;http://61.133.87.228:55443&quot;</span></span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>:<span class="string">&quot;https://124.64.8.50:8000&quot;</span></span><br><span class="line">&#125;  </span><br><span class="line">request.get(url,proxies=proxies)</span><br></pre></td></tr></table></figure><h2 id="re-正则"><a href="#re-正则" class="headerlink" title="re 正则"></a>re 正则</h2><h3 id="raw-string"><a href="#raw-string" class="headerlink" title="raw string"></a>raw string</h3><p>rstring 表示 raw string 原始字符串，表示这个字符串自动忽略所有的转义符号。常用在正则表达式字符串中，用来忽略 <code>\w</code> <code>\d</code> 这些匹配符号的转义。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">regex = <span class="string">r&quot;^[0-5][a-z].*?\\w+\\d+$&quot;</span>  </span><br><span class="line"></span><br><span class="line">result = re.<span class="built_in">compile</span>(regex)</span><br></pre></td></tr></table></figure><h3 id="re-常用"><a href="#re-常用" class="headerlink" title="re 常用"></a>re 常用</h3><p>注意下面所有的函数，除了输入正则字符串和被匹配字符串以外，还有一个可选参数 flags，多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：</p><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>re.I</td><td>使匹配对大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别（locale-aware）匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.S</td><td>使 . 匹配包括 <strong>换行</strong> 在内的所有字符</td></tr><tr><td>re.U</td><td>根据 Unicode 字符集解析字符。这个标志影响 \w, \W, \b, \B.</td></tr><tr><td>re.X</td><td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</td></tr></tbody></table><p>一般来说，上面最常用的就是 re.S 来让 <code>.</code> 匹配更加强大。</p><ul><li><p>re.compile() 预编译正则表达式，返回的对象是编译完成对象，调用下面只需要输入被匹配字符串即可。</p></li><li><p>re.findall() 返回一个匹配的 list</p></li><li><p>re.finditer() 返回一个匹配的迭代器，迭代器内对象为 match，通过的 group() 获取实例，效率高于 list。</p></li><li><p>re.search() 检索第一个符合匹配的，以 match 对象返回。</p></li></ul><h3 id="group-分组"><a href="#group-分组" class="headerlink" title="group() 分组"></a>group() 分组</h3><p>对于 re.finditer() 的优势中，除了比 list 性能更强以外，还可以对捕获的数据进行分组操作。</p><p>正则表达式中 <code>(.*?)</code> 这样的括号用于捕获符合括号里面匹配的内容，我们也可以对捕获的内容进行分类，方法就是添加分类的 group 标签 <code>(?P&lt;name&gt;RegEx)</code> 为符合正则表达式 RegEx 的文本进行分组命名为 name ：</p><p>然后通过返回的 iter 对象的 <code>group(&#39;name&#39;)</code> 返回对应分组的数据，或者 <code>groupdict()</code> 以字典的形式返回本次匹配的所有分组数据。</p><h2 id="BS4"><a href="#BS4" class="headerlink" title="BS4"></a>BS4</h2><p>BeautifulSoup4 一种基于 html 代码分析解析的库。推荐用于定位大量标签类相同的数据获取。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先将响应的 html 页面交给 BeautifulSoup，并告诉它使用 html 解析器：  </span></span><br><span class="line">bs = BeautifulSoup(response,<span class="string">&quot;html.parser&quot;</span>) <span class="comment"># parser 解析器  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后返回的就是一个解析了 HTML 的 DOM 对象，可以通过 find() find_all() 查找更小的 DOM 对象  </span></span><br><span class="line"><span class="comment"># 第一个参数是标签名，后面可以跟着 属性名=值 来进行定位。  </span></span><br><span class="line"><span class="comment"># 注意所有和 Python 关键字重合的，后面都加上 _ 来规避  </span></span><br><span class="line">bs.find(<span class="string">&quot;div&quot;</span>,class_=<span class="string">&quot;pic&quot;</span>) <span class="comment"># 返回第一个符合的 DOM 对象  </span></span><br><span class="line">bs.find_all() <span class="comment"># 返回所有符合的 DOM list  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 精准定位 DOM 之后，可以用 get(&#x27;class&#x27;) 来获取属性值，用 .text 获取标签内容。  </span></span><br><span class="line">name = bs.text  </span><br><span class="line">class_ = bs.get(<span class="string">&#x27;class&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>这个用来定位唯一的元素非常方便，这里使用 lxml 中的 etree （element tree） 来解析：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">html = etree.HTML(<span class="string">&#x27;&#x27;</span>) <span class="comment"># 输入 HTML 字符串进行解析</span></span><br><span class="line">html = etree.parse(<span class="string">&#x27;&#x27;</span>) <span class="comment"># 输入文件路径 URL，file 实例等解析为 DOM 对象</span></span><br><span class="line"></span><br><span class="line">html.xpath(<span class="string">&#x27;xxxxx&#x27;</span>) <span class="comment"># 进行进一步的 xpath 格式匹配，返回还是 DOM 对象</span></span><br></pre></td></tr></table></figure><h3 id="XPath-语法"><a href="#XPath-语法" class="headerlink" title="XPath 语法"></a>XPath 语法</h3><p>最简单的 XPath 是根据层次路径的元素名进行匹配的，如果有多个匹配的路径，就会全部被匹配，返回一个可迭代对象。</p><p>相同名称多个节点，可以用添加条件加以限制：</p><ul><li><code>div[2]</code> 来匹配第三个节点。</li><li><code>div[@class=&#39;click_to_sleep&#39;]</code> 和 <code>div[@id=&#39;catalina&#39;]</code> 来指定 div 元素的 class 和 id 属性值。</li></ul><hr><p>通过 xpath 不停的精确匹配，可以用 <code>./</code> 表示当前 DOM 节点。</p><hr><p>要获取 DOM 节点内容，匹配到节点之后，下一步用 <code>/text()</code>，返回字符串。</p><p>要获取 DOM 的属性值，匹配到节点之后，下一步用 <code>/@class</code>，返回属性 class 的字符串值。</p><h2 id="异步加速"><a href="#异步加速" class="headerlink" title="异步加速"></a>异步加速</h2><h3 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h3><p>见文章：Python-08</p><h3 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, headers=Script.headers) <span class="keyword">as</span> response:</span><br><span class="line">        content = <span class="keyword">await</span> response.text(encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">        content = <span class="keyword">await</span> response.json()</span><br></pre></td></tr></table></figure><h3 id="aiofiles"><a href="#aiofiles" class="headerlink" title="aiofiles"></a>aiofiles</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">with</span> aiofiles.<span class="built_in">open</span>(fileName, mode=<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">await</span> f.write(text)</span><br></pre></td></tr></table></figure><h2 id="Selenium-操作浏览器"><a href="#Selenium-操作浏览器" class="headerlink" title="Selenium 操作浏览器"></a>Selenium 操作浏览器</h2><p>下载对应浏览器的驱动，放置到脚本可以访问的 path 路径中，基本操作：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> Edge</span><br><span class="line">browser = Edge() <span class="comment"># 创建浏览器对象</span></span><br><span class="line">browser.get(<span class="string">&quot;https://www.baidu.com&quot;</span>) <span class="comment"># 访问目标网站</span></span><br><span class="line"></span><br><span class="line">element = browser.find_element_by_xpath() <span class="comment"># 定位元素并返回</span></span><br><span class="line"></span><br><span class="line">element.click() <span class="comment"># 对元素执行某种操作（假设为打开新窗口）</span></span><br><span class="line"></span><br><span class="line">browser.close() <span class="comment"># 关闭当前绑定窗口</span></span><br><span class="line"></span><br><span class="line">browser.switch_to.window(browser.window_handles[-<span class="number">1</span>]) <span class="comment"># 将目前窗口切换到新的窗口上面</span></span><br><span class="line"></span><br><span class="line">brower.close() <span class="comment"># 关闭当前绑定窗口</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反爬"><a href="#反爬" class="headerlink" title="反爬"></a>反爬</h2><h3 id="验证人机"><a href="#验证人机" class="headerlink" title="验证人机"></a>验证人机</h3><ol><li> 加上 user-agent 信息，模拟浏览器。</li><li> 加上 Referer 信息，显示访问的上一级链接，模拟用户访问顺序。</li></ol><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>这里说一下代理的原理，至于使用方式在前面的 requests 模块介绍里。</p><h2 id="web-知识"><a href="#web-知识" class="headerlink" title="web 知识"></a>web 知识</h2><h3 id="新页面渲染"><a href="#新页面渲染" class="headerlink" title="新页面渲染"></a>新页面渲染</h3><p>当浏览器进行一个新页面渲染（刷新）的时候，默认会将以前的请求记录消除，所以可以点击 <code>保留日志</code> 选项，来保留以前的请求。</p><p>遇到一些关键请求隐藏在新页面渲染之前，可以通过这样的方式看到。</p><h3 id="框架源代码"><a href="#框架源代码" class="headerlink" title="框架源代码"></a>框架源代码</h3><p>网页分为 页面源代码 和 框架源代码。页面源代码就是请求获取的 父页面。而框架源码就是父页面新请求出来的 iframe 的子页面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;requests-请求库&quot;&gt;&lt;a href=&quot;#requests-请求库&quot; class=&quot;headerlink&quot; title=&quot;requests 请求库&quot;&gt;&lt;/a&gt;requests 请求库&lt;/h2&gt;&lt;h3 id=&quot;发起请求&quot;&gt;&lt;a href=&quot;#发起请求&quot; cla</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
    <category term="爬虫" scheme="https://xorex.space/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python-07-文件操作</title>
    <link href="https://xorex.space/2022/01/25/3c0e22d4330e/"/>
    <id>https://xorex.space/2022/01/25/3c0e22d4330e/</id>
    <published>2022-01-25T08:35:42.000Z</published>
    <updated>2022-06-15T14:10:55.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>这里指的是针对一个文件的基本属性，比如路径，大小，名字，类型等，所以使用 os.path 来操作。</p><h3 id="绝对和相对"><a href="#绝对和相对" class="headerlink" title="绝对和相对"></a>绝对和相对</h3><p>相对路径可以用 <code>./XXX</code> 或者 <code>XXX</code> 开头表示，是相对于 <code>.py</code> 代码文件的路径。</p><p>绝对路径可以用 <code>E:/XXX</code> 或者 <code>/XXX</code></p><h3 id="路径判断"><a href="#路径判断" class="headerlink" title="路径判断"></a>路径判断</h3><ul><li><p>判断路径是否存在 os.path.exists()</p></li><li><p>判断是否为文件 os.path.isfile()</p></li><li><p>判断是否为文件夹 os.path.isdir()</p></li><li><p>判断路径是否为绝对路径 os.path.isabs()</p></li></ul><h3 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h3><ul><li><p>分离路径和文件名 os.path.split()</p></li><li><p>分离文件名和拓展名 os.path.splitext()</p></li><li><p>将路径和文件名拼接返回绝对路径 os.path.join(path,name)</p></li><li><p>获取路径名 os.path.dirname()</p></li><li><p>获取文件名 os.path.basename()</p></li><li><p>获取文件大小 os.path.getsize()</p></li><li><p>获取文件夹下的所有文件 os.listdir()</p></li></ul><h3 id="文件属性操作"><a href="#文件属性操作" class="headerlink" title="文件属性操作"></a>文件属性操作</h3><ul><li><p>创建文件 open(“Name.txt”, “a”).close() 建议使用这个创建文件。</p></li><li><p>创建文件夹 os.mkdir() 和创建多个文件夹 os.makedirs()</p></li><li><p>重命名 os.rename(old,new)</p></li><li><p>删除文件 os.remove() 和删除多个文件 os.removedirs()</p></li><li><p>复制文件 shutil.copy()</p></li><li><p>移动文件 shutil.move()</p></li></ul><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>使用内建函数 open() 来实现文件的读写操作：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(file_name [, mode=<span class="string">&#x27;r&#x27;</span> [ , buffering=-<span class="number">1</span> [ , encoding = <span class="literal">None</span> ]]])</span><br></pre></td></tr></table></figure><p>此格式中，用 [] 括起来的部分为可选参数，即可以使用也可以省略。其中，各个参数所代表的含义如下：<br>file：表示要创建的文件对象。</p><ul><li><p>file_name：要创建或打开文件的文件名称，该名称要用引号（单引号或双引号都可以）括起来。需要注意的是，如果要打开的文件和当前执行的代码文件位于同一目录，则直接写文件名即可；否则，此参数需要指定打开文件所在的完整路径。</p></li><li><p>mode：可选参数，用于指定文件的打开模式。可选的打开模式如表 1 所示。如果不写，则默认以只读（r）模式打开文件。</p></li><li><p>buffering：可选参数，用于指定对文件做读写操作时，是否使用缓冲区（本节后续会详细介绍）。</p></li><li><p>encoding：手动设定打开文件时所使用的编码格式，不同平台的 ecoding 参数值也不同，以 Windows 为例，其默认为 cp936（实际上就是 GBK 编码）。</p></li></ul><p><img src="https://xorex.space/image/339.jpg" alt="339.jpg"></p><center>表 1 open 函数支持的文件打开模式</center><table><thead><tr><th>模式</th><th>意义</th><th>注意事项</th></tr></thead><tbody><tr><td>r</td><td>只读模式打开文件，读文件内容的指针会放在文件的开头。</td><td>操作的文件必须存在。</td></tr><tr><td>rb</td><td>以二进制格式、采用只读模式打开文件，读文件内容的指针位于文件的开头，一般用于非文本文件，如图片文件、音频文件等。</td><td>↑</td></tr><tr><td>r+</td><td>打开文件后，既可以从头读取文件内容，也可以从开头向文件中写入新的内容，写入的新内容会覆盖文件中等长度的原有内容。</td><td>↑</td></tr><tr><td>rb+</td><td>以二进制格式、采用读写模式打开文件，读写文件的指针会放在文件的开头，通常针对非文本文件（如音频文件）。</td><td>↑</td></tr><tr><td>w</td><td>以只写模式打开文件，若该文件存在，打开时会清空文件中原有的内容。</td><td>若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。</td></tr><tr><td>wb</td><td>以二进制格式、只写模式打开文件，一般用于非文本文件（如音频文件）</td><td>↑</td></tr><tr><td>w+</td><td>打开文件后，会对原有内容进行清空，并对该文件有读写权限。</td><td>↑</td></tr><tr><td>wb+</td><td>以二进制格式、读写模式打开文件，一般用于非文本文件</td><td>↑</td></tr><tr><td>a</td><td>以追加模式打开一个文件，对文件只有写入权限，如果文件已经存在，文件指针将放在文件的末尾（即新写入内容会位于已有内容之后）；反之，则会创建新文件。</td><td>-</td></tr><tr><td>ab</td><td>以二进制格式打开文件，并采用追加模式，对文件只有写权限。如果该文件已存在，文件指针位于文件末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。</td><td>-</td></tr><tr><td>a+</td><td>以读写模式打开文件；如果文件存在，文件指针放在文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。</td><td>-</td></tr><tr><td>ab+</td><td>以二进制模式打开文件，并采用追加模式，对文件具有读写权限，如果文件存在，则文件指针位于文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。</td><td>-</td></tr></tbody></table><hr><p>对于二进制模式和文本模式的区别：</p><p>在 Windows 系统中，文件中用 \r\n 作为行末标识符（即换行符），当以文本格式读取文件时，会将 \r\n 转换成 \n；反之，以文本格式将数据写入文件时，会将 \n 转换成 \r\n。这种隐式转换换行符的行为，对用文本格式打开文本文件是没有问题的，但如果用文本格式打开二进制文件，就有可能改变文本中的数据（将 \r\n 隐式转换为 \n）。</p><h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>成功打开文件之后，获取的 file 对象可以完成对此文件的读写：</p><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>file 对象包含如下属性：</p><ul><li><p>file.name：返回文件的名称；</p></li><li><p>file.mode：返回打开文件时，采用的文件打开模式；</p></li><li><p>file.encoding：返回打开文件时使用的编码格式；</p></li><li><p>file.closed：判断文件是否己经关闭。</p></li></ul><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>一定要记得 open 的时候，设置的默认编码格式</p><ul><li><p>file.read([size]) 可以限制一次读取的字节 or 字符数量，不写的话默认 <strong>全部读取</strong> 返回一个字节串或者字符串。</p></li><li><p>file.readline([size]) 一次读一行（包括最后的 \n），可以限制读取一行的 size 大小。</p></li><li><p>file.readlines() 按照行一次性读取所有内容，返回一个列表。</p></li></ul><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ul><li><p>write() 往文件里面写入内容。如果要立刻看到写入效果，要么 close() 要么 flush()。</p></li><li><p>writelines()，将一个列表内容写入文件中，可以配合 readlines() 实现复制文件。</p></li><li><p>flush() 刷新缓存区，写入磁盘中。</p></li></ul><h3 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h3><p>主要靠这 file.tell() 和 file.seek() 两个函数来得到当前文件指针位置，和将文件指针移动到对应位置。如果要使用，必须是以二进制模式打开文件！！！</p><ul><li><p>file.tell() 返回当前文件指针位置。</p></li><li><p>file.seek(offset[, whence])</p></li></ul><p>其中，各个参数的含义如下：</p><ol><li><p> whence：作为可选参数，用于指定文件指针要放置的位置，该参数的参数值有 3 个选择：0 代表文件头（默认值）、1 代表当前位置、2 代表文件尾。</p></li><li><p> offset：表示相对于 whence 位置文件指针的偏移量，正数表示向后偏移，负数表示向前偏移。例如，当whence == 0 &amp;&amp;offset == 3（即 seek(3,0) ），表示文件指针移动至距离文件开头处 3 个字符的位置；当whence == 1 &amp;&amp;offset == 5（即 seek(5,1) ），表示文件指针向后移动，移动至距离当前位置 5 个字符处。</p></li></ol><p>也就是根据 whence 选定参考点，根据 offset 设定偏移量，从而重新定位文件指针位置。</p><h2 id="自动关闭"><a href="#自动关闭" class="headerlink" title="自动关闭"></a>自动关闭</h2><h3 id="with-as"><a href="#with-as" class="headerlink" title="with as"></a>with as</h3><p>Python 中也有和 Java 一样的 try(resource) 语句，用来自动控制上下文资源（文件，数据库链接等）。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> 表达式 [<span class="keyword">as</span> target]：  </span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure><p>此格式中，用 [] 括起来的部分可以使用，也可以省略。其中，target 参数用于指定一个变量，该语句会将 expression 指定的结果保存到该变量中。with as 语句中的代码块如果不想执行任何语句，可以直接使用 pass 语句代替。</p><h3 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h3><p>上下文 context，表示上文和下文…… 在编程里面，则指的是用来保存上文状态的东西。比如：</p><ol><li> 文件资源：里面就是保存各种文件信息的对象，可以叫做 上下文</li><li> 进程资源：切换进程保存在 PCB 里面的东西，也可以叫做 上下文</li><li> 数据库链接：保存数据库链接的东西，叫做 上下文</li><li> 请求数据：保存请求携带的各种信息，也叫 上下文</li></ol><p>就是要保存一下以前获得的东西，就叫上下文。而上下文管理器，就是管理上下文资源的对象，比如 Python 里面的 file。</p><p>file 对象实现了 <code>__start__() __exit__()</code> 因此就是上下文管理器，可以被 with as 语句所操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件操作&quot;&gt;&lt;a href=&quot;#文件操作&quot; class=&quot;headerlink&quot; title=&quot;文件操作&quot;&gt;&lt;/a&gt;文件操作&lt;/h2&gt;&lt;p&gt;这里指的是针对一个文件的基本属性，比如路径，大小，名字，类型等，所以使用 os.path 来操作。&lt;/p&gt;
&lt;h3 id=&quot;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-06-异常和代码管理</title>
    <link href="https://xorex.space/2022/01/22/ba1c421d07e7/"/>
    <id>https://xorex.space/2022/01/22/ba1c421d07e7/</id>
    <published>2022-01-22T08:17:37.000Z</published>
    <updated>2022-04-15T08:35:51.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><p>基本结构</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入被除数：&quot;</span>))  </span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入除数：&quot;</span>))  </span><br><span class="line">    c = a / b  </span><br><span class="line">    print(<span class="string">&quot;您输入的两个数相除的结果是：&quot;</span>, c)  </span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e: <span class="comment"># e 表示捕获的实例  </span></span><br><span class="line">    print(<span class="string">&quot;输入内容不是合法滴数字呢&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:  </span><br><span class="line">    print(<span class="string">&quot;除数不能为零呢&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> (ValueError,ZeroDivisionError) <span class="keyword">as</span> e: <span class="comment">#把两个异常结合在一起的写法  </span></span><br><span class="line">    print(<span class="string">&quot;输入数字异常呢&quot;</span>)  </span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e : <span class="comment"># 捕获商量捕获不了的异常  </span></span><br><span class="line">    print(<span class="string">&quot;出现未知异常呢&quot;</span>)  </span><br><span class="line">    print(e.args)  </span><br><span class="line">    print(<span class="built_in">str</span>(e))  </span><br><span class="line">    print(<span class="built_in">repr</span>(e))  </span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 没有出现异常之后，会执行 else 里面的代码  </span></span><br><span class="line">    print(<span class="string">&quot;计算成功，没有出现异常&quot;</span>)  </span><br><span class="line"><span class="keyword">finally</span>: <span class="comment"># 无论有没有异常都会执行的代码，即使异常没有被捕获  </span></span><br><span class="line">    print(<span class="string">&quot;计算结束&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="异常信息"><a href="#异常信息" class="headerlink" title="异常信息"></a>异常信息</h3><p>我们捕获到了对应的异常实例之后就需要对异常获取信息处理：</p><ul><li>e.args：返回异常的错误编号和描述字符串；</li><li>str(e)：返回异常信息，但不包括异常信息的类型；</li><li>repr(e)：返回较全的异常信息，包括异常信息的类型。</li></ul><h3 id="异常继承结构"><a href="#异常继承结构" class="headerlink" title="异常继承结构"></a>异常继承结构</h3><p><img src="https://xorex.space/image/338.jpg" alt="338.jpg"></p><p>如果要自己实现异常的时候，就一定要找对上层异常去继承。</p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>我们可以手动抛出异常 关键字 raise</p><p>可以在任何地方使用 raise，抛出一个异常的实例。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> e <span class="comment"># 在 except 语句里面抛出捕获的异常   </span></span><br><span class="line"><span class="keyword">raise</span> Exception <span class="comment"># 新建异常 Exception   </span></span><br><span class="line"><span class="keyword">raise</span> Exception(<span class="string">&quot;异常原因 XXX&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="查看异常信息"><a href="#查看异常信息" class="headerlink" title="查看异常信息"></a>查看异常信息</h3><p>导入 traceback 模块，调用方法：</p><ul><li><p><code>traceback.print_exc()</code> 控制台输出内容</p></li><li><p><code>traceback.print_exc(file=open(&#39;filename&#39;，&#39;a&#39;))</code> 文件 filename 中输出内容</p></li></ul><p>就直接在 except 里面调用即可。</p><h2 id="日志系统"><a href="#日志系统" class="headerlink" title="日志系统"></a>日志系统</h2><p>Python 自带 logging 模块可以使用，</p><h3 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h3><p>感觉确实没有 Java 的日志系统使用起来更方便一点。导入 logging 模块之后，需要用 baseConfig() 进行最基本的设置，常用的参数如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filename: str | PathLike[str] | None = ...,  </span><br><span class="line">filemode: str = ...,  </span><br><span class="line">format: str = ...,  </span><br><span class="line">datefmt: str | None = ...,  </span><br><span class="line">style: str = ...,  </span><br><span class="line">level: int | str | None = ...,  </span><br><span class="line">stream: SupportsWrite[str] | None = ...,  </span><br><span class="line">handlers: Iterable[Handler] | None = ...) -None</span><br></pre></td></tr></table></figure><p>主要集中在 level (日志显示最低等级)，format 输出日志格式，这两个上面。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line">logging.basicConfig(level=logging.DEBUG, <span class="built_in">format</span>=<span class="string">&#x27; %(asctime)s - %(levelname)s - %(message)s&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p>我们只要调用 logging 对应的日志输出函数，里面填充日志 message 内容</p><table><thead><tr><th>级别</th><th>对应的函数</th><th>描述</th></tr></thead><tbody><tr><td>DEBUG</td><td>logging.debug()</td><td>最低级别，用于小细节，通常只有在诊断问题时，才会关心这些消息。</td></tr><tr><td>INFO</td><td>logging.info()</td><td>用于记录程序中一般事件的信息，或确认一切工作正常。</td></tr><tr><td>WARNING</td><td>logging.warning()</td><td>用于表示可能的问题，它不会阻止程序的工作，但将来可能会。</td></tr><tr><td>ERROR</td><td>logging.error()</td><td>用于记录错误，它导致程序做某事失败。</td></tr><tr><td>CRITICAL</td><td>logging.critical()</td><td>最高级别，用于表示致命的错误，它导致或将要导致程序完全停止工作。</td></tr></tbody></table><p>具体的日志系统如何使用，以后写项目再研究。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>Python 一个 py 文件就是一个模块，可以通过 import 导入进来，然后通过文件名作为此文件代码的命名空间，来访问里面的变量和函数。</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>import 有两种写法：</p><ul><li><p><code>import module_name as alias</code> 将模块 module_name.py 导入，并起别名 alias（可以不起别名），然后就可以别名作为命名空间访问里面的变量和模块，就像类一样。</p></li><li><p><code>from module_name import func/var</code> 将变量或者函数单独导入，这样访问就不需要指定命名空间，用名字就可以了。</p></li></ul><p>当然如果遇到开头是空格或者数字的模块名，那就这样导入：</p><p><code>__import__(modulename:str)</code> 这是等价于 import 的内建函数。</p><h3 id="name"><a href="#name" class="headerlink" title="__name__"></a>__name__</h3><p>在运行程序的时候，会首先看所有 import 的模块，将这些模块的代码逐一经过解释器执行。但是对于模块中一些不想被导入是执行的代码，可以通过判断命名空间来决定是否执行，内建模块自带 <code>__name__</code> 变量。</p><p>在运行一个 Python 文件的时候，如果执行文件里面的代码，这个内建模块变量 <code>__name__</code> 的值为 <code>__main__</code>，当执行到 import 导入模块的时候，会改变 <code>__name__</code> 值为模块名字，然后再解释执行模块里面的内容。</p><p>所以当时直接运行模块文件的时候 <code>__name__</code> 值为 <code>__main__</code>，我们可以运行一些代码执行，当时作为模块导入另外的文件的时候，值就会变成文件名，就可以不运行这些代码。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="模块文档"><a href="#模块文档" class="headerlink" title="模块文档"></a>模块文档</h3><p>只需要用 <code>&#39;&#39;&#39;</code> 包裹在文件开始即可。然后再调用的地方可以用 <code>模块名.__doc__</code> 获取这些字符串里面的内容。</p><h3 id="模块查找"><a href="#模块查找" class="headerlink" title="模块查找"></a>模块查找</h3><p>这里的模块定位查找：</p><ul><li><p>在当前目录，即当前执行的程序文件所在目录下查找；</p></li><li><p>到 PYTHONPATH（环境变量）下的每个目录中查找；</p></li><li><p>到 Python 默认的安装目录下查找。</p></li></ul><p>这些目录都可以在 sys.path 中输出查看。</p><hr><p>当 Python 程序找不到模块的时候：</p><ul><li><p>向 sys.path 中临时添加模块文件存储位置的完整路径；</p></li><li><p>将模块放在 sys.path 变量中已包含的模块加载路径中；</p></li><li><p>设置 path 系统环境变量。</p></li></ul><h3 id="模块封装"><a href="#模块封装" class="headerlink" title="模块封装"></a>模块封装</h3><ol><li><p> 当用户通过 import 导入模块命名空间来访问模块成员的时候，如果想要限制一些方法的访问，可以使用 <code>_</code> 或者 <code>__</code> 作为开头限制访问。</p></li><li><p> 当用户通过 from xxx import * 进行全部导入的时候，可以通过内建列表 <code>__all__</code> 来设置允许被导入的成员名字。</p></li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">&#x27;fun1&#x27;</span>,<span class="string">&#x27;fun2&#x27;</span>,<span class="string">&#x27;var1&#x27;</span>,<span class="string">&#x27;var2&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="导入本质"><a href="#导入本质" class="headerlink" title="导入本质"></a>导入本质</h3><p>本质上就是创建了一个模块名的变量，类型是 <code>&lt;class &#39;module&#39;&gt;</code>， 将模块里面的代码，交给了这个变量，通过这个变量来访问模块成员。</p><h2 id="包-package"><a href="#包-package" class="headerlink" title="包 package"></a>包 package</h2><p>包是对模块的一种封装管理，是一个文件夹，文件夹的名字就是这个包的名字。这个文件夹里面可以包含另外一个包，也可以包含若干个模块。</p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>一般来说，一个 package 的文件夹下面都会有一个叫做 <code>__init__.py</code> 的模块，在单纯的导入包的时候，本质上就是导入了这个包的 <code>__init__.py</code> 模块。</p><p>比如我们可以新建一个文件夹叫 <code>my_package</code>，然后里面管理着两个模块 <code>module1.py</code> 和 <code>module2.py</code>，那么这个完整的 package 如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_package  </span><br><span class="line">     ┠── __init__.py  </span><br><span class="line">     ┠── module1.py  </span><br><span class="line">     ┗━━ module2.py</span><br></pre></td></tr></table></figure><h3 id="导入-package"><a href="#导入-package" class="headerlink" title="导入 package"></a>导入 package</h3><p>因为 package 相对于 module，多了一层概念，那么再导入的时候，也需要多一层 package 的名字：</p><p>有三种方式导入 package 中的 module：</p><ol><li><code>import 包名[.模块名 [as 别名]]</code></li><li><code>from 包名 import 模块名 [as 别名]</code></li><li><code>from 包名.模块名 import 成员名 [as 别名]</code></li></ol><ul><li>对于第一种，如果只导入包名的话，其实是导入了 <code>__init__.py</code> 这个模块了。并不是同时导入 package 里面的所有 module。导入 包名.模块名 之后，除非起一个别名，否则还是用 包名.模块名 这样的命名空间来访问。</li></ul><h3 id="利用-init-py"><a href="#利用-init-py" class="headerlink" title="利用 __init__.py"></a>利用 __init__.py</h3><p>实际上对与包的使用远远没有这么麻烦，比如在使用 requests 包的时候，可没对包里面的各种模块控制导入。这是因为第三方提供的包中，一般都会包的 <code>__init__.py</code> 模块中完成了整个包对外暴露的成员的控制，导入 <code>__init__.py</code> 就等于导入了整个包的功能。</p><p>因为导入包名其实就是导入了 <code>__init__.py</code>，所以只要在这个模块里面导入需要的成员，那么外界就可以借助着 <code>__init__.py</code> 也就是导入包名完成访问了。</p><hr><p>在 <code>__init__.py</code> 编写导入模块代码的时候，写法和外部导入是一样的，不同的是包名使用 <code>.</code> 来代替，比如 requests 里面：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> utils <span class="comment"># 在自己的包 request 中导入模块 utils  </span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> packages <span class="comment"># 导入 packages</span></span><br></pre></td></tr></table></figure><p>不过访问 <code>__init__.py</code> 里面导入的成员，肯定要加上包名这一层命名空间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;异常捕获&quot;&gt;&lt;a href=&quot;#异常捕获&quot; class=&quot;headerlink&quot; title=&quot;异常捕获&quot;&gt;&lt;/a&gt;异常捕获&lt;/h2&gt;&lt;p&gt;基本结构&lt;/p&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-05-类特殊成员</title>
    <link href="https://xorex.space/2022/01/21/f14e56f10092/"/>
    <id>https://xorex.space/2022/01/21/f14e56f10092/</id>
    <published>2022-01-21T08:08:04.000Z</published>
    <updated>2022-04-15T08:55:54.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>Python 提供了 enum 模块的枚举类 Enum，只需要继承这个类，里面的类属性就都变成 iterable 类型的了。</p><p>然后就可以使用循环访问了。</p><p>不同的是，枚举类无法修改成员，并且类属性名字不能重复。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xorex</span>(<span class="params">Enum</span>):</span>  </span><br><span class="line">    name = <span class="string">&quot;Xorex&quot;</span>  </span><br><span class="line">    grage = <span class="string">&quot;Tempest&quot;</span>  </span><br><span class="line">    age = <span class="number">18</span>  </span><br><span class="line">    Length = <span class="number">18</span>  </span><br><span class="line">    <span class="comment"># 上面两个 age 和 Length 因为值相同，会被看做成一个  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Xorex:  </span><br><span class="line">    print(i) <span class="comment">#只会输出前三个，Length 作为 age 的别名</span></span><br></pre></td></tr></table></figure><h2 id="特别的"><a href="#特别的" class="headerlink" title="特别的"></a>特别的</h2><h3 id="直接写代码"><a href="#直接写代码" class="headerlink" title="直接写代码"></a>直接写代码</h3><p>这里的直接写代码就是在类定义下面直接写，等价于 Java 的静态代码块，会在 <strong>加载类代码的时候运行</strong>。毕竟类下面定义的，就是这个类命名空间下面的代码嘛，自然遇到能执行的就执行，函数的话就封装起来嘛。</p><p>所以这里也不难理解，为什么直接写在类里面的变量，就等同于静态变量了……</p><p>调用 类名方法之后，解释器创建一个对象（用来保存实例属性和实例所属类的结构体），然后调用 <code>__init__</code> 方法并将这个对象（结构体）传入 self 中。执行完方法之后，self 作为返回值返回给调用处的地方。</p><p>一般来说，会在构造方法中，初始化类所需要的实例属性。</p><h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h3><p>Python 的描述符是一个特殊的类，这个类用于管理某一种属性的 getter 和 setter。举两个例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NameControl</span>:</span> <span class="comment"># 用来控制名字 name 的 setter 和 setter  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name: <span class="built_in">str</span> = <span class="string">&quot;HAHA&quot;</span></span>):</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span> <span class="comment"># 规定的 getter 方法  </span></span><br><span class="line">        <span class="keyword">return</span> self.name  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span>  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">str</span>):  </span><br><span class="line">            print(<span class="string">&quot;要输入字符串哦！&quot;</span>)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            self.name = value  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span>  </span><br><span class="line">    name = NameControl() <span class="comment"># 绑定到类属性上面</span></span><br></pre></td></tr></table></figure><ul><li><p>不理解为什么描述符是绑定在 <strong>类属性</strong> 上面。</p></li><li><p>类属性最初可以激活 getter 方法，但是无法激活 setter 方法</p></li><li><p>实例属性最初都可以激活 getter 和 setter</p></li><li><p>当对类属性进行赋值之后，描述符就失效了。应该是赋的值覆盖了绑定符地址。</p></li><li><p>一个类的多个实例，使用的描述符对象竟然是同一个？？？</p></li></ul><p>猜测应该是通过实例属性保存 描述符 实例，然后对实例访问和赋值就是对描述符进行访问赋值，会激活特殊方法 <code>__get__</code> <code>__set__</code>，从而通过描述符来实现对属性访问的控制。</p><p>对描述符里面的特殊方法的调用，是在 <code>__getattribute__()</code> 中决定调用的，判断的逻辑如下：</p><ol><li> 验证该属性是否为类实例对象的数据描述符；</li><li> 如果不是，就查看该属性是否能在类实例对象的 <code>__dict__</code> 中找到；</li><li> 最后，查看该属性是否为类实例对象的非数据描述符。</li></ol><h3 id="property-函数"><a href="#property-函数" class="headerlink" title="property() 函数"></a>property() 函数</h3><p>这个函数的作用和 描述符 类似。不过它是手动绑定起到 getter 和 setter 的方法，绑定方法为： <code>属性名=property(fget=None, fset=None, fdel=None, doc=None)</code> 这样以后在对 <code>属性名</code> 进行访问和赋值的时候，都会经过 property 绑定的方法完成。</p><ul><li>fget: getterFunction</li><li>fset: setterFunction</li><li>fdel: deleteFunction</li><li>doc: 字符串，属性描述信息。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span></span>):</span>  </span><br><span class="line">        self.__name = name  <span class="comment"># 记得要设置成私有属性 __name，因为如果名字还是 name 的话，就会无限触发绑定的 getName 方法，进入死调用循环。  </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getName</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        <span class="keyword">return</span> self.__name  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setName</span>(<span class="params">self, name: <span class="built_in">str</span></span>):</span>  </span><br><span class="line">        self.__name = name  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">    name = <span class="built_in">property</span>(getName,setName) <span class="comment"># 绑定到类属性 name 上面</span></span><br></pre></td></tr></table></figure><p>然后就可以随心所欲的在访问实例属性的时候，全都经过指定的 getter setter 方法了！！！</p><h2 id="类特殊成员"><a href="#类特殊成员" class="headerlink" title="类特殊成员"></a>类特殊成员</h2><p>Python 类中的特殊成员名字都是用下划线包起来的，这些特殊的成员在 Python 解释器下面会有特殊的作用。</p><p>不像是 Java 的那种没有特殊标识，比如 toString() 构造方法，iterator() 方法等，Python 的特殊方法一眼都可以看出来。</p><p>下面的特殊方法，如果不需要自己声明就可以调用，那么就一定是基类 object 里面包含有的！</p><h3 id="init-构造方法"><a href="#init-构造方法" class="headerlink" title="__init__() 构造方法"></a>__init__() 构造方法</h3><p>这里的构造方法和 Java 中是一样的，不过因为 Python 支持多继承以及不支持重载，所以在继承中，不会自动调用父类的构造方法，这里需要自己手动调用。</p><p>要么用 <code>super().__init__()</code> 要么 用 <code>类名.__init__(self)</code>。</p><h3 id="repr-描述方法"><a href="#repr-描述方法" class="headerlink" title="__repr__() 描述方法"></a>__repr__() 描述方法</h3><p>represent 类描述方法，在 object 中输出的是当前对象的 <code>类名+object at+内存地址</code>。可以重写，在遇到需要转化为字符串的时候，如果没有 <code>__str__()</code> 方法，则会调用 <code>__repr__()</code>，否则优先调用 <code>__str__()</code>。</p><h3 id="str-字符串"><a href="#str-字符串" class="headerlink" title="__str__() 字符串"></a>__str__() 字符串</h3><p>需要返回一个字符串，作为对象需要被转化为字符串类型的时候的值。</p><h3 id="del-销毁对象"><a href="#del-销毁对象" class="headerlink" title="__del__() 销毁对象"></a>__del__() 销毁对象</h3><p>对于 Python 来说，使用 <code>del XXX</code> 语句可以将对象的引用计数减一，减到零的时候，就会触发 <code>__del__()</code> 方法进行善后，善后完毕后清除内存。</p><p>需要注意的是，<code>__del___()</code> 就是一个善后的，它并不负责引用计数器减一和清除内存的工作，它只是被调用的。</p><p>另外，一定要记得在子类的 <code>__del__()</code> 中调用父类的 <code>__del__()</code> 来完全完成善后工作。因为父类并不单独存在对象，所以自然只调用 <code>__del__()</code> 即可。</p><h3 id="dir-列出成员"><a href="#dir-列出成员" class="headerlink" title="__dir__() 列出成员"></a>__dir__() 列出成员</h3><p>用来列出当前实例所持有的所有成员（包括继承来的属性和方法）。</p><p>和 dir() 的作用类似，不过区别是 dir() 可以列出来类和实例的成员，而 <code>__dir__()</code> 只能列出来实例的成员。</p><h3 id="dict-字典属性"><a href="#dict-字典属性" class="headerlink" title="__dict__ 字典属性"></a>__dict__ 字典属性</h3><ul><li>对于类属性 <code>__dict__</code>：以字典的形式输出所有的类属性。</li><li>对于实例属性 <code>__dict__</code>: 以字典的形式输出所有的实例属性。</li></ul><h3 id="call-调用绑定"><a href="#call-调用绑定" class="headerlink" title="__call__() 调用绑定"></a>__call__() 调用绑定</h3><p>在类中可以定义一个名字叫做 <code>__call__()</code> 的方法，这个方法会和 <code>实例名()</code> 这样的调用方式绑定，好玩：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xorex</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, name</span>):</span> <span class="comment"># 将方法和实例名绑定，可以通过实例名调用此方法  </span></span><br><span class="line">        print(name + <span class="string">&quot; called the Xorex.&quot;</span>)  </span><br><span class="line"></span><br><span class="line">xorex = Xorex()  </span><br><span class="line">xorex.__call__(<span class="string">&quot;Yukino&quot;</span>) <span class="comment"># 手动调用  </span></span><br><span class="line">xorex(<span class="string">&quot;Asuna&quot;</span>) <span class="comment"># 绑定调用</span></span><br></pre></td></tr></table></figure><h2 id="和类相关的内建函数"><a href="#和类相关的内建函数" class="headerlink" title="和类相关的内建函数"></a>和类相关的内建函数</h2><p>对于 Python 中的各种不需要 import 就可以使用的东西，比如各种方法，以及类 object 等，都是包含在内建模块中 builtins 里面。在运行 Python 代码之前会优先加载这个内建模块。</p><h3 id="hasattr"><a href="#hasattr" class="headerlink" title="hasattr()"></a>hasattr()</h3><p><code>hasattr(obj, name)</code> 返回布尔类型，判断是否有名字为 name 的方法或者属性。</p><h3 id="getattr"><a href="#getattr" class="headerlink" title="getattr()"></a>getattr()</h3><p><code>getattr(obj, name)</code> 如果找不到 name 那就跑出来异常。如果是属性，返回属性值，如果是方法，返回方法信息。</p><h3 id="setattr"><a href="#setattr" class="headerlink" title="setattr()"></a>setattr()</h3><p><code>setattr(obj, name, value)</code> 这个就是设置属性了。适合只有字符串的那种批量建立属性。</p><h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3><p><code>issubclass(cls, class_or_tuple)</code> 判断是否为子类，可以跟着一个 tuple 遍历判断。</p><p><code>isinstance(obj, class_or_tuple)</code> 判断是否为实例，可以跟着一个 tuple 遍历判断。</p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载是作用与对象进行运算符计算的时候，应该调用什么方法来完成:</p><p>数值运算：</p><table><thead><tr><th>重载方法</th><th>重载运算</th><th>运算</th></tr></thead><tbody><tr><td>__add__(self,rhs)</td><td>self + rhs</td><td>加法</td></tr><tr><td>__sub__(self,rhs)</td><td>self - rhs</td><td>减法</td></tr><tr><td>__mul__(self,rhs)</td><td>self * rhs</td><td>乘法</td></tr><tr><td>__truediv__(self,rhs)</td><td>self / rhs</td><td>除法</td></tr><tr><td>__floordiv__(self,rhs)</td><td>self //rhs</td><td>地板除</td></tr><tr><td>__mod__(self,rhs)</td><td>self % rhs</td><td>取模(求余)</td></tr><tr><td>__pow__(self,rhs)</td><td>self **rhs</td><td>幂运算</td></tr></tbody></table><p>逻辑运算：</p><table><thead><tr><th>重载方法</th><th>重载运算</th><th>运算</th></tr></thead><tbody><tr><td>__lt__(self,rhs)</td><td>self &lt; rhs</td><td>Less Than</td></tr><tr><td>__gt__(self,rhs)</td><td>self &gt; rhs</td><td>Grater Than</td></tr><tr><td>__le__(self,rhs)</td><td>self &lt;= rhs</td><td>Less Equal</td></tr><tr><td>__ge__(self,rhs)</td><td>self &gt;= rhs</td><td>Grater Equal</td></tr><tr><td>__eq__(self,rhs)</td><td>self = rhs</td><td>Equal</td></tr><tr><td>__ne__(self,rhs)</td><td>self != rhs</td><td>Nagtive Equal</td></tr></tbody></table><h2 id="装饰器原理"><a href="#装饰器原理" class="headerlink" title="装饰器原理"></a>装饰器原理</h2><p>我们之前是见过装饰器的，就是 @staticmethod @classmethod 这些。而它们是什么呢，可以干什么呢。</p><p>其实就是通过设计模式——装饰器来修改原有函数的功能，变成一个加强版本的函数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span>(<span class="params">Func</span>):</span> <span class="comment">#定义装饰器，会将被装饰的函数当作实参传入  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wapper</span>(<span class="params">*args,**kwargs</span>):</span> <span class="comment">#对传入的函数进行包装为新的此函数  </span></span><br><span class="line">        print(<span class="string">&quot;[logger] Invoke Func: &quot;</span>+Func.__name__)  </span><br><span class="line">        print(<span class="string">&quot;[logger] Args are &quot;</span>+args.__str__()+<span class="string">&#x27; &#x27;</span>+kwargs.__str__())  </span><br><span class="line">        <span class="keyword">return</span> Func(*args,**kwargs)  </span><br><span class="line">    <span class="keyword">return</span> wapper <span class="comment">#将包装好的函数地址返回给原函数名  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logger </span><span class="comment">#这个等价于函数后面多了一句话： hello = logger(hello)  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">name</span>):</span>  </span><br><span class="line">    print(<span class="string">&quot;Ya hello! &quot;</span>+name)  </span><br><span class="line"></span><br><span class="line">hello(<span class="string">&quot;Xorex&quot;</span>) <span class="comment">#调用被包装之后的函数</span></span><br></pre></td></tr></table></figure><p>上面代码的核心就是把 <code>@logger</code> 标注在函数 <code>hello</code> 上面之后，会自动生成一句代码到 <code>hello</code> 后面：<code>hello = logger(hello)</code> 所以我们要在 logger 里面定义装饰器的代码，将 hello 函数装饰之后返回一个新的被装饰过的函数。</p><hr><p>允许标注多个装饰器，执行顺序从上到下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@funA  </span></span><br><span class="line"><span class="meta">@funB  </span></span><br><span class="line"><span class="meta">@funC  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span>  </span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>则会这样执行：<code>fun = funA( funB ( funC (fun) ) )</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;枚举类&quot;&gt;&lt;a href=&quot;#枚举类&quot; class=&quot;headerlink&quot; title=&quot;枚举类&quot;&gt;&lt;/a&gt;枚举类&lt;/h2&gt;&lt;p&gt;Python 提供了 enum 模块的枚举类 Enum，只需要继承这个类，里面的类属性就都变成 iterable 类型的了。&lt;/p&gt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>迈尔斯-布里格斯性格分类法</title>
    <link href="https://xorex.space/2022/01/20/c3863c88e613/"/>
    <id>https://xorex.space/2022/01/20/c3863c88e613/</id>
    <published>2022-01-20T07:57:01.000Z</published>
    <updated>2022-04-15T08:00:24.842Z</updated>
    
    <content type="html"><![CDATA[<p>MBTI <code>Mybers-Briggs Type Indicator</code> 迈尔斯-布里格斯性格分类法。是我目前见到的，比较适合用来描述人性格的一种科学有效的方法。</p><h2 id="性格分类："><a href="#性格分类：" class="headerlink" title="性格分类："></a>性格分类：</h2><table><thead><tr><th>维度</th><th>类型-英文</th><th>类型-英文</th></tr></thead><tbody><tr><td>精力来源</td><td>外向 E Extrovert</td><td>内向 I Introvert</td></tr><tr><td>认知方式</td><td>感觉 S Sensing</td><td>直觉 N Intuition</td></tr><tr><td>决定方式</td><td>理性 T Thinking</td><td>感性 F Feeling</td></tr><tr><td>外部世界</td><td>判断 J Judgment</td><td>知觉 Perceiving</td></tr></tbody></table><h3 id="精力来源"><a href="#精力来源" class="headerlink" title="精力来源"></a>精力来源</h3><p>这个主要是精力来源，取决于社交是提供能量还是消耗能量。</p><h3 id="认知方式"><a href="#认知方式" class="headerlink" title="认知方式"></a>认知方式</h3><p>认知方式是人们在面对世界，面对新事物的时候，是如何认知它的。</p><p>对于 S Sensing 类型来说，就是一个具体的，详细的事物，而对于 N Intuition 来说，则是一类共性，整体情况，普遍规律等。</p><h3 id="决定方式"><a href="#决定方式" class="headerlink" title="决定方式"></a>决定方式</h3><p>决定方式 主要取决于在做决定的时候，参考的依据是什么。</p><p>T Thinking 类型按照客观的立场，一视同仁的按照规则看待，必须有逻辑，倾向于批评。</p><p>F Feeling 重视人的感受，更有人情味，重视和睦的氛围并想要维护。</p><h3 id="决定方式-1"><a href="#决定方式-1" class="headerlink" title="决定方式"></a>决定方式</h3><p>J Judging 判断型 目的强 喜欢有计划，有条理</p><p>P Perceiving 自由 散漫，不受约束 etc</p><p>感觉自己在 J 和 P 反复横跳 QAQ</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MBTI &lt;code&gt;Mybers-Briggs Type Indicator&lt;/code&gt; 迈尔斯-布里格斯性格分类法。是我目前见到的，比较适合用来描述人性格的一种科学有效的方法。&lt;/p&gt;
&lt;h2 id=&quot;性格分类：&quot;&gt;&lt;a href=&quot;#性格分类：&quot; class=&quot;he</summary>
      
    
    
    
    <category term="杂七杂八" scheme="https://xorex.space/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="MBTI" scheme="https://xorex.space/tags/MBTI/"/>
    
  </entry>
  
  <entry>
    <title>Python-04-面向对象</title>
    <link href="https://xorex.space/2022/01/17/d8f77f52e836/"/>
    <id>https://xorex.space/2022/01/17/d8f77f52e836/</id>
    <published>2022-01-17T07:23:42.000Z</published>
    <updated>2022-04-15T09:00:59.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>Python 中的面对对象中的概念中，和 Java 不同的只有字段，在 Python 中直接叫做 <code>属性</code> . 并且 Python 中的类其实就是一个独立的 <code>命名空间</code> 这个命名空间使用类名来调用，里面有变量，有方法（函数），像极了另外的一个 Python 文件。</p><blockquote><p>所以，类属性其实就是另外命名空间的全局变量，方法其实就是另外命名空间的函数！！！</p></blockquote><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在 Python 面对对象中使用的变量有三种类型：</p><ol><li> 类体中、所有函数之外：此范围定义的变量，称为类属性或类变量；（类命名空间的普通变量）</li><li> 类体中，所有函数内部：以“self.变量名”的方式定义的变量，称为实例属性或实例变量；（self 保存结构体地址的变量集合）</li><li> 类体中，所有函数内部：以“变量名=变量值”的方式定义的变量，称为局部变量。（类命名空间函数的局部变量）</li></ol><p>同时三者中的属性，也就是类属性和实例属性，默认都是 public 类型，如果想要设置 private 类型，则需要在属性名字前面加上 <code>__</code> 如 <code>__name</code>，外界访问就会报错。当然也可以加一个 <code>_</code> 外界虽然也能调用，但是编译器不会给提示，约定俗成为 private 类型。</p><p>并且类属性和实例属性都支持在类外面动态添加属性。</p><hr><ul><li><strong>类属性</strong> ，可以通过类名进行访问和修改。</li></ul><p>比较不同的是，Python 支持动态的为类添加类属性，直接赋值就可以了（可以理解为动态语言直接在叫做 类名 的命名空间文件中，修改了代码）：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span>  </span><br><span class="line">    name = <span class="string">&quot;People&quot;</span> <span class="comment"># 通过类名访问的静态字段 name  </span></span><br><span class="line"></span><br><span class="line">People.age = <span class="number">18</span> <span class="comment"># 动态添加类属性  </span></span><br><span class="line"></span><br><span class="line">print(People.age) <span class="comment"># 访问类属性</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>实例属性</strong> ，也就是 Java 中的普通字段，通过具体的实例进行访问。比较不同的是，Python 只能在方法中进行声明，并且需要以 <code>self.name=XXX</code> 来声明名字为 name 的实例对象。（实例就是保存实例变量的结构体地址）</li></ul><p>实例属性也支持动态的添加，但是是依托于某一个具体的实例进行属性添加，对于其他属性，没有影响。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span> <span class="comment"># 建议实例属性都放在构造器 __init__ 里面声明  </span></span><br><span class="line">        self.age = <span class="number">18</span> <span class="comment"># 以 self 开头，为实例属性  </span></span><br><span class="line"></span><br><span class="line">print(People().age) <span class="comment"># 通过新建实例来访问</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>局部变量</strong> ，这个和函数里面的概念是一样的，直接 <code>name=value</code> 的形式就创建了在当前方法内部有效的局部变量。（因为本质上就是一个类命名空间里面的函数呀）</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Python 不支持方法重载。如果有两个重名的方法，则后面的会覆盖前面的。</p><p>方法也是分为三种：类方法，实例方法和静态方法。</p><p>但是这三种方法在本质上都是一样的，都是类命名空间下面的普通函数，只不过根据必须传递的参数不同进行了划分。必须传递实例地址 self 的为实例方法，必须传递自己类命名空间的地址的方法叫做类方法，而静态方法就是什么都不用传递的普通方法。</p><p>因为类中定义的方法默认是需要 self 的实例方法，所以要定义其他两种就需要注解来标记一下。</p><hr><p>可以通过在方法名字前面加上 <code>__</code> 来将方法改成 private 类型。可以加上 <code>_</code> 变成假 private 类型。</p><hr><p>Python 同样支持对三种方法进行动态添加，只要先定义一个符合规范的方法，然后按照动态添加字段的方式，就可以动态添加方法了：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLanguage</span>:</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line"><span class="comment">#下面定义了一个实例方法  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span>  </span><br><span class="line">    print(<span class="string">&quot;正在调用实例方法&quot;</span>)  </span><br><span class="line"><span class="comment">#下面定义了一个类方法  </span></span><br><span class="line"><span class="meta">@classmethod  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info2</span>(<span class="params">cls</span>):</span>  </span><br><span class="line">    print(<span class="string">&quot;正在调用类方法&quot;</span>)  </span><br><span class="line"><span class="comment">#下面定义个静态方法  </span></span><br><span class="line"><span class="meta">@staticmethod  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info3</span>():</span>  </span><br><span class="line">    print(<span class="string">&quot;正在调用静态方法&quot;</span>)  </span><br><span class="line"><span class="comment">#类可以动态添加以上 3 种方法，会影响所有实例对象  </span></span><br><span class="line">CLanguage.info = info  </span><br><span class="line">CLanguage.info2 = info2  </span><br><span class="line">CLanguage.info3 = info3  </span><br><span class="line">clang = CLanguage()  </span><br><span class="line"></span><br><span class="line"><span class="comment">#类实例对象只能动态添加实例方法，不会影响其它实例对象  </span></span><br><span class="line">clang1 = CLanguage()  </span><br><span class="line">clanginfo = info  </span><br><span class="line"><span class="comment">#必须手动为 self 传值  </span></span><br><span class="line">clanginfo(clang1)</span><br></pre></td></tr></table></figure><p>尽量别改代码，不然维护起来，真的是，无语呀。</p><hr><ul><li><strong>实例方法</strong> ，类中定义的默认方法都是实例方法（必须有参数 self），也就是必须需要实例才可以访问的方法。</li></ul><p>有两种调用方式，一种是实例直接调用（self 自动传入），一种是类名调用，但是需要传入 self 参数：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hello</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;Hello!&quot;</span>)  </span><br><span class="line"></span><br><span class="line">xorex = People()  </span><br><span class="line">xorex.say_hello() <span class="comment"># 通过实例调用实例方法  </span></span><br><span class="line"></span><br><span class="line">People.say_hello(xorex) <span class="comment"># 通过类名调用实例方法</span></span><br></pre></td></tr></table></figure><hr><ul><li><strong>静态方法</strong> ，静态方法就等同于 Java 的静态方法。需要在方法前面加上 <code>@staticmethod</code>，通过类名访问。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span>  </span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>():</span>  </span><br><span class="line">        print(<span class="string">&quot;Hello&quot;</span>)  </span><br><span class="line"></span><br><span class="line">People.Hello()</span><br></pre></td></tr></table></figure><hr><ul><li><strong>类方法</strong> ，类方法有点类似于 Java 的静态方法，需要在方法前面加上注解 <code>@classmethod</code>，但是不一样的是，这个方法绑定了类本身，将类本身作为第一个默认参数传了进去，约定俗成这个参数名字为：cls</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span>  </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">what_is_classmethod</span>(<span class="params">cls</span>):</span>  </span><br><span class="line">        print(cls <span class="keyword">is</span> People) <span class="comment"># 输出内容为 True，可以看到 cls 就是类 People 的地址。  </span></span><br><span class="line"></span><br><span class="line">People.what_is_classmethod()</span><br></pre></td></tr></table></figure><h3 id="类封装性原理"><a href="#类封装性原理" class="headerlink" title="类封装性原理"></a>类封装性原理</h3><p>前面说在属性或者方法前面加 <code>_</code> 实现约定俗成的私有，但是仍然可调用的私有方法。</p><p>而名字加上 <code>__</code> 则变成真正不可调用的私有方法/属性。其实这个方法/属性调用接口还是存在的，只不过被 Python 改了名字，改成了 <code>_类名__属性名/方法名&quot;</code>，只要前面加上 <code>_类名</code> 还是可以调用这个私有方法/属性的。</p><p>只能说，Python 没有完全私有，还可以调用。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="默认继承"><a href="#默认继承" class="headerlink" title="默认继承"></a>默认继承</h3><p>在 Python 中，所有没有明面继承其他类的类，都会默认继承基类 object！</p><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>Python 支持继承和多继承，使用方法就是在定义类的时候，在类名后面加小括号，里面塞进去要继承的类名即可，就可以将父类的代码当作在同一命名空间使用了。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>:</span>  </span><br><span class="line">    fatherStatic = <span class="string">&quot;FatherStatic&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        self.fatherField = <span class="string">&quot;FatherField&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Father</span>):</span> <span class="comment"># 继承类 Father  </span></span><br><span class="line">    sonStatic = <span class="string">&quot;SonStatic&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        self.sonField = <span class="string">&quot;SonField&quot;</span></span><br></pre></td></tr></table></figure><p>上面的代码就等价于：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span>  </span><br><span class="line">    fatherStatic = <span class="string">&quot;FatherStatic&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        self.fatherField = <span class="string">&quot;FatherField&quot;</span>  </span><br><span class="line"></span><br><span class="line">    sonStatic = <span class="string">&quot;SonStatic&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        self.sonField = <span class="string">&quot;SonField&quot;</span></span><br></pre></td></tr></table></figure><p>因此在这种机制下，继承了父类的代码之后，父类定义的类属性和各种方法都得到了继承，但是一旦和子类有命名冲突，因为子类的定义在后面，所以会覆盖父类。（一定会被覆盖的就是 <strong>init</strong> 方法，所以说父类在 <strong>init</strong> 声明的实例属性无法被继承后的父类方法和子类使用）</p><p>也因此创建子对象的时候，并不会像 Java 一样调用父类的构造方法。</p><hr><p>我们知道被覆盖的方法仅仅只是因为调用顺序的原因，Java 提供 super 实例来通过定义调用偏移量实现对覆盖的父类方法和属性的访问。</p><p>Python 则可以通过 <code>父类名.方法(self)</code> 名手动绑定 self 对象的方式访问父类中的方法。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;Father Hello&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Father</span>):</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;Son Hello&quot;</span>)  </span><br><span class="line"></span><br><span class="line">son = Son()  </span><br><span class="line">son.Hello()  </span><br><span class="line">Father.Hello(son) <span class="comment"># 借助类访问方法，需要自己填充实例对象 self</span></span><br></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>Python 的多继承就是在类名字后面的小括号里面，多写几个父类，至于命名冲突之后的访问顺序，请参考后面介绍的 MRO 机制：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father1</span>:</span>  </span><br><span class="line">    father1Static = <span class="string">&quot;Father1Static&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(Fatherfather1Static)  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father2</span>:</span>  </span><br><span class="line">    father2Static = <span class="string">&quot;Father2Static&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(Fatherfather2Static)  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Father1,Father2</span>):</span> <span class="comment"># 多继承 Father1 和 Father2，优先级从左到右  </span></span><br><span class="line">    sonStatic = <span class="string">&quot;SonStatic&quot;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        self.sonField = <span class="string">&quot;SonField&quot;</span>  </span><br><span class="line"></span><br><span class="line">son = Son()  </span><br><span class="line">son.Hello() <span class="comment"># 说明 Father1 优先级高于 Father2  </span></span><br><span class="line">print(Son.father1Static) <span class="comment"># 继承了 Father1  </span></span><br><span class="line">print(Son.father2Static) <span class="comment"># 继承了 Father2</span></span><br></pre></td></tr></table></figure><p>但是上面的仅仅只是很简单的多继承关系，如果遇到了更复杂的，犹如很乱的多层树结构继承的时候，就需要根据 MRO 去分析了。</p><h3 id="MRO-机制"><a href="#MRO-机制" class="headerlink" title="MRO 机制"></a>MRO 机制</h3><p>MRO 全称 Method Resolution Order，方法解析顺序。</p><p>可以通过调用类名的类属性 <code>__mro__</code> 来获取类的优先级顺序，会返回一个元组。当然聪明的我们可以自己分析复杂的 <code>__mro__</code> :</p><hr><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span>  </span><br><span class="line">      print(<span class="string">&quot;CommonA&quot;</span>)  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span>  </span><br><span class="line">      print(<span class="string">&quot;CommonC&quot;</span>)  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B, C</span>):</span>  </span><br><span class="line">    <span class="keyword">pass</span>  </span><br><span class="line">print(D().method())</span><br></pre></td></tr></table></figure><p>对于上面的程序，把各个类的 MRO 记为如下等式：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类 A：L[A] = merge(A , object)  </span><br><span class="line">类 B：L[B] = [B] + merge(L[A] , [A])  </span><br><span class="line">类 C：L[C] = [C] + merge(L[A] , [A])  </span><br><span class="line">类 D：L[D] = [D] + merge(L[B] , L[C] , [B] , [C])</span><br></pre></td></tr></table></figure><p>注意，以类 A 等式为例，其中 merge 包含的 A 称为 L[A] 的头，剩余元素（这里仅有一个 object）称为尾。</p><p>这里的关键在于 merge，它的运算方式如下：</p><ol><li> 检查第一个列表的头元素（如 L[A] 的头），记作 H。</li><li> 若 H 未出现在 merge 中其它列表的尾部，则将其输出，并将其从所有列表中删除，然后回到步骤 1；否则，取出下一个列表的头部记作 H，继续该步骤。</li><li> 重复上述步骤，直至列表为空或者不能再找出可以输出的元素。如果是前一种情况，则算法结束；如果是后一种情况，Python 会抛出异常。</li></ol><p>由此，可以计算出类 B 的 MRO，其计算过程为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L[B] = [B] + merge(L[A],[A])  </span><br><span class="line">     = [B] + merge([A,object],[A])  </span><br><span class="line">     = [B,A] + merge([object])  </span><br><span class="line">     = [B,A,object]</span><br></pre></td></tr></table></figure><p>同理，其他类的 MRO 也可以轻松计算得出。</p><h3 id="父类的初始化"><a href="#父类的初始化" class="headerlink" title="父类的初始化"></a>父类的初始化</h3><p>因为 Python 的继承不会像 Java 一样，创建子对象的时候，是不会自动调用父类的构造方法的（因为方法覆盖，只会调用最后面的那个构造方法），所以如果要调用父类的构造方法来完成初始化，就要手动调用。</p><p>有两种方法：</p><ul><li><p>通过 <code>super().__init__()</code> 调用上一个优先级的父类的构造方法。</p></li><li><p>通过 <code>父类名.__init__(self)</code> 手动绑定实例来调用父类的构造方法。</p></li></ul><p>不过建议只在单继承中使用 super() 在多继承中只用后者。</p><h3 id="多态实现"><a href="#多态实现" class="headerlink" title="多态实现"></a>多态实现</h3><p>因为 Python 是动态类型，所以多态机制简直不要太好实现，根本不需要继承！！！</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">polymorphic</span>(<span class="params">self</span>):</span>  </span><br><span class="line">    self.Hello()  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;One Hello&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Hello</span>(<span class="params">self</span>):</span>  </span><br><span class="line">        print(<span class="string">&quot;Two Hello&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">all</span> = (One(),Two())  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">all</span>: <span class="comment"># 多态实现  </span></span><br><span class="line">    polymorphic(i)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h2&gt;&lt;p&gt;Python 中的面对对象中的概念中，和 Java 不同的只有字段，在 Python 中直接叫做 &lt;code&gt;属性&lt;/code&gt; . 并且 Pyth</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-03-结构和函数</title>
    <link href="https://xorex.space/2022/01/15/c1bb1d49fab2/"/>
    <id>https://xorex.space/2022/01/15/c1bb1d49fab2/</id>
    <published>2022-01-15T07:10:49.000Z</published>
    <updated>2022-06-16T11:16:49.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title="="></a>=</h2><p>赋值语句有个比较特殊的用法就是，一句话对多个变量同时赋值：<code>a,b=b,a</code> 使用逗号分割要赋值的元素，这个就实现了元素交换了。</p><p>而实现这样是，Python 把两边都当作元组来处理了…… 也就是 (a,b) 和 (b,a) 。</p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h2><p>代码格式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式 <span class="number">1</span>：  </span><br><span class="line">    代码块 <span class="number">1</span>  </span><br><span class="line"><span class="keyword">elif</span> 表达式 <span class="number">2</span>：  </span><br><span class="line">    代码块 <span class="number">2</span>  </span><br><span class="line"><span class="keyword">elif</span> 表达式 <span class="number">3</span>：  </span><br><span class="line">    代码块 <span class="number">3</span>  </span><br><span class="line">...//其它<span class="keyword">elif</span>语句  </span><br><span class="line"><span class="keyword">else</span>：  </span><br><span class="line">    代码块 n</span><br></pre></td></tr></table></figure><h3 id="真假判断"><a href="#真假判断" class="headerlink" title="真假判断"></a>真假判断</h3><p>对于 Python 来说，除了 True 和 False 以外，其他类型也可以用于决定真假。</p><ul><li><p>数字：0 0.0 为假，其他的为真。</p></li><li><p>字符串：空字符的时候为 False，又字符为真。</p></li><li><p>其他类型，None 是为假，其他的时候为真。</p></li></ul><h3 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h3><p>Python 提供了一种用于占位，但是什么都不执行的语句 <code>pass</code> （这是因为 Python 没有大括号，所以有些分支需要暂时不写代码的时候，用 pass 填充）</p><h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>断言，后面跟着一个表达式，当表达式为假的时候，抛出异常。来保证程序符合预期的运行。</p><p><code>assert EXPRESSION , NOTE</code></p><p>EXPRESSION 表示表达式，用来返回 Bool 值，NOTE 是注释，抛出异常的时候会随着注释一起出来，NOTE 可以不写。</p><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>while 的格式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式：  </span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>Python 的 for 只支持增强循环，格式为：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 迭代变量 <span class="keyword">in</span> 序列：  </span><br><span class="line">    <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">continue</span>  </span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure><p>这里一般使用 range(start,end) 来控制遍历次数，会返回一个 <code>[start,end)</code> 范围的 range 类型，start 可以不写，默认为 0.</p><h3 id="zip"><a href="#zip" class="headerlink" title="zip()"></a>zip()</h3><p>当要同时遍历多个序列的时候，就可以使用函数 <code>zip(a,b,c)</code> 来将三个序列同一个下标的元素和合并成一个元组，然后元组集合组成一个 zip 类型，可以通过遍历 zip 类型来实现同时遍历多个序列：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line">b = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]  </span><br><span class="line">c = [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(a, b, c):  </span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>然后输出：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>)  </span><br><span class="line">(<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>)  </span><br><span class="line">(<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>)  </span><br><span class="line">(<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure><h3 id="reversed-obj"><a href="#reversed-obj" class="headerlink" title="reversed(obj)"></a>reversed(obj)</h3><p>对于 list 来说，可以调用自己的 list.reverse() 将自己倒置一下。</p><p>但是不可变类型的序列来说，就没有办法修改自己了，因此引入了 <code>reversed(obj)</code> 方法。会返回一个倒置的自己，不过类型是 reversed 类型。可以遍历，想要改变的话，还是类型转换一下。</p><h3 id="sort-obj"><a href="#sort-obj" class="headerlink" title="sort(obj)"></a>sort(obj)</h3><p>和上面的那个一样，都是为了解决不可变类型的序列的。传入序列，返回一个排好序的列表（因为排序算法只能用列表实现嘛），格式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = <span class="built_in">sorted</span>(iterable, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>注意这里，key 传入的是一个 lambda 表达式，用于决定如何排列里面的元素。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Python 的函数定义格式如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名(<span class="params">参数列表</span>):</span>  </span><br><span class="line">    //实现特定功能的多行代码  </span><br><span class="line">    [<span class="keyword">return</span> [返回值]]</span><br></pre></td></tr></table></figure><p>函数名 本质上就是一个变量，里面存储着函数的地址。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>对于 Python 函数的参数来说，主要有以下需要注意的点：</p><ul><li>Python 中的所有参数传递都是引用传递。</li></ul><hr><ul><li>可以使用关键词来传递参数，这样就不用记忆形参的位置了：</li></ul><p>例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">first_name,last_name</span>):</span>  </span><br><span class="line">    <span class="keyword">return</span> first_name+<span class="string">&#x27; &#x27;</span>+last_name  </span><br><span class="line"></span><br><span class="line">print(get_name(<span class="string">&quot;Tempest&quot;</span>,<span class="string">&quot;Xorex&quot;</span>)) <span class="comment"># 这个就是按照形参的顺序传入实参  </span></span><br><span class="line">print(get_name(last_name=<span class="string">&quot;Xorex&quot;</span>, first_name=<span class="string">&quot;Tempest&quot;</span>)) <span class="comment"># 这个是根据关键词传递</span></span><br></pre></td></tr></table></figure><hr><ul><li>可以设置参数默认值，不过需要写在所有无默认值参数的后面，需要注意的是：参数默认值无法限制参数的类型:</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">first_name,last_name,sex=<span class="string">&quot;man&quot;</span>,high=<span class="number">10</span></span>):</span>  </span><br><span class="line">    <span class="keyword">return</span> first_name+<span class="string">&#x27; &#x27;</span>+last_name+<span class="string">&#x27; &#x27;</span>+<span class="built_in">str</span>(sex)+<span class="string">&#x27; &#x27;</span>+<span class="built_in">str</span>(high)  </span><br><span class="line"></span><br><span class="line">print(get_name(<span class="string">&quot;Tempest&quot;</span>,<span class="string">&quot;Xorex&quot;</span>,<span class="number">234</span>,<span class="string">&#x27;woman&#x27;</span>))  </span><br><span class="line">print(get_name(last_name=<span class="string">&quot;Xorex&quot;</span>, first_name=<span class="string">&quot;Tempest&quot;</span>))</span><br></pre></td></tr></table></figure><hr><p>可设置参数提示，格式 <code>参数名 : 类型名</code> 主要是给编辑器和程序员看的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_name</span>(<span class="params">name:<span class="built_in">str</span></span>)</span></span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>Python 的返回值可以返回多个参数，用逗号分割开来，会自动打包成一个元组。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">first_name, last_name</span>):</span>  </span><br><span class="line">    <span class="keyword">return</span> first_name, last_name  </span><br><span class="line"></span><br><span class="line">print(get_name(<span class="string">&quot;Tempest&quot;</span>,<span class="string">&quot;Xorex&quot;</span>))</span><br></pre></td></tr></table></figure><p>输出的内容就是一个元组。</p><hr><p>Python 支持返回值提示，格式 <code>def func_name() -&gt; 返回类型</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">self</span>) -&gt; str :</span>  </span><br><span class="line">    <span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>Python 的全局变量只要在函数外面声明就可以了。</p><ul><li>在函数内部可以随意访问全局变量的值，但是不能赋值修改，因为一旦赋值就等于创建了一个新的，和全局变量重名的局部变量。如果想要赋值全局变量的话，有两种方法：</li></ul><ol><li><p> <code>globals()[var_name] = XXX</code> 来获取全局变量的地址，从而完成修改。</p></li><li><p> 另外一个就是单独声明一下这个全局变量，就是加上 global 这个关键字（注意不能赋值，只单独声明），然后后面对这个全局变量进行赋值就不是创建一个新的局部变量，而是操作全局变量了。</p></li></ol><h3 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h3><p>可以在函数内部实现局部函数，也就是只有在函数内部调用的函数。函数名本质上就是存储指针地址的变量。这个变量的作用域也就是函数能调用的作用域。</p><p>当把这个函数的地址传递出去，让外界拿到函数的地址，也就是扩大了函数的作用域。</p><h3 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h3><p><a href="http://c.biancheng.net/view/5335.html">函数闭包详解</a></p><p>就是将函数的处理进行分阶段，第一阶段处理之后，返回一个新的函数，调用新函数处理第二阶段。</p><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>用于元素生成一个 Callable 的函数，格式：<code>name = lambda [list] : 表达式</code> 其中 <code>[list]</code> 表示可选参数，里面是用来描述形参列表的，可以不写：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello = <span class="keyword">lambda</span> : <span class="string">&quot;hello&quot;</span>  </span><br><span class="line"></span><br><span class="line">print(hello())</span><br></pre></td></tr></table></figure><h3 id="获取可操作变量"><a href="#获取可操作变量" class="headerlink" title="获取可操作变量"></a>获取可操作变量</h3><ul><li><p>globals() 以字典的形式返回所有的全局变量。</p></li><li><p>locals() 返回当前作用域所支持的所有变量，也是字典。</p></li><li><p>vars(obj) 返回对象中类的所有属性。</p></li></ul><h3 id="eval-exec"><a href="#eval-exec" class="headerlink" title="eval() exec()"></a>eval() exec()</h3><ul><li><p><code>eval(expression,globals=None,locals=None)</code></p></li><li><p><code>exec(code,globals=None,locals=None)</code></p></li></ul><p>都是输入字符串，然后执行，其中 eval 执行的是单个表达式，exec 可以执行复杂的代码块。其次 eval 执行完表达式之后会返回表达式的值。</p><p>对于 globals 表示的是可以使用的全局命名空间， locals 表示的是可以使用的局部命名空间。这两个东西因为了解的不是太多，所以具体使用以后再说。</p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>Python 内置了用于实现函数式编程的函数，下面的 obj 内容必须是序列：</p><ul><li><p><code>map(func,obj...)</code> 对于序列 obj 的每一个元素，都执行 func 函数得到结果，然后将结果封装为类 list 类型的 map 类型返回。如果 func 函数有多个输入参数，那么就需要多个序列 obj1,obj2 。</p></li><li><p><code>filter(func,obj...)</code> 这个 func 需要返回 Bool 类型，只有为 True 的序列元素输入，会被封装返回。如果输入多个参数（跟着多个 obj 序列输入），那么最后只输出对应输入的 Bool 值。</p></li></ul><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul><li><p>*args : arguments </p></li><li><p>**kwargs : keyword arguments</p></li></ul><p>固定格式是这样的：<code>Func(*args,**kwargs)</code> args 用元组保存直接传递进来的实参，kwargs 用字典保存使用 <code>key=value</code> 传进来的实参。</p><p>然后将保存到 序列 里面的实参进行分析使用即可。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义了支持参数收集的函数  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dis_str</span>(<span class="params">home,*<span class="built_in">str</span>,**course</span>) :</span>  </span><br><span class="line">    print(home)  </span><br><span class="line">    print(<span class="built_in">str</span>)  </span><br><span class="line">    print(course)  </span><br><span class="line"><span class="comment">#调用函数  </span></span><br><span class="line">dis_str(<span class="string">&quot;C语言中文网&quot;</span>,\\  </span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net&quot;</span>,\\  </span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>,\\  </span><br><span class="line">        shell教程=<span class="string">&quot;http://c.biancheng.net/shell/&quot;</span>,\\  </span><br><span class="line">        go教程=<span class="string">&quot;http://c.biancheng.net/golang/&quot;</span>,\\  </span><br><span class="line">        java教程=<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网  </span><br><span class="line">(&#x27;http://c.biancheng.net&#x27;, &#x27;http://c.biancheng.net/python/&#x27;)  </span><br><span class="line">&#123;&#x27;shell教程&#x27;: &#x27;http://c.biancheng.net/shell/&#x27;, &#x27;go教程&#x27;: &#x27;http://c.biancheng.net/golang/&#x27;, &#x27;java教程&#x27;: &#x27;http://c.biancheng.net/java/&#x27;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;=&quot;&gt;&lt;/a&gt;=&lt;/h2&gt;&lt;p&gt;赋值语句有个比较特殊的用法就是，一句话对多个变量同时赋值：&lt;code&gt;a,b=b,a&lt;/code&gt; 使用逗号分割要赋值的元素，这个就实现了元素交换了。&lt;</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-02-序列</title>
    <link href="https://xorex.space/2022/01/14/2a632949769c/"/>
    <id>https://xorex.space/2022/01/14/2a632949769c/</id>
    <published>2022-01-14T06:20:00.000Z</published>
    <updated>2022-04-15T09:05:17.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序列性质"><a href="#序列性质" class="headerlink" title="序列性质"></a>序列性质</h2><p>序列类型：字符串，列表，元组，集合和字典。</p><h3 id="通用性质"><a href="#通用性质" class="headerlink" title="通用性质"></a>通用性质</h3><h4 id="序列索引"><a href="#序列索引" class="headerlink" title="序列索引"></a>序列索引</h4><p>索引机制，可以通过 <code>[]</code> 对序列下标进行访问，支持 0 到 (n-1) 和 -1 到 -n 两种方式访问。</p><h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><p>a in b 表示查询 a 是否在 b 中，其中字典只能查询索引，也可以用 not in （一定要记得字符串也可以用!）</p><h4 id="序列内置函数"><a href="#序列内置函数" class="headerlink" title="序列内置函数"></a>序列内置函数</h4><p>len() 计算序列的长度，即返回序列中包含多少个元素。<br>max() 找出序列中的最大元素。注意，对序列使用 sum() 函数时，做加和操作的必须都是数字，不能是字符或字符串，否则该函数将抛出异常，因为解释器无法判定是要做连接操作（+ 运算符可以连接两个序列），还是做加和操作。<br>min() 找出序列中的最小元素。</p><p>list() 将序列转换为列表。<br>tuple() 将序列转化为元组。<br>str() 将序列转换为字符串。</p><p>sum() 计算元素和。<br>sorted() 对元素进行排序。<br>reversed() 反向序列中的元素。<br>enumerate() 将序列组合为一个索引序列，多用在 for 循环中。</p><p>copy() 浅拷贝<br>deepcopy() 深拷贝</p><hr><p>至于里面的具体用法，下面不同的序列里面会介绍。</p><h3 id="特殊性质"><a href="#特殊性质" class="headerlink" title="特殊性质"></a>特殊性质</h3><blockquote><p>注意，特殊性质只有字符串，列表和元组支持</p></blockquote><h4 id="序列切片"><a href="#序列切片" class="headerlink" title="序列切片"></a>序列切片</h4><p><code>[start : end : step]</code> 来返回一个从 start 开始，end 结束，元素取值间隔为 step。start 默认值 0，end 默认值 序列长度，step 默认值 1 。</p><h4 id="序列相加"><a href="#序列相加" class="headerlink" title="序列相加"></a>序列相加</h4><p>支持 <code>+</code> 运算符，将两个序列拼接为一个。</p><h4 id="序列相乘"><a href="#序列相乘" class="headerlink" title="序列相乘"></a>序列相乘</h4><p>乘法的作用是讲序列扩展为原来的倍数。 *n 表示赋值为 n 个重复的拼接在一起。</p><h2 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 list"></a>列表 list</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>概念和 Java 中列表是一样的，等价于一个存放 Object 的数组，类型返回为 list。</p><p>通过 [a,b,c,d] 来初始化列表，里面什么都可以塞，但是最好还是只塞同类型的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_data = []  </span><br><span class="line">print(<span class="built_in">type</span>(<span class="built_in">list</span>))</span><br></pre></td></tr></table></figure><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ul><li><p>append(obj) 将对象 obj 直接添加到列表尾部</p></li><li><p>extend(obj) 如果 obj 是序列，则等同于调用 list(obj) 之后，拼接到列表尾部（就是拆分一下再拼接）</p></li><li><p>insert(index,obj) 在指定索引 index 的地方，插入对象 obj</p></li></ul><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ul><li><p>根据索引删除，使用 <code>del list[x]</code>，（支持切片）和 <code>pop(index)</code>（只能一个一个删除）。</p></li><li><p>根据值删除，使用 <code>remove(obj)</code></p></li><li><p>全部删除 <code>del list_name</code>（删除变量），或者 <code>clear()</code>（删除数据引用）</p></li></ul><h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><p>支持索引和切片修改。</p><p><code>list_name[index]=x</code></p><p><code>list_name[start:end]=new_list=[x,y,z]</code></p><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p><code>index(obj,start,end)</code> 支持在 start end 区间里面找元素 obj start end 可以不写（字面量比较）。<br>count(obj) 可以返回元素出现次数（字面量比较而非地址）</p><h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple"></a>元组 tuple</h2><p>元组就是不能更改版本的列表，可以使用两种方式创建元组：</p><ol><li><p> 使用圆括号初始化元组 <code>(1,2,&#39;3&#39;)</code>，或者 <code>()</code></p></li><li><p> 将其他类型序列转化为元组 <code>tuple(obj)</code></p></li></ol><h2 id="字典-dic"><a href="#字典-dic" class="headerlink" title="字典 dic"></a>字典 dic</h2><p>就是 Java 里面的 Map。通过键值对的形式存储数据，其中对值没有要求，键必须是<code>不可变的</code>，比如数字、字符串和元组。</p><h3 id="创建字典"><a href="#创建字典" class="headerlink" title="创建字典"></a>创建字典</h3><ol><li><p> 使用大括号初始化字典 <code>dic_a = &#123;key1:value1,key2:value2&#125;</code></p></li><li><p> list 作为 keys 初始化字典：</p></li></ol><p>使用 <code>fromkeys(list,value)</code> 传入一个列表，和一个默认值，初始化出来列表作为 key 的字典。</p><ol start="3"><li> 使用构造函数 <code>dict()</code> 创建字典。</li></ol><h3 id="访问字典"><a href="#访问字典" class="headerlink" title="访问字典"></a>访问字典</h3><p>访问字典的 key 都是通过字面量进行比较的。</p><ol><li><p> 使用 <code>[key]</code> 来访问，如果没有找到则抛异常。</p></li><li><p> 使用 <code>get(key)</code> 来访问，如果没有找到则返回 None</p></li></ol><h3 id="添加修改"><a href="#添加修改" class="headerlink" title="添加修改"></a>添加修改</h3><p>想要添加数据，直接给不存在的 [key] 赋值即可。</p><p>要修该也直接 [key] 赋值即可。</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ul><li><p><code>keys()</code> 返回所有的键。</p></li><li><p><code>values()</code> 返回所有的值。</p></li><li><p><code>item()</code> 返回所有的键值对，每个键值对以元组的形式存在。</p></li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>使用 <code>pop(key)</code> 进行删除键值对。</p><h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h2><p>set 集合就是不存在重复元素的 list，它满足数学里面对集合的定义：唯一，不可变，无序。</p><p>这个玩意没有办法通过下标访问，只能借助于循环，进行遍历访问。一般用于数学里面集合运算，才会用 set。</p><p>这里的内容用到了再去看吧。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>这里主要就是字符串相关的 API，具体使用的时候，再去查一查吧。</p><h3 id="byte-string"><a href="#byte-string" class="headerlink" title="byte string"></a>byte string</h3><p>表示字符串使用 byte 数组来存储，因此可以这样来定义字符串：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">b&#x27;\xe5\x88\xa0\xe9\x99\xa4&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="format-string"><a href="#format-string" class="headerlink" title="format string"></a>format string</h3><p>Python 在 3.6 中支持了 f-string 语法，表示格式化字符串，format string：可以更方便的在字符串中填充变量：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xorex = <span class="string">&quot;Xorex&quot;</span>  </span><br><span class="line"></span><br><span class="line">name = <span class="string">f&quot;Tempest-<span class="subst">&#123;xorex&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>这样 name 字符串就是一个 fstring，并且会将大括号里面的变量进行字符替换，会自动调用 __str__ 方法进行转换。</p><h3 id="raw-string"><a href="#raw-string" class="headerlink" title="raw string"></a>raw string</h3><p>rstring 表示 raw string 原始字符串，表示这个字符串自动忽略所有的转义符号。常用在正则表达式字符串中，用来忽略 <code>\w</code> <code>\d</code> 这些匹配符号的转义。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">regex = <span class="string">r&quot;^[0-5][a-z].*?\\w+\\d+$&quot;</span>  </span><br><span class="line"></span><br><span class="line">result = re.<span class="built_in">compile</span>(regex)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;序列性质&quot;&gt;&lt;a href=&quot;#序列性质&quot; class=&quot;headerlink&quot; title=&quot;序列性质&quot;&gt;&lt;/a&gt;序列性质&lt;/h2&gt;&lt;p&gt;序列类型：字符串，列表，元组，集合和字典。&lt;/p&gt;
&lt;h3 id=&quot;通用性质&quot;&gt;&lt;a href=&quot;#通用性质&quot; class=</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python-01-基础语法</title>
    <link href="https://xorex.space/2022/01/13/79be75538808/"/>
    <id>https://xorex.space/2022/01/13/79be75538808/</id>
    <published>2022-01-13T03:49:41.000Z</published>
    <updated>2022-06-16T14:05:18.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ul><li><p>模块名：短小，全小写字母，下划线分割。</p></li><li><p>包名：全小写，其他和 Java 一样 space.xorex.bookstore。</p></li><li><p>类名：和 Java 完全一样，首字母大写的驼峰命名。</p></li><li><p>函数名，变量名：全小写字母，下划线分割。</p></li><li><p>常量：全大写。下划线分割</p></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="int-整形"><a href="#int-整形" class="headerlink" title="int 整形"></a>int 整形</h3><p>对于 Python 来说，无论多长的整数，都是 int 类型。会在内部随着大小在 byte short int long 高精度 进行自动切换，不需要担心转化的问题。</p><p>可以用不同进制的数赋值，并进行运算也是可以的！</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = <span class="number">0x22</span>  </span><br><span class="line">num2 = <span class="number">0x22</span>  </span><br><span class="line">print(num1 + num2)</span><br></pre></td></tr></table></figure><h3 id="float-浮点数"><a href="#float-浮点数" class="headerlink" title="float 浮点数"></a>float 浮点数</h3><p>同样支持 float double 高精度 随时切换，对外展示为 float 类型。</p><p>并且支持指数表示法：比如 <code>1.234E23</code></p><h3 id="complex-复数"><a href="#complex-复数" class="headerlink" title="complex 复数"></a>complex 复数</h3><p>Python 内置复数处理，没错就是实部+虚部，其中 a 和 b 是实数，则使用 a+bj 表示复数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">complex_number = <span class="number">1</span> + <span class="number">4j</span>  </span><br><span class="line">print(<span class="built_in">type</span>(complex_number))</span><br></pre></td></tr></table></figure><p>输出类型是复数 complex</p><h3 id="str-字符串"><a href="#str-字符串" class="headerlink" title="str 字符串"></a>str 字符串</h3><p>字符串，Pythno 字符串中，单引号和双引号没有任何区别，但是还是建议双引号。同时字符串不可被改变。</p><p>可以使用反斜杠来进行字符串转义。</p><hr><p>对于换行来说，使用 \ 可以表示下一行也是内容。下面输出 <code>Tempest Xorex</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;Tempest &quot;</span> \ </span><br><span class="line">      <span class="string">&quot;Xorex&quot;</span>  </span><br><span class="line">print(<span class="built_in">str</span>)</span><br></pre></td></tr></table></figure><hr><p>可以用 ‘’’ 或者 “”” 里面放格式自由的字符串。</p><h3 id="bytes-字节串"><a href="#bytes-字节串" class="headerlink" title="bytes 字节串"></a>bytes 字节串</h3><p>字节串和字符串比较相似，字符串是保存的一个个字符，字节串则是保存的一个个字节，可以类比字节数组 bytes[] 。字节串可以存储字符串，音频，图片等等由字节组成的数据。</p><p>将字符串转化为字节串：</p><ul><li>如果字符串内容都是 ASCII，在字符串常量前面加 b 即可转化：</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes_var = <span class="string">b&quot;Xorex&quot;</span>  </span><br><span class="line">print(<span class="built_in">type</span>(bytes_var)) <span class="comment">#输出内容为 bytes 类型</span></span><br></pre></td></tr></table></figure><ul><li>python 内置 bytes 类型的构造方法，可以通过构造方法获取</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes_b = <span class="built_in">bytes</span>(<span class="string">&quot;你好呀&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>) <span class="comment"># 字符串和转化字节的编码  </span></span><br><span class="line">print(<span class="built_in">type</span>(bytes_b))</span><br></pre></td></tr></table></figure><ul><li>利用字符串对象的 encode() 方法，返回一个字节串</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bytes_a = <span class="string">&quot;你好呀&quot;</span>.encode(<span class="string">&quot;UTF-8&quot;</span>)  </span><br><span class="line">print(bytes_a)</span><br></pre></td></tr></table></figure><h3 id="bool-布尔"><a href="#bool-布尔" class="headerlink" title="bool 布尔"></a>bool 布尔</h3><p>True 和 False 两种</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>Python 类型转换是通过函数完成的。下面是要转化为对应的类型的转化函数：</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>int(x)</td><td>将 x 转换成整数类型</td></tr><tr><td>float(x)</td><td>将 x 转换成浮点数类型</td></tr><tr><td>complex(real，[,imag])</td><td>创建一个复数</td></tr><tr><td>str(x)</td><td>将 x 转换为字符串</td></tr><tr><td>repr(x)</td><td>将 x 转换为表达式字符串</td></tr><tr><td>eval(str)</td><td>计算在字符串中的有效 Python 表达式，并返回一个对象</td></tr><tr><td>chr(x)</td><td>将整数 x 转换为一个字符</td></tr><tr><td>ord(x)</td><td>将一个字符 x 转换为它对应的整数值</td></tr><tr><td>hex(x)</td><td>将一个整数 x 转换为一个十六进制字符串</td></tr><tr><td>oct(x)</td><td>将一个整数 x 转换为一个八进制的字符串</td></tr></tbody></table><h4 id="str-x-和-repr-x"><a href="#str-x-和-repr-x" class="headerlink" title="str(x) 和 repr(x)"></a>str(x) 和 repr(x)</h4><p>两个都是对象的 toString() 方法，不同的是打印信息的目的不太相同：</p><ul><li><p>str() 的输出追求可读性，输出格式要便于理解，适合用于输出内容到用户终端。</p></li><li><p>repr() 的输出追求明确性，除了对象内容，还需要展示出对象的数据类型信息，适合开发和调试阶段使用。</p></li></ul><p>repr: representation 展示、演示。</p><h4 id="eval-str"><a href="#eval-str" class="headerlink" title="eval(str)"></a>eval(str)</h4><p>只要是 Python 能计算的表达式的字符串，放到里面都可以被解析计算。</p><h4 id="ord-x"><a href="#ord-x" class="headerlink" title="ord(x)"></a>ord(x)</h4><p>ord() ordinal 顺序的次序的，返回字符在 Unicode 中的编码次序，为 int 类型。</p><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>类似于 Java 的字符串类型的机制，不过由于 Python 没有基本数据类型，所以原本 Interger 这种包装类的缓存机制，也一并被 Python 统一设置在了全局里面。</p><table><thead><tr><th>数据类型</th><th>是否可以重用</th><th>生效范围</th></tr></thead><tbody><tr><td>范围在 [-5, 256] 之间的小整数</td><td>如果之前在程序中创建过，就直接存入缓存，后续不再创建。</td><td>全局</td></tr><tr><td>bool 类型</td><td>↑</td><td>↑</td></tr><tr><td>字符串类型数据</td><td>↑</td><td>↑</td></tr><tr><td>大于 256 的整数</td><td>只要在本代码块内创建过，就直接缓存，后续不再创建。</td><td>本代码块</td></tr><tr><td>大于 0 的浮点型小数</td><td>↑</td><td>↑</td></tr><tr><td>小于 0 的浮点型小数</td><td>不进行缓存，每次都需要额外创建。</td><td>↑</td></tr><tr><td>小于 -5 的整数</td><td>↑</td><td>↑</td></tr></tbody></table><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="输入-input"><a href="#输入-input" class="headerlink" title="输入 input()"></a>输入 input()</h3><p>将控制台的一行输入并返回为字符串。其中 input() 函数里面可以输入字符串作为输入提示。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="built_in">input</span>(<span class="string">&quot;请输入你的名字：&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="输出-print"><a href="#输出-print" class="headerlink" title="输出 print()"></a>输出 print()</h3><p>来看看 print() 函数的定义吧，我相信看了就懂：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># known special case of print</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span>(<span class="params">self, *args, sep=<span class="string">&#x27; &#x27;</span>, end=<span class="string">&#x27;\n&#x27;</span>, file=<span class="literal">None</span></span>):</span>  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;  </span></span><br><span class="line"><span class="string">    print(value, ..., sep=&#x27; &#x27;, end=&#x27;\n&#x27;, file=sys.stdout, flush=False)  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Prints the values to a stream, or to sys.stdout by default.  </span></span><br><span class="line"><span class="string">    Optional keyword arguments:  </span></span><br><span class="line"><span class="string">    file:  a file-like object (stream); defaults to the current sys.stdout.  </span></span><br><span class="line"><span class="string">    sep:   string inserted between values, default a space.  </span></span><br><span class="line"><span class="string">    end:   string appended after the last value, default a newline.  </span></span><br><span class="line"><span class="string">    flush: whether to forcibly flush the stream.  </span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>  </span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>默认分隔符空格，结尾是换行，输出到屏幕上（sys.stdout）。于是可以这样写：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Tempest&quot;</span>,<span class="string">&quot;Xorex&quot;</span>, end=<span class="string">&quot;[end]&quot;</span>,sep=<span class="string">&quot;[sep]&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后输出：<code>Tempest[sep]Xorex[end]</code></p><p>也可以设置 file 属性，定义输出位置，接收参数可以是 open() 打开的文件。</p><hr><p>print() 支持格式化输出，和 C 语言一样，在字符串中添加占位符，然后紧跟着字符串后面，表示占位符代替的变量。当一个占位符的时候可以不加括号，多个就需要加括号。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first_name = <span class="string">&quot;Tempest&quot;</span>  </span><br><span class="line">last_name = <span class="string">&quot;Xorex&quot;</span>  </span><br><span class="line">age = <span class="number">18</span>  </span><br><span class="line">print(<span class="string">&quot;First Name: %s; &quot;</span> %first_name,<span class="string">&quot;Last Name: %s;  age: %d;&quot;</span> %(last_name,age))</span><br></pre></td></tr></table></figure><p>输出：<code>First Name: Tempest; Last Name: Xorex; age: 18;</code></p><p>剩下的诸如输出宽度，输出精度，对齐方式什么的，就和 C 语言是一样的了。</p><h2 id="Python-运算"><a href="#Python-运算" class="headerlink" title="Python 运算"></a>Python 运算</h2><h3 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h3><p>和 Java 相比，除了基本的加减乘除模，多了整除 // 和幂运算</p><p>少了 <strong>自增</strong> 和 <strong>自减</strong>，因为 Python 中数字是常量对象，只能转移变量指向的对象，无法修改对象。</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>和 Java 的一样，只支持整形运算，运算位数取决于最长的那个数。</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>除了 大于小于等于不等于大于等于小于等于 以外，多了两个： <code>is</code> 和 <code>is not</code>。</p><p>前面的都是拿着字面量进行比较，而 <code>is</code> 和 <code>is not</code> 是进行对象地址进行比较的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">187987897234234</span>  </span><br><span class="line">y = <span class="built_in">int</span>(<span class="built_in">input</span>()) <span class="comment"># 不也写成字面量是因为有字面量缓存，所以输出转化一下，获取一个新的对象   </span></span><br><span class="line">print(x <span class="keyword">is</span> y) <span class="comment"># 输出结果是 False</span></span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符 and or not，支持任何数据类型（不仅仅是 Bool），支持短路运算。</p><h3 id="运算优先级和结合性"><a href="#运算优先级和结合性" class="headerlink" title="运算优先级和结合性"></a>运算优先级和结合性</h3><p>反正小括号优先级最高，不确定就加小括号。</p><p><img src="https://xorex.space/image/337.jpg" alt="337.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;命名规范&quot;&gt;&lt;a href=&quot;#命名规范&quot; class=&quot;headerlink&quot; title=&quot;命名规范&quot;&gt;&lt;/a&gt;命名规范&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;模块名：短小，全小写字母，下划线分割。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;包名：全小写，其他和 Java </summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Python" scheme="https://xorex.space/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://xorex.space/2021/12/17/3caac9085d1b/"/>
    <id>https://xorex.space/2021/12/17/3caac9085d1b/</id>
    <published>2021-12-17T03:24:42.000Z</published>
    <updated>2022-04-15T09:14:34.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-基础概念"><a href="#Docker-基础概念" class="headerlink" title="Docker 基础概念"></a>Docker 基础概念</h2><p>Docker 存在的意义，是提供了一个标准化的操作系统运行环境，每个环境独立运行一个应用，他们之间相互隔离。</p><p>像 VMWare 这样的软件是提供了一个物理机器级别的虚拟化，通过这个软件，可以在一台电脑上虚拟出来多个物理硬件系统，在每一个虚拟机器中可以安装不同的操作系统。而 Docker 则是更轻量，是提供了一个操作系统级别的虚拟化。通过 Docker，可以在一台电脑上虚拟化出来多个操作系统内核，这样实现了不同的应用可以有一个独立的操作系统的运行环境，它们之间互不干扰。</p><p><img src="https://xorex.space/image/336.jpg" alt="336.jpg"></p><p>Docker 的架构和 Maven 是一样的，都有官方的镜像文件地址，可以用阿里云镜像解决。（不会就去百度）</p><h2 id="Docker-命令"><a href="#Docker-命令" class="headerlink" title="Docker 命令"></a>Docker 命令</h2><h3 id="Docker-服务命令"><a href="#Docker-服务命令" class="headerlink" title="Docker 服务命令"></a>Docker 服务命令</h3><p>使用 systemctl 来控制 Docker 进程，这个 systemctl 是 systemd 的一个命令，它是 Linux 下的一款系统和服务管理器。</p><p><code>systemctl CONTROL docker</code></p><p>这里面可以填写的 CONTROL 命令是：start stop restart status enable（开机启动） disable（关闭开机启动）</p><h3 id="Docker-镜像操作"><a href="#Docker-镜像操作" class="headerlink" title="Docker 镜像操作"></a>Docker 镜像操作</h3><p><code>docker image ls</code> <code>docker images</code> 查看镜像</p><p><code>docker images -q</code> 只获取所有镜像的 ID，可以用于批量删除镜像</p><p><code>docker search NAME</code> 在 Docker 仓库里面去搜索叫做 NAME 的镜像。</p><p><code>docker pull NAME:TAG</code> 来直接获取叫做 NAME 版本为 TAG 的镜像，如果省略 TAG 的话，默认就是最新的版本了。</p><p><code>docker image rm NAME</code> 删除叫做 NAME 的镜像。</p><h3 id="Docker-容器操作"><a href="#Docker-容器操作" class="headerlink" title="Docker 容器操作"></a>Docker 容器操作</h3><h4 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h4><p><code>docker ps -a</code> 查看全部的容器（包括关闭了的）</p><p><code>docker ps -aq</code> 返回所有容器的 ID</p><h4 id="创建删除容器"><a href="#创建删除容器" class="headerlink" title="创建删除容器"></a>创建删除容器</h4><p><code>docker run XXX</code> 通过镜像创建一个容器并运行</p><p>参数：</p><ul><li>-i 保持容器运行</li><li>-t 分配一个容器的输入终端，退出之后，会关闭容器。</li><li>-d 在后台创建中断，通过 <code>docker exec CONTAINER_NAME</code> 进入容器中断操作，退出后不关闭容器</li><li><code>–name=XXX</code> 给容器一个名字</li><li>最后一个参数，就是创建容器的镜像名字</li></ul><p>因此 -it 创建出来的是交互式容器，-id 创建出来的是守护式容器。</p><p>eg: <code>docker run -id --name=Nginx002 nginx:latest</code> 创建根据 nginx latest 镜像创建的名字为 Nginx002 的容器，并以守护模式运行，然后执行 <code>docker exec -it Nginx002 /bin/bash</code> 来进入守护模式运行的容器。</p><p>注意上面的 /bin/bash 是进入容器中，需要执行的初始化命令，/bin/bash 就是用来启动容器的 bash 终端的，用来操作这个容器。</p><hr><p><code>docker rm NAME</code> 根据容器名字或者 ID：Name</p><h4 id="启动与关闭"><a href="#启动与关闭" class="headerlink" title="启动与关闭"></a>启动与关闭</h4><p><code>docker start NAME</code> 根据容器名字启动已经停止的容器。</p><p><code>docker stop NAME</code> …</p><h4 id="详细信息"><a href="#详细信息" class="headerlink" title="详细信息"></a>详细信息</h4><p><code>docker inspect NAME</code> 查看 NAME 容器的具体信息。</p><h2 id="数据卷设置"><a href="#数据卷设置" class="headerlink" title="数据卷设置"></a>数据卷设置</h2><p>通过和宿主机的目录建立同步映射，来解决容器和宿主机以及容器和容器之间的通讯。</p><h3 id="挂载目录"><a href="#挂载目录" class="headerlink" title="挂载目录"></a>挂载目录</h3><p>一个容器要挂载到宿主机的目录的时候，只能在创建的时候设置，不然就要去更改容器的配置文件才可以，所以在创建容器的时候，一定要思考好，挂载到那里才合适。</p><p>挂载目录的命令是在 run 的时候，加上 <code>-v 宿主机目录:容器目录</code> 即可。不存在会自动创建，存在就是原文件夹。</p><p><code>docker run -id --name=CONTAINER_NAME -v /Xorex/Nginx001:/Xorex/Nginx001 IMAGE_NAME</code></p><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>就是建立一个容器，这个容器作为一个数据卷容器。其他的容器挂载到它身上，就等价于挂载到了数据卷容器挂载的目录里面了。优势是可以通过数据卷容器，很方便的管理数据挂载。</p><p>首先建立数据卷容器： <code>docker run -id --name=CONTAINER_NAME -v /VOLUMNAME IMAGE_NAME</code> 和上面直接挂载不同的是，没有了宿主目录，只写一个容器的目录（宿主目录交给 Docker 分配）</p><p>然后就是建立普通容器，挂载到数据卷容器上面，使用 <code>--volumes-from VOLUM_DATA_CONTAINER_NAME</code> 来挂载到对应名字的数据卷容器上面：</p><p><code>docker run -id --name=CONTAINER_NAME --volumes-from VOLUM_DATA_CONTAINER_NAME IMAGE_NAME</code> 从而将创建的新容器，挂载到数据卷容器上面，也就等价于挂载到了它对应的宿主机目录上面。</p><h2 id="基本部署"><a href="#基本部署" class="headerlink" title="基本部署"></a>基本部署</h2><h3 id="MySQL-部署"><a href="#MySQL-部署" class="headerlink" title="MySQL 部署"></a>MySQL 部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br><span class="line">docker pull mysql</span><br><span class="line"></span><br><span class="line">mkdir ~/mysql</span><br><span class="line"><span class="built_in">cd</span> ~/mysql</span><br><span class="line"></span><br><span class="line">docker run -id \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">--name=MySQL \</span><br><span class="line">-v <span class="variable">$PWD</span>/conf:/etc/mysql/conf.d \</span><br><span class="line">-v <span class="variable">$PWD</span>/logs:/logs \</span><br><span class="line">-v <span class="variable">$PWD</span>/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=XXXXX \</span><br><span class="line">mysql</span><br></pre></td></tr></table></figure><ul><li>-p prot 端口映射</li><li>-v $PWD 是获取当前目录，用来拼接绝对路径。conf.d 数据库配置文件。 logs 数据库日志存放。 data 数据库表数据保存。</li><li>-e env 环境变量，设置数据库的初始登录密码。</li><li>\ 表示的是命令还没有输入完毕，符号后面不能有空格，直接回车继续输入指令。</li></ul><p>部署完毕之后，就可以在 MySQL 容器里面直接操作，或者外部访问宿主机的 3306 端口对 MySQL 进行链接访问了。</p><hr><p>如果是使用的阿里云服务器，记得在 网络安全-安全组 里面，将 3306 端口打开。</p><h3 id="Tomcat-部署"><a href="#Tomcat-部署" class="headerlink" title="Tomcat 部署"></a>Tomcat 部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">--name=Tomcat \</span><br><span class="line">-p 8080:8080 \</span><br><span class="line">-v <span class="variable">$PWD</span>:/usr/<span class="built_in">local</span>/tomcat/webapps \</span><br><span class="line">tomcat</span><br></pre></td></tr></table></figure><p>然后就可以访问服务器的 8080 端口，来对 Tomcat 进行访问了，好耶！</p><h3 id="Nginx-部署"><a href="#Nginx-部署" class="headerlink" title="Nginx 部署"></a>Nginx 部署</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">--name=Nginx \</span><br><span class="line">-p 80:80 \</span><br><span class="line">-v <span class="variable">$PWD</span>/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v <span class="variable">$PWD</span>/logs:/var/<span class="built_in">log</span>/nginx \</span><br><span class="line">-v <span class="variable">$PWD</span>/html:/usr/share/nginx/html \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><h3 id="Dokcer-镜像原理"><a href="#Dokcer-镜像原理" class="headerlink" title="Dokcer 镜像原理"></a>Dokcer 镜像原理</h3><p>对于 Docker 的镜像来说，根据各种依赖，将镜像进行了大量的分层，来实现镜像文件的复用。<br>比如对于 Tomcat 镜像来说，它能跑起来是借助于 Tomcat 镜像（Tomcat 代码），以及父依赖 JDK 环境，以及 JVM 运行起来的父依赖 Rootfs 镜像（Linux 发行版系统）。</p><p>这些多层的镜像被外界看作为一个整体，叫做一个 Tomcat 镜像，所以看起来会很大。但是当你下载其他的镜像的时候，可能会有一些父依赖镜像已经下载过了，所以就可以节省空间，实现镜像的复用。</p><p>所以：</p><ul><li><p>Docker 镜像的本质是一个分层的文件系统。</p></li><li><p>Docker 的 Centos 镜像只有 200mb，Centos 操作系统 ISO 镜像要几个 G 的原因是：Docker 借助分层文件系统，复用了宿主机的 Bootfs，因此 Docker 的 Centos 镜像只需要下载 Rootfs 和其他即可，相对来说节省很多空间。</p></li><li><p>Docker 的 Tomcat 镜像有 500mb 为什么比 Tomcat 安装包 70mb 大这么多：因为 Docker 的 Tomcat 还包括运行所依赖的父镜像 JDK 和 Rootfs 系统，所以加起来很大。而 Tomcat 安装包只包括自己本身，因此比较小。</p></li></ul><p>（但其实 Docker 的分层要比上面描述的更加细致，可以通过 <code>docker inspect IMAGE_NAME</code> 看一看具体的分层情况）</p><h3 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h3><h4 id="容器转镜像"><a href="#容器转镜像" class="headerlink" title="容器转镜像"></a>容器转镜像</h4><p>就是将已经有的运行容器转化为镜像，这个镜像可以以 tar 的形式来传播。</p><p><code>docker commit CONTAINER_NAME IMAGE_NAME:TAG</code> 将已经生成的容器 CONTAINER_NAME 转化为，版本为 TAG 的镜像 IMAGE_NAME 。</p><p><code>docker save -o TAR_NAME IMAGE_NAME:TAG</code> 将版本为 TAG 的镜像 IMAGE_NAME 压缩为 tar 文件：TAR_NAME 。</p><p><code>docker load -i TA2AME</code> 将压缩文件 TAR_NAME 加载镜像。</p><hr><p>需要注意的是，容器转镜像的时候，是不包括链接到宿主机的目录的！！！</p><h4 id="DockerFile-生成镜像"><a href="#DockerFile-生成镜像" class="headerlink" title="DockerFile 生成镜像"></a>DockerFile 生成镜像</h4><p>DockerFile 是一个文本文件，包含了大量的 Docker 指令来生成一个镜像。</p><h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><h3 id="DockerFile-关键字表"><a href="#DockerFile-关键字表" class="headerlink" title="DockerFile 关键字表"></a>DockerFile 关键字表</h3><table><thead><tr><th>关键字</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>FROM</td><td>指定父镜像</td><td>指定 dockerfile 基于那个 image 构建</td></tr><tr><td>MAINTAINER</td><td>作者信息</td><td>用来标明这个 dockerfile 谁写的</td></tr><tr><td>LABEL</td><td>标签</td><td>用来标明 dockerfile 的标签 可以使用 Label 代替 Maintainer 最终都是在docker image基本信息中可以查看</td></tr><tr><td>RUN</td><td>执行命令</td><td>执行一段命令 默认是 /bin/sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”]</td></tr><tr><td>CMD</td><td>容器启动命令</td><td>提供启动容器时候的默认命令 和 ENTRYPOINT 配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”]</td></tr><tr><td>ENTRYPOINT</td><td>入口</td><td>一般在制作一些执行就关闭的容器中会使用</td></tr><tr><td>COPY</td><td>复制文件</td><td>build 的时候复制文件到 image 中</td></tr><tr><td>ADD</td><td>添加文件</td><td>build 的时候添加文件到 image 中 不仅仅局限于当前 build 上下文 可以来源于远程服务</td></tr><tr><td>ENV</td><td>环境变量</td><td>指定 build 时候的环境变量 可以在启动的容器的时候 通过 -e 覆盖 格式 ENV name=value</td></tr><tr><td>ARG</td><td>构建参数</td><td>构建参数 只在构建的时候使用的参数 如果有 ENV 那么 ENV 的相同名字的值始终覆盖arg的参数</td></tr><tr><td>VOLUME</td><td>定义外部可以挂载的数据卷</td><td>指定 build 的 image 那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”]</td></tr><tr><td>EXPOSE</td><td>暴露端口</td><td>定义容器运行的时候监听的端口 启动容器的使用 -p 来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp</td></tr><tr><td>WORKDIR</td><td>工作目录</td><td>指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条 workdir 的路径的相对路径</td></tr><tr><td>USER</td><td>指定执行用户</td><td>指定 build 或者启动的时候 用户 在 RUN CMD ENTRYPONT 执行的时候的用户</td></tr><tr><td>HEALTHCHECK</td><td>健康检查</td><td>指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制</td></tr><tr><td>ONBUILD</td><td>触发器</td><td>当存在 ONBUILD 关键字的镜像作为基础镜像的时候 当执行 FROM 完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td></tr><tr><td>STOPSIGNAL</td><td>发送信号量到宿主机</td><td>该 STOPSIGNAL 指令设置将发送到容器的系统调用信号以退出。</td></tr><tr><td>SHELL</td><td>指定执行脚本的shell</td><td>指定 RUN CMD ENTRYPOINT 执行命令的时候 使用的 shell</td></tr></tbody></table><h3 id="编写-DockerFile"><a href="#编写-DockerFile" class="headerlink" title="编写 DockerFile"></a>编写 DockerFile</h3><p>将一个 SpringBoot 项目构建出一个镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> Xorex &lt;Xorex.space&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> springboot-hello-0.0.1-SNAPSHOT.jar app.jar</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> java -jar app.jar</span></span><br></pre></td></tr></table></figure><p>然后就是根据这个 DockerFile 自己生成一个 Docker 镜像。</p><p><code>docker build -f ./XXX.dockerfile -t IMAGE_NAME:TAG .</code> -f 表示指定文件位置， -t 表示后面执行生成的镜像的名字和版本号。（别忘了最后的 <code>.</code>）</p><p>比如我写的：<code>docker build -f /dockerfile -t app:1.0 .</code> 然后就会生成一个叫做 app:1.0 的镜像啦！只需要将这个镜像跑在容器中，就成功部署了项目啦。（有可能会要求你去建立一个 .dockerignore 的文件，就建立一个就好了，内容写 <code>*</code>）</p><p>还有，记得要 ADD 的东西，放到和 dockerfile 一个文件夹里面，不然可能会添加失败。</p><h3 id="自定义-CentOS7"><a href="#自定义-CentOS7" class="headerlink" title="自定义 CentOS7"></a>自定义 CentOS7</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER xorex &lt;xorex.space&gt;</span><br><span class="line">RUN yum install -y vim</span><br><span class="line">WORKDIR /Xorex</span><br></pre></td></tr></table></figure><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker-Compose"></a>Docker-Compose</h2><p>这个用于编写 Docker 执行的文件的，适用于大规模复杂部署。因为自己的 ECS 怎么都连不上 Github 所以就不学了吧。</p><p>把讲义里面的东西还是贴一下把，万一以后用得到。</p><h3 id="一、安装-Docker-Compose"><a href="#一、安装-Docker-Compose" class="headerlink" title="一、安装 Docker Compose"></a>一、安装 Docker Compose</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我 们以编译好的二进制包方式安装在Linux系统中。</span> </span><br><span class="line">https://github.com/docker/compose/releases/download/v2.2.3/docker-compose-linux-x86_64</span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置文件可执行权限</span> </span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本信息</span> </span><br><span class="line">docker-compose -version</span><br></pre></td></tr></table></figure><h3 id="二、卸载-Docker-Compose"><a href="#二、卸载-Docker-Compose" class="headerlink" title="二、卸载 Docker Compose"></a>二、卸载 Docker Compose</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 二进制包方式安装的，删除二进制文件即可</span></span><br><span class="line">rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="三、-使用-Docker-Compose-编排-Nginx-SpringBoot-项目"><a href="#三、-使用-Docker-Compose-编排-Nginx-SpringBoot-项目" class="headerlink" title="三、 使用 Docker Compose 编排 Nginx+SpringBoot 项目"></a>三、 使用 Docker Compose 编排 Nginx+SpringBoot 项目</h3><ul><li>创建 docker-compose 目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/docker-compose</span><br><span class="line">cd ~/docker-compose</span><br></pre></td></tr></table></figure><ul><li>编写 docker-compose.yml 文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">services:</span><br><span class="line">  nginx:</span><br><span class="line">   image: nginx</span><br><span class="line">   ports:</span><br><span class="line">    - 80:80</span><br><span class="line">   links:</span><br><span class="line">    - app</span><br><span class="line">   volumes:</span><br><span class="line">    - ./nginx/conf.d:/etc/nginx/conf.d</span><br><span class="line">  app:</span><br><span class="line">    image: app</span><br><span class="line">    expose:</span><br><span class="line">      - &quot;8080&quot;</span><br></pre></td></tr></table></figure><ul><li>创建./nginx/conf.d目录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ./nginx/conf.d</span><br></pre></td></tr></table></figure><ul><li>在./nginx/conf.d目录下 编写itheima.conf文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    access_log off;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://app:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在~/docker-compose 目录下 使用docker-compose 启动容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><ul><li>测试访问</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.149.135/hello</span><br></pre></td></tr></table></figure><h2 id="Docker-底层原理"><a href="#Docker-底层原理" class="headerlink" title="Docker 底层原理"></a>Docker 底层原理</h2><p>Docker 是使用 Go 语言，利用了 <strong>Linux 内核</strong> 的一个软件。也就是虚拟化本身，是 Linux 内核自己支持的，Docker 只是利用了这个特性。</p><p>总的来说，Docker 的镜像就是一个分层管理的文件系统和一些命令组成。Docker 开启的容器，对于宿主机来说就是一个进程，但是被命名空间和其他进程隔离。通过 Linux 内核 <code>CGroups</code> 系统管理容器能分配到的物理机器资源大小。</p><h3 id="Namespace-命名空间"><a href="#Namespace-命名空间" class="headerlink" title="Namespace 命名空间"></a>Namespace 命名空间</h3><p>一个容器对应一系列的命名空间，通过不同容器的命名空间的隔离，实现了资源调用的隔离。主要有以下的命名空间的使用：</p><p><code>PID</code> Process ID 隔离进程</p><p><code>NET</code> NetWroking 隔离网络</p><p><code>IPC</code> InterPress Communication 共享内存</p><p><code>MNT</code> Mount 文件挂载</p><p><code>UTS</code> Unix TimeSharing System 隔离内核</p><p>等等等等。</p><h3 id="Control-Groups"><a href="#Control-Groups" class="headerlink" title="Control Groups"></a>Control Groups</h3><p>Control Groups 又被称作为 CGroups，是 Linux 提供的针对进程的资源利用（CPU 内存 等）的统计和限制的一种技术。</p><p>CGroups 技术加入 Linux 内核让 Docker 容器分配到不同的资源成为可能，下面是 CGroups 起到的一些作用：</p><ul><li><p>资源限制（Resource limiting）：可以将组设置为不超过设定的内存限制。比如：内存子系统可以为进程组设定一个内存使用上限，一旦进程组使用的内存达到限额再申请内存，就会出发Out of Memory警告。</p></li><li><p>优先级（Prioritization）：通过优先级让一些组优先得到更多的CPU等资源。</p></li><li><p>资源审计（Accounting）：用来统计系统实际上把多少资源用到适合的目的上，可以使用cpuacct子系统记录某个进程组使用的CPU时间。</p></li><li><p>隔离（isolation）：为组隔离命名空间，这样一个组不会看到另一个组的进程、网络连接和文件系统。</p></li><li><p>控制（Control）：挂起、恢复和重启动等操作。</p></li></ul><h3 id="Union-File-System"><a href="#Union-File-System" class="headerlink" title="Union File System"></a>Union File System</h3><p>联合文件系统，是 Linux 的一种轻量级高性能分层文件系统。</p><p>联合文件系统是实现Docker镜像的技术基础。Docker镜像可以通过分层来进行继承。例如，用户基于基础镜像（用来生成其他镜像的基础，往往没有父镜像）来制作各种不同的应用镜像。这些镜像共享同一个基础镜像层，提高了存储效率。此外，当用户改变了一个Docker镜像（比如升级程序到新的版本），则会创建一个新的层（layer）。因此，用户不用替换整个原镜像或者重新建立，只需要添加新层即可。用户分发镜像的时候，也只需要分发被改动的新层内容（增量部分）。这让Docker的镜像管理变得十分轻量级和快速。</p><p>镜像分层，相同内容复用！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Docker-基础概念&quot;&gt;&lt;a href=&quot;#Docker-基础概念&quot; class=&quot;headerlink&quot; title=&quot;Docker 基础概念&quot;&gt;&lt;/a&gt;Docker 基础概念&lt;/h2&gt;&lt;p&gt;Docker 存在的意义，是提供了一个标准化的操作系统运行环境，每个</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Docker" scheme="https://xorex.space/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="https://xorex.space/2021/12/14/45f3eae43303/"/>
    <id>https://xorex.space/2021/12/14/45f3eae43303/</id>
    <published>2021-12-14T02:59:39.000Z</published>
    <updated>2022-04-15T09:17:36.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven-的基础概念"><a href="#Maven-的基础概念" class="headerlink" title="Maven 的基础概念"></a>Maven 的基础概念</h2><blockquote><p>Maven 是用来管理工程的一个软件，参与管理开发测试部署的整个生命周期。</p></blockquote><h3 id="Maven-安装目录"><a href="#Maven-安装目录" class="headerlink" title="Maven 安装目录"></a>Maven 安装目录</h3><p><img src="https://xorex.space/image/332.jpg" alt="332.jpg"></p><p>上面就是 Maven 的安装目录：</p><ul><li><p>bin 是 Maven 的可运行文件，是一些运行配置文件和 cmd 的 shell 脚本。</p></li><li><p>boot 是 Maven 的类加载器，负责加载自己本身和管理的各种类。</p></li><li><p>conf 是 Maven 的所有配置文件保存地。</p></li><li><p>lib 是保存写 Maven 的 Java 程序需要的外部库 Jar 包保存的地方。</p></li><li><p>剩下的 LICENCE 和 NOTICE 就都是证书和注意事项了。</p></li></ul><h3 id="资源坐标"><a href="#资源坐标" class="headerlink" title="资源坐标"></a>资源坐标</h3><blockquote><p>描述 Maven 仓库中资源的位置，也就是一个 Jar 包的唯一描述符。</p></blockquote><p>通过下面的三个标签唯一的确定一个 Jar 包资源:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>所属于组织的名称，一般用域名反写标识<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>代码包的单独名称<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>代码包的单独版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Maven-操作基本命令"><a href="#Maven-操作基本命令" class="headerlink" title="Maven 操作基本命令"></a>Maven 操作基本命令</h2><p>Maven 的命令通过 shell 脚本 mvn 来执行命令，脚本 mvn 进行各种环境验证，通过后调用 JVM 运行使用 Java 编写的 Maven 主程序执行命令。</p><ul><li>mvn compile 将符合 Maven 项目目录的源码和测试代码编译成字节码，并放到 Target 目录里面。</li><li>mvn clean 删掉生成的编译文件 Target</li><li>mvn test 运行所有的测试程序，根据 Assert 的断言结果，生成测试报告。</li><li>mvn package 执行 compile test，都通过之后，将代码打成 jar 包放到 target 目录下面。</li><li>mvn install 执行 compile test 通过之后，将代码打包 jar 并放置在 Maven 管理的本地仓库中。</li></ul><h2 id="Maven-管理的生命周期与插件"><a href="#Maven-管理的生命周期与插件" class="headerlink" title="Maven 管理的生命周期与插件"></a>Maven 管理的生命周期与插件</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>这里指的是一个项目构建的完整生命周期的不同阶段，主要分为比较大的 clean default site 三个阶段，其中最重要的 defualt 阶段</p><ul><li>clean</li></ul><p>负责初始清理工作：pre-clean，clean，post-clean。</p><ul><li>default</li></ul><p>核心工作，编译测试打包部署，在要执行生命周期的某个事件的时候，必须从头开始一直执行到对应的位置。</p><p><img src="https://xorex.space/image/332.jpg" alt="332.jpg"></p><ul><li>site 产生报告，发布站点。</li></ul><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><blockquote><p>插件是用来拓展在某个生命周期的阶段，所能做的事情的。插件也是 Java 代码写的，也需要唯一资源标识来引入 Jar 包，唯一不同的是配置在生命周期的执行阶段和执行内容。</p></blockquote><p><code>&lt;goal&gt;</code> 里面添加执行内容。<code>&lt;phase&gt;</code> 执行插件在哪个生命周期阶段执行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span><span class="comment">&lt;!--执行内容是啥--&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span><span class="comment">&lt;!--在哪个阶段执行插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><p>比如下图，在生命周期的不同阶段可以激活不同的插件完成不同的工作，然后获得各种输出，比如 war jar xml 文档 等插件执行的结果。</p><p><img src="https://xorex.space/image/333.jpg" alt="333.jpg"></p><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="依赖声明"><a href="#依赖声明" class="headerlink" title="依赖声明"></a>依赖声明</h3><blockquote><p>用来声明项目需要依赖的代码库，会自动从仓库中下载并配合 IDEA 添加依赖。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br></pre></td></tr></table></figure><p>依赖代码状态以及打包的范围：</p><table><thead><tr><th>scope</th><th>使用范围</th><th>例子</th></tr></thead><tbody><tr><td>compile</td><td>（默认）主程序，测试，打包都需要</td><td>commons-logging</td></tr><tr><td>test</td><td>测试和打包会用到，但是主程序用不了</td><td>junit</td></tr><tr><td>runtime</td><td>只有打包的时候会用到，主程序和测试不用</td><td>mysql</td></tr><tr><td>provided</td><td>主程序和测试程序可以用，但是不会打包，服务器自带的</td><td>servlet-api</td></tr></tbody></table><h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><blockquote><p>正是有了依赖传递，出现了间接依赖的情况：</p></blockquote><ul><li>直接依赖：在当前模块中的 pom.xml 中直接加入的外部库依赖文件，被成为直接依赖，可以被使用。</li><li>间接依赖：项目依赖的其他外部库所依赖的文件，可以传递给当前项目使用，不需要在 pom.xml 中声明。</li></ul><h4 id="依赖冲突裁决规则"><a href="#依赖冲突裁决规则" class="headerlink" title="依赖冲突裁决规则"></a>依赖冲突裁决规则</h4><p>对于一个依赖，项目中有大量的不同版本，那么遵循以下调用顺序：</p><ol><li><strong>路径优先</strong>：对于两个相同依赖的不同版本，对于当前项目进行依赖传递路径遍历，哪个版本的距离更近，选用哪一个</li><li><strong>声明优先</strong>：对于向同级距离的间接依赖来说，所属的直接依赖，谁在前面谁优先。</li><li><strong>后来优先</strong>：对于直接依赖的版本来说，在后面添加依赖的优先。</li></ol><p><img src="https://xorex.space/image/334.jpg" alt="334.jpg"></p><h4 id="依赖传递控制"><a href="#依赖传递控制" class="headerlink" title="依赖传递控制"></a>依赖传递控制</h4><p>可以控制依赖传递特性是否发生，主项目可以控制自己的依赖是否将间接依赖传递过来，也可以控制自己是否将自己的依赖暴暴露给依赖他的项目。</p><ul><li>隐藏依赖：将当前项目部分依赖文件隐藏，无法被依赖当前项目的父项目看到并进行间接依赖访问。只需要在项目依赖中添加 <code>&lt;optional&gt;true&lt;/optional&gt;</code> 即可。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> <span class="comment">&lt;!--引用自己的项目就看不到依赖传递过去的 junit 了--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>断开依赖：主动隐藏/屏蔽直接依赖中传递过来的间接依赖，在本项目的依赖声明里面，添加 想要断开的间接依赖的唯一标识（不包括版本号，会断开所有的版本的间接依赖）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span> <span class="comment">&lt;!--排除依赖 junit 传过来的依赖 log4j--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-spring-cloud-config-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="多项目管理"><a href="#多项目管理" class="headerlink" title="多项目管理"></a>多项目管理</h2><h3 id="聚合管理"><a href="#聚合管理" class="headerlink" title="聚合管理"></a>聚合管理</h3><p>对于一个项目的多个模块，如果可以一起进行管理，一键所有模块一起编译测试打包，那该多是一件美事！这个 Mavan 当然可以做到啦！</p><p>首先建立一个空的项目来管理子项目，在空项目的 pom.xml 文件中，标记 <code>&lt;packaging&gt;</code> 为 pom 管理文件，然后添加 <code>&lt;module&gt;</code> 来标注自己管理的模块：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Module01<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Module02<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>../Module03<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>好了，现在对与管理模块的任何操作，都是对它包括的所有 modules 共同的操作了。</p><h3 id="配置继承"><a href="#配置继承" class="headerlink" title="配置继承"></a>配置继承</h3><p>对于多个模块有着相同的配置约束，可以写到一个模块的 pom.xml ，然后其他模块的 pom.xml 引用这个父配置文件，实现父配置文件对下属模块的配置统一管理。</p><p>父配置文件可以配置下面的东西给子模块配置继承：</p><p><img src="https://xorex.space/image/335.jpg" alt="335.jpg"></p><p>然后子项目只需要再 <code>&lt;parent&gt;</code> 中写上父项目的唯一资源标识符，就可以继承上面的配置了。比较常用的就是 <code>&lt;dependencyManagement&gt;</code> 中规定不同组件的版本号，然后版本号就可以被子项目配置文件继承，不需要再写具体版本信息了，直接继承父项目配置文件中的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>space.xorex<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Manage<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../Manage/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--这个非常重要，是父项目 pom.xml 相对路径地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性就是可以获取某些值的变量，可以通过 ${属性名} 来取出来值：</p><ul><li>自定义属性值： </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span><span class="comment">&lt;!--在这里定义属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要可以用来规范</p><ul><li>内置属性：</li></ul><p>Maven 内置的一些固定属性，如 ${basedir} ${version} 等，可以直接用。</p><ul><li>Java 系统属性：</li></ul><p>可以读取的 Java 本身的一些信息，通过 user 头获取，如 ${user.XXX}</p><ul><li>环境变量属性：</li></ul><p>可以获取系统环境的一些属性值，通过 env 头获取：${env.XXX}</p><h2 id="多环境兼容"><a href="#多环境兼容" class="headerlink" title="多环境兼容"></a>多环境兼容</h2><p>对于生产测试发布不同的环境来说，使用的配置信息可能是不同的，就需要对每一种情况进行预设的配置信息管理，这就是 Maven 的多环境兼容。主要就是在 <code>&lt;profiles&gt;</code> 中添加唯一 <code>&lt;id&gt;</code> 的 <code>&lt;profile&gt;</code>。然后就可以在里面增加很多这个环境下，独有的一些属性和配置。</p><p>当我们执行命令制定了生产环境的 id 的时候，就会生效此 <code>&lt;profile&gt;</code> 里面定义的各种配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>Development<span class="tag">&lt;/<span class="name">id</span>&gt;</span> <span class="comment">&lt;!--两套环境开发和测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span> <span class="comment">&lt;!--此环境下的生效属性值--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">now.properties</span>&gt;</span>Development<span class="tag">&lt;/<span class="name">devep.properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!--此环境下才需要的依赖--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>XXXX<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">now.properties</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">devep.properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>XXXX<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>XXX<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="私人-Maven-服务器"><a href="#私人-Maven-服务器" class="headerlink" title="私人 Maven 服务器"></a>私人 Maven 服务器</h2><p>这里使用的是 Nexus，使用 bin 中的 <code>nexus.exe /run nexus</code> 命令启动，在 localhost:8081 默认地址打开。</p><p>可以在 <code>etc/nexus-defualt.propertie</code> 来修改基础的配置，在 <code>bin/nexus.vmoptions</code> 中修改 Java 写的服务器本身的 JVM 参数来改变服务器本身。</p><p>启动私服之后，可以创建不同的仓库用来放不同的 Jar 包，然后将这些仓库都添加到 <code>maven-public</code> 组里面，这样 Jar 包放到不同的仓库中，但是在同一个组中获取。</p><p>然后就是在 Maven 的配置文件中，修改 Jar 包上传和获取的地址。</p><p>首先是设置上传的服务器，设置了两个，一个是快照仓库一个是发行仓库：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>XOREX-SNAPSHOT<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>root<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>1e4b489a-bf28-41ae-a46e-073ea9c5119e<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>XOREX-RELEASE<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>root<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>1e4b489a-bf28-41ae-a46e-073ea9c5119e<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在项目的 pom.xml 中指定当前项目 deploy 的时候，上传到哪一个服务器上面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>XOREX-RELEASE<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/XOREX-RELEASE/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>XOREX-SNAPSHOT<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/XOREX-SNAPSHOT/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后就是配置获取 Jar 包的地址，原本我们配置了一个 <code>&lt;mirrors&gt;</code> 用来从阿里云中获取 center 服务器的镜像 Jar，现在我们要多设置一个自己的私服，从上面获取自己团队编写的 Jar 包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>XOREX-GROUP<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>XOREX-GROUP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/XOREX-GROUP/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后运行到 Deploy，就会把代码发行到私服上面了QAQ。</p><p>Maven 大概就告一段落了……</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Maven-的基础概念&quot;&gt;&lt;a href=&quot;#Maven-的基础概念&quot; class=&quot;headerlink&quot; title=&quot;Maven 的基础概念&quot;&gt;&lt;/a&gt;Maven 的基础概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Maven 是用来管理工程的一个软件，参与</summary>
      
    
    
    
    <category term="开发知识" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Java" scheme="https://xorex.space/tags/Java/"/>
    
    <category term="Maven" scheme="https://xorex.space/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Happy Diary</title>
    <link href="https://xorex.space/2021/12/04/0dab1fe2e30e/"/>
    <id>https://xorex.space/2021/12/04/0dab1fe2e30e/</id>
    <published>2021-12-04T02:52:13.000Z</published>
    <updated>2022-04-15T03:24:38.915Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a8816b9d44045b4653f0f0d5b368e2032296e7e0a798af928f49b8c4d88ce742">8a972074cb8fb594adf191142c932486f63d9db6a4bbbbf65eb58b44e7f3a5026192d555de38132d9cf05714cfb089920b22e42d6c98e6ad651278fd4997f55d94184ce8dfef36bf416ace9824be68b08ea149a353017f91555d529c7b313bbf966a3ddae1dc07c077ab9940e0edcd144a80b9c72d682fabbb930fb3dbd451ed518cda96db3758ad0bb761427d25af4891fce1f7dd93f6b9e3096f28d0b225b0bc89281c5f42721f1383d7ccc378ad7682d1300f40aa1727f562bdce805dcc6d1481e44ca40ecc8f0c2205848dc0d1430486584dd27ad1d360fb70759f13c72a0b35e89238ff6d7024ae404ed851f4e0f674baea90189aa17004ecb7db5b042e7a32473ac081c782daac2a6075ab5538000f0a1b585f27f0f37d0e32874f1731ebafd91851960081523fe346834bbc64f21af15d532897b4105dcbdb7cc183953dfd9bf311aaebfaeca57d59a5354154173469c816231893629fb4261b6a480ef0a5e0ac28709db6a8a84b620963ec7095c0b2162a760182688a06e8b43a7a25749e3be25d9e70ebbfe6b59482de154286bfcf8db7168b490a8f7bb925644d7410a5f8a3f67238b80f5c11917b5f7c968378ffea6d77a02bb9fa2f504b129f87ee3f4ec0b70d83ca40fef8420cce0a98d2d7c521b3ac97cb920fb762b70c82118b1e745cbb09aa1de5f32a30d66b94ed7db4fbdccdf78db354a21f324f169425e85b85d8ddda79a002f194278218e0d215a0f666776820bcc30589413921249c3bb8caeaebdcc2c0bdf33d0f70bfcf473361b4952e49bf595c8ee029ee8c313c2fc239c5b5e4e61e736ea420d13a4cdf985e5fe8494efe373d26a5eec46092d454db6d773539c96926e2711c7ba23b54c5aa91ae2128c185a714ac9f2713ca1f09090097df204de60f395c50e0aa717d0af036388eae053e874f79ea0d55b1665cefc83609b55b3c3dc410572d1de92804ab5dc64e465fe59fefe24e1cea014573420633224b13f90b9b9d10d30df501d391f59e41ffc2dc1e91312c52fd3bc2997121e7d3f95a06898f4515ccc3ad8ee97c474d60f339093988bbebea7da6789e0551bf78bc1e77c59a7de8a352c2b0b73a230ba65b4936fc64e4ba6513610f536fbc0509206e248ca09ddd6564075d965736505ce550370d589e4787c9f78245e39dd4f8eb11ab5f69250ab19032b5ede33a4c7b5f7afdbc0eec1a26046d63e0c09dc824d4690bb2c37788fcad4e3a5b77701f3162a188fe04a7553861a1c9d5c501573e3f0311943919a85554813f7b05896da38bfb3f361bbdfe93069e42612edce6526cb00eabefd5070a11b9d7909ac273a9e32349012e57b6916ecd37d7b8e1a4379585c6b11e5e606ecb1a4a1cc673b528fa16857840b777281b71b8940fdf0e8bae33d283655e5bf2c7f989eb19a327cda9c9272524a00d5304605e8aa2abc8898d9f3527a91ac4d6b06c3b4a72bd6d8110d3a5ab58b3a1a9ebb6cf93c8ffa112d53b0af17d1f31e4f488a3a50541deec3c02ab8bcae54389f548fe28a2b62b6075fded197fea4a2c4f4b7b252f70044e1087bf1aa406869620bb3b1e6fdbbe7aaf02dfd740c2386511fd60ec3c19445c0de4f7421daca14eae07c190a25eff55f202820f59ad33b5a52078dac0d278e3c7c776fbfa8f01d26cc8b7b0b4383978c060e723cd03fc686a782e577603a16cff0cb739be41d0513368fc3e9f4dfc277e5ddbbef229839e3e1469a2cac76315d2b458d1e62bc6358fee65bdbcd82657cd89440221f251c8b1c61d564eb74e4f05adc5a0980ab8f42d8334c627e4a5afad16102ba645b3f424292c1b454da865752f7a37310c35d0cdc89c554aad59995809e04ee73fd15def4d6d0a75c091f94777788eb1356d082478bcba6df0b6930b5b2b316bdb101ccdbee32e24427e27c91ab050ba7dcc8bdf3354a99ad99124741ebe46a38c444c07b5f4a62130603bdbaf278172b57d4141ce3715725707150ab2ce5d73d45f5f132c7ba7267564823082a9856c590ddd8dc487cdb3a0f5495cadd41977c4b22aa4f40b786ed332bc3a8d5ddaeacd862862040109bd547742e9cae03632316d09fd0bbc03826561957ca18f519501332c2e05cfcd2f39e406a7cb5d5a973e9428f126fc7c4d52c0149d9306ce2809c8aa5f037f4801f0d09edcd7d832571c3aa63254a8571aa9ffc164cccc278a87ec997bb7a02077b9919fd12a302adc9ef5e11b290aee7253295a9aecf7c671c8a968f76753b96a891754a3131ef8a0e40178fdeb75901434098f4902e367252c2adc27a4ca845385dd30491904ef754755c30934b95e39d54020fa5b57f71b65462e8fdb3dd9e33e5d36762665e376462659cfb813a1e9fea117df569f67e819ab78146269a02e4e2828b74c0b60957758d31f276df7a8c7508b68245b9cb6b73c8b9972ea65f942c235354fa806dac7d4c6fedb897b9e24df8b861b862ef6109cb9ac460425a1f1fbb2e84f94ff3b8b36a1d20c2f5c7e2041a36a53d01372a41e089ecf4d46434714d6020201f7c8b6d3c08d44219fff29370fbc93065605fe35bf3a049078bd232570c5c996a050193c389a73c6c2f3b0a2b3d5c0c46481bf627190d96aed110d7202f62bbc74d71f49482a97016af032486f212b626df5d383a15c30d29b4c6b663eff30a0128816ed96d327cd490147a69a04a05cba5f0b03569de901230fba3c59c1e405d4d225a264d9c15625327fe7491f7dde991253346f0de716580458c69543daebe7179870448d6a2393fbccb55f85652ae388a245a98f2231e8926624926a5afe3cf8d80799d6fd594b3528d6fee6caf7d7cd39df48b9c376a39782ce4a1de16e6b0604ef8f3473984522d8496df7ec48529eb8d390e271b47570b58454c03c3ba1dbd07d58706dd4b5f33cb75a38d2ad576877a16cfb253cc59353ade2b1cffe69d816aed75ec3e25a300014d34ba411b51ffa3ae970028c8cdaac2f5c16152680b24e4869ff944573dbf2e4df167e354249197449aba48e2cc08fcfe303fcb356984c57bd60907e700d01c9bd69f01551819589aeac89aa2466e20c8c8046db27e7a96a9c862596b2bf7ce246207072f649d072d81cb774000c006cb4a873fc6a13bd9647dc2f5ad964a7c02f7c6e50b71bd8bd91bd12a7d27d41544efcfe2b6836d6dfaf426026fdef0ce586be08c605ac03edb3b3257985bac0432e3ed7f7728807361caa884a051c34e505d0de94db8d956fa9703a7cd54c0c81caab7aa00d52ab471f1fa7a0df436b72629ce6732e6721cf63b433f2ae6035e0400f85f947e5a78104da86e9ed01caf999aec9d8a04faee2fceb36200586efa0723e2709ff73ad207824383afd7fd384bec980653cc746e328feaf1298bc6cd80a104cc4c37d6507369625a5679d5f3db4a19040af94998cd31552acfd7009fe0164c62939193bfa2134019a9d54c5520dd24e49735a0acba042efd188c2f4f68721d8d9f62c87aea17d7a1b4331fa5da94a81bfae7e173d0163baeacc714a88f8a7e936eb5860b9f3de450129f022b4706b104375c75fd86ddb3608ea368561f229e427c85ca4138215b756f212f3cf8aa0708b4db9201be7f94f91444bf368924a176ee498800d35f53643de557339b8bd8f09962d6baeaf894e3b0a82e228991975a3fcebbd9a941b72c4dca47423b00508c4a116c8016a3da1fd94d44aeeeda65ba6eae35246528a6974c5b2b4a8e988149f9aebf39960124d25c20a870ba166f49b2677a66376b6a4ddc2b24f4884cd109bb104fb95f89cf1c106ef4a6ddd506cca08933dddcd946e598dcceafb783c4f30a0d43981efec00e28d857d411d3acb221a67d4b4c037a83fcc2c0d456b53b6b50ccc773cf3166c1ffdb5a9e92ca77671dfc7b42b5dde618c3505eae95fba46dc9bf491bda9e018c5dee5da39cae937ec12892e0fa4428a91f9b92f5897731e3465cc6fd4c743ce4208f80feeb45bbd64bbc21999f8dd7590ff8503d5274b4d496b9072d702463f7544d2f014cf6134a66e9759e8d9f661b4b9539b77652a46c3a00458db5881ef74281b15b31ba80419edda2dc0525bcc1cb54c09f7d1166a01a60d66b3753d8c484788416e15057741891066251fce938499bee1b735916d9832abe4812285e5457c8583ef7e988f13d5ff1c471a6d099477ad7270d122fc4529966f43a33424ddf302888c75009850df2cb420c6102c80a043ca0453c9fb184d6ee8ced17acc9436760f35d90261efe69dc197c7dddb2b2feb019a6c13bd2939aa6a196ee683c81e01def57c746aaafda7acf30f24cb6b03982b8c1cea615eac39a1fd638aa1054bf657e2030b9adee0631aca4f18d3ef9a3dc7180ebbfd193d3cfc06a1d9ce1547b4618b479ff092058aff0133c05edb32895a84b1dde0a31c4d9539a5799af46ddd3140f4a2c27ddec7baa452c990b91a4cea4f914a9a0be54363febf2ef6a8afbe0818b0e73cd561040e514290fd1b8efb43104a9139c144f72f85c0fcdec23dc3cbada04e8a6659bac2b96cb596cfa16f2c0c98e521820ff65081eecb83a4c3e23b3e302913be79f46e361b85d7fe03268cddb8fd15651bbae5eedbea649ec7994be6c366922328f8bbca258292b418fdac352bc01ef4f35d77e126b91d6439ddc1e4ab39407274700cf8ef687fe86f0bb8dfd999217268eafea62f4e0781dc072eeadf6788012dda887b02c6b4b9951b23b312fcdf6bcc5c4ba25a7e292ecab8ef673a1a88f2470ff84813b4866ddaededbedd7917712e871e383b20361833776cbc5246128a7bd36e04b492a82e888f2d885e78655a76051f18355e099e843534bcb91f8de31afedc950d262e09f3483eee6ee39c0e94108d79b8f0957482f1c99e4c6222f1e128372d7dd618764ac0f04da5fc2dcdbc44cecd6a5d5f851ad2ca021df8117f0b8795194f1318e6b387841492a21ca7f917ee1fe91bede9735214e4f731ebe1b2ae0faa089f7a0ce5d8855b918b9d88afd2b8722412b5ae2742769b0008d10b7478af369e4c308b7efa3998fb8afaa819777db9304098de8ae792895effe5650703f0cf4c4fc3e04fa12cb08a39614a6b438bca308bc4488f19f8315322d8466a2db8c738235374faa84852712f918cde7a18991bfbb82b0120259fddf6dca04f540ed2747445fdf37541a960dfbf68334a11b2fc703e3b15669508e89e731e6605665c2ed08e1fb6c1c317e6d3a3d3bf4315d2ea34d6b58f1f93f44ee980351a163d9f6d9348e8d4d1b01bf29ad56f05e52fce44e0092fdea39f99ad7696ee2215ad7200e7e4b139b37be776349824588112ce09222ec5c5f6496378ab929fca2fabfe55600c468dca3fd1eb1688828be411281ccf392f4b6d159a354d260853d98b91c43ffa5f242361391dc17c77d9445cfceb5dc61527106acc1b2499a7e72574db90afd748c334d382e0023c533b08a034fc7e5602003ca202a4204f1dbc2890576b4ed937651fa033a5e209d6ecad0ccfdb7318ab62746f0c3a1b824995baa54ff9555a254e28638b64cb8171bb80178aec4c3c9b683ff9de9743ca97181d589fd0b10b2c60c9052d1b55b8ac2de9a5a2c92efa77e2a87517d208656cca86f8a0e68858ad4df9fe3372783064075e122a7e65aec48334ad653bc6dde45953a6ef369ef2790f9f6c545e8fc45a47adc1e2dad8dd9a5e822ee1def168a3f3e621eb995a85c372f04c22a6831ce3a12cb4d8c2a5a09347ead8204dedf9e8efdda9d3394b9d83785c560ac8e3077a9325502dd605b256901b4612f60bd3b34f830b46ba3d3f716f2278c3b025826de8c91b295ff87073def866a87109e8c514c47bb7e81a14a09e060eac180e4a30bbaeae690bc048c982de138aa6c8fae5b8f06039563f409c3116c93e7b58bbefbfd029ba62bc67392fd59ff5507747645e8f2284bcca72662367d7f5fdf4a6badbf93cc5508b187bef25dde5a8a9a305165c3739190baffb77e0537bedb351c39cd4b69c528570d15b164f248fd583e1dc6a6383e7ffcbe04b996b9daefc576c4580f04b54a440a753ab1218504eb914a00fe2cdab1bea2654f5f05b57c96fd91497e1120ca16646cb352e9541b45eadae7c0d3fe5140ae9524d8f33a4d410c7948e959f299abfa48288a5eeabb985951a9235576c9c34c0f47b88087fc2a04ebd9d2e1eefd5c6fe15cc075356f15eb8d644b79cf21e9651679341b45e15b7d1bb3d0c709d3aa830b144a0cc767f691bd5fef93b233442b591213177a8611f6c467f10d55d993f855262a5b462b1976b13b986062ab490a36f0ddb2f4622e253bd97c3b8ab5946b08853ff51c1c6399aede35c9c63cd7e3e21b751279c46f63f52ee987087e4e22dfa64e3b9ec6026187c0c2c2adcf0035d0af731c4596811ee6f5fda03c1bea1fe38508ffc79af3d09ebe822d1cc1843e566744b60222593d703df015a8afef4a2e644475e29dc4d9cbc2d22360ec6c816064d90a48fee3939db3c28db21de7b7eb2ee7a568541441ed42961e5c381c26a2805a7bed1251118f92ff747508f2b44a46520c3fe91c6abbf1c4ece87ac46bfb4e1fdff7f74f0807cb47bb8e03e70d43260c3f8e8540eaecc1ddd390c99d7620ca80d04a74ab13388de90bac40e8f1d4e7df75f88b0a10e7db95be75304211429610e499a0d003b5824d98ec0b110f051c89299475df1cff2d434a2f1c092a5302f54d07a0a5ee2583ae65c7a7e1ced042db82328713ef6bb6f0b36e2cb445c977541d87a1a189abfe45fe66f09f3c185b12d8440fbdbf1bb32b7554ad82b3864fef18feb90358dd1f39643068a43b87deb3ddf5884e68c1f7933d3e699c9bf3a767c2385f5de830ad1eb993711cd5b9d602716f7c609715a642a402154d6dc95d6f9e399f7952fe20346ba9372b2bd7733e8b30feddde9bc6f18774c16abc75c85cf223565f595c92afc295b78a9f9512dee46b5a4973530c290077dc6b5d85a5ad5cd0149fceacecda7f693b87a9860c4c13fc9f7887b2aeedbc1e0df32eb99579fbf7f6d99594e77a9c7dedfe4230d8ea849f6322c09869622430396af51e8feabf3250f1de3c7ec898d805173256681a202e94991e3358137751e714e89a9f1ca2c136b8789a2cbbf7c27e1e78a1cfa4e9a40c4ac6b91f32d77195611318bffa6c3ae6cb2300fccd70804e8537d07911e728fe3ae8bd37a69c4cb680df28d0cad6add5ae389bcebb64c635cb7f95f7648488b976e956286dab90e21ae9c8ca6a9323bb073cc95fc1ad9f0a54368452c7d17f51b6889cacb9ee23297bd8388052a37ff7e8cd155daf1e6400a8789285d80a666ede5d44f290ee3310b90a53fa14bbfd54a99281d53eb4bf17487fad0fd72933c848ccd671c39b8985d00cfba6441cdd64f91b352c89ecbf644e6341f83215004bb33565458195680b025e37083d579acef851af640b677674458c10fa91acb577c299ee596a3ccd6a4b88ea11ede55ce5aceb14d56d1c9995352d2bfcf649151b62eeaa0a2accb8ffdf71bb5f2949a6a286c9692b5b2dbbbb2ca932a389afcf85d300d701af900b67e132bf8a548af490154dd076ab73a89db3822d2c3e8c43ce206e9981509e88dc53f31102014cd38b0cc34e7f8a2d383d50d32ff4804e15cfe817c3361851c8ab4486865d8443be68c08c35cd8252c09ecac5c75965bc022e8c480b2d4d37c91ad4d04d3ecc0cc81753d5e693bad6a94c90f7bf97090c6987d05b5d09ebe8a5e6a7f4e7299e2032b0c659a9fc7b1cf1cc3329246cc3b4ba6f289ffb2c6477cc2ff7518a2260d21bc4b92eb01ca94253f3635c90be87fa35f7917f5e112b91a039ca76b9160acf72dc7353f005e9062b4567171ae793648a2a79240b3f36551549d67f5fb609ad44d660b40695954b008f6af7412aee5b07a55f401e320ed1b8524f279a79a3665c5b50d566decf498ba2070aa18f5a6844e4ab937b2789445dfbea29f1718eebe6a07195a8a1492ea0891cb28521e95808bcd3dd9498cbba72a2baa74d0686b9fd5c11c86af56f9cd93e6feb55b111fdfe4fa95aa4bd92457288920539fd4e57556c658631f9cae59d5b002df1878e86df8f49ed6d1e13624ba067a0366a173ef923d4dad14571e06b23f33b83a02a5aecff943c282099feebe448ef0b8169c7548b8f40e4394200eb1128f18716d39ea72683cdbcd00d00886b95e60d91fcc556bed97ddd480d7eae9c37b1b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Encrypted</summary>
    
    
    
    <category term="Diary" scheme="https://xorex.space/categories/Diary/"/>
    
    
    <category term="幸福" scheme="https://xorex.space/tags/%E5%B9%B8%E7%A6%8F/"/>
    
  </entry>
  
  <entry>
    <title>Cloud &amp; Bird</title>
    <link href="https://xorex.space/2021/12/04/ed40d524dbbc/"/>
    <id>https://xorex.space/2021/12/04/ed40d524dbbc/</id>
    <published>2021-12-04T02:36:42.000Z</published>
    <updated>2022-04-15T02:58:09.939Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7784e14fe46c8ce1d33c299903e8baddceb62424c400a496771176e2a226ba8f">8a972074cb8fb594adf191142c932486f63d9db6a4bbbbf65eb58b44e7f3a502760a7b258612f12ecdd307a3b70adf4bf69f59b8c7989e0098909e81107be6ae6531b2d419acb20880ea1ef38ad5d4adbc539cbcb1917681f1e266f18e9b83385afbad4035a8a35666acb3d44b698f04247e222af37e916ab7405d4b2fc81360ee7b43c9aaf937ac9aa92d7a0ef02c50b06c5abef4f5fdb014533994769d979de62dab43c6ecbbbe59fcea2f1b6e578cd7b1ba933977e05c96d5516cdb59454b35929823bd49c07636703118366db2ca40f238ecf09c81a0a7ad320800c981d6873f78de72a8c7eda925aa3966590f00a5422e59a9c9a7b39355bf99868eb81ea5c4a2504d01bab61275fdf11b5c2f5621fe204ceaf63ab6f53527b815023370a0762810bfd1fff052fb4c9e9c71e73256c9d6e285ead1ff6861c0b114c01e848f2a6820d116d081f89a74a23417171a4030938a5c7a8cc24d9bf7f4c101f7076e40a98842904ad68a85ae1c9fa895e3fce0995666886a1a8472864b2592da1b0149d8dde6db5ce9e3038224c52eb319e6487aa889c85674b5e4a569a1b57af4a7fd82e5a58eed672dee532a55c03d90f988c24994b95286a74486ecb9b8b9890eabcf11962881a91290c06ef1f182c55e6a4d1c3d0439a2c6ea371e0f67626db716950dba2ea7e26db08f61b8a764db3e462c76a8c6c17e22b89ddfe0797cdcf8f36b7103c1689bf63e1c8cb6aa01a927806779e08142fc6833d8b568fc95005cf8ba22ec7aafa65f8a1a457a779b7262dbd5055abb11d5814a65d4d03edc3102ad88ed96cc1ffa6cc5df1143dcd31f0a05e1ba1677915fe8b0e0d61279672a78b5fe5b5b3645837d6a7b836e70fba8b03517b27cb0ac8c81a605ebadd3277cc1a919f94f336faa14f1171d9350f38076690be0f24577cb39f535132d59fa1db4d14165b932607b49664f49f571efb9792ec4f4f0082fa423c7e20d2e4bc3b7a518c08189a96c175a8a7fe5d002f03d795dc95f18cab223dcf8a67485e5792d7e1907737fbc6f9afc756b5d4036ee6a91f43bce08050bd264cd7043f4e7023a698b283bf8beb7752a7f254952c7dd3d2f12e48b62d1fc540cc990499487e6b68f04db76958d4920caeeb1750fc0402b02fd063808fe6416ece8ce259fb1bda2c4f4c350405600379f4237a277e48171baec17ae99893fd165b47d849edb4d2ee903f57730791bcd2c7d3a1e2f6ee5efc734b9504ba1a7574cc685c8f3a7ae4ebdc79e6ac7e4bb0d5948494969a0a8c8164dad1abc1f5ea0d15ae27ad723a915cfb85c3139352ac8392481de84ed0fcb026edf606eec28723078c06dd94befec10030ac1ffe2cb65297cacf345b7abe17848a4d02a3ebe8a80a99435f50565e8c26d62c7de1a925910a8749c461327292a3f4a40fc5c9123d8d1a7ca9355bf05482be4dd4d014be420e095ef4f73655132cd8ed5ad5de2494ed0fe25d48389dad7dad2ebcceca03f113b579655381f3d1167319d73fb409b78b4005c201d28280aca32842e21902cb040b669bf4ef9e402a4a24f6422f5aac9525a5f01e24f812ad7a85944e2f1c04f5b7ba2facfbe089ae7e6f6d93984369b17458b397168be552171d1a3c026b1c1e8ce387746667c0341df09b8e98272c48d590501f2da7eb7dc52cb27d76de2d4b440abf843940015b2a35b7ea59e495cf304b767ddc7f934f925f8f4cae3c4676b4640e33d69e51637e8eb92103f7e780acbcf2152daff09fb56df0e369a9664417afba0eb2732e03f227e6a78da2bd4aaa2ab8e88980c90e4fffc2877e264c0db218dcf5f86966b8bada463c23b7b54fec91a0b98b802e8de1124df2e2073228b3dd567d6e4973c0aa9baf0e8f24ae32b4378a48167228d69cd331b610db073475d51f9f1ffc4a55a6f4a4a592a232f024d09545394600557c6e54a68239ab73bdf7d6b297b57edec27fc040ea978d137fba7e184642d240bed456338d453410795c0a52c14c7dfa30449dfd93c5c19a412d027d8991c179b7589c17dc6540bcb4398139f5851feb0773c5d07881552409162e4ebd16a475cf701c810f62bf05a7097c0599d94d7341866a98f404c2365b6e43df20a3ed235ac4e5f83b6a5d47a527d70a880f374126a0b233ced1cee4a3d95b5204e9dae6b597313cabc860466c2003fdcb65d2f155c7d7164749d79e568729dd80077537f57c8bc2dafc74ed64708a80b9ef5d64e5c1a30136593487b29ca3a0fece0f53f22f6ffb882d4e8a6fa805796d1d5a305403a487830ef2408b7756b643776d93ff481eebc3dd8ce7140dbffe4311d9055d41dafa9dc642f1bae0ea79d4d3fe3c6dcecc7ee7f16cea212630c74044953b4bcb4aeb3692743584b51558adece348fd9d6b59376da150e2c5023ee0775875b1ff15607a5dea9e4974fbd14b8f59e31a6dd51546c649e4d3e78911932934a17564091f76e77a051e529e8652e521bf231a59bac1771f40fde6378a841ca030f65c96955902ab6d6678b23b832e96edab39def47455ebb0fbb60eccca0a0f00924fbd5977aa6de1ac5c585084f3e610baba10484691052d0e6c57b5dfbc994fc42b741b07de4f20f6238e535a381050b81e1dba43c2392d228d315b17c798e6a44c8858e5c203864444ee079fb4c5425f13a5e496d33011fc07b157f6a1c277a298cf67546204cf392d37b0ec86a9cf8c1ec320f631898291d23612532d76f14599aea13aefa248ad1b0e92e169b19eb5bc9f174b527bb8654eea70636e5c5e205bbb0cf5665a52eb5a58874a939ab495cf7837cba975f9370bfa1eacb8fc0b579c7b821cd2d0efd22fb6872d4b8c44ee92bc57944d3c19090225fd83797b952a3f94969ccaa124bf7777bc24ddbdc19939b27fa19677c834e6d94e1aef7002f1833d1df77dca0bab46c7131dd75691461033b3419f72b4cde8d4e14a52429e7a89ccf1738fff225c500c460f73ab34331f3f0a28b6bcfcfc9aa31b65bc316e4f51853f23080879af0f1c17a0ba5ef3f10010b16ebb143300c673214ee9af40e258b9c895d074ba7e9a2e3bfb209ceaa7d1f1fe2e006e6ba31780514f83d6d8e818418be260175b33e58131219e8bf2df5c5422a86c91cae68a23f1d1c12cea1c2268527c759127ac949f2931547b51e9685116fa8e6b09f76c2d16b10b37491f8770ea3d116fa7223bf91baadd3098676c65eb7c517f24cccc485afd3c9cdf1ffb9b5e6fc97c939d6e461a1151b35b28237c19a031781daeea0b5b8de378e33f2523c0b88764d26ed3636ca917ebfb81a5115e4240d60b3d4606baa55fcc97f33d028d41e34208c620f5d5eafb3e0639f9cbbba4b96fe8756392d097abcae35106a25a28570aa71926d69c51e7bace1df86cb0ff831bf6f6fb76331a6d0d73e4860c55e061c317f6aa2ef3b95fc0ec040b124f4c15f2793b8730e7a73362300a50ba0bb5f2978ec120a2b011539c1132103b0fb1ba50afea968d1d18b346a5a4bc00fc2d74fe9bd1f2c6de8fd4e5c7476e74dda0e079eb8773801471967e2b4eac3de2ea468e621d68591db107d47e4d16593b88ab684eb45fb3b08125edb59471e18503f585993d5c31e3dc3b18efe3df1b8fc746fb1355cb3cd8ba58596ddf9054fef28252139e9fc6ac89d256255bd651b96299026c5462a522995196ab57638959074f7aabd8233e023b268b27fec4e6d6bcbf75197acee06c29aea76b7ac8e3b3fdf6a7104db5539723c8152fc1d04fe5d69ad443bc897cb967426f8ea32c6016df310b44146417cf4cc44194352b0f33a6d5bedfae732597baf8a4324ee500c5144f603221063b3074c8971d4a0d5d91ae8a49b270cfca22418ee97fbbf3eeff0aa49cf3351e5d77af49fa8f8e806495a2424260752d70a57b5b07f4cd855e63fff81fdfaf8f46edf3fec8a97f8feda6e625331c7e8a6ba2288d1ae7d819b0c6bf194a1dd0108a29d38f58b12db43379e9784a61d07e0beb7c8a5a1de573ac72716d706fbdc86341fcdd433de948294d788c5145092a2647e24ec8f74e546b8d0f6851c0e4461b4e09387e271c47699b9dd80dd2159f9c03286f7cc94f7f0302b6ec5efd6344acc1b15ea7d4fb2727edd0dcd6b5811c071f4575ca8af602bfebb38756541be5eeb0d5de491f408e55679c868fb6b905c1b48dc921de36c3dec427529a2286085f328007f1bde3347048b3f7700ec465d2976ba5ec44a7d3a301efd88264c8b9785e0b104c3de00a96340e2d80c271b5db91d54bae909b38d6deb57c46df545c51d7275d3d61520d3f82cd3dbca3aa641ea912910c278c43868e7c9f6b7cf483678289a16504627806728323f9e8f24daa83e83be0ee24d5fc35fc7ade9ed3a8b8081a97e03a5052ba9088ab0436e611fe9678a76fc497fbd0f301bc485bb272cb1633f6f210dedf84984d184ce64a48173feff5d8e237af5a9734193d686bcaf944046da63e5c2de04edfade959b7e7334ebceb03be21c38ecea03cc292a204d1b489979f39ad64e0163d4fa0cba77cad9012c7d24334cd2947795ffe3de8d4cbf8a9152272e6ccdcb537413bb199b4a2a4fe271245fe74bf4537924696e4238a6b8f6ab6f9c11c55fec419a61cb70404e60592ff396dcfce564b18cc61df1689da9dc0ba595a399e411bb69a53b54e2083b9bd94753527f506c24de54fc952309fd16557aaf1e6c3462d099036e282a802b1f887ca0daae24a0eb215cf4510de86743a7c7f8189edd858554ca713441933b01e14b0f08987221506b32d61775dce2851c248302b6d2398a23858e8e0451cff5e6b234c5ef5b7928cfc7a8794321e7775482b368c24ec1dc39eac7d1d118359235def2abd059e5fc64e87a0ab50fa59372d36581ec97cc3b8514e88fe2641639a2d665af81f74f6933e7775aa25bd9612fe894885145f1597dc2e05d0bdd52fad61987964c0e883cd58aa9245cdb6e025cf7d188252803a1f62bca370dc3113a16f2e00dbbcc4d962efb3da52560bbf5b2dd067a21fc2324a605f7c9a458e2af69a9e4fdfbf6f32093ba394ded78c95b8e176a69b24fe17bff2dcb292f6d01bcfebd99411b35612754cd5c4f3dbe8a687b5026d7b8449740c44a9ff6dd2aa70c4fcd2d72fa60e2e86276c1c9bcf63ffeb11436cb9abf23ceb907221f714d627249b6ac7b4e9112e2f00a2aac717b8888e02095ebd31ae4464325114fce807f18a4940f15415ca37d65ae9915c9802d2acb74981e648f8643933ec677aea829c90b7d188cd6ebe30d9cb263feeb7498cefbc75c19252c176ddb811a584c700d44816fa6af0363db054a6e3328e95388734cf6fa76fe9c1ddb1f77e752c0032797bb916b29a52db806b330180048588f76586c1ee87fc4f63b87ac88bfc3393a9801ed7357c0e3e076ca1263a258d8406784592dcac5d7ae07d7ab2d6d306d023cfd92fb0a6f98fe28856bcef92b49c792ced2159d11e7b73a6474b5aee8bdd574779d1121c500e3e8adb8abf90fc75be4ac17edd8d55ac759d22c32e1dfbb2371202e37911345d000d0545a321a09fc024092101dc43cd0e666779fe104cf07cd852c08531c7ce6bf524b3e98b8c1833dd0c40f6f56e1c65c92c54e87ae690e092b430e8a9031626e0f90fa65616d335f9a71167456c8d39c46ac4c9c9d677729a50d311c3392154cf5c926f6371256b994fbe5ea6d54da4e29d7f4c7047c4f556fc0b0802a6da2efae1eb1d8bb1582ee78d3a60b7846ac9d12cea6bdcec90ce881d753c9198f407758441408e42ef3bb6ce07da76887f94f73bea18cee61bbf411e1c35508b72ccdd21a11ce11462af08618b7b73829d940e10ad7285ad8029db42054bf9c039c9361da21dd4feba047b88ea561361ff10dcf908ea648ac75d152d59192d1be35e624093b952811740c310a80e4775e23d18589fbd5b82c9d6503c4f81b48150e2da4b8d84b56b0a21c8fe573d6f2f3c29ea318c7f3630a195f466f5acae9c582e272b764638677e9551904995e94744bac3612f9a70111a7219b8bd20ce98960617033bc42f0ce26f0307cb59ed908a0e1a35b1c803abf9022245a8341a79d96888c27d97315a23a5bbbabc493cbe7f8f3d056e9dccb7fdf66415c875abeea94c09a6be36cd3756a5af624ad9fcafe223b38081452ee000be83229c291a97ce79c2f8c71fb371129e37410a497b8169fbeb19e7f05e32441f338736c90d39d9de42ff176991bd1e88db6216a5bc35f544393010429a5ede9c8f37e06fa1891086ed2ce2fb69cfd5a5017d06c63aa61749f81a72265f230db31d31210ae62837f2755c2c9c1de8c6acbf983b5900556413bf5f0ebcff4bbc1959473cbc8afbf2666bd57f540e73c08cd0eb33655d066f2f4d7980225a94237d52029c9007ed33a2987e61b6570130866c654e6f105b035ecd146ea876417f86d3d1b5c6ae98b14654bde10488d9b508714c11ff562714c08ec392d6786ac525bfeb407292bd194eaa41febfa9a50e0f00fa91c9f50311be1ae0e9e50e4e59b3f2bd7a9d2ef5d0a9d8ab03360ff8d6dd8bb3a9f2a970218869a1179f8c32b5652267ea8670156305bf3df5f602428a173e63a7e0b403a90bd9684ba8bb0aedf9d98cabf2ea44c7daa141a710977ad360848656e2a0b6577e3764041c5f54f834fede1f549f69aaee8e4fc197fc0697d56c14318bf3366f9850c058022551d9bbe22429558ab5259c82d769b2067ba2a95554f397ac38c5086fe3a5cd8e331e923547fe14c6a2198c4448301fbd9b70f39da78260b5380c80ad9ac790e622d03449c93fa34ebc09070f9c0e4ecc11c4c383c1139b37769ae34b2b198db7c12bab343660425e3d1273ad28109da7afc81d6f7544b0bc1a4244ef407dce03e164e311f4884bc480b5d76b865ea1f0284385033896ea03d2002cb05598736f45c440a01557d9df000d71c119c090219f41e195b3753edf29e3033d190d8fc2f9b1d171f63717a695d461189faa05adc36bd2f6d59b52cd86ac6f9d4e883e40020f573395eb6eed10a9dc3f6663e17d4dd3d8c6a288db38190a67b4c127064cd7a31da7891e77f001133dbbe6139bcd9128eb2655e87e5168b222150815b99f0e257887d829a6d8e5e9bbbd3af1d14568eb0b60ac8603634909423afa09338a65e44f1a597742e2dd38de36ec8e186707d1a6dfde6860f4ad5b9a7d34bfde9314703ac60d6fbca63baed5956332606ccc3f16adfc08ff806ee4a26d0b8ab09a3b39da79f4b45aa62eb2c4dc8824cc2ddf69b51b6f977bf33dcb6bdb721a08a9619b6d89f7b08957f873235a4eeb87316060384a2423d0d0374ee8f28b2438ad0e8a886f76f772b52f3a914afa6cfc922c7e0659ae9887e6466e23dff37bce46f190befdfc5cb1929e1aae08a712acc16d695748a04405eae6fddfb56f6fd6d4f0b803aeda2a96c8306fe791c9ed90784844a59286103d8f19010b30d4d18139b0096aca2fafd646b274e92cae473e3252f42210a5c734e812a387ce8ca29517fa08a0edb7ea8ad7d4c0881eaa9d066952e667cceaa367b839884ee2cc082adbb3f073c3dd0281f4f9f20afba1a3f1adebeb98f0801a77d2019b9e588b1f6e8a422b4aa37c72e8b24908920b27f700941546d065e9dda7e4254a6f69b694c1eaef93e6af8221a4c952dddb0c68f3ba508e575307fb4ab47d0e5460953a6de68b0f7e2d31314e4ee36a0b1f50e139f36e40ff28433a2671ae0032a29e6b6820b21185b6cf2dc21a177183740c46c780976f2d23791542bdb15e195afbb883c4fd6dc8813e9bcf5c65b976743eb3c40ab557a6821551be32066969172b04491ca875cabb67529273b7b79049de565821899d747e96032444ce68986f275eae33f81cba69d119d04181ea92e42e2bef5cf40645391cc3705c6c0dc09c5f62e38cab7704f4be8c0eaf8c2ebae894b0c57b843b1555cdf7c6b6ada70c23b1c1f978ad663e7b8261162cf7bf0f496c1f6ddc22aab4b45347a1a1d1e5f3ba6076e7881b44d610dbcd1092319a97dcc106318550728e3e1f145b48ab40316cb37b7edc0ebd61e8105c449510eee5ff8f369224e8248abd331fb711431956e255d86df4e40fe54aa19751fdfc1c969285fe4cf38e7a66c4c1c147832d399076d902b463416ee00cfe41a1e038a64345a737f93fac79d2ef42c39986d3e808718f87de4d488135739883e69febf66cd0709795cf05c1bb18edfce6f433d2e744ac9af8136ffb293c85e3e8dfc0bb466ddf23aa9c8f5acf0ea8c48e9512e8cccd2a263e9feb8555164846d52d727c9ac382e3d0d182ad8f83f0981d91eee647372ed63276b372a1be010ddd13a4013450892ad1b16e6478794138fcd4370d960e5f39e9ad75f22745e43a36400ad8ff2434e7fd2b191f9b0d241926b24789ed9a177218df3f243e05430c14ed607ef29002ebfff11a6a8eca4987e8b494d08df9c6d3611edffe54cad18b2c431786b533ab9f73d89b6f632371be19fb30ef80fa21db34263c9eba5b005a88a4c84855a798eb67593b32ea54ebd0cb800809fb6dbd1bb51ea60006701eeb4652edfd655f62bbb9297f84f7f0c43a83cb4f1b8b704512858a7c53caa464103ff89d77d1e6bd0c43adcbd65b5f5df51cc73751d10db0384fc5883f730c941646751e2fa81776a0176ea8e48cae3eb5eeac3c0e59df8cbcb35b9d4669284fa435720e17de74e69f0bb7def2ee65eb3b21292e63f42d4b154fa6dd7addb250a596bdd0e681f0b8cebcb041ebe898b8c62575b2d742f3212b663f9572ba5fb9c621e3ca44d933c5c79e4d1af3d6c60f00658c953bd3db2485f1d143548b593042ebd122c1a8a33a0d4fde5bac3d75ccebb0f956df06f68da8352dddd07e5a3ede79e2439c35df0afeb5f47c709ede4387be128af780421531293c0a212adaf1866052720fdef1a613d0b322ba088ed4c5b3e2ea286d7d219a5c06ae7781f2f641d409f12155ccf4ca708ba4d6eeaa355223de4748ad94c480008a8df8537f63644a5b17eb0c447534a9555c706abf13eff2cb3260a61d8cf0a97ac836804c1f4e3b4c4bc6a6b0332fc4a1e37cfc4a852382e2573a1272d7509d5edd8342c131bfa5cf38874116df5cfac3d28f0ce054ecebf55988024ba5bcd963de80495c3de4040e291aaeb5b00510b60ff2610d4e2f922b7c04ed8f2ff393dbda1a54c30fc2ab604070009f2d541ffdab1345b0dc02c890bff97244a76df57fd388c58670659d5cd80ac21d6869a942261ac65856fd26be3dd11d51497447d7303f9bca4f77a5d32cc55b4b7591caa14b02d784e802454fbddfe9b745ce7ec7f81692e454105f0ca4a7fe0a4d0c64cfc6414196f015f6db0a9c69b8db182f00ca3b724978906fdca52fec57c992de8f064c943f1a673075a034f23b4b0e37e7446140512d614fb265fff356bb08e81daa22abd03c378ce8b0cdcd9bfd9ebff8aa93a9e7320804651e836bd273cc43ca7ba9623fc63c58691b3e65a4af7a72022d58a0b5a624d13cfe30ab2239f411280705ca013315f21ef84af71c68de2c8248ca7c4313d3903de160b4e5217716a0612c9f7b5293d2cc3a04773c425dcabc36b8435c507904842f852967360a250b1fb31010c7fff00f23ae10d6ad6b7f6e367dcf2fc780b37c48ecc178dd1da607f77f542d39bd2ae91fde547cbe5594d51e180a11985b48da22a31a0b4225270c04f69a20d788a5437944c61b941afb095e8cd03505f3dd9bc98b943971f45182d75e18071f34bc5594409e2faecd453729b5e7b9df9fca81ee02547c1cc0869e76aa1a21dc62c0d5d454700fc0c9163079aad14767d5b4160f0f6e82cba6c4ad618c4d20ec17e5aad8de6432c5144929b6ceb6ca52d76fde98c539ee1848878cb47699ecb2e23095f3273686a21fb02dfa0aaa22c50fbcf1c502f5d0c1aa7364abcfb1d29d42109f40fb1b3d7a95ebc81504d742f42cf8557d4c20c5adb318d1e11fa5e1a7453a5f6199e623f24f2b46b5b3cbd036abf5f47ab030e8eee0d31635cc99e322d5d9f29a3a2b3e119f2abf018bb4333f8a5e75cce4abc4c84d81b02f36c3edb73550b2462e14b61d876c4435c6ab9a83cb7bfaa97f1bd7d0e7d6cbeccc42b28d11afe6b110c1287fd2f8f6a9fa9b7f710a750862b6d7d239b581a45aafe3e9298cbf2de94a6feec48e7a3fadeadcfde00d0ca618ce53614cd90e8997b658262963f0f4569f131b7096312ebf62c199b492169b0f7c07d9a3680bb09a7431ed787fb525f4e985baa10b357c4e6492d236a517842abdc053df462cc39c767daea4c8458dccb00fe25d6c75579184253f38510dfa3dac222d4ea7e9bfc81a797b26b7c5297f450c1a5695e5e0c7f14e8f6488b1724523ba8cd8bdc87bd16dbae255a4bf18356ab317f2dad58c8225db8d405b4d0e313e6b5466fa47e6f4a3844f04a4e6acb8648fd66aefe954c79639289a23cf3c68d7cab25da83434401bb6e3911556b199b7ab80639ebe9a155c00cfca8b0b20b53f92eced3cc531f9a4640005cf925737d606f506e726b10a19c9e12ae786517565cd435ba04ce992a568bee3dfbbed156711908f7cb4cfa06e849bf9e9bdb978b3b342180c4bc7a2aa3dac5209348a173ef9d85cb1593696ceade419b9447358a484d06f237ddd7641241a398e979a33f34326b3d61206cf8be5ddd110918da30d9de9548e68908226b1b40d84a1884cbad59fe7ca28fcde6fb496231e5f471425493dce445470a0ed842bc2c36d57399a9360304f5b6e321caf9bdc69582042aa6e7f13803e5077b193d7c2ac5ff6560c8e4b2605447fc70ae74988d06345be461b79a82f637bfc45c9fd166aa5f62b0abd27094a6e9d8dff570adb4d8a5c3877761cbf6bfc866901c7bbef665b022b8477fb9b6a82dabc28b92ba4e584f10e48d3f7d2b0d9d0d83c0f4ab962dfd811711cb16e943c8a26537acf26fe5d08ba4d83f9289a67c4fa83a9879780903625b76d42a6b1050b04d3be1fe19d7dd6e96c476f918f3df184f24a93fdff752ba35ea484868e30aad2d515424d5bc12fb2b5b763eb561e63dd6e2b08ef74b189cb9af5ca4635ac87a9248ef053d8e9732df995bc9e494da3dac40201aa285d649e25717213c7bedb31c9d5984418adcc41396d9af90c517cffd35776f7655ef2191ed49d03387a86d162b91595902d6af7df1f59008de9212598e00ea6d061eb79554de585bcecd33a95e375e6eb8d90cd9baa74f9b6638008d23c12c49aeee168d771affb011ef2e706047e4b74b0cc672738e1176305700760ec7db3433f6475defe2b9dc635b7bc2613ed1af3b713cf43f000b7392202dfe7cee85fd79ca7595d4829419baf002198a76123bbbdce6ea11ee990341ec4bef1bc09898c99fd35829703c7c9dddcef00ba6c83c4cbf1d323fb2e9f19069f9b07fa759835c109b12d0729be20a66631863f164022f1ec38de363b10c46a85b5fcb2f7bbd4719d4e6b445be6ebe0e72822ed97c05250e8c702159410d308b306dc3aafdb985f578da3330459bb573693afe2806d70714e6113f98fc9e1151bebdbd361f2fa7bf98bb857f1a4ab79070fe0cdd75f6b66546884d851271d95b48d611a4513690d631bdb2ab8aee573b5e5db5616099fc778e879635022b219f18ad09faa660ac33c353f4164526ab2177c70aef5522a29c5d49462fdab4ff929904eb0cfc2e7c4b98db724c05057fd51a90529187d26332ac0bed6dabc356261fdf1a7b1e99147d3a95c3b2c29f3d6aa220330c54227c33165802ef396c96c83c0cd65c6cdfbcf027c8aba1af600894214132ddec672c023da705f7e63a6eec83362763737a7f2ad1e142b0357858963dc7970ee927c8d61aa6ae96557d43f916ed1ba63976d68358b58bd5d947651e8fcf59eaa8d665d32b07469e3f075f9cc48cdaa1ab8ce84d21a3d2c529bd4f7f96cbdc99e3ce1871956eb7808420584b9bddf26bb71bfd1f9ac94988a27de41488168ea6d2e65ded0259efa46db17ee10e0da0a65904f417f9e682f721fd1285885c63b9fb0c075000b5e1dee2baf694f5de16fe956a834da60504581c7cefc7b708d49bdd203f01a2669954600e9bac95473818e8acec2d2205f16ddaf9f81d8a4a976934d42b9a5eb939fac7fe5653852a4020ad98ef8333f2cc079834b48051603008345611f51fdc1acec48894a74fa6d3920ba031ea911ab8ec9c47d1d3b53dedafa77cfed74f2fb1cb99cdbc04a7e976a5b2bb3dc3b688010e476c598136ef0d6bd005078da287a09b77989785547b49fe408e7520fb6d73270f57dfdfa41fd8ded585486ada7d631f098ffea6619f7d1f7ccb40b4397a5f682d77ab35e404c4c1fdedd48c007c2a09465fb128f9e75336ec60c5fb054aafda25376b98cf0921f1dcd6c48b73c7366202bb4a2323143663c77cf7d33892ec6752e213cb6817df1b1263799795488c11cf4c9075ecbe5a123acd760dc4702d7b5dd86c1640fb92bbcec059a54960a48331af652925c160573f62d135007b062a556c8bcf4de20dcd81192d3a5d1420c75e3ec1c8de88cac232dab2ff6a986b284bdc68551b6a0a2e09bddd7de73e6a4b12d22c6dfe994ae9a35c51c8237ef33532f945d45a46a08ab5faa6cd7fd0b6c5df823248a7c25e45bff0ecb01945818989d577fb52df8835417a1de2c09f6e6436f9600c7bbbf2274f351c154744e4c9bcd6e0b9434d41bd23112f4283cc88ab633a4170e7f74832dd7e3a79dc39162f68133e76cabf34dee0e691c67c3fe710b2ec7a086d7ae0959ca0b48e49f80ded7ea6e151cb7d451d8b59874ebb1e547ba06d7173f8a8916593bccd98118ef540bb73b94d89b4a862dbc67426731b6effe44e4c103003e3f71747fa619d17d414d3a395af542a91e3dac535d94d442e4c055ed04545c97b1a30cee04eb45c8e08d3ee271debf32c2d61a1f853615c50ed9d3a3dcd25174be92c518e91f64d46b58fbb4402085a4c9f89f10472f925a10d549680255174f6d3cc8072450b3f72160e8a2757e645fadfffe6b2afa00144b2258345e7cba52693bff9e6b7ae650364a25d0b32f6c7d0bfd3207b024693f5bebb747d5e6dc68a395c46d441b2c32235815277f244205a87b13133496eea5bfcec00932fc464ca8979ca341f70eef217cff874b8c08fdd405140d148e7b1779829abc403409c0c6e37ec7f5ec1286513e3374592e468b4b21a5a858208e89140ac2eec69d5ae96af3163f6c545f0fd46849f89deab9a6d07dfe5e0cd31bd227eda96ddc8ea80239af5ed7672d6af0790328ca47118cc58fcd199f0ff8b08167bbbe35e8f3f2af14d6afaaf846a8c3f4180c277783b96680812d3818638567a6b936fe111fea8af7eb9e069fc31589383eedcc2d5acadf2d051b364230d8967dd7c4b91d5d0fcc1f18e2855c30ffc7060904f2215e6960864f0fe264e88b8df6bcfb71acea2a5fa487dbe1c3c418bb9b745a06e9b1c32e66d0627</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Encrypted</summary>
    
    
    
    <category term="Diary" scheme="https://xorex.space/categories/Diary/"/>
    
    
    <category term="幸福" scheme="https://xorex.space/tags/%E5%B9%B8%E7%A6%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM-11-Java语法分析</title>
    <link href="https://xorex.space/2021/10/22/dc3e9fcdc928/"/>
    <id>https://xorex.space/2021/10/22/dc3e9fcdc928/</id>
    <published>2021-10-22T02:32:38.000Z</published>
    <updated>2022-04-15T02:52:31.733Z</updated>
    
    
    
    
    <category term="开发底层原理" scheme="https://xorex.space/categories/%E5%BC%80%E5%8F%91%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="jvm" scheme="https://xorex.space/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>JVM-10-字节码指令</title>
    <link href="https://xorex.space/2021/10/19/8900134debe5/"/>
    <id>https://xorex.space/2021/10/19/8900134debe5/</id>
    <published>2021-10-19T12:13:20.000Z</published>
    <updated>2021-10-19T13:47:12.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>Java 字节码由操作码和操作数组成，操作码固定为一个字节（所以数量不超过 256 个）。因为 JVM 采用栈结构，所以基本上的字节码都没操作数。</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础概念&quot;&gt;&lt;a href=&quot;#基础概念&quot; class=&quot;headerlink&quot; title=&quot;基础概念&quot;&gt;&lt;/a&gt;基础概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Java 字节码由操作码和操作数组成，操作码固定为一个字节（所以数量不超过 256 个）。因为 JVM 采用栈结</summary>
      
    
    
    
    
    <category term="jvm" scheme="https://xorex.space/tags/jvm/"/>
    
  </entry>
  
</feed>
