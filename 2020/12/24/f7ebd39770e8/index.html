<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java 核心类学习笔记 | Xorex</title><meta name="keywords" content="Java,笔记,核心类"><meta name="author" content="Xorex"><meta name="copyright" content="Xorex"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 内置了很多核心类，这些类会经常被用到。所以这些 Java 的核心类也需要好好学一学。但是其实核心类中的内容是非常多的，这里只是选择了一些很基础很常见的部分。对于那些高阶的东西，以后会详细的学习的。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 核心类学习笔记">
<meta property="og:url" content="https://xorex.space/2020/12/24/f7ebd39770e8/index.html">
<meta property="og:site_name" content="Xorex">
<meta property="og:description" content="Java 内置了很多核心类，这些类会经常被用到。所以这些 Java 的核心类也需要好好学一学。但是其实核心类中的内容是非常多的，这里只是选择了一些很基础很常见的部分。对于那些高阶的东西，以后会详细的学习的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xorex.space/waifus/020.jpg">
<meta property="article:published_time" content="2020-12-24T08:42:32.000Z">
<meta property="article:modified_time" content="2021-03-29T13:54:45.104Z">
<meta property="article:author" content="Xorex">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="核心类">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xorex.space/waifus/020.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://xorex.space/2020/12/24/f7ebd39770e8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-29 21:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Xorex" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/Megumi.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">232</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">146</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/PostTop.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Xorex</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java 核心类学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-12-24T08:42:32.000Z" title="undefined 2020-12-24 16:42">2020-12-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="String-相关"><a href="#String-相关" class="headerlink" title="String 相关"></a>String 相关</h2><h3 id="String-的实现"><a href="#String-的实现" class="headerlink" title="String 的实现"></a>String 的实现</h3><p>String 在老版本的 Java 中以 private final char[] 基本数据结构封装成为类，新版本则是换成了 private final byte[] （因为对于 ASCII 字符可以节省大量的空间）。里面封装了很多方法和属性可以使用。</p>
<p>在 Java 的编译期，会自动地把所有的字符常量都放入一个常量池中，然后 String 类型的变量其 实就是引用了一个常量的地址。那么在判断两个字符串是否相同其实就是在判断它们对于常量池的地址引用是否相同。所以对于涉及到可变字符串的比较（在程序运行中会对字符串进行改变），是不可以使用 <code>==</code> 来判断两个字符是否相等，反而应该使用 String 类内置的方法 <code>String1.equals(String1)</code> 来进行比较。  如果要忽略大小写则可以使用 <code>equalsIgnoreCase()</code> 方法来比较忽略大小写之后是否相同。</p>
<h3 id="搜索和提取字串"><a href="#搜索和提取字串" class="headerlink" title="搜索和提取字串"></a>搜索和提取字串</h3><p>String 类里面还内置了很多用来操作字符串的方法：</p>
<ul>
<li><p>判断是否包含子串：<br><code>contains(String)</code> 返回 boolean 为输入的 String 是否在当前的实例中包含。</p>
</li>
<li><p>搜索子串：</p>
<p><code>indexOf(String)</code> 返回 int 为最前匹配到输入子串 String 的坐标。</p>
<p><code>lastIndexOf(String)</code> 返回 int 为最后匹配到输入子串 String 的坐标。</p>
<p><code>startsWith(String)</code> 返回 boolean 为是否以输入子串 String 为开头。</p>
<p><code>endsWith(String)</code> 返回 boolean 为是否以输入子串 String 为结尾。</p>
</li>
<li><p>截取字串：</p>
<p><code>substring(BeginIndex,EndIndex)</code> 返回 String 为从开始坐标到结尾坐标的连续子串。（EndIndex可以省略，则默认为字符串结尾)</p>
</li>
<li><p>去除首尾空白字符：</p>
<p><code>trim()</code> 返回一个去除了首尾空白字符的字符串。</p>
<p><code>strip()</code> 作用和 <code>trim()</code> 相同，但是类中文的空白字符也会被删除.</p>
</li>
<li><p>替换子串：</p>
<p><code>replace(String1,String2)</code>  返回一个将实例的 String1 全部替换为 String2 的字符串。</p>
<p><code>replaceAll(Regex,String2)</code>  返回一个将实例中符合正则表达式 Regex 的地方全部替换为 String2 的字符串。</p>
</li>
<li><p>分割字串</p>
<p><code>split(Regex)</code> 返回一个符合正则表达式 Regex 的地方分割出来的字符串数组。</p>
</li>
<li><p>拼接字符串</p>
<p><code>String.join(String1,StrArr)</code> 此为 String 类的静态方法，将输入的字符串数组的元素之间加上 String1 然后拼接成一个新的字符串。</p>
<p><code>String1+String2</code> 更省力一点，直接使用 <code>+</code> 运算。</p>
</li>
<li><p>格式化字符串</p>
<p>占位符和 scanf 差别不多，%s %c %d %f 等等。</p>
<p><code>formatted()</code> 非静态方法，作用于已经格式化好的字符串，只需要在参数里面填充替换元素就可以了，最后返回替换完成的字符串。</p>
<p><code>format()</code> 静态方法，通过类 String 调用，需要在第一个参数位置填充格式化的字符串，然后后面的参数位置一次填充替换元素，最后返回替换完成的字符串。</p>
</li>
</ul>
<h3 id="String-和-char-转换"><a href="#String-和-char-转换" class="headerlink" title="String 和 char[] 转换"></a>String 和 char[] 转换</h3><p>String  变量转化为 char[] 可以直接使用 String 类里面的 <code>toCharArray()</code>，此方法会返回一个字符串实例转化成的字符数组，比如：<code>char[] Xorex=&quot;Xorex&quot;.toCharArray();</code></p>
<p>而 char[] 转换为 String 需要在实例化出来一个 String 的时候，将字符数组 char[] 作为构造参数加进去即可，这样返回的实例就是 char[] 转化的字符串，比如：<code>String Xorex=new String(CharArray);</code>  ，需要注意的一点是这种转化形式虽说是引用类型传入了 String 类的构造方法，但是内部在生成新的字符串的时候，并不是对传入 char[] 类型数据的引用，而是复制，也就是说这是两个独立的数据，并不需要担心对一个的修改而造成对另外一个的改变。</p>
<h3 id="String-编码"><a href="#String-编码" class="headerlink" title="String 编码"></a>String 编码</h3><p>最开始的开始，计算机的字符是使用 ASCII 作为编码方式的，这让英语系国家们用的很开心，只需要 1 个字节就可以轻松的表示自己所有的字符。</p>
<p>但是后来有其他的非英语系国家为了使用自己国家语言文字的计算机，开始开发自己国家的字符编码，比如中国汉字的编码 <code>GB2312-80</code> 和 <code>GBK</code> 。但是对于网上传输其他国家的文字，因为使用的文字编码不同，会导致无法解析，比如韩国电脑解析不出来 GBK 编码的文字，打开直接乱码。</p>
<p>为了统一编码方式，将所有的文字都制定一个标准，让所有人都能解析所有文字，于是 Unicode 就诞生了，这是一个立志于编写所有文字的标准。</p>
<p>在创造 Java 的时候，当时创造者认为两个字节的 Unicode 就可以容纳世界上所有的主流文字了，所以就给 Java 的 char 类型设置了两字节的空间，并使用 Unicode 作为 char 类型的编码方式。由于像汉字这样的表意文字大量加入 Unicode 家族，导致了 Unicode 的大小不断膨胀，一度到了四个字节的大小。</p>
<p>这时候英语系国家的人就不乐意了，因为他们的大量内容都是使用 ASCII 作为编码的，他们不但需要改变自己的编码方式，还要白白的多使用三个字节的空间来存储一个字符，于是基于 Unicode 字符集的编码方式： UTF-8 就诞生了。</p>
<p>UTF-8 的最大特性就是可变字符长度，对于 ASCII 的字符，编码方式和 ASCII 相同，都只占用一个字节的空间。这样就不但不需要改变原来使用 ASCII 编码的信息，还符合和其他文字一起用的标准，并且能节省大量的空间。由于这些优良的特性，使得 UTF-8 编码快速成为了互联网上最流行的文字编码形式。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>对于和 String 类有关的类型转换只有两种，一种是从其他类型按照长得样子转化为 String 类型，另外一种则是将 String 字符按照长的样子转化为所属于的类型。</p>
<ol>
<li>对于其他类型转化为 String 类型，则使用 String 类的静态方法  <code>valueOf();</code>  这是一个重载方法，尽管输入不同的类型就是了。比如 <code>String.valueOf(3.14);</code> 会返回一个字符串 <code>&quot;3.14&quot;</code> 。</li>
<li>对于 String 类型转化为其他类型，则需要使用要转化为类型所对应的类的静态方法，比如将字符串 “3.14” 转化为 double 类型的数据，则需要 Java 自带的类 Double，里面有一个方法 <code>parseDouble()</code> 可以将接受的字符串转化为字面的 double 类型的数据。需要注意的是，如果输入的字符串对于需要转换的数据类型来说不合法，那么就会报错。基本数据类型对应的类一般都是首字母大写的全称。</li>
<li>还有一种比较特殊的类型转换，那就是将 String 类型转化为字节类，使用的是 String 类的方法：<code>.getBytes()</code> ，会返回一个字节数组，里面的数组是 String 类里面的字符使用 Unicode 编码的存储。</li>
</ol>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>String 类可以使用 <code>+</code> 来将两个字符串进行拼接，对于常量的字符串来说，<code>&quot;Xorex&quot;+&quot;Tempest&quot;</code> 会被在编译的时候直接变成常量 <code>&quot;XorexTempest&quot;</code> ，速度会很快。但是对于非常量的字符来说，每一次使用 <code>+</code> 来运算 String 类的时候，就会经历创建新的字符串，扔掉旧的字符串这个过程。这不但会占用大量的内存，还会影响 Java GC（Garbage Collection）的效率。于是 Java 中就引入了全新的可变字符长度的类 StringBuilder 和 StringBuffer 。两者几乎相同同，唯一的不同是 StringBuffer 是线程安全的，因此效率要低一点。</p>
<p>StringBuilder 类的初始化，也就是构造方法有三种，一种是接受 String 作为初始化数据，一种是接受 CharSequence 作为初始化数据（CharSequence 不太了解就不管了），最后就是接受一个整形作为初始化容器的大小（默认大小是16）。</p>
<p>StringBuilder 里面有很多对字符串进行操作的方法，比如在字符串后面附加字符串 <code>.append(String str);</code> ，在指定位置插入字符串 <code>.insert(int Pos,String str);</code>，在进行大量的字符串操作中，因为使用的是可变的字符串，所以性能会快上很多。由于内置的所有操作方法都会返回实例本身 <code>this</code>，也就是说可以进行链式操作，将需要的一套操作接在后面即可。</p>
<p>如果预测或者花较小的代价知道需要操作的字符串最大的长度是多少，这个速度还能更快，因为这个类的默认容器大小是16，如果不够用，会重新创建一个两倍原来大小的容器来存放字符串。如果操作字符很大，那么就会有 log(n) 次容器的销毁和创建，如果在初始化的时候直接输入一个合适的大小，那么容器销毁和创建次数就会大大减少，从而提高性能。</p>
<h2 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h2><p>故名思意，这个类就是用来连接 String 类的，专门用来处理用分隔符拼接数组，首先需要给构造函数一个分隔符，<code>new StringJoiner(String SplitSignal)</code>，当然也可以在添加分隔符的同时指定开头和结尾，只需要在 SplitSignal 后面依次加上两个字符串就可以了，比如：<code>new StringJoiner(String SplitSignal,String StartSignal,String EndSignal);</code></p>
<p>String 类提供了一个静态方法 <code>String.join(String SplitSignal,String[] StringArr)</code> ，这个静态方法会返回一个用分隔符来拼接的数组。</p>
<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>一般来说，引用类型是一个类，而基本类型则不是，但是我们也可以把 Java 的基本类型包装成引用类型。在 Java 的库里面，真的将基本数据类型都打包了一个类。</p>
<table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">对应的引用类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">java.lang.Boolean</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">java.lang.Byte</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">java.lang.Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">java.lang.Integer</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">java.lang.Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">java.lang.Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">java.lang.Double</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">java.lang.Character</td>
</tr>
</tbody></table>
<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>这些类里面都定义了很多方法来供我们使用，而且编译器还对这些方法进行了优化，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer n=<span class="number">1</span>; <span class="comment">// Integer n=Integer.valueOf(1);</span></span><br><span class="line"><span class="keyword">int</span> m=n; <span class="comment">// int m=n.intValue();</span></span><br></pre></td></tr></table></figure>

<p>上面的代码会被编译器自动优化成注释后面的代码，这被称为自动装箱和自动拆箱。</p>
<p>因为是个类，所以不可以使用 <code>==</code> 来判断是否相等，需要使用 equals() 来比较判断。</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>观察上面的代码，Integer.valueOf() 返回的是一个对象，也就是说，这个方法可以创建对象，我们把能够创建一个新的对象的 <strong>静态方法</strong> 称为工厂方法。查看 Integer.valueOf() 的源代码就可以发现，当输入的参数在一个特定的范围里面的时候，就会使用缓存技术来提高性能。当然这样我们就不需要考虑创建对象的具体细节，将这些任务交给工厂方法就可以了。</p>
<h3 id="包装其他的方法"><a href="#包装其他的方法" class="headerlink" title="包装其他的方法"></a>包装其他的方法</h3><p>像 Integer 类里面还包含有很多用于进制转换的方法，比较好用的比如 <code>Integer.toString(int i,int cimal)</code>  然后这个方法就会返回将数字 i 转化为对应 cimal 进制的字符串。</p>
<p><code>Integer.parseInt(String Num)</code> 则是会将一个长得像整形数字的字符串转化为一个整形并返回。如果再添加一个整形的进制参数，可以按照指定的进制进行解析字符串所表示的字符。</p>
<h3 id="处理无符号整形"><a href="#处理无符号整形" class="headerlink" title="处理无符号整形"></a>处理无符号整形</h3><p>虽然 CPU 支持无符号整形，但是 Java 并没有提供这些。于是基本数据类型的包装方法加入了可以转化无符号数为有符号数的方法。</p>
<p>转化的方法就是按照当前数据的二进制补码看作无符号整形的编码来解析，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> n=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> m=Short.toUnsignedint(n);</span><br></pre></td></tr></table></figure>

<p>结果这个 m 的值是 255，因为 -1 在计算机里的存储是  <code>11111111</code> ，那么按照无符号来进行解析的话，它就是十进制的 <code>255</code> 。因为这个表示范围肯定超过了有符号数的范围，所以进行无符号转化的时候，必须转化为更大范围的基本数据，比如 Short 只有 <code>toUnsignedInt()</code> 和 <code>toUnsignedLong()</code> 两个方法，Long 的无符号转化就只能转化为 String 类型。</p>
<h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><p>JavaBean 的内容和 JavaBean 这个名称没有任何的关系，JavaBean 其实指的是一种设计模式，就是将类中的非方法字段，全部设置成 private ，对于外界想要改变和获取的非方法字段，单独设置 public 方法 getter() 和 setter() 来对这些非方法字段进行修改和读取。</p>
<p>为什么要这样干？ 其实这是为了保证程序的兼容性，有些非方法字段如果随意开放，一旦在后期的程序迭代中改变了这个非方法字段，那么以前的程序就有运行的问题。所以保留一个 getter() 和 setter() 方法，这样只需要修改这两个方法里面的代码就可以解决兼容性的问题。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Tempest Xorex;</span><br><span class="line">        Xorex.setHight(<span class="number">178</span>);</span><br><span class="line">        Xorex.setWeight(<span class="number">100</span>);</span><br><span class="line">        System.out.println(Xorex.getHight());</span><br><span class="line">        System.out.println(Xorex.getWeight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tempest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHight</span><span class="params">(<span class="keyword">int</span> hight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hight=hight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight=weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.hight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码通过一组 set/get 方法将私有字段与外界联系起来，这样的一组方法和字段被称为类的一个属性。比如上面的代码 Tempest 类就设置了两个属性 hight 和 weight ，一定要记得属性是由三个字段组成，set 方法，get 方法和数据。</p>
<h2 id="枚举类-enum"><a href="#枚举类-enum" class="headerlink" title="枚举类 enum"></a>枚举类 enum</h2><p>enum -&gt; enumeration [ɪˌnjuːməˈreɪʃn] 枚举</p>
<p>enum 是一个特殊的标识符，表示将一个类声明为枚举类，枚举类是一系列常量元素的集合。这里的枚举要实现的目标就是一个常量集合，比如月份，星期这些。有的时候我们需要处理这些需要被枚举的常量的时候，一个枚举类的构造会大大规范我们代码的统一性。</p>
<p>而一个枚举类的定义也很简单，直接用 enum + 类名 即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Mon,Tue,Wed,Thu,Fri,Sat,Sun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码在编译的时候，会被自动转化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Week</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week Mon=<span class="keyword">new</span> Week();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week Tue=<span class="keyword">new</span> Week();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week Wed=<span class="keyword">new</span> Week();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week Thu=<span class="keyword">new</span> Week();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week Fri=<span class="keyword">new</span> Week();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week Sat=<span class="keyword">new</span> Week();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week Sun=<span class="keyword">new</span> Week();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为枚举类是继承于 Enum 类，所以 Enum 类里面的很多很好玩的方法就可以使用了。</p>
<p>name() 不可重写方法，返回常量名。</p>
<p>toString() 可重写方法，默认返回常量名。</p>
<p>ordinal() 返回常量的顺序。</p>
<p>values() 静态方法，返回一个包含所有常量的数组。</p>
<p>下面一般是比较常用的 enum 枚举类的使用方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Week i : Week.values())</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Mon(<span class="string">&quot;Monday&quot;</span>),</span><br><span class="line">    Tue(<span class="string">&quot;Tuesday&quot;</span>),</span><br><span class="line">    Wed(<span class="string">&quot;Wednesday&quot;</span>),</span><br><span class="line">    Thu(<span class="string">&quot;Thursday&quot;</span>),</span><br><span class="line">    Fri(<span class="string">&quot;Friday&quot;</span>),</span><br><span class="line">    Sat(<span class="string">&quot;Saturday&quot;</span>),</span><br><span class="line">    Sun(<span class="string">&quot;Sunday&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value=value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="记录类-record"><a href="#记录类-record" class="headerlink" title="记录类 record"></a>记录类 record</h2><p>上面提到了枚举类 enum，用一个简单的语法来代替常用的设置类情形。同样的，在写代码的时候，会出现想要写一个类来专门保存一组不变的数据，对于拥有这种统一格式的数据，有一种专门的类叫作 record 记录类 来将这些数据记录下来。</p>
<p>record 的语法和 enum 很像：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这样就可以声明一个叫作 Point 的纪录类了，编译器会自动把这些代码都补全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">extends</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样和 enum 一样，用了极少的代码完成了这些任务，语法糖真甜。</p>
<p>除了使用最基本的语法糖，我们当然可以在里面添加一些自定义的功能，比如补充构造方法，添加静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">record</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Point &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Point&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要添加普通的方法，那为什么不试试功能更加全面的普通类呢？这个 record 语法糖是在 Java 14  才更新的，而且还是 preview 功能，大概还没有多少人用过这个东西吧。</p>
<h2 id="高精度-BigInteger"><a href="#高精度-BigInteger" class="headerlink" title="高精度 BigInteger"></a>高精度 BigInteger</h2><p>对于处理超过 long 表示的整数的时候，Java 贴心的准备了 BigInteger 类来处理这些内容，其内部是使用 final int[] 来实现的高精度，使用之前导入 java.math.BigInteger 类。</p>
<ul>
<li><p>add() 两个实例之间相加。</p>
</li>
<li><p>subtract() 两个实例之间相减。</p>
</li>
<li><p>multiply() 两个实例之间相乘。</p>
</li>
<li><p>divide() 两个实例之间相除。</p>
</li>
<li><p>pow(int x) 将实例的 x 幂。</p>
</li>
</ul>
<p>当然这里面还包括将 BigInteger 转化为基本数据类型的方法：</p>
<ul>
<li>转换为 byte：byteValue()</li>
<li>转换为 short：shortValue()</li>
<li>转换为 int：intValue()</li>
<li>转换为 long：longValue()</li>
<li>转换为 float：floatValue()</li>
<li>转换为 double：doubleValue()</li>
</ul>
<h2 id="高精度-BigDecimal"><a href="#高精度-BigDecimal" class="headerlink" title="高精度 BigDecimal"></a>高精度 BigDecimal</h2><p>不同于 Integer 这个 Decimal 表示的是浮点数，也就是高精度的浮点数，它可以保留任意精度。BigDecimal 里面有一些不太一样的方法，用来解决对于浮点数的一些需求。</p>
<ul>
<li>scale() 返回 BigDecimal 实例的小数位数。</li>
<li>stripTrailingZeros() 字面意思 strip 脱去，Trail 末尾，即去掉末尾的零。</li>
<li>n.divideAndReminder(m) 让 n 除以 m 并且返回商和余数。返回类型为 BigDecimal[]，里面有两个元素，第一个是商，第二个是余数。</li>
</ul>
<p>将两个 BigDecimal 数据进行比对的时候，尽量不要使用 equals() 而是要使用 compareTo()，对于 equals() 比对的时候比较严格，需要两个BigDecimal 数据不仅数值上相等，还要求两者的 scale() 值也相等。但是 compareTo() 只要求前者相等即为相等。</p>
<p>compareTo() 会返回正数负数和零，分别表示大于小于和等于。</p>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>数学工具人，里面含有各种静态的工具方法，下面大致说一下比较常用的，不常用的用到了再说。</p>
<ul>
<li>计算绝对值 Math.abs(Num)</li>
<li>计算最大值/最小值 Math.max(Num) / Math.min(Num)</li>
<li>计算 x 的 y 次方 Math.pow(x,y)</li>
<li>计算开方 Math.sqrt(x)</li>
<li>计算 e 的 x 次方 Math.exp(x)</li>
<li>计算以 e 为底的对数  Math.log(x)</li>
<li>计算以10 为底的对数 Math.log10(x)</li>
<li>计算三角函数 Math.sin(x) / cos(x) / tan(x) …</li>
<li>常量 Math.PI / Math.E （double 常量，非高精）</li>
<li>随机数 Math.random() 返回一个 double 的随机数。</li>
</ul>
<h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>一个专门生成伪随机数的一个类，可以创建实例的时候给 Random 构造函数一个种子，也可以不给，如果不给的话，每次在创建实例的时候，会把当前的时间戳作为种子，所以看起来就不是一个伪随机数了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Random random=<span class="keyword">new</span> Random(); <span class="comment">//创建一个 Random 的实例，此时 random 的种子已确定。</span></span><br><span class="line">System.out.println(random.nextInt()); <span class="comment">//Int范围内一个随机整数</span></span><br><span class="line">System.out.println(random.nextDouble()); <span class="comment">// 0-1 范围内返回内一个随机浮点数</span></span><br><span class="line">System.out.println(random.nextInt(<span class="number">100</span>)); <span class="comment">// 0-100 范围内返回一个随机整数 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SecureRandom"><a href="#SecureRandom" class="headerlink" title="SecureRandom"></a>SecureRandom</h3><p>真正的随机数我们是没有办法通过计算机获得的，但是我们只需要一个安全的随机数即可，所谓安全就是这个随机数不可被预测，而这个安全性的保障是通过随机事件所产生的 熵 来实现的。随机事件比如 CPU 的热噪声，读取磁盘的字节，网络流量等等。</p>
<p>正是因为 SecureRandom 的安全性实现是依靠不可被预测的随机熵实现的，所以它无法被设置种子。SecureRandom 有不同的底层实现方法，因为设备的不同使的支持的实现方法也不同，所以我们应该优先调用安全强度更高的安全算法，如果设备不提供的话，再使用普通的安全算法。</p>
<p>那么使用 try-catch 语句来尝试这个过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SecureRandom SR=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SR=SecureRandom.getInstanceStrong();</span><br><span class="line">            System.out.println(<span class="string">&quot;Seccess!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            SR=<span class="keyword">new</span> SecureRandom();</span><br><span class="line">            System.out.println(<span class="string">&quot;Failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(SR.nextInt());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码执行过程就是，尝试调用 SecureRandom 类中的静态方法 getInstanceStrong() 来获得更高安全性的随机算法。如果设备不支持，那么就使用普通的随机算法。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote>
<p>拖延了一个多星期的核心类学习笔记终于完成了，这一遍地学习更多地是留下一个印象，知道有这些用法，以后肯定会对里面内在的原理之类进行研究的。下一个目标，在年前完成异常处理的学习吧！</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Xorex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xorex.space/2020/12/24/f7ebd39770e8/">https://xorex.space/2020/12/24/f7ebd39770e8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xorex.space" target="_blank">Xorex</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/%E6%A0%B8%E5%BF%83%E7%B1%BB/">核心类</a></div><div class="post_share"><div class="social-share" data-image="/waifus/020.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/28/3198a37cb267/"><img class="prev-cover" src="/waifus/019.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 异常学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2020/12/24/c1b945298bef/"><img class="next-cover" src="/waifus/023.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java 面向对象学习笔记</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC8yODcyMS81Mjky"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/Megumi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Xorex</div><div class="author-info__description">要成为世界上最幸福的人啊！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">232</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">146</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Administrator-Xorex"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Administrator-Xorex" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://tool.gljlw.com/qq/?qq=2676424606" target="_blank" title="添加好友"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:cloudloverain@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/65831075" target="_blank" title="bilibili"><i class="fas fa-tv"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E7%9B%B8%E5%85%B3"><span class="toc-number">1.</span> <span class="toc-text">String 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.</span> <span class="toc-text">String 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E5%92%8C%E6%8F%90%E5%8F%96%E5%AD%97%E4%B8%B2"><span class="toc-number">1.2.</span> <span class="toc-text">搜索和提取字串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E5%92%8C-char-%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.</span> <span class="toc-text">String 和 char[] 转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E7%BC%96%E7%A0%81"><span class="toc-number">1.4.</span> <span class="toc-text">String 编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.</span> <span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder"><span class="toc-number">2.</span> <span class="toc-text">StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringJoiner"><span class="toc-number">3.</span> <span class="toc-text">StringJoiner</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">包装类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">4.1.</span> <span class="toc-text">装箱与拆箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">工厂方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E5%85%B6%E4%BB%96%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">包装其他的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E5%BD%A2"><span class="toc-number">4.4.</span> <span class="toc-text">处理无符号整形</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaBean"><span class="toc-number">5.</span> <span class="toc-text">JavaBean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB-enum"><span class="toc-number">6.</span> <span class="toc-text">枚举类 enum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%B1%BB-record"><span class="toc-number">7.</span> <span class="toc-text">记录类 record</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6-BigInteger"><span class="toc-number">8.</span> <span class="toc-text">高精度 BigInteger</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6-BigDecimal"><span class="toc-number">9.</span> <span class="toc-text">高精度 BigDecimal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Math"><span class="toc-number">10.1.</span> <span class="toc-text">Math</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Random"><span class="toc-number">10.2.</span> <span class="toc-text">Random</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SecureRandom"><span class="toc-number">10.3.</span> <span class="toc-text">SecureRandom</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E"><span class="toc-number">11.</span> <span class="toc-text">最后</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2022 By Xorex</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="Xorex" data-fontsize="18px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>