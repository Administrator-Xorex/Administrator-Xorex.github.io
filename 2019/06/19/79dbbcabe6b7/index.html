<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Python学习笔记 | Xorex</title><meta name="keywords" content="笔记,Python"><meta name="author" content="Xorex"><meta name="copyright" content="Xorex"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Python具有丰富和强大的库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块（尤其是C&#x2F;C++）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中[3]  有特别要求的部分，用更合适的语言改写，比如3D游戏中的图形渲染模块，性能要求特别高，就可以用C&#x2F;C++重写，而后封装为Python可以调用的扩展类库。需要注意的是在您使用">
<meta property="og:type" content="article">
<meta property="og:title" content="Python学习笔记">
<meta property="og:url" content="https://xorex.space/2019/06/19/79dbbcabe6b7/index.html">
<meta property="og:site_name" content="Xorex">
<meta property="og:description" content="Python具有丰富和强大的库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块（尤其是C&#x2F;C++）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中[3]  有特别要求的部分，用更合适的语言改写，比如3D游戏中的图形渲染模块，性能要求特别高，就可以用C&#x2F;C++重写，而后封装为Python可以调用的扩展类库。需要注意的是在您使用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xorex.space/waifus/041.jpg">
<meta property="article:published_time" content="2019-06-19T13:27:11.000Z">
<meta property="article:modified_time" content="2021-02-20T14:16:05.244Z">
<meta property="article:author" content="Xorex">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xorex.space/waifus/041.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://xorex.space/2019/06/19/79dbbcabe6b7/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-02-20 22:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="Xorex" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/Megumi.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">129</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">100</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/image/PostTop.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Xorex</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2019-06-19T13:27:11.000Z" title="undefined 2019-06-19 21:27">2019-06-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/">开发知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><blockquote>
<p>不知不觉自己已经高中毕业了（并不），这个暑假需要学点什么，然后就买了一本《Python编程从入门到实践》，并夕夕上只要25块，看起来超值。然后暑假就学习如何用Python来编写程序吧，至于C++的康复计划，留到以后有时间再说。所以下面就记录一些经常需要查询的东西，帮助自己学习Python。</p>
</blockquote>
<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="字符串修改"><a href="#字符串修改" class="headerlink" title="字符串修改"></a>字符串修改</h2><p><code>title()</code> 使字符串中单词的一个字母大写 </p>
<p><code>upper()</code> 使字符串中所有字母大写</p>
<p><code>lower()</code> 使字符串中所有字母小写</p>
<hr>
<p>两个字符串可以直接相加：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">First_Name=<span class="string">&quot;Katou&quot;</span></span><br><span class="line">Last_Name=<span class="string">&quot;Megumi&quot;</span></span><br><span class="line">Name=First_Name+<span class="string">&quot; &quot;</span>+Last_Name</span><br><span class="line">print(Name)</span><br></pre></td></tr></table></figure>
<p>输出结果就是 <code>Katou Megumi</code></p>
<hr>
<p>strip 「脱光衣服」</p>
<p><code>rstrip()</code> 删除字符串里所有的空格</p>
<p><code>lstrip()</code> 删除字符串开头的空格</p>
<p><code>strip()</code> 删除字符串开头和末尾的空格</p>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>在Python3中，两个整数相除的结果并非整数，而是浮点数，如果需要得到整除数，则需要将结果强制转换为整数即刻。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a,b=<span class="built_in">input</span>().split()</span><br><span class="line">ans=<span class="built_in">int</span>(a/b)</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>
<p>这样输出的就是整数了。</p>
<hr>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><code>#</code>后面接单行注释</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">下面</span></span><br><span class="line"><span class="string">就可以</span></span><br><span class="line"><span class="string">接</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="The-Zen-of-Python"><a href="#The-Zen-of-Python" class="headerlink" title="The Zen of Python"></a>The Zen of Python</h2><table>
<thead>
<tr>
<th>The Zen of Python</th>
<th>Python之禅</th>
</tr>
</thead>
<tbody><tr>
<td>Beautiful is better than ugly.</td>
<td>优美胜于丑陋</td>
</tr>
<tr>
<td>Explicit is better than implicit.</td>
<td>明了胜于晦涩</td>
</tr>
<tr>
<td>Simple is better than complex.</td>
<td>简洁胜于复杂</td>
</tr>
<tr>
<td>Complex is better than complicated.</td>
<td>复杂胜于凌乱</td>
</tr>
<tr>
<td>Flat is better than nested.</td>
<td>扁平胜于嵌套</td>
</tr>
<tr>
<td>Sparse is better than dense.</td>
<td>间隔胜于紧凑</td>
</tr>
<tr>
<td>Readability counts.</td>
<td>可读性很重要</td>
</tr>
<tr>
<td>Special cases aren’t special enough to break the rules.Although practicality beats purity.</td>
<td>即便假借特例的实用性之名，也不可违背这些规则</td>
</tr>
<tr>
<td>Errors should never pass silently.Unless explicitly silenced.</td>
<td>不要包容所有错误，除非你确定需要这样做</td>
</tr>
<tr>
<td>In the face of ambiguity, refuse the temptation to guess.</td>
<td>当存在多种可能，不要尝试去猜测</td>
</tr>
<tr>
<td>There should be one– and preferably only one –obvious way to do it.</td>
<td>而是尽量找一种，最好是唯一一种明显的解决方案</td>
</tr>
<tr>
<td>Although that way may not be obvious at first unless you’re Dutch.</td>
<td>虽然这并不容易，因为你不是 Python 之父</td>
</tr>
<tr>
<td>Now is better than never.Although never is often better than <em>right</em> now.</td>
<td>做也许好过不做，但不假思索就动手还不如不做</td>
</tr>
<tr>
<td>If the implementation is hard to explain, it’s a bad idea.If the implementation is easy to explain, it may be a good idea.</td>
<td>如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然</td>
</tr>
<tr>
<td>Namespaces are one honking great idea – let’s do more of those!</td>
<td>命名空间是一种绝妙的理念，我们应当多加利用</td>
</tr>
</tbody></table>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表和C++ 里面的数组是比较相似的，Python里面，列表是线性且连续的，也就是说，不存在两个元素之间有空元素，所以这样就让Python在实现各种操作的时候简单了很多，但是也感觉可操作性就大大降低了，并没有C++的数组灵活。</p>
<p>列表在使用之前，必须声明一个空列表，如<code>a=[]</code>。这样才能实现下一步操作。</p>
<hr>
<p>Python添加新元素的方法是使用<code>append()</code>函数和<code>insert()</code>函数。</p>
<p>append 「附加，增补」</p>
<p>insert 「插入，嵌入」</p>
<p>所以顾名思义，append是在列表末尾增加一个新元素</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">&quot;Xorex&quot;</span>]</span><br><span class="line">a.append(<span class="string">&quot; is best!&quot;</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>输出结果就是[‘Xorex’,’ is best!’]</p>
<p>insert是在列表中间添加元素，格式：insert(下标,元素)</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=[]</span><br><span class="line">a.append(<span class="number">1</span>)</span><br><span class="line">a.append(<span class="number">2</span>)</span><br><span class="line">a.append(<span class="number">3</span>)</span><br><span class="line">print(a)</span><br><span class="line">a.insert(<span class="number">0</span>,<span class="string">&#x27;Number&#x27;</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>这样输出结果就分别为，[1, 2, 3] 和 [‘Number’, 1, 2, 3]，Numer被插入到了下标为0的位置，其他元素往后移动一位。</p>
<hr>
<p>如果要修改某个下标的元素就直接 <code>a[下标]=元素</code> ，即可。</p>
<hr>
<p>如果要删除列表里的元素，那么有下面几种方法：</p>
<ol>
<li><p>使用<code>del</code>删除，如果你已经得知元素下标，可以这样写<code>del a[0]</code>，这样<code>a[0]</code>，也就是a列表里面的第一个元素就被删除了。</p>
</li>
<li><p>使用<code>pop()</code>删除，<code>pop()</code>可以删除制定位置元素并返回删除的元素值，如<code>print(a.pop(2))</code>就会删<code>a</code>列表里面第三个元素并返回删除的元素值，然后输出它。如果你不写弹出下标，那么就会默认删除最后一个元素，并返回最后一个元素的值，有点类似于堆栈，而pop的意思就是弹出。</p>
</li>
<li><p>使用<code>remove()</code>删除元素，<code>a.remove(要删除的元素)</code>就可以删除掉列表中所有为<code>Xorex</code>的元素，如果有多个元素都是<code>Xorex</code>，那么默认删除第一个元素，后面的<code>Xorex</code>保持不变。如果要删除全部，需要用循环不断验证，删除。</p>
</li>
</ol>
<hr>
<p>对列表中元素进行排列，有以下几种方法。</p>
<p><code>sort()</code>进行从小到大排列，并更改列表里面的元素顺序，如果想要从大到小，那么就需要在函数里面添加参数<code>sort(reverse=true)</code></p>
<p>reverse 「颠倒，使翻转」</p>
<p>而同样是排列的<code>sorted()</code>函数作用和<code>sort()</code>是一样的，不同的是<code>sorted()</code>只会返回排列好的列表，而不会更改原来列表里面的元素顺序。</p>
<p><strong>注意</strong> 如果单独使用<code>reverse()</code>函数对列表进行更改的话，并不会排序，只会将列表元素顺序反过来。</p>
<p><code>sort()</code>和<code>sorted()</code>其实是支持自定义排序的，<code>sort(cmp,key,reserve)</code> 其中<code>cmp</code>代表着排序规则，<code>key</code>代表着参与排序的元素，<code>reserve</code>代表着是升序排序还是降序排序。</p>
<hr>
<p>确定列表长度可以使用<code>len()</code>函数，如<code>len(a)</code>就会返回列表<code>a</code>的长度。</p>
<hr>
<p>range 「一系列，范围」</p>
<p><code>range()</code>可以生成一系列的数字，<code>range(5)</code>是生成从<code>0</code>到<code>4</code>的五个数字，而<code>range(1,6)</code>是生成从<code>1</code>到<code>6-1</code>的五个数字。最后<code>range(1,11,2)</code>代表着从<code>1</code>开始，不断加<code>2</code>输出，直到小于等于<code>11-1</code>。</p>
<p>如果需要得知一个列表中的最大值，最小值，总和，可以使用<code>min(a)</code> <code>max(a)</code>和<code>sum(a)</code></p>
<hr>
<p>列表循环的新方法</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=[x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>这样生成的就是从<code>1</code>到<code>10</code>的平方了。</p>
<hr>
<p>列表的复制中，如果使用<code>b=a</code>使列表<code>a</code>的值赋给了列表<code>b</code>。那么实际上<code>a</code>和<code>b</code>就已经是同一个列表了。也就是意味着如果你更改列表<code>a</code>的值，那么列表<code>b</code>的值也会改变。</p>
<p>那么如何避免上面的情况呢，就需要这样来复制:<code>b=a[:]</code>也就是一个一个把<code>a</code>的值给<code>b</code>，这样<code>a</code>和<code>b</code>就是两个不一样的列表了！</p>
<hr>
<p>列表是可以使用二维，或二维以上的列表，具体实现方法就是俄罗斯套娃一样，列表里面套列表（元组，字典也是可以的），下标的表示方法和C++一样，比如下面的代码:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=[[[<span class="number">1</span>,<span class="string">&#x27;HEXO&#x27;</span>],<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">b=[<span class="string">&#x27;Xorex&#x27;</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.append(b)</span><br><span class="line">print(a[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>最后输出的结果就是<code>HEXO</code></p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组就是不能修改的列表，从<code>Python</code>里面有元组就可以看出来，<code>Python</code>真的是一个非常实用化的语言，而并非追求灵活和性能的C++。（实测Python的速度超级慢，同样的计算量大概需要耗时是C++的二十倍到一百倍）</p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p><code>Python</code>里面的<code>if</code>语句和<code>C++</code>里面基本上是一样的，不同之处就是在判断多个满足条件的时候，<code>Python</code>使用的是英文<code>and</code>、<code>or</code>等等，而并非符号语言。</p>
<p>其次<code>Python</code>支持判断一个元素是否在一个列表里面，使用<code>in</code>即可，比如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> <span class="keyword">in</span> a: </span><br><span class="line">    print(<span class="string">&quot;Yes!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这样就会判断<code>1</code>在列表<code>a</code>中，所以就返回了<code>true</code>值，输出了<code>Yes!</code>。</p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是<code>Python</code>完全不同于<code>C++</code>的一种变量类型。可以说是语言自带的<code>Hash</code>，非常强大，非常实用！</p>
<p>首先实用字典之前需要先声明一个空字典<code>a=&#123;&#125;</code></p>
<p>字典数据的添加不需要函数，直接<code>a[&#39;Xorex&#39;]=&quot;The Best Coder!</code>，就添加了<code>Xorex-The Best Coder!</code>的一个键-值对，在访问<code>a[&#39;Xorex&#39;]</code>的时候，返回的值直接就是<code>The Best Coder!</code></p>
<p>需要删除使用<code>del</code>格式即可：<code>del a[&#39;Xorex&#39;]</code>这样这个键值对就被删除了。</p>
<hr>
<p>和列表一样，字典也可以实现多维度操作，原理就是俄罗斯套娃，字典里面随便套，一层套一层，下标和<code>C++</code>一样，比如下面的代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:&#123;<span class="number">1</span>:&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">2</span>&#125;,<span class="number">2</span>:<span class="number">2</span>&#125;&#125;</span><br><span class="line">b=[<span class="string">&#x27;Xorex&#x27;</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>][<span class="number">2</span>]=b</span><br><span class="line">print(a[<span class="number">2</span>][<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>输出结果就是<code>Xorex</code></p>
<hr>
<p>字典和列表一样，也可以使用<code>for</code>循环来把所有元素遍历一遍，比如下面的代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:&#123;<span class="number">1</span>:&#123;<span class="number">1</span>:<span class="number">1</span>,<span class="number">2</span>:<span class="number">2</span>&#125;,<span class="number">2</span>:<span class="number">2</span>&#125;&#125;</span><br><span class="line">b=[<span class="string">&#x27;Xorex&#x27;</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a[<span class="number">2</span>][<span class="number">1</span>][<span class="number">2</span>]=b</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a[<span class="number">2</span>]:</span><br><span class="line">    print(i,a[<span class="number">2</span>][i])</span><br></pre></td></tr></table></figure>
<p>输出结果就是：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &#123;<span class="number">1</span>: <span class="number">1</span>, <span class="number">2</span>: [<span class="string">&#x27;Xorex&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p><code>Python</code>默认让用户输入的都是以字符串的形式存储在变量里面，如果需要不同的数据类型，那么就需要强制转换，写法和<code>C++</code>一样：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a=a+<span class="number">1</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>输出的结果就是你所输入的值加一。</p>
<hr>
<p><code>split()</code>可以实现像cin一样的读入一行的不同数据，原理就是将一行字符串以空格分开，单独存储在一个列表里面。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b=<span class="built_in">input</span>().split()</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br></pre></td></tr></table></figure>
<p>上面使用<code>split()</code>的时候，一定要保证一行里面只有两个数据，不然就会出现<code>ValueError</code>，如果不放心的话可以使用<code>try-except</code>代码块或者直接将一行分离的数据存储在列表中。</p>
<p>split「分裂，分离」</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-string-split.html">具体用法</a></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><code>Python</code>和<code>C++</code>一样，有两种循环方式，一种是<code>for</code>另一种是<code>while</code>。</p>
<p>详情：<a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python3-loop.html">循环语句</a></p>
<p>但是这里需要注意的是，如果在使用<code>for</code>循环来遍历整个列表的时候，就不应该修改这个列表，否则就会出现一些奇奇怪怪的错误，这个时候就应该使用<code>while</code>循环。</p>
<hr>
<p>同时<code>Python</code>也带有<code>continue</code>和<code>break</code>语句，使用方法和<code>C++</code>一模一样。</p>
<p><strong>注意</strong><code>Python</code>里面的<code>True</code>和<code>False</code>首字母是大写的！</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>格式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params">variable=<span class="number">0</span></span>):</span></span><br><span class="line">    then work</span><br><span class="line">    <span class="keyword">return</span> something</span><br></pre></td></tr></table></figure>
<p>其实<code>Python</code>函数的各种功能个<code>C++</code>的差不多，但是需要注意的是，当你在函数里面修改传递的参数的时候，如果参数是数字，字符串的话，是不会影响函数实参的值的。但是如果你传递进去的参数是列表和字典，那么当你修改形参的值的时候，实参的值也会变，这点是必须要注意的，比如下面代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Change</span>(<span class="params">b</span>):</span></span><br><span class="line">    b.append(<span class="number">3</span>)</span><br><span class="line">Change(a)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>最后输出的列表<code>a</code>的值是<code>[1,2,3]</code>，即使你修改的是<code>b</code>的值，那么实参也会跟着改变，如果想要实参不会跟着改变，那就需要这样写：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Change</span>(<span class="params">b</span>):</span></span><br><span class="line">    b.append(<span class="number">3</span>)</span><br><span class="line">Change(a[:])</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>传进去一个被复制下来的列表，这样修改函数里面的列表的时候就不会连带着一起修改实参的数据了。然后上述代码的输出结果就是<code>[1,2]</code>，可见实参<code>a</code>列表并没有被跟着一起修改。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><blockquote>
<p><code>Python</code>的模块，其实和<code>C++</code>里面的库差不多，就是一个各种函数的集合体，不过不需要你在主代码里面编写函数，这些函数存储在其他文件里面，你直接通过调用其函数所在的模块，就可以间接调用这个函数。</p>
</blockquote>
<p>模块是一个独立的文件，拓展名是<code>.py</code>，里面直接留各种函数就行了，比如我们开一个模块叫做<code>Xorex.py</code>，里面包含三个函数。</p>
<p>文件<code>Xorex.py</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">The_True</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Xorex is the best!&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">The_False</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Xorex is not the best!&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Xorex</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Xorex is a programmer!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>然后我们就可以在其他代码里面调用这个函数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Xorex <span class="comment">#使用import来导入整个模块Xorex</span></span><br><span class="line">Xorex.The_True() </span><br><span class="line">Xorex.Xorex()</span><br><span class="line">Xorex.The_False()</span><br><span class="line"><span class="comment">#调用模块Xorex里面的三个函数</span></span><br></pre></td></tr></table></figure>
<p>结果就是输出了:</p>
<p>「世界真理」：<code>Xorex is the best!</code></p>
<p>「真实身份」：<code>Xorex is a programmer!</code></p>
<p>「世界谎言」：<code>Xorex is not the best!</code></p>
<p>import 「引进，进口」</p>
<p>而<code>import</code>导入的是整个模块里面的所有东西，整个模块会全部添加到自己的程序里面，如果不想全部都导入，而是导入特定的函数，那么就需要这样写：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Xorex <span class="keyword">import</span> Xorex,The_True</span><br><span class="line">Xorex()</span><br><span class="line">The_True()</span><br><span class="line">The_False()</span><br></pre></td></tr></table></figure>
<p>或者不导入整个模块，导入全部的函数，并且函数的调用和上面是一样，</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Xorex <span class="keyword">import</span> *</span><br><span class="line">Xorex()</span><br><span class="line">The_True()</span><br><span class="line">The_False()</span><br></pre></td></tr></table></figure>
<p>这两种导入方式在调用函数的时候不需要写模块的名字，只需要像直接调用本地函数一样调用就好了。而且<code>Python</code>还支持重新命名，如下把<code>Xorex</code>模块里面的<code>The_True()</code>重新命名为<code>TT()</code>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Xorex <span class="keyword">import</span> The_True <span class="keyword">as</span> TT</span><br><span class="line">TT()</span><br></pre></td></tr></table></figure>
<hr>
<p>模块支持将一个模块里面的函数导入到另外一个模块里面，只要在模块前面写上<code>import</code>语句就行了，实际操作可以参考下面<code>class</code>从一个模块导入另一个模块的操作。</p>
<h2 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h2><p>类就是<code>C++</code>里面加强版的结构体，或者说结构体是特殊的类，下面是类创建的格式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,First,Last</span>):</span></span><br><span class="line">        self.First_Name=First</span><br><span class="line">        self.Last_Name=Last</span><br><span class="line">Xorex=Name(<span class="string">&#x27;Tempest&#x27;</span>,<span class="string">&#x27;Xorex&#x27;</span>)</span><br><span class="line">print(Xorex.First_Name,Xorex.Last_Name)</span><br></pre></td></tr></table></figure>
<p>这样就实现了类似于<code>C++</code>里面结构体的功能了，定义“结构体”名字为<code>Name</code>，<code>Name</code>里面有两个子元素，分别为<code>First_Name</code>和<code>Last_Name</code>。需要“声明”一个“结构体”类型的变量的时候，只需要另此变量等于所定义的结构体就行了，需要为变量赋值的话可以以函数的形式传递参数，其中<code>self</code>参数不需要传递，<code>Python</code>会自动向<code>self</code>传递目前对象（Xorex）的地址，也就是说，调用<code>Xorex=Name(&#39;Tempest&#39;,&#39;Xorex&#39;)</code>的时候，<code>self</code>在里面就相当于<code>Xorex</code>，也就是说，<code>self.First_Name=First</code>就会等价于<code>Xorex.First_Name=First</code>，因为<code>self</code>被传入了<code>Xorex</code>的地址。</p>
<p>而<code>__init__</code>函数（方法）是<code>class</code>里面自动运行的名字，如果在定义<code>class</code>的时候，添加有一个叫做<code>__init__</code>的函数（方法），那么在声明<code>class</code>类型变量的时候会自动运行这个叫做<code>__init__</code>的函数（方法）。你可以用<code>__init__</code>函数（方法）在声明<code>class</code>类型变量的时候，直接就赋值，因为<code>class</code>里面的变量是不允许没有初始值的。</p>
<p>当然如果你想声明以后再给<code>class</code>里面的变量赋值的话，可以这样写：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span>:</span></span><br><span class="line">    First_Name=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    Last_Name=<span class="string">&#x27;&#x27;</span></span><br><span class="line">Xorex=Name()</span><br><span class="line">Xorex.First_Name=<span class="string">&#x27;Tempest&#x27;</span></span><br><span class="line">Xorex.Last_Name=<span class="string">&#x27;Xorex&#x27;</span></span><br><span class="line">print(Xorex.First_Name,Xorex.Last_Name)</span><br></pre></td></tr></table></figure>
<p>输出的结果和上面的代码是一样的。</p>
<hr>
<p><code>class</code>比<code>C++</code>里面结构体厉害的地方在于，<code>class</code>功能更多，比如里面可以内置函数（方法），但是这个标准名称叫方法，下文也不再以函数称呼，而是方法。</p>
<p>同样和上面定义的方法<code>__init__()</code>一样，所有的<code>class</code>内部定义的方法都需要一个参数，用来记录当前对象的地址，程序员们约定俗成使用<code>self</code>作为此参数，位于所有形参的前面，即使方法不需要传递参数，那么还是需要<code>self</code>来记录地址的。</p>
<p>比如我们可以实现一个<code>class</code>内部的方法：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bilibili</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Cheer</span>(<span class="params">self,Name</span>):</span></span><br><span class="line">        print(Name+<span class="string">&quot;,Let&#x27;s cheer for bilibili!&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Coin</span>(<span class="params">self,Number</span>):</span></span><br><span class="line">        <span class="keyword">if</span> Number == <span class="number">1</span>:</span><br><span class="line">            print(<span class="string">&quot;You have successfully thrown a coin!&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> Number == <span class="number">2</span>:</span><br><span class="line">            print(<span class="string">&quot;You have successfully thrown two coins!&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;Sorry,You can&#x27;t throw this coins!&quot;</span>)</span><br><span class="line">Xorex=bilibili()</span><br><span class="line">Xorex.Cheer(<span class="string">&quot;Xorex&quot;</span>)</span><br><span class="line">Xorex.Coin(-<span class="number">1</span>)</span><br><span class="line">Xorex.Coin(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这里首先声明一个自定义<code>bilibili</code>类型的变量<code>Xorex</code>，然后调用<code>bilibili</code>里面的方法。格式：<code>Variable.Function(Parameter/None)</code></p>
<hr>
<p><code>class</code>是可以继承的，「继承」字面意思，即使用其他<code>class</code>的功能（比如其他<code>class</code>定义的方法）</p>
<p>下面就是一个<code>class</code>继承上面三个<code>class</code>的各种功能的代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">First</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;First&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Second</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Second&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Third</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Third&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">First,Second,Third</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        First.__init__(self)</span><br><span class="line">        Second.__init__(self)</span><br><span class="line">        Third.__init__(self)</span><br><span class="line">Xorex=Son()</span><br></pre></td></tr></table></figure>
<p><code>Son</code>继承了上面的<code>First</code>、<code>Second</code>和<code>Third</code>的功能，然后被<code>Son</code>的默认执行方法执行了使用前面三个<code>class</code>的默认执行方法的命令。最后的输出结果:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">First</span><br><span class="line">Second</span><br><span class="line">Third</span><br></pre></td></tr></table></figure>
<hr>
<p><code>class</code>和函数一样，支持存储在模块中，从外部进行调用，两者格式是一样的，都是通过<code>import</code>来实现。</p>
<p>新建一个叫<code>Xorex.py</code>的模块，里面存入需要的<code>class</code>:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">First</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;First&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Second</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Second&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Third</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Third&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>然后在当前代码调用<code>Xorex</code>模块里面定义的<code>class</code>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入整个模块，需要调用前指明Xorex模块</span></span><br><span class="line"><span class="keyword">import</span> Xorex</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Xorex.First,Xorex.Second,Xorex.Third</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        Xorex.First.__init__(self)</span><br><span class="line">        Xorex.Third.__init__(self)</span><br><span class="line">Xorex=Son()</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#只导入需要的class，或者全部class，不需要指明Xorex模块</span></span><br><span class="line"><span class="keyword">from</span> Xorex <span class="keyword">import</span> First,Second,Third <span class="comment">#指名导入class</span></span><br><span class="line"><span class="keyword">from</span> Xorex <span class="keyword">import</span> * <span class="comment">#导入全部class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">First,Second,Third</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        First.__init__(self)</span><br><span class="line">        Third.__init__(self)</span><br><span class="line">Xorex=Son()</span><br></pre></td></tr></table></figure>
<hr>
<p><code>class</code>支持不同模块之间的相互导入，如果将导入看做是代码复制的话其实就很好理解了，使用在模块前面加上<code>import</code>语句就行了。注意的是<code>import Name</code>格式导入的是整个模块所有的内容，所以在模块的相互导入的时候不能使用：<code>import Name</code>格式，而应该使用<code>from XXX import XXX</code>导入类。在主程序里面调用模块的时候不受限制，可以使用上面的两种导入方法。</p>
<h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><p>读取文件里面的数据格式，这里使用<code>with open(&#39;XXX&#39;) as XXX</code>的写法，可以不用管文件关闭的问题，<code>Python</code>会执行完<code>with</code>句型后面的代码之后关掉文件。而这里<code>open()</code>里面填写的是文件名称，后面的<code>XXX</code>是一个变量，用来存储你打开文件的地址。文件一旦关闭，存储的文件地址也就无法使用了。</p>
<p>那么如何获得文件里面的数据呢，需要使用<code>read()</code>来以字符串的形式返回文件里面的所有内容。如果需要分开处理，直接上<code>split()</code>大法。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Data=[]</span><br><span class="line">Path=<span class="string">&#x27;D:\Xorex\python\data.in&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(Path) <span class="keyword">as</span> Xorex:</span><br><span class="line">    Data=Xorex.read().split()</span><br><span class="line">n=<span class="built_in">int</span>(Data[<span class="number">0</span>])</span><br><span class="line">m=<span class="built_in">int</span>(Data[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">del</span> Data[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">del</span> Data[<span class="number">0</span>]</span><br><span class="line">print(n,m,Data)</span><br></pre></td></tr></table></figure>
<p>这样我们就得到了文件<code>data.in</code>里面所有的数据了，如果文件<code>data.in</code>和<code>Python</code>程序在同一个目录里面，那么就可以简写了，比如，可以删除<code>Python</code>程序目录的地址内容，如果<code>data.in</code>在<code>Python</code>程序同目录的<code>Data</code>文件夹里面，那么<code>Path</code>路径可以更改为：<code>Path=&#39;data\data.in&#39;</code>。</p>
<p>当然我们可以不使用<code>read()</code>来读取整个文件里面的内容，我们可以一行一行的读取，需要用到<code>for</code>循环：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Data=[]</span><br><span class="line">Path=<span class="string">&#x27;data.in&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(Path) <span class="keyword">as</span> Xorex:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> Xorex:</span><br><span class="line">        print(line.rstrip())</span><br></pre></td></tr></table></figure>
<p>这样每一行的数据都会以字符串的形式被存储在<code>line</code>这个变量里面，使用<code>rstrip()</code>函数是为了删除不必要的空行。</p>
<hr>
<p>使用<code>readlines()</code>函数可以把每一行数据单独的存储在一个列表里面，比如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.in&#x27;</span>) <span class="keyword">as</span> Xorex:</span><br><span class="line">    Data=Xorex.readlines()</span><br><span class="line">print(Data)</span><br></pre></td></tr></table></figure>
<p>这样输出的就是一个列表了。</p>
<hr>
<p><strong>关于文件输出</strong></p>
<p>格式和输入基本一样，不过需要增加一个参数<code>&#39;w&#39;</code>，表明是输出，如果不写<code>&#39;w&#39;</code>默认是文件输入。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.out&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> Xorex:</span><br><span class="line">    Xorex.write(<span class="string">&quot;Xorex is the best coder!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行程序会生成一个名称为<code>data.out</code>的文件，里面就包含这一句话：<code>Xorex is the best coder!</code></p>
<p>使用<code>&#39;w&#39;</code>来输出数据会使被输出的文件清空，如果你不想原来<code>data.out</code>的数据被清空（覆盖），那么你就可以使用参数<code>&#39;a&#39;</code>，是<code>add</code>的意思，不改变文件里面的内容，直接在后面加上要输出的东西。</p>
<p>注意这里<code>write</code>只能输出字符串，如果想要以其他形式输出，那么可以使用<code>json</code>模块规范化输出。</p>
<hr>
<p>这里再介绍一种文件输出更好的写法：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Xorex=<span class="built_in">open</span>(<span class="string">&#x27;data.out&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">Xorex.write(<span class="string">&quot;Xorex is the best coder!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>注意这里<code>Xorex</code>是特定的指向<code>data.out</code>这个输出文件可以再程序里任何位置调用<code>Xorex.write()</code>函数，并且<code>open</code>里面还有很多参数，比如<a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python3-func-open.html">Python3 open()函数</a></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>当<code>Python</code>程序遇到运行错误的时候，我们当然并不想让这个程序就这样不知所措的停止运行，所以<code>try-except</code>语句便诞生了，可以定向处理错误，知道有这个东西就行了，估计很少用到（目前）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a,b=<span class="built_in">input</span>().split()</span><br><span class="line">a=<span class="built_in">int</span>(a)</span><br><span class="line">b=<span class="built_in">int</span>(b)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(a/b)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    print(<span class="string">&quot;You can&#x27;t divide by zero!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码里面，程序会先尝试运行<code>try</code>后面的，如果出现了<code>except</code>后面跟随的异常<code>ZeroDivisionError</code>，也就是除零错误，那么就会执行<code>except</code>下面的代码，也就是输出错误原因。如果想要出现错误的时候程序什么都不做，那么在<code>except</code>下面写上<code>pass</code>即可。</p>
<h2 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h2><p>模块<code>json</code>可以将程序里面的数据单独存储下来，即使程序结束运行数据仍然存在。<code>json</code>是可以跨平台使用的，所以子啊使用<code>json</code>模块的时候，一定要记得使用<code>import</code>将其导入到代码里面。</p>
<p><code>json.dump(data,file_object)</code>函数需要接受两个参数，一个是需要存储的数据<code>data</code>，另外一个就是需要存储的目标文件的地址<code>file_object</code>，一般这个地址在使用<code>with open(file) as file_object</code>的时候，已经吧<code>file</code>的地址存储在了<code>file_object</code>里面。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">Numbers=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.out&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> Xorex:</span><br><span class="line">    json.dump(Numbers,Xorex)</span><br></pre></td></tr></table></figure>
<p>这样<code>Numbers</code>里面的数据就会以列表的形式存储在<code>data.out</code>文件里面了。打开<code>data.out</code>文件，你就会发现里面有：<code>[1,2,3,4,5,6]</code>。</p>
<p><code>dump</code>:「丢弃，倾倒」</p>
<hr>
<p>我们如果需要从规范的<code>json</code>格式的数据文件里面读入数据，就不能使用<code>read()</code>了，因为这样读进去的是字符串而并非列表，字典等格式化数据。这里就需要使用<code>json</code>里面的<code>load</code>函数。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data.in&#x27;</span>) <span class="keyword">as</span> Xorex:</span><br><span class="line">    Numbers=json.load(Xorex)</span><br></pre></td></tr></table></figure>
<p>这样变量<code>Numbers</code>里面就存储了来自于<code>data.in</code>文件里面的标准数据了。如果<code>data.in</code>里面没有存储数据就去读取，那么就会报错，为了避免这样的情况，我们可以使用<code>try-except</code>语句来判断是否出现异常，并写出应对异常的代码。</p>
<h1 id="最后总结："><a href="#最后总结：" class="headerlink" title="最后总结："></a>最后总结：</h1><blockquote>
<p>至此，<code>Python</code>的基础学习暂时告一段落，开始<code>Python</code>实战内容，加油吧！</p>
</blockquote>
<p><img src="https://xorex.space/image/101.jpg"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Xorex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xorex.space/2019/06/19/79dbbcabe6b7/">https://xorex.space/2019/06/19/79dbbcabe6b7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xorex.space" target="_blank">Xorex</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="/waifus/041.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/06/26/01915b74a55c/"><img class="prev-cover" src="/waifus/042.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Python实践-保护小雪乃</div></div></a></div><div class="next-post pull-right"><a href="/2018/04/25/d633663416bc/"><img class="next-cover" src="/waifus/052.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">一台电脑上两个 SSH 的配置方法</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC8yODcyMS81Mjky"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/Megumi.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Xorex</div><div class="author-info__description">要去热爱每一天的生活啊！</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">129</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">100</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Administrator-Xorex"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Administrator-Xorex" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="http://tool.gljlw.com/qq/?qq=2676424606" target="_blank" title="添加好友"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:cloudloverain@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://space.bilibili.com/65831075" target="_blank" title="bilibili"><i class="fas fa-tv"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-number">1.</span> <span class="toc-text">说在前面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Python"><span class="toc-number">2.</span> <span class="toc-text">Python</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%AE%E6%94%B9"><span class="toc-number">2.1.</span> <span class="toc-text">字符串修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97"><span class="toc-number">2.2.</span> <span class="toc-text">数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">2.3.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Zen-of-Python"><span class="toc-number">2.4.</span> <span class="toc-text">The Zen of Python</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8"><span class="toc-number">2.5.</span> <span class="toc-text">列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-number">2.6.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.7.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">2.8.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5"><span class="toc-number">2.9.</span> <span class="toc-text">输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.10.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.11.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97"><span class="toc-number">2.12.</span> <span class="toc-text">模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class%E7%B1%BB"><span class="toc-number">2.13.</span> <span class="toc-text">class类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">2.14.</span> <span class="toc-text">文件处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">2.15.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">2.16.</span> <span class="toc-text">存储数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">最后总结：</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2021 By Xorex</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="Xorex" data-fontsize="18px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>